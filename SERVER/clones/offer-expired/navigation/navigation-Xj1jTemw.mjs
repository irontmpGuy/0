import { g as QN, w as ZN, b as zre, u as Jre, K as zb } from "./tokens-shared-DI5D0LMK.mjs";
import { r as Pu, i as oE, n as Te, a as Dm, m as Wre, x as he, o as v, b as Jb, e as Gre, E as Kre, u as Fp, t as eM, c as Ln, d as fn, f as nr, g as vc, h as Yre } from "./lit-shared-BBccXYj9.mjs";
class Xc {
  constructor(t, { target: r, config: n, callback: o, skipInitial: a }) {
    this.t = /* @__PURE__ */ new Set(), this.o = !1, this.i = !1, this.h = t, r !== null && this.t.add(r ?? t), this.l = n, this.o = a ?? this.o, this.callback = o, window.ResizeObserver ? (this.u = new ResizeObserver(((i) => {
      this.handleChanges(i), this.h.requestUpdate();
    })), t.addController(this)) : console.warn("ResizeController error: browser does not support ResizeObserver.");
  }
  handleChanges(t) {
    this.value = this.callback?.(t, this.u);
  }
  hostConnected() {
    for (const t of this.t) this.observe(t);
  }
  hostDisconnected() {
    this.disconnect();
  }
  async hostUpdated() {
    !this.o && this.i && this.handleChanges([]), this.i = !1;
  }
  observe(t) {
    this.t.add(t), this.u.observe(t, this.l), this.i = !0, this.h.requestUpdate();
  }
  unobserve(t) {
    this.t.delete(t), this.u.unobserve(t);
  }
  disconnect() {
    this.u.disconnect();
  }
}
var Mf = { NODE_ENV: "production" };
const fo = ({ hrefTemplate: e = "", domain: t = "", locale: r = "" }) => {
  if (!e)
    return "";
  const n = r?.replace(/_/g, "-");
  let o = e;
  return t ? o = o.replace(/({|%7B)domain(}|%7D)/gi, t || "") : o = o.replace(/\/?({|%7B)domain(}|%7D)/gi, t || ""), n ? o = o.replace(/({|%7B)locale(}|%7D)/gi, n || "") : o = o.replace(/\/?({|%7B)locale(}|%7D)/gi, n || ""), o;
}, TP = (e) => e?.pointerType === "touch", Xre = [
  // Complete style tag breakout attempts - remove everything from </style> onwards
  /<\/style[^>]*>[\s\S]*/gi,
  // Script tags and their content
  /<script[^>]*>[\s\S]*?<\/script[^>]*>/gi,
  // Any remaining HTML tags
  /<[^>]*>/gi,
  // JavaScript URLs in any context
  /javascript\s*:[^;}\s]*/gi,
  // CSS expressions (IE-specific but still dangerous)
  /expression\s*\([^)]*\)/gi,
  // Import statements that could load external resources
  /@import\s+[^;]*/gi,
  // Behavior property (IE-specific)
  /behavior\s*:[^;]*/gi,
  // CSS injection attempts - closing brace followed by anything until opening brace
  /}\s*[^{}]*\{/g
], Qre = [
  // CSS unicode escapes that could be used to obfuscate javascript:
  /\\[0-9a-f]{1,6}\s*/gi,
  // CSS comments that could hide malicious content
  /\/\*[\s\S]*?\*\//g
];
function Wb(e, t = {}) {
  if (!e || typeof e != "string")
    return "";
  let r = e.trim();
  for (const n of Xre)
    r = r.replace(n, "");
  if (t.strict)
    for (const n of Qre)
      n.source.includes("\\*") && t.allowComments || (r = r.replace(n, ""));
  return r = r.replace(/\s+/g, " ").replace(/;\s*;+/g, ";").replace(/:\s+/g, ": ").replace(/\s*;\s*/g, "; ").replace(/;\s*$/g, ";").replace(/;\s*}/g, "}").trim(), r;
}
const Cr = (e, t) => !!(e && e === "true"), Zre = (e) => e && typeof e == "string" ? +e : e;
var Qc = {}, Mr = {}, AP;
function ene() {
  if (AP) return Mr;
  AP = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.pickupWithVariantKey = Mr.extractVariantKeys = Mr.mergeScreenshotOptions = Mr.createBaseScreenshotOptions = Mr.expandViewportsOption = void 0;
  const e = {
    waitAssets: !0,
    waitImages: !1,
    waitFor: "",
    fullPage: !0,
    skip: !1,
    focus: "",
    hover: "",
    click: "",
    variants: {},
    omitBackground: !1,
    captureBeyondViewport: !0,
    clip: null,
    forwardConsoleLogs: !1,
    trace: !1
  };
  function t(i) {
    if (!i.viewports)
      return i;
    const { viewports: s } = i, d = { ...i };
    delete d.viewports;
    const l = Array.isArray(s) ? s : Object.keys(s);
    if (!l.length)
      return i;
    const p = (h) => Array.isArray(s) ? h : s[h], f = { ...i.variants };
    return l.slice(1).forEach((h) => f[h] = { viewport: p(h) }), d.viewport = p(l[0]), d.variants = f, l.length > 1 && (d.defaultVariantSuffix = l[0]), d;
  }
  Mr.expandViewportsOption = t;
  function r({ delay: i, disableWaitAssets: s, viewports: d }) {
    return d.length > 1 ? {
      ...e,
      delay: i,
      waitAssets: !s,
      viewport: d[0],
      variants: d.slice(1).reduce((l, p) => ({ ...l, [p]: { viewport: p } }), {}),
      defaultVariantSuffix: d[0]
    } : {
      ...e,
      delay: i,
      waitAssets: !s,
      viewport: d[0],
      defaultVariantSuffix: ""
    };
  }
  Mr.createBaseScreenshotOptions = r;
  function n(i, s) {
    const d = Object.assign({}, i, s);
    return !i.viewport || typeof i.viewport == "string" ? s.viewport && (d.viewport = s.viewport) : s.viewport && (typeof s.viewport == "object" ? d.viewport = {
      ...i.viewport,
      ...s.viewport
    } : d.viewport = s.viewport), i.variants && (d.variants = n(i.variants, s.variants || {})), d;
  }
  Mr.mergeScreenshotOptions = n;
  function o({ variants: i, defaultVariantSuffix: s }) {
    if (!i)
      return [null, []];
    let d;
    const l = Object.keys(i).reduce((p, f) => {
      const h = [], m = (g, w = []) => {
        if (s && s === g)
          return h.push([g, ...w]), !0;
        if (!i[g])
          return d = {
            type: "notFound",
            from: w[0],
            to: g
          }, !1;
        if (w.find((x) => x === g))
          return d = {
            type: "circular",
            refs: [g, ...w]
          }, !1;
        const _ = i[g].extends, b = Array.isArray(_) ? _ : typeof _ == "string" ? [_] : [];
        return b.length ? b.every((x) => m(x, [g, ...w])) : (h.push([g, ...w]), !0);
      };
      return m(f), [...p, ...h.map((g) => ({ isDefault: !1, keys: g }))];
    }, []);
    return d ? [d, []] : [null, l];
  }
  Mr.extractVariantKeys = o;
  function a(i, s) {
    if (s.isDefault)
      return i;
    const d = Object.assign({}, i), l = d.variants || {};
    delete d.variants;
    const p = s.keys[0] && s.keys[0] === i.defaultVariantSuffix ? 1 : 0;
    return s.keys.slice(p).reduce((f, h) => n(f, l[h]), d);
  }
  return Mr.pickupWithVariantKey = a, Mr;
}
var $P;
function tne() {
  if ($P) return Qc;
  $P = 1, Object.defineProperty(Qc, "__esModule", { value: !0 }), Qc.triggerScreenshot = void 0;
  const e = /* @__PURE__ */ ene();
  function t(f) {
    const h = window;
    if (h.emitCapture)
      return f(h);
  }
  function r(f) {
    const { searchParams: h } = new URL(f), m = h.get("id"), g = h.get("selectedKind"), w = h.get("selectedStory");
    if (m)
      return m;
    if (g && w)
      return `${g}/${w}`;
    throw new Error();
  }
  function n(f = 0) {
    return new Promise((h) => setTimeout(h, f));
  }
  function o(f) {
    if (!f)
      return Promise.resolve();
    if (typeof f == "string") {
      const h = window[f];
      return typeof h != "function" ? Promise.resolve() : Promise.resolve().then(() => h());
    } else return typeof f == "function" ? f() : Promise.resolve();
  }
  function a(f) {
    return new Promise((h) => f.requestIdleCallback(h, { timeout: 3e3 }));
  }
  function i(f, h, m) {
    h && (f.optionStore || (f.optionStore = {}), f.optionStore[h] || (f.optionStore[h] = []), f.optionStore[h].push(m));
  }
  function s(f, h) {
    if (!f.optionStore || !f.optionStore[h])
      return null;
    const m = f.optionStore[h];
    return delete f.optionStore[h], m;
  }
  function d(f = {}, h) {
    let m;
    h && h.id ? m = h.id : h && h.story && h.kind ? m = h.kind + "/" + h.story : m = r(location.href), t((g) => i(g, m, f));
  }
  function l() {
    t(async (f) => {
      await f.waitBrowserMetricsStable();
      const [h, m] = await Promise.all([
        f.getBaseScreenshotOptions(),
        // Options set via CLI
        f.getCurrentVariantKey()
        // Variant key for this capturing process
      ]), g = r(location.href), w = s(f, g);
      if (!w)
        return;
      const _ = w.reduce((x, P) => (0, e.mergeScreenshotOptions)(x, (0, e.expandViewportsOption)(P)), h), b = (0, e.pickupWithVariantKey)(_, m);
      if (b.skip)
        return f.emitCapture(b, g);
      await n(b.delay), await o(b.waitFor), await a(f), await f.emitCapture(b, g);
    });
  }
  function p(f, h) {
    d(f, h), Promise.resolve().then(l);
  }
  return Qc.triggerScreenshot = p, Qc;
}
var rne = tne(), nne = Object.create, qm = Object.defineProperty, one = Object.getOwnPropertyDescriptor, tM = Object.getOwnPropertyNames, ane = Object.getPrototypeOf, ine = Object.prototype.hasOwnProperty, c = (e, t) => qm(e, "name", { value: t, configurable: !0 }), Up = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
}), W = (e, t) => function() {
  return t || (0, e[tM(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Qd = (e, t) => {
  for (var r in t)
    qm(e, r, { get: t[r], enumerable: !0 });
}, sne = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of tM(t))
      !ine.call(e, o) && o !== r && qm(e, o, { get: () => t[o], enumerable: !(n = one(t, o)) || n.enumerable });
  return e;
}, or = (e, t, r) => (r = e != null ? nne(ane(e)) : {}, sne(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? qm(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), lne = 5e3;
function aE() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
c(aE, "isTestEnvironment");
function iE(e = !0) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  const t = document.createElement("style");
  t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(t);
  const r = document.createElement("style");
  return r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(r), document.body.clientHeight, document.head.removeChild(t), () => {
    r.parentNode?.removeChild(r);
  };
}
c(iE, "pauseAnimations");
async function sE(e) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let t = !1;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((r) => {
      setTimeout(() => {
        const n = [globalThis.document, ...lE(globalThis.document)], o = /* @__PURE__ */ c(async () => {
          if (t || e?.aborted)
            return;
          const a = n.flatMap((i) => i?.getAnimations?.() || []).filter((i) => i.playState === "running" && !rM(i));
          a.length > 0 && (await Promise.all(a.map((i) => i.finished)), await o());
        }, "checkAnimationsFinished");
        o().then(r);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (r) => setTimeout(() => {
        t = !0, r(void 0);
      }, lne)
    )
  ]);
}
c(sE, "waitForAnimations");
function lE(e) {
  return [e, ...e.querySelectorAll("*")].reduce((t, r) => ("shadowRoot" in r && r.shadowRoot && t.push(r.shadowRoot, ...lE(r.shadowRoot)), t), []);
}
c(lE, "getShadowRoots");
function rM(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    const t = getComputedStyle(e.effect.target, e.effect.pseudoElement), r = t.animationName?.split(", ").indexOf(e.animationName);
    return t.animationIterationCount.split(", ")[r] === "infinite";
  }
  return !1;
}
c(rM, "isInfiniteAnimation");
var nM = W({
  "../node_modules/picoquery/lib/string-util.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeString = n;
    var t = Array.from({ length: 256 }, (o, a) => "%" + ((a < 16 ? "0" : "") + a.toString(16)).toUpperCase()), r = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function n(o) {
      const a = o.length;
      if (a === 0)
        return "";
      let i = "", s = 0, d = 0;
      e: for (; d < a; d++) {
        let l = o.charCodeAt(d);
        for (; l < 128; ) {
          if (r[l] !== 1 && (s < d && (i += o.slice(s, d)), s = d + 1, i += t[l]), ++d === a)
            break e;
          l = o.charCodeAt(d);
        }
        if (s < d && (i += o.slice(s, d)), l < 2048) {
          s = d + 1, i += t[192 | l >> 6] + t[128 | l & 63];
          continue;
        }
        if (l < 55296 || l >= 57344) {
          s = d + 1, i += t[224 | l >> 12] + t[128 | l >> 6 & 63] + t[128 | l & 63];
          continue;
        }
        if (++d, d >= a)
          throw new Error("URI malformed");
        const p = o.charCodeAt(d) & 1023;
        s = d + 1, l = 65536 + ((l & 1023) << 10 | p), i += t[240 | l >> 18] + t[128 | l >> 12 & 63] + t[128 | l >> 6 & 63] + t[128 | l & 63];
      }
      return s === 0 ? o : s < a ? i + o.slice(s) : i;
    }
    c(n, "encodeString");
  }
}), cE = W({
  "../node_modules/picoquery/lib/shared.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0;
    var t = nM(), r = /* @__PURE__ */ c((a) => {
      switch (typeof a) {
        case "string":
          return (0, t.encodeString)(a);
        case "bigint":
        case "boolean":
          return "" + a;
        case "number":
          if (Number.isFinite(a))
            return a < 1e21 ? "" + a : (0, t.encodeString)("" + a);
          break;
      }
      return a instanceof Date ? (0, t.encodeString)(a.toISOString()) : "";
    }, "defaultValueSerializer");
    e.defaultValueSerializer = r;
    var n = /* @__PURE__ */ c((a) => a instanceof Date, "defaultShouldSerializeObject");
    e.defaultShouldSerializeObject = n;
    var o = /* @__PURE__ */ c((a) => a, "identityFunc");
    e.defaultOptions = {
      nesting: !0,
      nestingSyntax: "dot",
      arrayRepeat: !1,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: o,
      valueSerializer: e.defaultValueSerializer,
      keyDeserializer: o,
      shouldSerializeObject: e.defaultShouldSerializeObject
    };
  }
}), oM = W({
  "../node_modules/picoquery/lib/object-util.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getDeepObject = o, e.stringifyObject = p;
    var t = cE(), r = nM();
    function n(f) {
      return f === "__proto__" || f === "constructor" || f === "prototype";
    }
    c(n, "isPrototypeKey");
    function o(f, h, m, g, w) {
      if (n(h))
        return f;
      const _ = f[h];
      return typeof _ == "object" && _ !== null ? _ : !g && (w || typeof m == "number" || typeof m == "string" && m * 0 === 0 && m.indexOf(".") === -1) ? f[h] = [] : f[h] = {};
    }
    c(o, "getDeepObject");
    var a = 20, i = "[]", s = "[", d = "]", l = ".";
    function p(f, h, m = 0, g, w) {
      const { nestingSyntax: _ = t.defaultOptions.nestingSyntax, arrayRepeat: b = t.defaultOptions.arrayRepeat, arrayRepeatSyntax: x = t.defaultOptions.arrayRepeatSyntax, nesting: P = t.defaultOptions.nesting, delimiter: R = t.defaultOptions.delimiter, valueSerializer: N = t.defaultOptions.valueSerializer, shouldSerializeObject: C = t.defaultOptions.shouldSerializeObject } = h, A = typeof R == "number" ? String.fromCharCode(R) : R, E = w === !0 && b, T = _ === "dot" || _ === "js" && !w;
      if (m > a)
        return "";
      let O = "", k = !0, M = !1;
      for (const L in f) {
        const $ = f[L];
        if ($ === void 0)
          continue;
        let I;
        g ? (I = g, E ? x === "bracket" && (I += i) : T ? (I += l, I += L) : (I += s, I += L, I += d)) : I = L, k || (O += A), typeof $ == "object" && $ !== null && !C($) ? (M = $.pop !== void 0, (P || b && M) && (O += p($, h, m + 1, I, M))) : (O += (0, r.encodeString)(I), O += "=", O += N($, L)), k && (k = !1);
      }
      return O;
    }
    c(p, "stringifyObject");
  }
}), cne = W({
  "../node_modules/picoquery/lib/decode-uri-component.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeURIComponent = o;
    var t = 12, r = 0, n = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function o(s) {
      let d = s.indexOf("%");
      if (d === -1)
        return s;
      const l = s.length;
      let p = "", f = 0, h = 0, m = d, g = t;
      for (; d > -1 && d < l; ) {
        const w = i(s[d + 1], 4), _ = i(s[d + 2], 0), b = w | _, x = n[b];
        if (g = n[256 + g + x], h = h << 6 | b & n[364 + x], g === t)
          p += s.slice(f, m), p += h <= 65535 ? String.fromCharCode(h) : String.fromCharCode(55232 + (h >> 10), 56320 + (h & 1023)), h = 0, f = d + 3, d = m = s.indexOf("%", f);
        else {
          if (g === r)
            return null;
          if (d += 3, d < l && s.charCodeAt(d) === 37)
            continue;
          return null;
        }
      }
      return p + s.slice(f);
    }
    c(o, "decodeURIComponent");
    var a = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function i(s, d) {
      const l = a[s];
      return l === void 0 ? 255 : l << d;
    }
    c(i, "hexCodeToInt");
  }
}), une = W({
  "../node_modules/picoquery/lib/parse.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.numberValueDeserializer = e.numberKeyDeserializer = void 0, e.parse = l;
    var t = oM(), r = cE(), n = cne(), o = /* @__PURE__ */ c((p) => {
      const f = Number(p);
      return Number.isNaN(f) ? p : f;
    }, "numberKeyDeserializer");
    e.numberKeyDeserializer = o;
    var a = /* @__PURE__ */ c((p) => {
      const f = Number(p);
      return Number.isNaN(f) ? p : f;
    }, "numberValueDeserializer");
    e.numberValueDeserializer = a;
    var i = /\+/g, s = /* @__PURE__ */ c(function() {
    }, "Empty");
    s.prototype = /* @__PURE__ */ Object.create(null);
    function d(p, f, h, m, g) {
      let w = p.substring(f, h);
      return m && (w = w.replace(i, " ")), g && (w = (0, n.decodeURIComponent)(w) || w), w;
    }
    c(d, "computeKeySlice");
    function l(p, f) {
      const { valueDeserializer: h = r.defaultOptions.valueDeserializer, keyDeserializer: m = r.defaultOptions.keyDeserializer, arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax, nesting: w = r.defaultOptions.nesting, arrayRepeat: _ = r.defaultOptions.arrayRepeat, nestingSyntax: b = r.defaultOptions.nestingSyntax, delimiter: x = r.defaultOptions.delimiter } = f ?? {}, P = typeof x == "string" ? x.charCodeAt(0) : x, R = b === "js", N = new s();
      if (typeof p != "string")
        return N;
      const C = p.length;
      let A = "", E = -1, T = -1, O = -1, k = N, M, L = "", $ = "", I = !1, D = !1, F = !1, J = !1, oe = !1, ce = !1, le = 0, re = -1, we = -1, _e = -1;
      for (let de = 0; de < C + 1; de++) {
        if (le = de !== C ? p.charCodeAt(de) : P, le === P) {
          if (ce = T > E, ce || (T = de), O !== T - 1 && ($ = d(p, O + 1, re > -1 ? re : T, F, I), L = m($), M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, R && oe, void 0))), ce || L !== "") {
            ce && (A = p.slice(T + 1, de), J && (A = A.replace(i, " ")), D && (A = (0, n.decodeURIComponent)(A) || A));
            const ne = h(A, L);
            if (_) {
              const $e = k[L];
              $e === void 0 ? re > -1 ? k[L] = [ne] : k[L] = ne : $e.pop ? $e.push(ne) : k[L] = [$e, ne];
            } else
              k[L] = ne;
          }
          A = "", E = de, T = de, I = !1, D = !1, F = !1, J = !1, oe = !1, re = -1, O = de, k = N, M = void 0, L = "";
        } else le === 93 ? (_ && g === "bracket" && _e === 91 && (re = we), w && (b === "index" || R) && T <= E && (O !== we && ($ = d(p, O + 1, de, F, I), L = m($), M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, void 0, void 0)), M = L, F = !1, I = !1), O = de, oe = !1)) : le === 46 ? w && (b === "dot" || R) && T <= E && (O !== we && ($ = d(p, O + 1, de, F, I), L = m($), M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, R)), M = L, F = !1, I = !1), oe = !0, O = de) : le === 91 ? w && (b === "index" || R) && T <= E && (O !== we && ($ = d(p, O + 1, de, F, I), L = m($), R && M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, R)), M = L, F = !1, I = !1, oe = !1), O = de) : le === 61 ? T <= E ? T = de : D = !0 : le === 43 ? T > E ? J = !0 : F = !0 : le === 37 && (T > E ? D = !0 : I = !0);
        we = de, _e = le;
      }
      return N;
    }
    c(l, "parse");
  }
}), dne = W({
  "../node_modules/picoquery/lib/stringify.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringify = r;
    var t = oM();
    function r(n, o) {
      if (n === null || typeof n != "object")
        return "";
      const a = o ?? {};
      return (0, t.stringifyObject)(n, a);
    }
    c(r, "stringify");
  }
}), uE = W({
  "../node_modules/picoquery/lib/main.js"(e) {
    var t = e && e.__createBinding || (Object.create ? function(a, i, s, d) {
      d === void 0 && (d = s);
      var l = Object.getOwnPropertyDescriptor(i, s);
      (!l || ("get" in l ? !i.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: /* @__PURE__ */ c(function() {
        return i[s];
      }, "get") }), Object.defineProperty(a, d, l);
    } : function(a, i, s, d) {
      d === void 0 && (d = s), a[d] = i[s];
    }), r = e && e.__exportStar || function(a, i) {
      for (var s in a) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, a, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringify = e.parse = void 0;
    var n = une();
    Object.defineProperty(e, "parse", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return n.parse;
    }, "get") });
    var o = dne();
    Object.defineProperty(e, "stringify", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return o.stringify;
    }, "get") }), r(cE(), e);
  }
});
function Kr(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null ? Object.prototype.toString.call(e) === "[object Object]" : !1;
}
c(Kr, "isPlainObject");
function aM(e) {
  return e == null || typeof e != "object" && typeof e != "function";
}
c(aM, "isPrimitive");
function iM(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
c(iM, "isTypedArray");
function Df(e) {
  return Object.getOwnPropertySymbols(e).filter((t) => Object.prototype.propertyIsEnumerable.call(e, t));
}
c(Df, "getSymbols");
function qf(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
c(qf, "getTag");
var sM = "[object RegExp]", lM = "[object String]", cM = "[object Number]", uM = "[object Boolean]", Wv = "[object Arguments]", dM = "[object Symbol]", pM = "[object Date]", fM = "[object Map]", hM = "[object Set]", mM = "[object Array]", pne = "[object Function]", yM = "[object ArrayBuffer]", ef = "[object Object]", fne = "[object Error]", gM = "[object DataView]", bM = "[object Uint8Array]", vM = "[object Uint8ClampedArray]", wM = "[object Uint16Array]", _M = "[object Uint32Array]", hne = "[object BigUint64Array]", EM = "[object Int8Array]", xM = "[object Int16Array]", SM = "[object Int32Array]", mne = "[object BigInt64Array]", TM = "[object Float32Array]", AM = "[object Float64Array]";
function Ol(e, t) {
  const r = {}, n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const a = n[o], i = e[a];
    r[a] = t(i, a, e);
  }
  return r;
}
c(Ol, "mapValues");
function dE(e) {
  return e === "__proto__";
}
c(dE, "isUnsafeProperty");
function Gv(e) {
  return typeof e == "object" && e !== null;
}
c(Gv, "isObjectLike");
function Kv(e, t, r) {
  const n = Object.keys(t);
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    if (dE(a))
      continue;
    const i = t[a], s = e[a], d = r(s, i, a, e, t);
    d !== void 0 ? e[a] = d : Array.isArray(i) ? e[a] = Kv(s ?? [], i, r) : Gv(s) && Gv(i) ? e[a] = Kv(s ?? {}, i, r) : (s === void 0 || i !== void 0) && (e[a] = i);
  }
  return e;
}
c(Kv, "mergeWith");
function yne(e, t) {
  const r = {};
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    Object.hasOwn(e, o) && (r[o] = e[o]);
  }
  return r;
}
c(yne, "pick");
function $M(e, t) {
  const r = {}, n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const a = n[o], i = e[a];
    t(i, a) && (r[a] = i);
  }
  return r;
}
c($M, "pickBy");
function Mi(e, t, r, n = /* @__PURE__ */ new Map(), o = void 0) {
  const a = o?.(e, t, r, n);
  if (a !== void 0)
    return a;
  if (aM(e))
    return e;
  if (n.has(e))
    return n.get(e);
  if (Array.isArray(e)) {
    const i = new Array(e.length);
    n.set(e, i);
    for (let s = 0; s < e.length; s++)
      i[s] = Mi(e[s], s, r, n, o);
    return Object.hasOwn(e, "index") && (i.index = e.index), Object.hasOwn(e, "input") && (i.input = e.input), i;
  }
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof RegExp) {
    const i = new RegExp(e.source, e.flags);
    return i.lastIndex = e.lastIndex, i;
  }
  if (e instanceof Map) {
    const i = /* @__PURE__ */ new Map();
    n.set(e, i);
    for (const [s, d] of e)
      i.set(s, Mi(d, s, r, n, o));
    return i;
  }
  if (e instanceof Set) {
    const i = /* @__PURE__ */ new Set();
    n.set(e, i);
    for (const s of e)
      i.add(Mi(s, void 0, r, n, o));
    return i;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(e))
    return e.subarray();
  if (iM(e)) {
    const i = new (Object.getPrototypeOf(e)).constructor(e.length);
    n.set(e, i);
    for (let s = 0; s < e.length; s++)
      i[s] = Mi(e[s], s, r, n, o);
    return i;
  }
  if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
    return e.slice(0);
  if (e instanceof DataView) {
    const i = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
    return n.set(e, i), Ws(i, e, r, n, o), i;
  }
  if (typeof File < "u" && e instanceof File) {
    const i = new File([e], e.name, {
      type: e.type
    });
    return n.set(e, i), Ws(i, e, r, n, o), i;
  }
  if (e instanceof Blob) {
    const i = new Blob([e], { type: e.type });
    return n.set(e, i), Ws(i, e, r, n, o), i;
  }
  if (e instanceof Error) {
    const i = new e.constructor();
    return n.set(e, i), i.message = e.message, i.name = e.name, i.stack = e.stack, i.cause = e.cause, Ws(i, e, r, n, o), i;
  }
  if (typeof e == "object" && CM(e)) {
    const i = Object.create(Object.getPrototypeOf(e));
    return n.set(e, i), Ws(i, e, r, n, o), i;
  }
  return e;
}
c(Mi, "cloneDeepWithImpl");
function Ws(e, t, r = e, n, o) {
  const a = [...Object.keys(t), ...Df(t)];
  for (let i = 0; i < a.length; i++) {
    const s = a[i], d = Object.getOwnPropertyDescriptor(e, s);
    (d == null || d.writable) && (e[s] = Mi(t[s], s, r, n, o));
  }
}
c(Ws, "copyProperties");
function CM(e) {
  switch (qf(e)) {
    case Wv:
    case mM:
    case yM:
    case gM:
    case uM:
    case pM:
    case TM:
    case AM:
    case EM:
    case xM:
    case SM:
    case fM:
    case cM:
    case ef:
    case sM:
    case hM:
    case lM:
    case dM:
    case bM:
    case vM:
    case wM:
    case _M:
      return !0;
    default:
      return !1;
  }
}
c(CM, "isCloneableObject");
function kM(e) {
  return Mi(e, void 0, e, /* @__PURE__ */ new Map(), void 0);
}
c(kM, "cloneDeep");
function al(e, t) {
  const r = Object.keys(t);
  for (let n = 0; n < r.length; n++) {
    const o = r[n];
    if (dE(o))
      continue;
    const a = t[o], i = e[o];
    Array.isArray(a) ? Array.isArray(i) ? e[o] = al(i, a) : e[o] = al([], a) : Kr(a) ? Kr(i) ? e[o] = al(i, a) : e[o] = al({}, a) : (i === void 0 || a !== void 0) && (e[o] = a);
  }
  return e;
}
c(al, "merge");
function gne(e, t) {
  return al(kM(e), t);
}
c(gne, "toMerged");
function Yv({
  code: e,
  category: t
}) {
  const r = String(e).padStart(4, "0");
  return `SB_${t}_${r}`;
}
c(Yv, "parseErrorCode");
function Xv(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e))
    return e;
  try {
    const t = new URL(e);
    return t.searchParams.set("ref", "error"), t.toString();
  } catch {
    return e;
  }
}
c(Xv, "appendErrorRef");
var PM = class OM extends Error {
  constructor(t) {
    super(OM.getFullMessage(t)), this.data = {}, this.fromStorybook = !0, this.category = t.category, this.documentation = t.documentation ?? !1, this.code = t.code;
  }
  get fullErrorCode() {
    return Yv({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    const t = this.constructor.name;
    return `${this.fullErrorCode} (${t})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: t,
    code: r,
    category: n,
    message: o
  }) {
    let a;
    return t === !0 ? a = `https://storybook.js.org/error/${Yv({ code: r, category: n })}?ref=error` : typeof t == "string" ? a = Xv(t) : Array.isArray(t) && (a = `
${t.map((i) => `	- ${Xv(i)}`).join(`
`)}`), `${o}${a != null ? `

More info: ${a}
` : ""}`;
  }
};
c(PM, "StorybookError");
var Ft = PM;
function Ue(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  var n = Array.from(typeof e == "string" ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var o = n.reduce(function(s, d) {
    var l = d.match(/\n([\t ]+|(?!\s).)/g);
    return l ? s.concat(l.map(function(p) {
      var f, h;
      return (h = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && h !== void 0 ? h : 0;
    })) : s;
  }, []);
  if (o.length) {
    var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, o) + "}", "g");
    n = n.map(function(s) {
      return s.replace(a, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var i = n[0];
  return t.forEach(function(s, d) {
    var l = i.match(/(?:^|\n)( *)$/), p = l ? l[1] : "", f = s;
    typeof s == "string" && s.includes(`
`) && (f = String(s).split(`
`).map(function(h, m) {
      return m === 0 ? h : "" + p + h;
    }).join(`
`)), i += f + n[d + 1];
  }), i;
}
c(Ue, "dedent");
var RM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: Ue`
        Couldn't find story matching id '${t.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${t.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    }), this.data = t;
  }
};
c(RM, "MissingStoryAfterHmrError");
var bne = RM, jM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: Ue`
        We detected that you use an implicit action arg while ${t.phase} of your story.  
        ${t.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${t.name}: fn()
          }`
    }), this.data = t;
  }
};
c(jM, "ImplicitActionsDuringRendering");
var vne = jM, IM = class extends Ft {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: Ue`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
c(IM, "CalledExtractOnStoreError");
var wne = IM, NM = class extends Ft {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: Ue`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
c(NM, "MissingRenderToCanvasError");
var _ne = NM, MM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: Ue`
        Called \`Preview.${t.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${t.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    }), this.data = t;
  }
};
c(MM, "CalledPreviewMethodBeforeInitializationError");
var sn = MM, DM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: Ue`
        Error fetching \`/index.json\`:
        
        ${t.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    }), this.data = t;
  }
};
c(DM, "StoryIndexFetchError");
var Ene = DM, qM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: Ue`
        Tried to render docs entry ${t.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    }), this.data = t;
  }
};
c(qM, "MdxFileWithNoCsfReferencesError");
var xne = qM, LM = class extends Ft {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: Ue`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
c(LM, "EmptyIndexError");
var Sne = LM, FM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: Ue`
        Couldn't find story matching '${t.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    }), this.data = t;
  }
};
c(FM, "NoStoryMatchError");
var Tne = FM, UM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: Ue`
        Couldn't find story matching id '${t.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    }), this.data = t;
  }
};
c(UM, "MissingStoryFromCsfFileError");
var Ane = UM, BM = class extends Ft {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: Ue`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
c(BM, "StoryStoreAccessedBeforeInitializationError");
var $ne = BM, HM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: Ue`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${t.playFunction}`
    }), this.data = t;
  }
};
c(HM, "MountMustBeDestructuredError");
var VM = HM, zM = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: Ue`
        No render function available for storyId '${t.id}'
      `
    }), this.data = t;
  }
};
c(zM, "NoRenderFunctionError");
var Cne = zM, JM = class extends Ft {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: Ue`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // ðŸ‘ˆ mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
c(JM, "NoStoryMountedError");
var kne = JM, Pne = class extends Ft {
  constructor(t) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${t.status.typeId}" but was added to store with typeId "${t.typeId}". Full status: ${JSON.stringify(
        t.status,
        null,
        2
      )}`
    }), this.data = t;
  }
};
c(Pne, "StatusTypeIdMismatchError");
var One = class extends Ft {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: Ue`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
c(One, "NextJsSharpError");
var Rne = class extends Ft {
  constructor(t) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: Ue`
        Tried to access router mocks from "${t.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    }), this.data = t;
  }
};
c(Rne, "NextjsRouterMocksNotAvailable");
var jne = class extends Ft {
  constructor(t) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: Ue`
        There was a failure when generating detailed ArgTypes in ${t.language} for:
        ${JSON.stringify(t.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    }), this.data = t;
  }
};
c(jne, "UnknownArgTypesError");
var Ine = class extends Ft {
  constructor(t) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: Ue`
        Encountered an unsupported value "${t.value}" when setting the viewport ${t.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    }), this.data = t;
  }
};
c(Ine, "UnsupportedViewportDimensionError");
var Nne = class extends Ft {
  constructor() {
    super({
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
c(Nne, "ElementA11yParameterError");
var Mne = W({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(e, t) {
    (function(r, n) {
      typeof e == "object" && typeof t < "u" ? n(e) : typeof define == "function" && define.amd ? define(["exports"], n) : (r = typeof globalThis < "u" ? globalThis : r || self, n(r.jtpp = {}));
    })(e, function(r) {
      function n(y) {
        return y.text !== void 0 && y.text !== "" ? `'${y.type}' with value '${y.text}'` : `'${y.type}'`;
      }
      c(n, "tokenToString");
      const o = class WM extends Error {
        constructor(S) {
          super(`No parslet found for token: ${n(S)}`), this.token = S, Object.setPrototypeOf(this, WM.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      c(o, "NoParsletFoundError");
      let a = o;
      const i = class GM extends Error {
        constructor(S) {
          super(`The parsing ended early. The next token was: ${n(S)}`), this.token = S, Object.setPrototypeOf(this, GM.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      c(i, "EarlyEndOfParseError");
      let s = i;
      const d = class KM extends Error {
        constructor(S, j) {
          let U = `Unexpected type: '${S.type}'.`;
          j !== void 0 && (U += ` Message: ${j}`), super(U), Object.setPrototypeOf(this, KM.prototype);
        }
      };
      c(d, "UnexpectedTypeError");
      let l = d;
      function p(y) {
        return (S) => S.startsWith(y) ? { type: y, text: y } : null;
      }
      c(p, "makePunctuationRule");
      function f(y) {
        let S = 0, j;
        const U = y[0];
        let Q = !1;
        if (U !== "'" && U !== '"')
          return null;
        for (; S < y.length; ) {
          if (S++, j = y[S], !Q && j === U) {
            S++;
            break;
          }
          Q = !Q && j === "\\";
        }
        if (j !== U)
          throw new Error("Unterminated String");
        return y.slice(0, S);
      }
      c(f, "getQuoted");
      const h = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), m = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function g(y) {
        let S = y[0];
        if (!h.test(S))
          return null;
        let j = 1;
        do {
          if (S = y[j], !m.test(S))
            break;
          j++;
        } while (j < y.length);
        return y.slice(0, j);
      }
      c(g, "getIdentifier");
      const w = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function _(y) {
        var S, j;
        return (j = (S = w.exec(y)) === null || S === void 0 ? void 0 : S[0]) !== null && j !== void 0 ? j : null;
      }
      c(_, "getNumber");
      const b = /* @__PURE__ */ c((y) => {
        const S = g(y);
        return S == null ? null : {
          type: "Identifier",
          text: S
        };
      }, "identifierRule");
      function x(y) {
        return (S) => {
          if (!S.startsWith(y))
            return null;
          const j = S[y.length];
          return j !== void 0 && m.test(j) ? null : {
            type: y,
            text: y
          };
        };
      }
      c(x, "makeKeyWordRule");
      const P = /* @__PURE__ */ c((y) => {
        const S = f(y);
        return S == null ? null : {
          type: "StringValue",
          text: S
        };
      }, "stringValueRule"), R = /* @__PURE__ */ c((y) => y.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, "eofRule"), N = /* @__PURE__ */ c((y) => {
        const S = _(y);
        return S === null ? null : {
          type: "Number",
          text: S
        };
      }, "numberRule"), C = [
        R,
        p("=>"),
        p("("),
        p(")"),
        p("{"),
        p("}"),
        p("["),
        p("]"),
        p("|"),
        p("&"),
        p("<"),
        p(">"),
        p(","),
        p(";"),
        p("*"),
        p("?"),
        p("!"),
        p("="),
        p(":"),
        p("..."),
        p("."),
        p("#"),
        p("~"),
        p("/"),
        p("@"),
        x("undefined"),
        x("null"),
        x("function"),
        x("this"),
        x("new"),
        x("module"),
        x("event"),
        x("extends"),
        x("external"),
        x("infer"),
        x("typeof"),
        x("keyof"),
        x("readonly"),
        x("import"),
        x("is"),
        x("in"),
        x("asserts"),
        N,
        b,
        P
      ], A = /^\s*\n\s*/, E = class tf {
        static create(S) {
          const j = this.read(S);
          S = j.text;
          const U = this.read(S);
          return S = U.text, new tf(S, void 0, j.token, U.token);
        }
        constructor(S, j, U, Q) {
          this.text = "", this.text = S, this.previous = j, this.current = U, this.next = Q;
        }
        static read(S, j = !1) {
          j = j || A.test(S), S = S.trim();
          for (const U of C) {
            const Q = U(S);
            if (Q !== null) {
              const ie = Object.assign(Object.assign({}, Q), { startOfLine: j });
              return S = S.slice(ie.text.length), { text: S, token: ie };
            }
          }
          throw new Error("Unexpected Token " + S);
        }
        advance() {
          const S = tf.read(this.text);
          return new tf(S.text, this.current, this.next, S.token);
        }
      };
      c(E, "Lexer");
      let T = E;
      function O(y) {
        if (y === void 0)
          throw new Error("Unexpected undefined");
        if (y.type === "JsdocTypeKeyValue" || y.type === "JsdocTypeParameterList" || y.type === "JsdocTypeProperty" || y.type === "JsdocTypeReadonlyProperty" || y.type === "JsdocTypeObjectField" || y.type === "JsdocTypeJsdocObjectField" || y.type === "JsdocTypeIndexSignature" || y.type === "JsdocTypeMappedType" || y.type === "JsdocTypeTypeParameter")
          throw new l(y);
        return y;
      }
      c(O, "assertRootResult");
      function k(y) {
        return y.type === "JsdocTypeKeyValue" ? L(y) : O(y);
      }
      c(k, "assertPlainKeyValueOrRootResult");
      function M(y) {
        return y.type === "JsdocTypeName" ? y : L(y);
      }
      c(M, "assertPlainKeyValueOrNameResult");
      function L(y) {
        if (y.type !== "JsdocTypeKeyValue")
          throw new l(y);
        return y;
      }
      c(L, "assertPlainKeyValueResult");
      function $(y) {
        var S;
        if (y.type === "JsdocTypeVariadic") {
          if (((S = y.element) === null || S === void 0 ? void 0 : S.type) === "JsdocTypeName")
            return y;
          throw new l(y);
        }
        if (y.type !== "JsdocTypeNumber" && y.type !== "JsdocTypeName")
          throw new l(y);
        return y;
      }
      c($, "assertNumberOrVariadicNameResult");
      function I(y) {
        if (y.type === "JsdocTypeTuple" || y.type === "JsdocTypeGeneric" && y.meta.brackets === "square")
          return y;
        throw new l(y);
      }
      c(I, "assertArrayOrTupleResult");
      function D(y) {
        return y.type === "JsdocTypeIndexSignature" || y.type === "JsdocTypeMappedType";
      }
      c(D, "isSquaredProperty");
      var F;
      (function(y) {
        y[y.ALL = 0] = "ALL", y[y.PARAMETER_LIST = 1] = "PARAMETER_LIST", y[y.OBJECT = 2] = "OBJECT", y[y.KEY_VALUE = 3] = "KEY_VALUE", y[y.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", y[y.UNION = 5] = "UNION", y[y.INTERSECTION = 6] = "INTERSECTION", y[y.PREFIX = 7] = "PREFIX", y[y.INFIX = 8] = "INFIX", y[y.TUPLE = 9] = "TUPLE", y[y.SYMBOL = 10] = "SYMBOL", y[y.OPTIONAL = 11] = "OPTIONAL", y[y.NULLABLE = 12] = "NULLABLE", y[y.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", y[y.FUNCTION = 14] = "FUNCTION", y[y.ARROW = 15] = "ARROW", y[y.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", y[y.GENERIC = 17] = "GENERIC", y[y.NAME_PATH = 18] = "NAME_PATH", y[y.PARENTHESIS = 19] = "PARENTHESIS", y[y.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(F || (F = {}));
      const J = class {
        constructor(y, S, j) {
          this.grammar = y, typeof S == "string" ? this._lexer = T.create(S) : this._lexer = S, this.baseParser = j;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          const y = this.parseType(F.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new s(this.lexer.current);
          return y;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(y) {
          return O(this.parseIntermediateType(y));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(y) {
          const S = this.tryParslets(null, y);
          if (S === null)
            throw new a(this.lexer.current);
          return this.parseInfixIntermediateType(S, y);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(y, S) {
          let j = this.tryParslets(y, S);
          for (; j !== null; )
            y = j, j = this.tryParslets(y, S);
          return y;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(y, S) {
          for (const j of this.grammar) {
            const U = j(this, S, y);
            if (U !== null)
              return U;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(y) {
          return Array.isArray(y) || (y = [y]), y.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
        }
        acceptLexerState(y) {
          this._lexer = y.lexer;
        }
      };
      c(J, "Parser");
      let oe = J;
      function ce(y) {
        return y === "}" || y === "EOF" || y === "|" || y === "," || y === ")" || y === ">";
      }
      c(ce, "isQuestionMarkUnknownType");
      const le = /* @__PURE__ */ c((y, S, j) => {
        const U = y.lexer.current.type, Q = y.lexer.next.type;
        return j == null && U === "?" && !ce(Q) || j != null && U === "?" ? (y.consume("?"), j == null ? {
          type: "JsdocTypeNullable",
          element: y.parseType(F.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: O(j),
          meta: {
            position: "suffix"
          }
        }) : null;
      }, "nullableParslet");
      function re(y) {
        const S = /* @__PURE__ */ c((j, U, Q) => {
          const ie = j.lexer.current.type, pe = j.lexer.next.type;
          if (Q === null) {
            if ("parsePrefix" in y && y.accept(ie, pe))
              return y.parsePrefix(j);
          } else if ("parseInfix" in y && y.precedence > U && y.accept(ie, pe))
            return y.parseInfix(j, Q);
          return null;
        }, "parslet");
        return Object.defineProperty(S, "name", {
          value: y.name
        }), S;
      }
      c(re, "composeParslet");
      const we = re({
        name: "optionalParslet",
        accept: /* @__PURE__ */ c((y) => y === "=", "accept"),
        precedence: F.OPTIONAL,
        parsePrefix: /* @__PURE__ */ c((y) => (y.consume("="), {
          type: "JsdocTypeOptional",
          element: y.parseType(F.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }), "parsePrefix"),
        parseInfix: /* @__PURE__ */ c((y, S) => (y.consume("="), {
          type: "JsdocTypeOptional",
          element: O(S),
          meta: {
            position: "suffix"
          }
        }), "parseInfix")
      }), _e = re({
        name: "numberParslet",
        accept: /* @__PURE__ */ c((y) => y === "Number", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          const S = parseFloat(y.lexer.current.text);
          return y.consume("Number"), {
            type: "JsdocTypeNumber",
            value: S
          };
        }, "parsePrefix")
      }), de = re({
        name: "parenthesisParslet",
        accept: /* @__PURE__ */ c((y) => y === "(", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          if (y.consume("("), y.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          const S = y.parseIntermediateType(F.ALL);
          if (!y.consume(")"))
            throw new Error("Unterminated parenthesis");
          return S.type === "JsdocTypeParameterList" ? S : S.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [S]
          } : {
            type: "JsdocTypeParenthesis",
            element: O(S)
          };
        }, "parsePrefix")
      }), ne = re({
        name: "specialTypesParslet",
        accept: /* @__PURE__ */ c((y, S) => y === "?" && ce(S) || y === "null" || y === "undefined" || y === "*", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          if (y.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (y.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (y.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (y.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + y.lexer.current.text);
        }, "parsePrefix")
      }), $e = re({
        name: "notNullableParslet",
        accept: /* @__PURE__ */ c((y) => y === "!", "accept"),
        precedence: F.NULLABLE,
        parsePrefix: /* @__PURE__ */ c((y) => (y.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: y.parseType(F.NULLABLE),
          meta: {
            position: "prefix"
          }
        }), "parsePrefix"),
        parseInfix: /* @__PURE__ */ c((y, S) => (y.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: O(S),
          meta: {
            position: "suffix"
          }
        }), "parseInfix")
      });
      function Se({ allowTrailingComma: y }) {
        return re({
          name: "parameterListParslet",
          accept: /* @__PURE__ */ c((S) => S === ",", "accept"),
          precedence: F.PARAMETER_LIST,
          parseInfix: /* @__PURE__ */ c((S, j) => {
            const U = [
              k(j)
            ];
            S.consume(",");
            do
              try {
                const Q = S.parseIntermediateType(F.PARAMETER_LIST);
                U.push(k(Q));
              } catch (Q) {
                if (Q instanceof a)
                  break;
                throw Q;
              }
            while (S.consume(","));
            if (U.length > 0 && U.slice(0, -1).some((Q) => Q.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements: U
            };
          }, "parseInfix")
        });
      }
      c(Se, "createParameterListParslet");
      const nt = re({
        name: "genericParslet",
        accept: /* @__PURE__ */ c((y, S) => y === "<" || y === "." && S === "<", "accept"),
        precedence: F.GENERIC,
        parseInfix: /* @__PURE__ */ c((y, S) => {
          const j = y.consume(".");
          y.consume("<");
          const U = [];
          let Q = !1;
          if (y.consume("infer")) {
            Q = !0;
            const ie = y.parseIntermediateType(F.SYMBOL);
            if (ie.type !== "JsdocTypeName")
              throw new l(ie, "A typescript asserts always has to have a name on the left side.");
            U.push(ie);
          } else
            do
              U.push(y.parseType(F.PARAMETER_LIST));
            while (y.consume(","));
          if (!y.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: O(S), elements: U }, Q ? { infer: !0 } : {}), { meta: {
            brackets: "angle",
            dot: j
          } });
        }, "parseInfix")
      }), We = re({
        name: "unionParslet",
        accept: /* @__PURE__ */ c((y) => y === "|", "accept"),
        precedence: F.UNION,
        parseInfix: /* @__PURE__ */ c((y, S) => {
          y.consume("|");
          const j = [];
          do
            j.push(y.parseType(F.UNION));
          while (y.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [O(S), ...j]
          };
        }, "parseInfix")
      }), q = [
        le,
        we,
        _e,
        de,
        ne,
        $e,
        Se({
          allowTrailingComma: !0
        }),
        nt,
        We,
        we
      ];
      function te({ allowSquareBracketsOnAnyType: y, allowJsdocNamePaths: S, pathGrammar: j }) {
        return /* @__PURE__ */ c(function(U, Q, ie) {
          if (ie == null || Q >= F.NAME_PATH)
            return null;
          const pe = U.lexer.current.type, Pe = U.lexer.next.type;
          if (!(pe === "." && Pe !== "<" || pe === "[" && (y || ie.type === "JsdocTypeName") || S && (pe === "~" || pe === "#")))
            return null;
          let Oe, Ge = !1;
          U.consume(".") ? Oe = "property" : U.consume("[") ? (Oe = "property-brackets", Ge = !0) : U.consume("~") ? Oe = "inner" : (U.consume("#"), Oe = "instance");
          const Jt = j !== null ? new oe(j, U.lexer, U) : U, xt = Jt.parseIntermediateType(F.NAME_PATH);
          U.acceptLexerState(Jt);
          let kn;
          switch (xt.type) {
            case "JsdocTypeName":
              kn = {
                type: "JsdocTypeProperty",
                value: xt.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              kn = {
                type: "JsdocTypeProperty",
                value: xt.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              kn = {
                type: "JsdocTypeProperty",
                value: xt.value,
                meta: {
                  quote: xt.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (xt.specialType === "event")
                kn = xt;
              else
                throw new l(xt, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new l(xt, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (Ge && !U.consume("]")) {
            const Yc = U.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${Yc.type}' with text '${Yc.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: O(ie),
            right: kn,
            pathType: Oe
          };
        }, "namePathParslet");
      }
      c(te, "createNamePathParslet");
      function ae({ allowedAdditionalTokens: y }) {
        return re({
          name: "nameParslet",
          accept: /* @__PURE__ */ c((S) => S === "Identifier" || S === "this" || S === "new" || y.includes(S), "accept"),
          parsePrefix: /* @__PURE__ */ c((S) => {
            const { type: j, text: U } = S.lexer.current;
            return S.consume(j), {
              type: "JsdocTypeName",
              value: U
            };
          }, "parsePrefix")
        });
      }
      c(ae, "createNameParslet");
      const ue = re({
        name: "stringValueParslet",
        accept: /* @__PURE__ */ c((y) => y === "StringValue", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          const S = y.lexer.current.text;
          return y.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: S.slice(1, -1),
            meta: {
              quote: S[0] === "'" ? "single" : "double"
            }
          };
        }, "parsePrefix")
      });
      function se({ pathGrammar: y, allowedTypes: S }) {
        return re({
          name: "specialNamePathParslet",
          accept: /* @__PURE__ */ c((j) => S.includes(j), "accept"),
          parsePrefix: /* @__PURE__ */ c((j) => {
            const U = j.lexer.current.type;
            if (j.consume(U), !j.consume(":"))
              return {
                type: "JsdocTypeName",
                value: U
              };
            let Q, ie = j.lexer.current;
            if (j.consume("StringValue"))
              Q = {
                type: "JsdocTypeSpecialNamePath",
                value: ie.text.slice(1, -1),
                specialType: U,
                meta: {
                  quote: ie.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let Oe = "";
              const Ge = ["Identifier", "@", "/"];
              for (; Ge.some((Jt) => j.consume(Jt)); )
                Oe += ie.text, ie = j.lexer.current;
              Q = {
                type: "JsdocTypeSpecialNamePath",
                value: Oe,
                specialType: U,
                meta: {
                  quote: void 0
                }
              };
            }
            const pe = new oe(y, j.lexer, j), Pe = pe.parseInfixIntermediateType(Q, F.ALL);
            return j.acceptLexerState(pe), O(Pe);
          }, "parsePrefix")
        });
      }
      c(se, "createSpecialNamePathParslet");
      const ye = [
        ae({
          allowedAdditionalTokens: ["external", "module"]
        }),
        ue,
        _e,
        te({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: null
        })
      ], fe = [
        ...ye,
        se({
          allowedTypes: ["event"],
          pathGrammar: ye
        })
      ];
      function Ae(y) {
        let S;
        if (y.type === "JsdocTypeParameterList")
          S = y.elements;
        else if (y.type === "JsdocTypeParenthesis")
          S = [y.element];
        else
          throw new l(y);
        return S.map((j) => k(j));
      }
      c(Ae, "getParameters");
      function Fe(y) {
        const S = Ae(y);
        if (S.some((j) => j.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return S;
      }
      c(Fe, "getUnnamedParameters");
      function dt({ allowNamedParameters: y, allowNoReturnType: S, allowWithoutParenthesis: j, allowNewAsFunctionKeyword: U }) {
        return re({
          name: "functionParslet",
          accept: /* @__PURE__ */ c((Q, ie) => Q === "function" || U && Q === "new" && ie === "(", "accept"),
          parsePrefix: /* @__PURE__ */ c((Q) => {
            const ie = Q.consume("new");
            Q.consume("function");
            const pe = Q.lexer.current.type === "(";
            if (!pe) {
              if (!j)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let Pe = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: !1,
              constructor: ie,
              parenthesis: pe
            };
            const Oe = Q.parseIntermediateType(F.FUNCTION);
            if (y === void 0)
              Pe.parameters = Fe(Oe);
            else {
              if (ie && Oe.type === "JsdocTypeFunction" && Oe.arrow)
                return Pe = Oe, Pe.constructor = !0, Pe;
              Pe.parameters = Ae(Oe);
              for (const Ge of Pe.parameters)
                if (Ge.type === "JsdocTypeKeyValue" && !y.includes(Ge.key))
                  throw new Error(`only allowed named parameters are ${y.join(", ")} but got ${Ge.type}`);
            }
            if (Q.consume(":"))
              Pe.returnType = Q.parseType(F.PREFIX);
            else if (!S)
              throw new Error("function is missing return type");
            return Pe;
          }, "parsePrefix")
        });
      }
      c(dt, "createFunctionParslet");
      function pt({ allowPostfix: y, allowEnclosingBrackets: S }) {
        return re({
          name: "variadicParslet",
          accept: /* @__PURE__ */ c((j) => j === "...", "accept"),
          precedence: F.PREFIX,
          parsePrefix: /* @__PURE__ */ c((j) => {
            j.consume("...");
            const U = S && j.consume("[");
            try {
              const Q = j.parseType(F.PREFIX);
              if (U && !j.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: O(Q),
                meta: {
                  position: "prefix",
                  squareBrackets: U
                }
              };
            } catch (Q) {
              if (Q instanceof a) {
                if (U)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: !1
                  }
                };
              } else
                throw Q;
            }
          }, "parsePrefix"),
          parseInfix: y ? (j, U) => (j.consume("..."), {
            type: "JsdocTypeVariadic",
            element: O(U),
            meta: {
              position: "suffix",
              squareBrackets: !1
            }
          }) : void 0
        });
      }
      c(pt, "createVariadicParslet");
      const it = re({
        name: "symbolParslet",
        accept: /* @__PURE__ */ c((y) => y === "(", "accept"),
        precedence: F.SYMBOL,
        parseInfix: /* @__PURE__ */ c((y, S) => {
          if (S.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          y.consume("(");
          const j = {
            type: "JsdocTypeSymbol",
            value: S.value
          };
          if (!y.consume(")")) {
            const U = y.parseIntermediateType(F.SYMBOL);
            if (j.element = $(U), !y.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return j;
        }, "parseInfix")
      }), Ht = re({
        name: "arrayBracketsParslet",
        precedence: F.ARRAY_BRACKETS,
        accept: /* @__PURE__ */ c((y, S) => y === "[" && S === "]", "accept"),
        parseInfix: /* @__PURE__ */ c((y, S) => (y.consume("["), y.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            O(S)
          ],
          meta: {
            brackets: "square",
            dot: !1
          }
        }), "parseInfix")
      });
      function _t({ objectFieldGrammar: y, allowKeyTypes: S }) {
        return re({
          name: "objectParslet",
          accept: /* @__PURE__ */ c((j) => j === "{", "accept"),
          parsePrefix: /* @__PURE__ */ c((j) => {
            j.consume("{");
            const U = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!j.consume("}")) {
              let Q;
              const ie = new oe(y, j.lexer, j);
              for (; ; ) {
                ie.acceptLexerState(j);
                let pe = ie.parseIntermediateType(F.OBJECT);
                j.acceptLexerState(ie), pe === void 0 && S && (pe = j.parseIntermediateType(F.OBJECT));
                let Pe = !1;
                if (pe.type === "JsdocTypeNullable" && (Pe = !0, pe = pe.element), pe.type === "JsdocTypeNumber" || pe.type === "JsdocTypeName" || pe.type === "JsdocTypeStringValue") {
                  let Oe;
                  pe.type === "JsdocTypeStringValue" && (Oe = pe.meta.quote), U.elements.push({
                    type: "JsdocTypeObjectField",
                    key: pe.value.toString(),
                    right: void 0,
                    optional: Pe,
                    readonly: !1,
                    meta: {
                      quote: Oe
                    }
                  });
                } else if (pe.type === "JsdocTypeObjectField" || pe.type === "JsdocTypeJsdocObjectField")
                  U.elements.push(pe);
                else
                  throw new l(pe);
                if (j.lexer.current.startOfLine)
                  Q = "linebreak", j.consume(",") || j.consume(";");
                else if (j.consume(","))
                  Q = "comma";
                else if (j.consume(";"))
                  Q = "semicolon";
                else
                  break;
                if (j.lexer.current.type === "}")
                  break;
              }
              if (U.meta.separator = Q ?? "comma", Q === "linebreak" && (U.meta.propertyIndent = "  "), !j.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return U;
          }, "parsePrefix")
        });
      }
      c(_t, "createObjectParslet");
      function Et({ allowSquaredProperties: y, allowKeyTypes: S, allowReadonly: j, allowOptional: U }) {
        return re({
          name: "objectFieldParslet",
          precedence: F.KEY_VALUE,
          accept: /* @__PURE__ */ c((Q) => Q === ":", "accept"),
          parseInfix: /* @__PURE__ */ c((Q, ie) => {
            var pe;
            let Pe = !1, Oe = !1;
            U && ie.type === "JsdocTypeNullable" && (Pe = !0, ie = ie.element), j && ie.type === "JsdocTypeReadonlyProperty" && (Oe = !0, ie = ie.element);
            const Ge = (pe = Q.baseParser) !== null && pe !== void 0 ? pe : Q;
            if (Ge.acceptLexerState(Q), ie.type === "JsdocTypeNumber" || ie.type === "JsdocTypeName" || ie.type === "JsdocTypeStringValue" || D(ie)) {
              if (D(ie) && !y)
                throw new l(ie);
              Ge.consume(":");
              let Jt;
              ie.type === "JsdocTypeStringValue" && (Jt = ie.meta.quote);
              const xt = Ge.parseType(F.KEY_VALUE);
              return Q.acceptLexerState(Ge), {
                type: "JsdocTypeObjectField",
                key: D(ie) ? ie : ie.value.toString(),
                right: xt,
                optional: Pe,
                readonly: Oe,
                meta: {
                  quote: Jt
                }
              };
            } else {
              if (!S)
                throw new l(ie);
              Ge.consume(":");
              const Jt = Ge.parseType(F.KEY_VALUE);
              return Q.acceptLexerState(Ge), {
                type: "JsdocTypeJsdocObjectField",
                left: O(ie),
                right: Jt
              };
            }
          }, "parseInfix")
        });
      }
      c(Et, "createObjectFieldParslet");
      function Nr({ allowOptional: y, allowVariadic: S }) {
        return re({
          name: "keyValueParslet",
          precedence: F.KEY_VALUE,
          accept: /* @__PURE__ */ c((j) => j === ":", "accept"),
          parseInfix: /* @__PURE__ */ c((j, U) => {
            let Q = !1, ie = !1;
            if (y && U.type === "JsdocTypeNullable" && (Q = !0, U = U.element), S && U.type === "JsdocTypeVariadic" && U.element !== void 0 && (ie = !0, U = U.element), U.type !== "JsdocTypeName")
              throw new l(U);
            j.consume(":");
            const pe = j.parseType(F.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: U.value,
              right: pe,
              optional: Q,
              variadic: ie
            };
          }, "parseInfix")
        });
      }
      c(Nr, "createKeyValueParslet");
      const To = [
        ...q,
        dt({
          allowWithoutParenthesis: !0,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        ue,
        se({
          allowedTypes: ["module", "external", "event"],
          pathGrammar: fe
        }),
        pt({
          allowEnclosingBrackets: !0,
          allowPostfix: !0
        }),
        ae({
          allowedAdditionalTokens: ["keyof"]
        }),
        it,
        Ht,
        te({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: fe
        })
      ], di = [
        ...To,
        _t({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            ae({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            Et({
              allowSquaredProperties: !1,
              allowKeyTypes: !0,
              allowOptional: !1,
              allowReadonly: !1
            }),
            ...To
          ],
          allowKeyTypes: !0
        }),
        Nr({
          allowOptional: !0,
          allowVariadic: !0
        })
      ], Ao = re({
        name: "typeOfParslet",
        accept: /* @__PURE__ */ c((y) => y === "typeof", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => (y.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: y.parseType(F.KEY_OF_TYPE_OF)
        }), "parsePrefix")
      }), pi = [
        ae({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        le,
        we,
        ue,
        _e,
        Et({
          allowSquaredProperties: !1,
          allowKeyTypes: !1,
          allowOptional: !1,
          allowReadonly: !1
        })
      ], fi = [
        ...q,
        _t({
          allowKeyTypes: !1,
          objectFieldGrammar: pi
        }),
        ae({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        Ao,
        dt({
          allowWithoutParenthesis: !1,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        pt({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        // additional name parslet is needed for some special cases
        ae({
          allowedAdditionalTokens: ["keyof"]
        }),
        se({
          allowedTypes: ["module"],
          pathGrammar: fe
        }),
        te({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: fe
        }),
        Nr({
          allowOptional: !1,
          allowVariadic: !1
        }),
        it
      ], hi = re({
        name: "assertsParslet",
        accept: /* @__PURE__ */ c((y) => y === "asserts", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          y.consume("asserts");
          const S = y.parseIntermediateType(F.SYMBOL);
          if (S.type !== "JsdocTypeName")
            throw new l(S, "A typescript asserts always has to have a name on the left side.");
          return y.consume("is") ? {
            type: "JsdocTypeAsserts",
            left: S,
            right: O(y.parseIntermediateType(F.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: S
          };
        }, "parsePrefix")
      });
      function $o({ allowQuestionMark: y }) {
        return re({
          name: "tupleParslet",
          accept: /* @__PURE__ */ c((S) => S === "[", "accept"),
          parsePrefix: /* @__PURE__ */ c((S) => {
            S.consume("[");
            const j = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (S.consume("]"))
              return j;
            const U = S.parseIntermediateType(F.ALL);
            if (U.type === "JsdocTypeParameterList" ? U.elements[0].type === "JsdocTypeKeyValue" ? j.elements = U.elements.map(L) : j.elements = U.elements.map(O) : U.type === "JsdocTypeKeyValue" ? j.elements = [L(U)] : j.elements = [O(U)], !S.consume("]"))
              throw new Error("Unterminated '['");
            if (j.elements.some((Q) => Q.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return j;
          }, "parsePrefix")
        });
      }
      c($o, "createTupleParslet");
      const mi = re({
        name: "keyOfParslet",
        accept: /* @__PURE__ */ c((y) => y === "keyof", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => (y.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: O(y.parseType(F.KEY_OF_TYPE_OF))
        }), "parsePrefix")
      }), yi = re({
        name: "importParslet",
        accept: /* @__PURE__ */ c((y) => y === "import", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          if (y.consume("import"), !y.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          const S = y.parseType(F.PREFIX);
          if (S.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!y.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: S
          };
        }, "parsePrefix")
      }), gi = re({
        name: "readonlyPropertyParslet",
        accept: /* @__PURE__ */ c((y) => y === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => (y.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: y.parseIntermediateType(F.KEY_VALUE)
        }), "parsePrefix")
      }), bi = re({
        name: "arrowFunctionParslet",
        precedence: F.ARROW,
        accept: /* @__PURE__ */ c((y) => y === "=>", "accept"),
        parseInfix: /* @__PURE__ */ c((y, S) => (y.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: Ae(S).map(M),
          arrow: !0,
          constructor: !1,
          parenthesis: !0,
          returnType: y.parseType(F.OBJECT)
        }), "parseInfix")
      }), vi = re({
        name: "genericArrowFunctionParslet",
        accept: /* @__PURE__ */ c((y) => y === "<", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          const S = [];
          y.consume("<");
          do {
            let U, Q = y.parseIntermediateType(F.SYMBOL);
            if (Q.type === "JsdocTypeOptional" && (Q = Q.element, U = y.parseType(F.SYMBOL)), Q.type !== "JsdocTypeName")
              throw new l(Q);
            let ie;
            y.consume("extends") && (ie = y.parseType(F.SYMBOL), ie.type === "JsdocTypeOptional" && (ie = ie.element, U = y.parseType(F.SYMBOL)));
            const pe = {
              type: "JsdocTypeTypeParameter",
              name: Q
            };
            if (ie !== void 0 && (pe.constraint = ie), U !== void 0 && (pe.defaultValue = U), S.push(pe), y.consume(">"))
              break;
          } while (y.consume(","));
          const j = y.parseIntermediateType(F.SYMBOL);
          return j.typeParameters = S, j;
        }, "parsePrefix")
      }), wi = re({
        name: "intersectionParslet",
        accept: /* @__PURE__ */ c((y) => y === "&", "accept"),
        precedence: F.INTERSECTION,
        parseInfix: /* @__PURE__ */ c((y, S) => {
          y.consume("&");
          const j = [];
          do
            j.push(y.parseType(F.INTERSECTION));
          while (y.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [O(S), ...j]
          };
        }, "parseInfix")
      }), _i = re({
        name: "predicateParslet",
        precedence: F.INFIX,
        accept: /* @__PURE__ */ c((y) => y === "is", "accept"),
        parseInfix: /* @__PURE__ */ c((y, S) => {
          if (S.type !== "JsdocTypeName")
            throw new l(S, "A typescript predicate always has to have a name on the left side.");
          return y.consume("is"), {
            type: "JsdocTypePredicate",
            left: S,
            right: O(y.parseIntermediateType(F.INFIX))
          };
        }, "parseInfix")
      }), Ei = re({
        name: "objectSquareBracketPropertyParslet",
        accept: /* @__PURE__ */ c((y) => y === "[", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => {
          if (y.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          y.consume("[");
          const S = y.lexer.current.text;
          y.consume("Identifier");
          let j;
          if (y.consume(":")) {
            const U = y.baseParser;
            U.acceptLexerState(y), j = {
              type: "JsdocTypeIndexSignature",
              key: S,
              right: U.parseType(F.INDEX_BRACKETS)
            }, y.acceptLexerState(U);
          } else if (y.consume("in")) {
            const U = y.baseParser;
            U.acceptLexerState(y), j = {
              type: "JsdocTypeMappedType",
              key: S,
              right: U.parseType(F.ARRAY_BRACKETS)
            }, y.acceptLexerState(U);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!y.consume("]"))
            throw new Error("Unterminated square brackets");
          return j;
        }, "parsePrefix")
      }), xi = re({
        name: "readonlyArrayParslet",
        accept: /* @__PURE__ */ c((y) => y === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ c((y) => (y.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: I(y.parseIntermediateType(F.ALL))
        }), "parsePrefix")
      }), Si = re({
        name: "conditionalParslet",
        precedence: F.INFIX,
        accept: /* @__PURE__ */ c((y) => y === "extends", "accept"),
        parseInfix: /* @__PURE__ */ c((y, S) => {
          y.consume("extends");
          const j = y.parseType(F.KEY_OF_TYPE_OF).element, U = y.parseType(F.INFIX);
          return y.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: O(S),
            extendsType: j,
            trueType: U,
            falseType: y.parseType(F.INFIX)
          };
        }, "parseInfix")
      }), Ti = [
        gi,
        ae({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        le,
        we,
        ue,
        _e,
        Et({
          allowSquaredProperties: !0,
          allowKeyTypes: !1,
          allowOptional: !0,
          allowReadonly: !0
        }),
        Ei
      ], Ai = [
        ...q,
        _t({
          allowKeyTypes: !1,
          objectFieldGrammar: Ti
        }),
        xi,
        Ao,
        mi,
        yi,
        ue,
        dt({
          allowWithoutParenthesis: !0,
          allowNoReturnType: !1,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: !0
        }),
        $o({
          allowQuestionMark: !1
        }),
        pt({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        hi,
        Si,
        ae({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        se({
          allowedTypes: ["module"],
          pathGrammar: fe
        }),
        Ht,
        bi,
        vi,
        te({
          allowSquareBracketsOnAnyType: !0,
          allowJsdocNamePaths: !1,
          pathGrammar: fe
        }),
        wi,
        _i,
        Nr({
          allowVariadic: !0,
          allowOptional: !0
        })
      ];
      function $n(y, S) {
        switch (S) {
          case "closure":
            return new oe(fi, y).parse();
          case "jsdoc":
            return new oe(di, y).parse();
          case "typescript":
            return new oe(Ai, y).parse();
        }
      }
      c($n, "parse");
      function Co(y, S = ["typescript", "closure", "jsdoc"]) {
        let j;
        for (const U of S)
          try {
            return $n(y, U);
          } catch (Q) {
            j = Q;
          }
        throw j;
      }
      c(Co, "tryParse");
      function K(y, S) {
        const j = y[S.type];
        if (j === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${S.type}.`);
        return j(S, (U) => K(y, U));
      }
      c(K, "transform");
      function Ce(y) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      c(Ce, "notAvailableTransform");
      function sr(y) {
        const S = {
          params: []
        };
        for (const j of y.parameters)
          j.type === "JsdocTypeKeyValue" ? j.key === "this" ? S.this = j.right : j.key === "new" ? S.new = j.right : S.params.push(j) : S.params.push(j);
        return S;
      }
      c(sr, "extractSpecialParams");
      function Cn(y, S, j) {
        return y === "prefix" ? j + S : S + j;
      }
      c(Cn, "applyPosition");
      function Vt(y, S) {
        switch (S) {
          case "double":
            return `"${y}"`;
          case "single":
            return `'${y}'`;
          case void 0:
            return y;
        }
      }
      c(Vt, "quote");
      function $i() {
        return {
          JsdocTypeParenthesis: /* @__PURE__ */ c((y, S) => `(${y.element !== void 0 ? S(y.element) : ""})`, "JsdocTypeParenthesis"),
          JsdocTypeKeyof: /* @__PURE__ */ c((y, S) => `keyof ${S(y.element)}`, "JsdocTypeKeyof"),
          JsdocTypeFunction: /* @__PURE__ */ c((y, S) => {
            var j;
            if (y.arrow) {
              if (y.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let U = `${y.typeParameters !== void 0 ? `<${(j = y.typeParameters.map(S).join(", ")) !== null && j !== void 0 ? j : ""}>` : ""}(${y.parameters.map(S).join(", ")}) => ${S(y.returnType)}`;
              return y.constructor && (U = "new " + U), U;
            } else {
              let U = y.constructor ? "new" : "function";
              return y.parenthesis && (U += `(${y.parameters.map(S).join(", ")})`, y.returnType !== void 0 && (U += `: ${S(y.returnType)}`)), U;
            }
          }, "JsdocTypeFunction"),
          JsdocTypeName: /* @__PURE__ */ c((y) => y.value, "JsdocTypeName"),
          JsdocTypeTuple: /* @__PURE__ */ c((y, S) => `[${y.elements.map(S).join(", ")}]`, "JsdocTypeTuple"),
          JsdocTypeVariadic: /* @__PURE__ */ c((y, S) => y.meta.position === void 0 ? "..." : Cn(y.meta.position, S(y.element), "..."), "JsdocTypeVariadic"),
          JsdocTypeNamePath: /* @__PURE__ */ c((y, S) => {
            const j = S(y.left), U = S(y.right);
            switch (y.pathType) {
              case "inner":
                return `${j}~${U}`;
              case "instance":
                return `${j}#${U}`;
              case "property":
                return `${j}.${U}`;
              case "property-brackets":
                return `${j}[${U}]`;
            }
          }, "JsdocTypeNamePath"),
          JsdocTypeStringValue: /* @__PURE__ */ c((y) => Vt(y.value, y.meta.quote), "JsdocTypeStringValue"),
          JsdocTypeAny: /* @__PURE__ */ c(() => "*", "JsdocTypeAny"),
          JsdocTypeGeneric: /* @__PURE__ */ c((y, S) => {
            if (y.meta.brackets === "square") {
              const j = y.elements[0], U = S(j);
              return j.type === "JsdocTypeUnion" || j.type === "JsdocTypeIntersection" ? `(${U})[]` : `${U}[]`;
            } else
              return `${S(y.left)}${y.meta.dot ? "." : ""}<${y.infer === !0 ? "infer " : ""}${y.elements.map(S).join(", ")}>`;
          }, "JsdocTypeGeneric"),
          JsdocTypeImport: /* @__PURE__ */ c((y, S) => `import(${S(y.element)})`, "JsdocTypeImport"),
          JsdocTypeObjectField: /* @__PURE__ */ c((y, S) => {
            let j = "";
            return y.readonly && (j += "readonly "), typeof y.key == "string" ? j += Vt(y.key, y.meta.quote) : j += S(y.key), y.optional && (j += "?"), y.right === void 0 ? j : j + `: ${S(y.right)}`;
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ c((y, S) => `${S(y.left)}: ${S(y.right)}`, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ c((y, S) => {
            let j = y.key;
            return y.optional && (j += "?"), y.variadic && (j = "..." + j), y.right === void 0 ? j : j + `: ${S(y.right)}`;
          }, "JsdocTypeKeyValue"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ c((y) => `${y.specialType}:${Vt(y.value, y.meta.quote)}`, "JsdocTypeSpecialNamePath"),
          JsdocTypeNotNullable: /* @__PURE__ */ c((y, S) => Cn(y.meta.position, S(y.element), "!"), "JsdocTypeNotNullable"),
          JsdocTypeNull: /* @__PURE__ */ c(() => "null", "JsdocTypeNull"),
          JsdocTypeNullable: /* @__PURE__ */ c((y, S) => Cn(y.meta.position, S(y.element), "?"), "JsdocTypeNullable"),
          JsdocTypeNumber: /* @__PURE__ */ c((y) => y.value.toString(), "JsdocTypeNumber"),
          JsdocTypeObject: /* @__PURE__ */ c((y, S) => {
            var j, U;
            return `{${(y.meta.separator === "linebreak" && y.elements.length > 1 ? `
` + ((j = y.meta.propertyIndent) !== null && j !== void 0 ? j : "") : "") + y.elements.map(S).join(y.meta.separator === "comma" ? ", " : y.meta.separator === "linebreak" ? `
` + ((U = y.meta.propertyIndent) !== null && U !== void 0 ? U : "") : "; ") + (y.meta.separator === "linebreak" && y.elements.length > 1 ? `
` : "")}}`;
          }, "JsdocTypeObject"),
          JsdocTypeOptional: /* @__PURE__ */ c((y, S) => Cn(y.meta.position, S(y.element), "="), "JsdocTypeOptional"),
          JsdocTypeSymbol: /* @__PURE__ */ c((y, S) => `${y.value}(${y.element !== void 0 ? S(y.element) : ""})`, "JsdocTypeSymbol"),
          JsdocTypeTypeof: /* @__PURE__ */ c((y, S) => `typeof ${S(y.element)}`, "JsdocTypeTypeof"),
          JsdocTypeUndefined: /* @__PURE__ */ c(() => "undefined", "JsdocTypeUndefined"),
          JsdocTypeUnion: /* @__PURE__ */ c((y, S) => y.elements.map(S).join(" | "), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ c(() => "?", "JsdocTypeUnknown"),
          JsdocTypeIntersection: /* @__PURE__ */ c((y, S) => y.elements.map(S).join(" & "), "JsdocTypeIntersection"),
          JsdocTypeProperty: /* @__PURE__ */ c((y) => Vt(y.value, y.meta.quote), "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ c((y, S) => `${S(y.left)} is ${S(y.right)}`, "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ c((y, S) => `[${y.key}: ${S(y.right)}]`, "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ c((y, S) => `[${y.key} in ${S(y.right)}]`, "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ c((y, S) => `asserts ${S(y.left)} is ${S(y.right)}`, "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ c((y, S) => `readonly ${S(y.element)}`, "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ c((y, S) => `asserts ${S(y.element)}`, "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ c((y, S) => `${S(y.checksType)} extends ${S(y.extendsType)} ? ${S(y.trueType)} : ${S(y.falseType)}`, "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ c((y, S) => `${S(y.name)}${y.constraint !== void 0 ? ` extends ${S(y.constraint)}` : ""}${y.defaultValue !== void 0 ? ` = ${S(y.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
        };
      }
      c($i, "stringifyRules");
      const Ub = $i();
      function Hc(y) {
        return K(Ub, y);
      }
      c(Hc, "stringify");
      const Bb = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function zt(y) {
        const S = {
          type: "NameExpression",
          name: y
        };
        return Bb.includes(y) && (S.reservedWord = !0), S;
      }
      c(zt, "makeName");
      const Hb = {
        JsdocTypeOptional: /* @__PURE__ */ c((y, S) => {
          const j = S(y.element);
          return j.optional = !0, j;
        }, "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ c((y, S) => {
          const j = S(y.element);
          return j.nullable = !0, j;
        }, "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ c((y, S) => {
          const j = S(y.element);
          return j.nullable = !1, j;
        }, "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ c((y, S) => {
          if (y.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          const j = S(y.element);
          return j.repeatable = !0, j;
        }, "JsdocTypeVariadic"),
        JsdocTypeAny: /* @__PURE__ */ c(() => ({
          type: "AllLiteral"
        }), "JsdocTypeAny"),
        JsdocTypeNull: /* @__PURE__ */ c(() => ({
          type: "NullLiteral"
        }), "JsdocTypeNull"),
        JsdocTypeStringValue: /* @__PURE__ */ c((y) => zt(Vt(y.value, y.meta.quote)), "JsdocTypeStringValue"),
        JsdocTypeUndefined: /* @__PURE__ */ c(() => ({
          type: "UndefinedLiteral"
        }), "JsdocTypeUndefined"),
        JsdocTypeUnknown: /* @__PURE__ */ c(() => ({
          type: "UnknownLiteral"
        }), "JsdocTypeUnknown"),
        JsdocTypeFunction: /* @__PURE__ */ c((y, S) => {
          const j = sr(y), U = {
            type: "FunctionType",
            params: j.params.map(S)
          };
          return j.this !== void 0 && (U.this = S(j.this)), j.new !== void 0 && (U.new = S(j.new)), y.returnType !== void 0 && (U.result = S(y.returnType)), U;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ c((y, S) => ({
          type: "TypeApplication",
          applications: y.elements.map((j) => S(j)),
          expression: S(y.left)
        }), "JsdocTypeGeneric"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ c((y) => zt(y.specialType + ":" + Vt(y.value, y.meta.quote)), "JsdocTypeSpecialNamePath"),
        JsdocTypeName: /* @__PURE__ */ c((y) => y.value !== "function" ? zt(y.value) : {
          type: "FunctionType",
          params: []
        }, "JsdocTypeName"),
        JsdocTypeNumber: /* @__PURE__ */ c((y) => zt(y.value.toString()), "JsdocTypeNumber"),
        JsdocTypeObject: /* @__PURE__ */ c((y, S) => {
          const j = {
            type: "RecordType",
            fields: []
          };
          for (const U of y.elements)
            U.type !== "JsdocTypeObjectField" && U.type !== "JsdocTypeJsdocObjectField" ? j.fields.push({
              type: "FieldType",
              key: S(U),
              value: void 0
            }) : j.fields.push(S(U));
          return j;
        }, "JsdocTypeObject"),
        JsdocTypeObjectField: /* @__PURE__ */ c((y, S) => {
          if (typeof y.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: zt(Vt(y.key, y.meta.quote)),
            value: y.right === void 0 ? void 0 : S(y.right)
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ c((y, S) => ({
          type: "FieldType",
          key: S(y.left),
          value: S(y.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeUnion: /* @__PURE__ */ c((y, S) => ({
          type: "TypeUnion",
          elements: y.elements.map((j) => S(j))
        }), "JsdocTypeUnion"),
        JsdocTypeKeyValue: /* @__PURE__ */ c((y, S) => ({
          type: "FieldType",
          key: zt(y.key),
          value: y.right === void 0 ? void 0 : S(y.right)
        }), "JsdocTypeKeyValue"),
        JsdocTypeNamePath: /* @__PURE__ */ c((y, S) => {
          const j = S(y.left);
          let U;
          y.right.type === "JsdocTypeSpecialNamePath" ? U = S(y.right).name : U = Vt(y.right.value, y.right.meta.quote);
          const Q = y.pathType === "inner" ? "~" : y.pathType === "instance" ? "#" : ".";
          return zt(`${j.name}${Q}${U}`);
        }, "JsdocTypeNamePath"),
        JsdocTypeSymbol: /* @__PURE__ */ c((y) => {
          let S = "", j = y.element, U = !1;
          return j?.type === "JsdocTypeVariadic" && (j.meta.position === "prefix" ? S = "..." : U = !0, j = j.element), j?.type === "JsdocTypeName" ? S += j.value : j?.type === "JsdocTypeNumber" && (S += j.value.toString()), U && (S += "..."), zt(`${y.value}(${S})`);
        }, "JsdocTypeSymbol"),
        JsdocTypeParenthesis: /* @__PURE__ */ c((y, S) => S(O(y.element)), "JsdocTypeParenthesis"),
        JsdocTypeMappedType: Ce,
        JsdocTypeIndexSignature: Ce,
        JsdocTypeImport: Ce,
        JsdocTypeKeyof: Ce,
        JsdocTypeTuple: Ce,
        JsdocTypeTypeof: Ce,
        JsdocTypeIntersection: Ce,
        JsdocTypeProperty: Ce,
        JsdocTypePredicate: Ce,
        JsdocTypeAsserts: Ce,
        JsdocTypeReadonlyArray: Ce,
        JsdocTypeAssertsPlain: Ce,
        JsdocTypeConditional: Ce,
        JsdocTypeTypeParameter: Ce
      };
      function Vc(y) {
        return K(Hb, y);
      }
      c(Vc, "catharsisTransform");
      function lr(y) {
        switch (y) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      c(lr, "getQuoteStyle");
      function zc(y) {
        switch (y) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      c(zc, "getMemberType");
      function ko(y, S) {
        return S.length === 2 ? {
          type: y,
          left: S[0],
          right: S[1]
        } : {
          type: y,
          left: S[0],
          right: ko(y, S.slice(1))
        };
      }
      c(ko, "nestResults");
      const Vb = {
        JsdocTypeOptional: /* @__PURE__ */ c((y, S) => ({
          type: "OPTIONAL",
          value: S(y.element),
          meta: {
            syntax: y.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }), "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ c((y, S) => ({
          type: "NULLABLE",
          value: S(y.element),
          meta: {
            syntax: y.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }), "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ c((y, S) => ({
          type: "NOT_NULLABLE",
          value: S(y.element),
          meta: {
            syntax: y.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ c((y, S) => {
          const j = {
            type: "VARIADIC",
            meta: {
              syntax: y.meta.position === "prefix" ? "PREFIX_DOTS" : y.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return y.element !== void 0 && (j.value = S(y.element)), j;
        }, "JsdocTypeVariadic"),
        JsdocTypeName: /* @__PURE__ */ c((y) => ({
          type: "NAME",
          name: y.value
        }), "JsdocTypeName"),
        JsdocTypeTypeof: /* @__PURE__ */ c((y, S) => ({
          type: "TYPE_QUERY",
          name: S(y.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeTuple: /* @__PURE__ */ c((y, S) => ({
          type: "TUPLE",
          entries: y.elements.map(S)
        }), "JsdocTypeTuple"),
        JsdocTypeKeyof: /* @__PURE__ */ c((y, S) => ({
          type: "KEY_QUERY",
          value: S(y.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeImport: /* @__PURE__ */ c((y) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: lr(y.element.meta.quote),
            string: y.element.value
          }
        }), "JsdocTypeImport"),
        JsdocTypeUndefined: /* @__PURE__ */ c(() => ({
          type: "NAME",
          name: "undefined"
        }), "JsdocTypeUndefined"),
        JsdocTypeAny: /* @__PURE__ */ c(() => ({
          type: "ANY"
        }), "JsdocTypeAny"),
        JsdocTypeFunction: /* @__PURE__ */ c((y, S) => {
          const j = sr(y), U = {
            type: y.arrow ? "ARROW" : "FUNCTION",
            params: j.params.map((Q) => {
              if (Q.type === "JsdocTypeKeyValue") {
                if (Q.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: Q.key,
                  typeName: S(Q.right)
                };
              } else
                return S(Q);
            }),
            new: null,
            returns: null
          };
          return j.this !== void 0 ? U.this = S(j.this) : y.arrow || (U.this = null), j.new !== void 0 && (U.new = S(j.new)), y.returnType !== void 0 && (U.returns = S(y.returnType)), U;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ c((y, S) => {
          const j = {
            type: "GENERIC",
            subject: S(y.left),
            objects: y.elements.map(S),
            meta: {
              syntax: y.meta.brackets === "square" ? "SQUARE_BRACKET" : y.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return y.meta.brackets === "square" && y.elements[0].type === "JsdocTypeFunction" && !y.elements[0].parenthesis && (j.objects[0] = {
            type: "NAME",
            name: "function"
          }), j;
        }, "JsdocTypeGeneric"),
        JsdocTypeObjectField: /* @__PURE__ */ c((y, S) => {
          if (typeof y.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (y.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: y.key,
              quoteStyle: lr(y.meta.quote),
              value: null,
              readonly: !1
            };
          let j = S(y.right);
          return y.optional && (j = {
            type: "OPTIONAL",
            value: j,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: y.key.toString(),
            quoteStyle: lr(y.meta.quote),
            value: j,
            readonly: !1
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ c(() => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        }, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: /* @__PURE__ */ c((y, S) => {
          if (y.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: y.key,
              quoteStyle: "none",
              value: null,
              readonly: !1
            };
          let j = S(y.right);
          return y.optional && (j = {
            type: "OPTIONAL",
            value: j,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: y.key,
            quoteStyle: "none",
            value: j,
            readonly: !1
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeObject: /* @__PURE__ */ c((y, S) => {
          const j = [];
          for (const U of y.elements)
            (U.type === "JsdocTypeObjectField" || U.type === "JsdocTypeJsdocObjectField") && j.push(S(U));
          return {
            type: "RECORD",
            entries: j
          };
        }, "JsdocTypeObject"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ c((y) => {
          if (y.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${y.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: lr(y.meta.quote),
              path: y.value
            }
          };
        }, "JsdocTypeSpecialNamePath"),
        JsdocTypeNamePath: /* @__PURE__ */ c((y, S) => {
          let j = !1, U, Q;
          y.right.type === "JsdocTypeSpecialNamePath" && y.right.specialType === "event" ? (j = !0, U = y.right.value, Q = lr(y.right.meta.quote)) : (U = y.right.value, Q = lr(y.right.meta.quote));
          const ie = {
            type: zc(y.pathType),
            owner: S(y.left),
            name: U,
            quoteStyle: Q,
            hasEventPrefix: j
          };
          if (ie.owner.type === "MODULE") {
            const pe = ie.owner;
            return ie.owner = ie.owner.value, pe.value = ie, pe;
          } else
            return ie;
        }, "JsdocTypeNamePath"),
        JsdocTypeUnion: /* @__PURE__ */ c((y, S) => ko("UNION", y.elements.map(S)), "JsdocTypeUnion"),
        JsdocTypeParenthesis: /* @__PURE__ */ c((y, S) => ({
          type: "PARENTHESIS",
          value: S(O(y.element))
        }), "JsdocTypeParenthesis"),
        JsdocTypeNull: /* @__PURE__ */ c(() => ({
          type: "NAME",
          name: "null"
        }), "JsdocTypeNull"),
        JsdocTypeUnknown: /* @__PURE__ */ c(() => ({
          type: "UNKNOWN"
        }), "JsdocTypeUnknown"),
        JsdocTypeStringValue: /* @__PURE__ */ c((y) => ({
          type: "STRING_VALUE",
          quoteStyle: lr(y.meta.quote),
          string: y.value
        }), "JsdocTypeStringValue"),
        JsdocTypeIntersection: /* @__PURE__ */ c((y, S) => ko("INTERSECTION", y.elements.map(S)), "JsdocTypeIntersection"),
        JsdocTypeNumber: /* @__PURE__ */ c((y) => ({
          type: "NUMBER_VALUE",
          number: y.value.toString()
        }), "JsdocTypeNumber"),
        JsdocTypeSymbol: Ce,
        JsdocTypeProperty: Ce,
        JsdocTypePredicate: Ce,
        JsdocTypeMappedType: Ce,
        JsdocTypeIndexSignature: Ce,
        JsdocTypeAsserts: Ce,
        JsdocTypeReadonlyArray: Ce,
        JsdocTypeAssertsPlain: Ce,
        JsdocTypeConditional: Ce,
        JsdocTypeTypeParameter: Ce
      };
      function Jc(y) {
        return K(Vb, y);
      }
      c(Jc, "jtpTransform");
      function Wc() {
        return {
          JsdocTypeIntersection: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeIntersection",
            elements: y.elements.map(S)
          }), "JsdocTypeIntersection"),
          JsdocTypeGeneric: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeGeneric",
            left: S(y.left),
            elements: y.elements.map(S),
            meta: {
              dot: y.meta.dot,
              brackets: y.meta.brackets
            }
          }), "JsdocTypeGeneric"),
          JsdocTypeNullable: /* @__PURE__ */ c((y) => y, "JsdocTypeNullable"),
          JsdocTypeUnion: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeUnion",
            elements: y.elements.map(S)
          }), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ c((y) => y, "JsdocTypeUnknown"),
          JsdocTypeUndefined: /* @__PURE__ */ c((y) => y, "JsdocTypeUndefined"),
          JsdocTypeTypeof: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeTypeof",
            element: S(y.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeSymbol: /* @__PURE__ */ c((y, S) => {
            const j = {
              type: "JsdocTypeSymbol",
              value: y.value
            };
            return y.element !== void 0 && (j.element = S(y.element)), j;
          }, "JsdocTypeSymbol"),
          JsdocTypeOptional: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeOptional",
            element: S(y.element),
            meta: {
              position: y.meta.position
            }
          }), "JsdocTypeOptional"),
          JsdocTypeObject: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: y.elements.map(S)
          }), "JsdocTypeObject"),
          JsdocTypeNumber: /* @__PURE__ */ c((y) => y, "JsdocTypeNumber"),
          JsdocTypeNull: /* @__PURE__ */ c((y) => y, "JsdocTypeNull"),
          JsdocTypeNotNullable: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeNotNullable",
            element: S(y.element),
            meta: {
              position: y.meta.position
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ c((y) => y, "JsdocTypeSpecialNamePath"),
          JsdocTypeObjectField: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeObjectField",
            key: y.key,
            right: y.right === void 0 ? void 0 : S(y.right),
            optional: y.optional,
            readonly: y.readonly,
            meta: y.meta
          }), "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeJsdocObjectField",
            left: S(y.left),
            right: S(y.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeKeyValue",
            key: y.key,
            right: y.right === void 0 ? void 0 : S(y.right),
            optional: y.optional,
            variadic: y.variadic
          }), "JsdocTypeKeyValue"),
          JsdocTypeImport: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeImport",
            element: S(y.element)
          }), "JsdocTypeImport"),
          JsdocTypeAny: /* @__PURE__ */ c((y) => y, "JsdocTypeAny"),
          JsdocTypeStringValue: /* @__PURE__ */ c((y) => y, "JsdocTypeStringValue"),
          JsdocTypeNamePath: /* @__PURE__ */ c((y) => y, "JsdocTypeNamePath"),
          JsdocTypeVariadic: /* @__PURE__ */ c((y, S) => {
            const j = {
              type: "JsdocTypeVariadic",
              meta: {
                position: y.meta.position,
                squareBrackets: y.meta.squareBrackets
              }
            };
            return y.element !== void 0 && (j.element = S(y.element)), j;
          }, "JsdocTypeVariadic"),
          JsdocTypeTuple: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeTuple",
            elements: y.elements.map(S)
          }), "JsdocTypeTuple"),
          JsdocTypeName: /* @__PURE__ */ c((y) => y, "JsdocTypeName"),
          JsdocTypeFunction: /* @__PURE__ */ c((y, S) => {
            const j = {
              type: "JsdocTypeFunction",
              arrow: y.arrow,
              parameters: y.parameters.map(S),
              constructor: y.constructor,
              parenthesis: y.parenthesis
            };
            return y.returnType !== void 0 && (j.returnType = S(y.returnType)), j;
          }, "JsdocTypeFunction"),
          JsdocTypeKeyof: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeKeyof",
            element: S(y.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeParenthesis: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeParenthesis",
            element: S(y.element)
          }), "JsdocTypeParenthesis"),
          JsdocTypeProperty: /* @__PURE__ */ c((y) => y, "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypePredicate",
            left: S(y.left),
            right: S(y.right)
          }), "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeIndexSignature",
            key: y.key,
            right: S(y.right)
          }), "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeMappedType",
            key: y.key,
            right: S(y.right)
          }), "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeAsserts",
            left: S(y.left),
            right: S(y.right)
          }), "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeReadonlyArray",
            element: S(y.element)
          }), "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeAssertsPlain",
            element: S(y.element)
          }), "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeConditional",
            checksType: S(y.checksType),
            extendsType: S(y.extendsType),
            trueType: S(y.trueType),
            falseType: S(y.falseType)
          }), "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ c((y, S) => ({
            type: "JsdocTypeTypeParameter",
            name: S(y.name),
            constraint: y.constraint !== void 0 ? S(y.constraint) : void 0,
            defaultValue: y.defaultValue !== void 0 ? S(y.defaultValue) : void 0
          }), "JsdocTypeTypeParameter")
        };
      }
      c(Wc, "identityTransformRules");
      const Gc = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function Po(y, S, j, U, Q) {
        U?.(y, S, j);
        const ie = Gc[y.type];
        for (const pe of ie) {
          const Pe = y[pe];
          if (Pe !== void 0)
            if (Array.isArray(Pe))
              for (const Oe of Pe)
                Po(Oe, y, pe, U, Q);
            else
              Po(Pe, y, pe, U, Q);
        }
        Q?.(y, S, j);
      }
      c(Po, "_traverse");
      function Kc(y, S, j) {
        Po(y, void 0, void 0, S, j);
      }
      c(Kc, "traverse"), r.catharsisTransform = Vc, r.identityTransformRules = Wc, r.jtpTransform = Jc, r.parse = $n, r.stringify = Hc, r.stringifyRules = $i, r.transform = K, r.traverse = Kc, r.tryParse = Co, r.visitorKeys = Gc;
    });
  }
}), Dne = ["null", "undefined"];
function Lm(e) {
  return Dne.some((t) => t === e);
}
c(Lm, "isDefaultValueBlacklisted");
var qne = /* @__PURE__ */ c((e) => {
  if (!e)
    return "";
  if (typeof e == "string")
    return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, "str");
function pE(e) {
  return !!e.__docgenInfo;
}
c(pE, "hasDocgen");
function Lne(e) {
  return e != null && Object.keys(e).length > 0;
}
c(Lne, "isValidDocgenSection");
function Fne(e, t) {
  return pE(e) ? e.__docgenInfo[t] : null;
}
c(Fne, "getDocgenSection");
function YM(e) {
  return pE(e) ? qne(e.__docgenInfo.description) : "";
}
c(YM, "getDocgenDescription");
var Pa;
(function(e) {
  e.start = "/**", e.nostart = "/***", e.delim = "*", e.end = "*/";
})(Pa = Pa || (Pa = {}));
function XM(e) {
  return /^\s+$/.test(e);
}
c(XM, "isSpace");
function QM(e) {
  const t = e.match(/\r+$/);
  return t == null ? ["", e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
c(QM, "splitCR");
function Wi(e) {
  const t = e.match(/^\s+/);
  return t == null ? ["", e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
c(Wi, "splitSpace");
function ZM(e) {
  return e.split(/\n/);
}
c(ZM, "splitLines");
function eD(e = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: !1, description: "", problems: [], source: [] }, e);
}
c(eD, "seedSpec");
function tD(e = {}) {
  return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, e);
}
c(tD, "seedTokens");
var Une = /^@\S+/;
function rD({ fence: e = "```" } = {}) {
  const t = nD(e), r = /* @__PURE__ */ c((n, o) => t(n) ? !o : o, "toggleFence");
  return /* @__PURE__ */ c(function(n) {
    const o = [[]];
    let a = !1;
    for (const i of n)
      Une.test(i.tokens.description) && !a ? o.push([i]) : o[o.length - 1].push(i), a = r(i.tokens.description, a);
    return o;
  }, "parseBlock");
}
c(rD, "getParser");
function nD(e) {
  return typeof e == "string" ? (t) => t.split(e).length % 2 === 0 : e;
}
c(nD, "getFencer");
function oD({ startLine: e = 0, markers: t = Pa } = {}) {
  let r = null, n = e;
  return /* @__PURE__ */ c(function(o) {
    let a = o;
    const i = tD();
    if ([i.lineEnd, a] = QM(a), [i.start, a] = Wi(a), r === null && a.startsWith(t.start) && !a.startsWith(t.nostart) && (r = [], i.delimiter = a.slice(0, t.start.length), a = a.slice(t.start.length), [i.postDelimiter, a] = Wi(a)), r === null)
      return n++, null;
    const s = a.trimRight().endsWith(t.end);
    if (i.delimiter === "" && a.startsWith(t.delim) && !a.startsWith(t.end) && (i.delimiter = t.delim, a = a.slice(t.delim.length), [i.postDelimiter, a] = Wi(a)), s) {
      const d = a.trimRight();
      i.end = a.slice(d.length - t.end.length), a = d.slice(0, -t.end.length);
    }
    if (i.description = a, r.push({ number: n, source: o, tokens: i }), n++, s) {
      const d = r.slice();
      return r = null, d;
    }
    return null;
  }, "parseSource");
}
c(oD, "getParser");
function aD({ tokenizers: e }) {
  return /* @__PURE__ */ c(function(t) {
    var r;
    let n = eD({ source: t });
    for (const o of e)
      if (n = o(n), !((r = n.problems[n.problems.length - 1]) === null || r === void 0) && r.critical)
        break;
    return n;
  }, "parseSpec");
}
c(aD, "getParser");
function iD() {
  return (e) => {
    const { tokens: t } = e.source[0], r = t.description.match(/\s*(@(\S+))(\s*)/);
    return r === null ? (e.problems.push({
      code: "spec:tag:prefix",
      message: 'tag should start with "@" symbol',
      line: e.source[0].number,
      critical: !0
    }), e) : (t.tag = r[1], t.postTag = r[3], t.description = t.description.slice(r[0].length), e.tag = r[2], e);
  };
}
c(iD, "tagTokenizer");
function sD(e = "compact") {
  const t = lD(e);
  return (r) => {
    let n = 0, o = [];
    for (const [s, { tokens: d }] of r.source.entries()) {
      let l = "";
      if (s === 0 && d.description[0] !== "{")
        return r;
      for (const p of d.description)
        if (p === "{" && n++, p === "}" && n--, l += p, n === 0)
          break;
      if (o.push([d, l]), n === 0)
        break;
    }
    if (n !== 0)
      return r.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: r.source[0].number,
        critical: !0
      }), r;
    const a = [], i = o[0][0].postDelimiter.length;
    for (const [s, [d, l]] of o.entries())
      d.type = l, s > 0 && (d.type = d.postDelimiter.slice(i) + l, d.postDelimiter = d.postDelimiter.slice(0, i)), [d.postType, d.description] = Wi(d.description.slice(l.length)), a.push(d.type);
    return a[0] = a[0].slice(1), a[a.length - 1] = a[a.length - 1].slice(0, -1), r.type = t(a), r;
  };
}
c(sD, "typeTokenizer");
var Bne = /* @__PURE__ */ c((e) => e.trim(), "trim");
function lD(e) {
  return e === "compact" ? (t) => t.map(Bne).join("") : e === "preserve" ? (t) => t.join(`
`) : e;
}
c(lD, "getJoiner");
var Hne = /* @__PURE__ */ c((e) => e && e.startsWith('"') && e.endsWith('"'), "isQuoted");
function cD() {
  const e = /* @__PURE__ */ c((t, { tokens: r }, n) => r.type === "" ? t : n, "typeEnd");
  return (t) => {
    const { tokens: r } = t.source[t.source.reduce(e, 0)], n = r.description.trimLeft(), o = n.split('"');
    if (o.length > 1 && o[0] === "" && o.length % 2 === 1)
      return t.name = o[1], r.name = `"${o[1]}"`, [r.postName, r.description] = Wi(n.slice(r.name.length)), t;
    let a = 0, i = "", s = !1, d;
    for (const p of n) {
      if (a === 0 && XM(p))
        break;
      p === "[" && a++, p === "]" && a--, i += p;
    }
    if (a !== 0)
      return t.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: t.source[0].number,
        critical: !0
      }), t;
    const l = i;
    if (i[0] === "[" && i[i.length - 1] === "]") {
      s = !0, i = i.slice(1, -1);
      const p = i.split("=");
      if (i = p[0].trim(), p[1] !== void 0 && (d = p.slice(1).join("=").trim()), i === "")
        return t.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: t.source[0].number,
          critical: !0
        }), t;
      if (d === "")
        return t.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: t.source[0].number,
          critical: !0
        }), t;
      if (!Hne(d) && /=(?!>)/.test(d))
        return t.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: t.source[0].number,
          critical: !0
        }), t;
    }
    return t.optional = s, t.name = i, r.name = l, d !== void 0 && (t.default = d), [r.postName, r.description] = Wi(n.slice(r.name.length)), t;
  };
}
c(cD, "nameTokenizer");
function uD(e = "compact", t = Pa) {
  const r = fE(e);
  return (n) => (n.description = r(n.source, t), n);
}
c(uD, "descriptionTokenizer");
function fE(e) {
  return e === "compact" ? dD : e === "preserve" ? pD : e;
}
c(fE, "getJoiner");
function dD(e, t = Pa) {
  return e.map(({ tokens: { description: r } }) => r.trim()).filter((r) => r !== "").join(" ");
}
c(dD, "compactJoiner");
var Vne = /* @__PURE__ */ c((e, { tokens: t }, r) => t.type === "" ? e : r, "lineNo"), zne = /* @__PURE__ */ c(({ tokens: e }) => (e.delimiter === "" ? e.start : e.postDelimiter.slice(1)) + e.description, "getDescription");
function pD(e, t = Pa) {
  if (e.length === 0)
    return "";
  e[0].tokens.description === "" && e[0].tokens.delimiter === t.start && (e = e.slice(1));
  const r = e[e.length - 1];
  return r !== void 0 && r.tokens.description === "" && r.tokens.end.endsWith(t.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(Vne, 0)), e.map(zne).join(`
`);
}
c(pD, "preserveJoiner");
function fD({ startLine: e = 0, fence: t = "```", spacing: r = "compact", markers: n = Pa, tokenizers: o = [
  iD(),
  sD(r),
  cD(),
  uD(r)
] } = {}) {
  if (e < 0 || e % 1 > 0)
    throw new Error("Invalid startLine");
  const a = oD({ startLine: e, markers: n }), i = rD({ fence: t }), s = aD({ tokenizers: o }), d = fE(r);
  return function(l) {
    const p = [];
    for (const f of ZM(l)) {
      const h = a(f);
      if (h === null)
        continue;
      const m = i(h), g = m.slice(1).map(s);
      p.push({
        description: d(m[0], n),
        tags: g,
        source: h,
        problems: g.reduce((w, _) => w.concat(_.problems), [])
      });
    }
    return p;
  };
}
c(fD, "getParser");
function hD(e) {
  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.lineEnd;
}
c(hD, "join");
function Jne() {
  return (e) => e.source.map(({ tokens: t }) => hD(t)).join(`
`);
}
c(Jne, "getStringifier");
function mD(e, t = {}) {
  return fD(t)(e);
}
c(mD, "parse");
var hE = or(Mne(), 1);
function yD(e) {
  return e != null && e.includes("@");
}
c(yD, "containsJsDoc");
function gD(e) {
  const t = `/**
` + (e ?? "").split(`
`).map((n) => ` * ${n}`).join(`
`) + `
*/`, r = mD(t, {
    spacing: "preserve"
  });
  if (!r || r.length === 0)
    throw new Error("Cannot parse JSDoc tags.");
  return r[0];
}
c(gD, "parse");
var Wne = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
}, Gne = /* @__PURE__ */ c((e, t = Wne) => {
  if (!yD(e))
    return {
      includesJsDoc: !1,
      ignore: !1
    };
  const r = gD(e), n = bD(r, t.tags);
  return n.ignore ? {
    includesJsDoc: !0,
    ignore: !0
  } : {
    includesJsDoc: !0,
    ignore: !1,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: r.description.trim(),
    extractedTags: n
  };
}, "parseJsDoc");
function bD(e, t) {
  const r = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: !1
  };
  for (const n of e.tags)
    if (!(t !== void 0 && !t.includes(n.tag)))
      if (n.tag === "ignore") {
        r.ignore = !0;
        break;
      } else
        switch (n.tag) {
          // arg & argument are aliases for param.
          case "param":
          case "arg":
          case "argument": {
            const o = wD(n);
            o != null && (r.params == null && (r.params = []), r.params.push(o));
            break;
          }
          case "deprecated": {
            const o = _D(n);
            o != null && (r.deprecated = o);
            break;
          }
          case "returns": {
            const o = ED(n);
            o != null && (r.returns = o);
            break;
          }
        }
  return r;
}
c(bD, "extractJsDocTags");
function vD(e) {
  return e.replace(/[\.-]$/, "");
}
c(vD, "normaliseParamName");
function wD(e) {
  if (!e.name || e.name === "-")
    return null;
  const t = gE(e.type);
  return {
    name: e.name,
    type: t,
    description: yE(e.description),
    getPrettyName: /* @__PURE__ */ c(() => vD(e.name), "getPrettyName"),
    getTypeName: /* @__PURE__ */ c(() => t ? bE(t) : null, "getTypeName")
  };
}
c(wD, "extractParam");
function _D(e) {
  return e.name ? mE(e.name, e.description) : null;
}
c(_D, "extractDeprecated");
function mE(e, t) {
  const r = e === "" ? t : `${e} ${t}`;
  return yE(r);
}
c(mE, "joinNameAndDescription");
function yE(e) {
  const t = e.replace(/^- /g, "").trim();
  return t === "" ? null : t;
}
c(yE, "normaliseDescription");
function ED(e) {
  const t = gE(e.type);
  return t ? {
    type: t,
    description: mE(e.name, e.description),
    getTypeName: /* @__PURE__ */ c(() => bE(t), "getTypeName")
  } : null;
}
c(ED, "extractReturns");
var ei = (0, hE.stringifyRules)(), Kne = ei.JsdocTypeObject;
ei.JsdocTypeAny = () => "any";
ei.JsdocTypeObject = (e, t) => `(${Kne(e, t)})`;
ei.JsdocTypeOptional = (e, t) => t(e.element);
ei.JsdocTypeNullable = (e, t) => t(e.element);
ei.JsdocTypeNotNullable = (e, t) => t(e.element);
ei.JsdocTypeUnion = (e, t) => e.elements.map(t).join("|");
function gE(e) {
  try {
    return (0, hE.parse)(e, "typescript");
  } catch {
    return null;
  }
}
c(gE, "extractType");
function bE(e) {
  return (0, hE.transform)(ei, e);
}
c(bE, "extractTypeName");
var Yne = 90, Xne = 50;
function vE(e) {
  return e.length > Yne;
}
c(vE, "isTooLongForTypeSummary");
function xD(e) {
  return e.length > Xne;
}
c(xD, "isTooLongForDefaultValueSummary");
function tr(e, t) {
  return e === t ? { summary: e } : { summary: e, detail: t };
}
c(tr, "createSummaryValue");
function Qne(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Lm(r))
      return xD(r) ? tr(t?.name, r) : tr(r);
  }
  return null;
}
c(Qne, "createDefaultValue");
function wE({ name: e, value: t, elements: r, raw: n }) {
  return t ?? (r != null ? r.map(wE).join(" | ") : n ?? e);
}
c(wE, "generateUnionElement");
function SD({ name: e, raw: t, elements: r }) {
  return r != null ? tr(r.map(wE).join(" | ")) : t != null ? tr(t.replace(/^\|\s*/, "")) : tr(e);
}
c(SD, "generateUnion");
function TD({ type: e, raw: t }) {
  return t != null ? tr(t) : tr(e);
}
c(TD, "generateFuncSignature");
function AD({ type: e, raw: t }) {
  return t != null ? vE(t) ? tr(e, t) : tr(t) : tr(e);
}
c(AD, "generateObjectSignature");
function $D(e) {
  const { type: t } = e;
  return t === "object" ? AD(e) : TD(e);
}
c($D, "generateSignature");
function CD({ name: e, raw: t }) {
  return t != null ? vE(t) ? tr(e, t) : tr(t) : tr(e);
}
c(CD, "generateDefault");
function Zne(e) {
  if (e == null)
    return null;
  switch (e.name) {
    case "union":
      return SD(e);
    case "signature":
      return $D(e);
    default:
      return CD(e);
  }
}
c(Zne, "createType");
function eoe({ defaultValue: e }) {
  if (e != null) {
    const { value: t } = e;
    if (!Lm(t))
      return tr(t);
  }
  return null;
}
c(eoe, "createDefaultValue");
function toe({ tsType: e, required: t }) {
  if (e == null)
    return null;
  let r = e.name;
  return t || (r = r.replace(" | undefined", "")), tr(
    ["Array", "Record", "signature"].includes(e.name) ? e.raw : r
  );
}
c(toe, "createType");
function kD(e) {
  return e != null ? tr(e.name) : null;
}
c(kD, "createType");
function PD(e) {
  const { computed: t, func: r } = e;
  return typeof t > "u" && typeof r > "u";
}
c(PD, "isReactDocgenTypescript");
function OD(e) {
  return e ? e.name === "string" ? !0 : e.name === "enum" ? Array.isArray(e.value) && e.value.every(
    ({ value: t }) => typeof t == "string" && t[0] === '"' && t[t.length - 1] === '"'
  ) : !1 : !1;
}
c(OD, "isStringValued");
function RD(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Lm(r))
      return PD(e) && OD(t) ? tr(JSON.stringify(r)) : tr(r);
  }
  return null;
}
c(RD, "createDefaultValue");
function roe(e, t, r) {
  const { description: n, required: o, defaultValue: a } = r;
  return {
    name: e,
    type: kD(t),
    required: o,
    description: n,
    defaultValue: RD(a, t)
  };
}
c(roe, "createBasicPropDef");
function noe(e, t) {
  if (t?.includesJsDoc) {
    const { description: r, extractedTags: n } = t;
    r != null && (e.description = t.description);
    const o = {
      ...n,
      params: n?.params?.map(
        (a) => ({
          name: a.getPrettyName(),
          description: a.description
        })
      )
    };
    Object.values(o).filter(Boolean).length > 0 && (e.jsDocTags = o);
  }
  return e;
}
c(noe, "applyJsDocResult");
function ooe(e, t, r, n) {
  const o = Gne(t.description);
  return o.includesJsDoc && o.ignore ? null : {
    propDef: n(e, t, o),
    jsDocTags: o.extractedTags,
    docgenInfo: t,
    typeSystem: r
  };
}
c(ooe, "extractProp");
function aoe(e) {
  return e != null ? YM(e) : "";
}
c(aoe, "extractComponentDescription");
var Ba = /* @__PURE__ */ c((...e) => {
  const t = {}, r = e.filter(Boolean), n = r.reduce((o, a) => (Object.entries(a).forEach(([i, s]) => {
    const d = o[i];
    Array.isArray(s) || typeof d > "u" ? o[i] = s : Kr(s) && Kr(d) ? t[i] = !0 : typeof s < "u" && (o[i] = s);
  }), o), {});
  return Object.keys(t).forEach((o) => {
    const a = r.filter(Boolean).map((i) => i[o]).filter((i) => typeof i < "u");
    a.every((i) => Kr(i)) ? n[o] = Ba(...a) : n[o] = a[a.length - 1];
  }), n;
}, "combineParameters"), ioe = "storybook/docs", soe = `${ioe}/snippet-rendered`;
function jD() {
}
c(jD, "noop");
function ID(e, t) {
  return e === t || Number.isNaN(e) && Number.isNaN(t);
}
c(ID, "eq");
function ND(e, t, r) {
  return il(e, t, void 0, void 0, void 0, void 0, r);
}
c(ND, "isEqualWith");
function il(e, t, r, n, o, a, i) {
  const s = i(e, t, r, n, o, a);
  if (s !== void 0)
    return s;
  if (typeof e == typeof t)
    switch (typeof e) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return e === t;
      case "number":
        return e === t || Object.is(e, t);
      case "function":
        return e === t;
      case "object":
        return gl(e, t, a, i);
    }
  return gl(e, t, a, i);
}
c(il, "isEqualWithImpl");
function gl(e, t, r, n) {
  if (Object.is(e, t))
    return !0;
  let o = qf(e), a = qf(t);
  if (o === Wv && (o = ef), a === Wv && (a = ef), o !== a)
    return !1;
  switch (o) {
    case lM:
      return e.toString() === t.toString();
    case cM: {
      const d = e.valueOf(), l = t.valueOf();
      return ID(d, l);
    }
    case uM:
    case pM:
    case dM:
      return Object.is(e.valueOf(), t.valueOf());
    case sM:
      return e.source === t.source && e.flags === t.flags;
    case pne:
      return e === t;
  }
  r = r ?? /* @__PURE__ */ new Map();
  const i = r.get(e), s = r.get(t);
  if (i != null && s != null)
    return i === t;
  r.set(e, t), r.set(t, e);
  try {
    switch (o) {
      case fM: {
        if (e.size !== t.size)
          return !1;
        for (const [d, l] of e.entries())
          if (!t.has(d) || !il(l, t.get(d), d, e, t, r, n))
            return !1;
        return !0;
      }
      case hM: {
        if (e.size !== t.size)
          return !1;
        const d = Array.from(e.values()), l = Array.from(t.values());
        for (let p = 0; p < d.length; p++) {
          const f = d[p], h = l.findIndex((m) => il(f, m, void 0, e, t, r, n));
          if (h === -1)
            return !1;
          l.splice(h, 1);
        }
        return !0;
      }
      case mM:
      case bM:
      case vM:
      case wM:
      case _M:
      case hne:
      case EM:
      case xM:
      case SM:
      case mne:
      case TM:
      case AM: {
        if (typeof Buffer < "u" && Buffer.isBuffer(e) !== Buffer.isBuffer(t) || e.length !== t.length)
          return !1;
        for (let d = 0; d < e.length; d++)
          if (!il(e[d], t[d], d, e, t, r, n))
            return !1;
        return !0;
      }
      case yM:
        return e.byteLength !== t.byteLength ? !1 : gl(new Uint8Array(e), new Uint8Array(t), r, n);
      case gM:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset ? !1 : gl(new Uint8Array(e), new Uint8Array(t), r, n);
      case fne:
        return e.name === t.name && e.message === t.message;
      case ef: {
        if (!(gl(e.constructor, t.constructor, r, n) || Kr(e) && Kr(t)))
          return !1;
        const d = [...Object.keys(e), ...Df(e)], l = [...Object.keys(t), ...Df(t)];
        if (d.length !== l.length)
          return !1;
        for (let p = 0; p < d.length; p++) {
          const f = d[p], h = e[f];
          if (!Object.hasOwn(t, f))
            return !1;
          const m = t[f];
          if (!il(h, m, f, e, t, r, n))
            return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    r.delete(e), r.delete(t);
  }
}
c(gl, "areObjectsEqual");
function MD(e, t) {
  return ND(e, t, jD);
}
c(MD, "isEqual");
var loe = "Invariant failed";
function lo(e, t) {
  if (!e)
    throw new Error(loe);
}
c(lo, "invariant");
var DD = W({
  "../node_modules/entities/lib/maps/entities.json"(e, t) {
    t.exports = { Aacute: "Ã", aacute: "Ã¡", Abreve: "Ä‚", abreve: "Äƒ", ac: "âˆ¾", acd: "âˆ¿", acE: "âˆ¾Ì³", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", Acy: "Ð", acy: "Ð°", AElig: "Ã†", aelig: "Ã¦", af: "â¡", Afr: "ð”„", afr: "ð”ž", Agrave: "Ã€", agrave: "Ã ", alefsym: "â„µ", aleph: "â„µ", Alpha: "Î‘", alpha: "Î±", Amacr: "Ä€", amacr: "Ä", amalg: "â¨¿", amp: "&", AMP: "&", andand: "â©•", And: "â©“", and: "âˆ§", andd: "â©œ", andslope: "â©˜", andv: "â©š", ang: "âˆ ", ange: "â¦¤", angle: "âˆ ", angmsdaa: "â¦¨", angmsdab: "â¦©", angmsdac: "â¦ª", angmsdad: "â¦«", angmsdae: "â¦¬", angmsdaf: "â¦­", angmsdag: "â¦®", angmsdah: "â¦¯", angmsd: "âˆ¡", angrt: "âˆŸ", angrtvb: "âŠ¾", angrtvbd: "â¦", angsph: "âˆ¢", angst: "Ã…", angzarr: "â¼", Aogon: "Ä„", aogon: "Ä…", Aopf: "ð”¸", aopf: "ð•’", apacir: "â©¯", ap: "â‰ˆ", apE: "â©°", ape: "â‰Š", apid: "â‰‹", apos: "'", ApplyFunction: "â¡", approx: "â‰ˆ", approxeq: "â‰Š", Aring: "Ã…", aring: "Ã¥", Ascr: "ð’œ", ascr: "ð’¶", Assign: "â‰”", ast: "*", asymp: "â‰ˆ", asympeq: "â‰", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", awconint: "âˆ³", awint: "â¨‘", backcong: "â‰Œ", backepsilon: "Ï¶", backprime: "â€µ", backsim: "âˆ½", backsimeq: "â‹", Backslash: "âˆ–", Barv: "â«§", barvee: "âŠ½", barwed: "âŒ…", Barwed: "âŒ†", barwedge: "âŒ…", bbrk: "âŽµ", bbrktbrk: "âŽ¶", bcong: "â‰Œ", Bcy: "Ð‘", bcy: "Ð±", bdquo: "â€ž", becaus: "âˆµ", because: "âˆµ", Because: "âˆµ", bemptyv: "â¦°", bepsi: "Ï¶", bernou: "â„¬", Bernoullis: "â„¬", Beta: "Î’", beta: "Î²", beth: "â„¶", between: "â‰¬", Bfr: "ð”…", bfr: "ð”Ÿ", bigcap: "â‹‚", bigcirc: "â—¯", bigcup: "â‹ƒ", bigodot: "â¨€", bigoplus: "â¨", bigotimes: "â¨‚", bigsqcup: "â¨†", bigstar: "â˜…", bigtriangledown: "â–½", bigtriangleup: "â–³", biguplus: "â¨„", bigvee: "â‹", bigwedge: "â‹€", bkarow: "â¤", blacklozenge: "â§«", blacksquare: "â–ª", blacktriangle: "â–´", blacktriangledown: "â–¾", blacktriangleleft: "â—‚", blacktriangleright: "â–¸", blank: "â£", blk12: "â–’", blk14: "â–‘", blk34: "â–“", block: "â–ˆ", bne: "=âƒ¥", bnequiv: "â‰¡âƒ¥", bNot: "â«­", bnot: "âŒ", Bopf: "ð”¹", bopf: "ð•“", bot: "âŠ¥", bottom: "âŠ¥", bowtie: "â‹ˆ", boxbox: "â§‰", boxdl: "â”", boxdL: "â••", boxDl: "â•–", boxDL: "â•—", boxdr: "â”Œ", boxdR: "â•’", boxDr: "â•“", boxDR: "â•”", boxh: "â”€", boxH: "â•", boxhd: "â”¬", boxHd: "â•¤", boxhD: "â•¥", boxHD: "â•¦", boxhu: "â”´", boxHu: "â•§", boxhU: "â•¨", boxHU: "â•©", boxminus: "âŠŸ", boxplus: "âŠž", boxtimes: "âŠ ", boxul: "â”˜", boxuL: "â•›", boxUl: "â•œ", boxUL: "â•", boxur: "â””", boxuR: "â•˜", boxUr: "â•™", boxUR: "â•š", boxv: "â”‚", boxV: "â•‘", boxvh: "â”¼", boxvH: "â•ª", boxVh: "â•«", boxVH: "â•¬", boxvl: "â”¤", boxvL: "â•¡", boxVl: "â•¢", boxVL: "â•£", boxvr: "â”œ", boxvR: "â•ž", boxVr: "â•Ÿ", boxVR: "â• ", bprime: "â€µ", breve: "Ë˜", Breve: "Ë˜", brvbar: "Â¦", bscr: "ð’·", Bscr: "â„¬", bsemi: "â", bsim: "âˆ½", bsime: "â‹", bsolb: "â§…", bsol: "\\", bsolhsub: "âŸˆ", bull: "â€¢", bullet: "â€¢", bump: "â‰Ž", bumpE: "âª®", bumpe: "â‰", Bumpeq: "â‰Ž", bumpeq: "â‰", Cacute: "Ä†", cacute: "Ä‡", capand: "â©„", capbrcup: "â©‰", capcap: "â©‹", cap: "âˆ©", Cap: "â‹’", capcup: "â©‡", capdot: "â©€", CapitalDifferentialD: "â……", caps: "âˆ©ï¸€", caret: "â", caron: "Ë‡", Cayleys: "â„­", ccaps: "â©", Ccaron: "ÄŒ", ccaron: "Ä", Ccedil: "Ã‡", ccedil: "Ã§", Ccirc: "Äˆ", ccirc: "Ä‰", Cconint: "âˆ°", ccups: "â©Œ", ccupssm: "â©", Cdot: "ÄŠ", cdot: "Ä‹", cedil: "Â¸", Cedilla: "Â¸", cemptyv: "â¦²", cent: "Â¢", centerdot: "Â·", CenterDot: "Â·", cfr: "ð” ", Cfr: "â„­", CHcy: "Ð§", chcy: "Ñ‡", check: "âœ“", checkmark: "âœ“", Chi: "Î§", chi: "Ï‡", circ: "Ë†", circeq: "â‰—", circlearrowleft: "â†º", circlearrowright: "â†»", circledast: "âŠ›", circledcirc: "âŠš", circleddash: "âŠ", CircleDot: "âŠ™", circledR: "Â®", circledS: "â“ˆ", CircleMinus: "âŠ–", CirclePlus: "âŠ•", CircleTimes: "âŠ—", cir: "â—‹", cirE: "â§ƒ", cire: "â‰—", cirfnint: "â¨", cirmid: "â«¯", cirscir: "â§‚", ClockwiseContourIntegral: "âˆ²", CloseCurlyDoubleQuote: "â€", CloseCurlyQuote: "â€™", clubs: "â™£", clubsuit: "â™£", colon: ":", Colon: "âˆ·", Colone: "â©´", colone: "â‰”", coloneq: "â‰”", comma: ",", commat: "@", comp: "âˆ", compfn: "âˆ˜", complement: "âˆ", complexes: "â„‚", cong: "â‰…", congdot: "â©­", Congruent: "â‰¡", conint: "âˆ®", Conint: "âˆ¯", ContourIntegral: "âˆ®", copf: "ð•”", Copf: "â„‚", coprod: "âˆ", Coproduct: "âˆ", copy: "Â©", COPY: "Â©", copysr: "â„—", CounterClockwiseContourIntegral: "âˆ³", crarr: "â†µ", cross: "âœ—", Cross: "â¨¯", Cscr: "ð’ž", cscr: "ð’¸", csub: "â«", csube: "â«‘", csup: "â«", csupe: "â«’", ctdot: "â‹¯", cudarrl: "â¤¸", cudarrr: "â¤µ", cuepr: "â‹ž", cuesc: "â‹Ÿ", cularr: "â†¶", cularrp: "â¤½", cupbrcap: "â©ˆ", cupcap: "â©†", CupCap: "â‰", cup: "âˆª", Cup: "â‹“", cupcup: "â©Š", cupdot: "âŠ", cupor: "â©…", cups: "âˆªï¸€", curarr: "â†·", curarrm: "â¤¼", curlyeqprec: "â‹ž", curlyeqsucc: "â‹Ÿ", curlyvee: "â‹Ž", curlywedge: "â‹", curren: "Â¤", curvearrowleft: "â†¶", curvearrowright: "â†·", cuvee: "â‹Ž", cuwed: "â‹", cwconint: "âˆ²", cwint: "âˆ±", cylcty: "âŒ­", dagger: "â€ ", Dagger: "â€¡", daleth: "â„¸", darr: "â†“", Darr: "â†¡", dArr: "â‡“", dash: "â€", Dashv: "â«¤", dashv: "âŠ£", dbkarow: "â¤", dblac: "Ë", Dcaron: "ÄŽ", dcaron: "Ä", Dcy: "Ð”", dcy: "Ð´", ddagger: "â€¡", ddarr: "â‡Š", DD: "â……", dd: "â…†", DDotrahd: "â¤‘", ddotseq: "â©·", deg: "Â°", Del: "âˆ‡", Delta: "Î”", delta: "Î´", demptyv: "â¦±", dfisht: "â¥¿", Dfr: "ð”‡", dfr: "ð”¡", dHar: "â¥¥", dharl: "â‡ƒ", dharr: "â‡‚", DiacriticalAcute: "Â´", DiacriticalDot: "Ë™", DiacriticalDoubleAcute: "Ë", DiacriticalGrave: "`", DiacriticalTilde: "Ëœ", diam: "â‹„", diamond: "â‹„", Diamond: "â‹„", diamondsuit: "â™¦", diams: "â™¦", die: "Â¨", DifferentialD: "â…†", digamma: "Ï", disin: "â‹²", div: "Ã·", divide: "Ã·", divideontimes: "â‹‡", divonx: "â‹‡", DJcy: "Ð‚", djcy: "Ñ’", dlcorn: "âŒž", dlcrop: "âŒ", dollar: "$", Dopf: "ð”»", dopf: "ð••", Dot: "Â¨", dot: "Ë™", DotDot: "âƒœ", doteq: "â‰", doteqdot: "â‰‘", DotEqual: "â‰", dotminus: "âˆ¸", dotplus: "âˆ”", dotsquare: "âŠ¡", doublebarwedge: "âŒ†", DoubleContourIntegral: "âˆ¯", DoubleDot: "Â¨", DoubleDownArrow: "â‡“", DoubleLeftArrow: "â‡", DoubleLeftRightArrow: "â‡”", DoubleLeftTee: "â«¤", DoubleLongLeftArrow: "âŸ¸", DoubleLongLeftRightArrow: "âŸº", DoubleLongRightArrow: "âŸ¹", DoubleRightArrow: "â‡’", DoubleRightTee: "âŠ¨", DoubleUpArrow: "â‡‘", DoubleUpDownArrow: "â‡•", DoubleVerticalBar: "âˆ¥", DownArrowBar: "â¤“", downarrow: "â†“", DownArrow: "â†“", Downarrow: "â‡“", DownArrowUpArrow: "â‡µ", DownBreve: "Ì‘", downdownarrows: "â‡Š", downharpoonleft: "â‡ƒ", downharpoonright: "â‡‚", DownLeftRightVector: "â¥", DownLeftTeeVector: "â¥ž", DownLeftVectorBar: "â¥–", DownLeftVector: "â†½", DownRightTeeVector: "â¥Ÿ", DownRightVectorBar: "â¥—", DownRightVector: "â‡", DownTeeArrow: "â†§", DownTee: "âŠ¤", drbkarow: "â¤", drcorn: "âŒŸ", drcrop: "âŒŒ", Dscr: "ð’Ÿ", dscr: "ð’¹", DScy: "Ð…", dscy: "Ñ•", dsol: "â§¶", Dstrok: "Ä", dstrok: "Ä‘", dtdot: "â‹±", dtri: "â–¿", dtrif: "â–¾", duarr: "â‡µ", duhar: "â¥¯", dwangle: "â¦¦", DZcy: "Ð", dzcy: "ÑŸ", dzigrarr: "âŸ¿", Eacute: "Ã‰", eacute: "Ã©", easter: "â©®", Ecaron: "Äš", ecaron: "Ä›", Ecirc: "ÃŠ", ecirc: "Ãª", ecir: "â‰–", ecolon: "â‰•", Ecy: "Ð­", ecy: "Ñ", eDDot: "â©·", Edot: "Ä–", edot: "Ä—", eDot: "â‰‘", ee: "â…‡", efDot: "â‰’", Efr: "ð”ˆ", efr: "ð”¢", eg: "âªš", Egrave: "Ãˆ", egrave: "Ã¨", egs: "âª–", egsdot: "âª˜", el: "âª™", Element: "âˆˆ", elinters: "â§", ell: "â„“", els: "âª•", elsdot: "âª—", Emacr: "Ä’", emacr: "Ä“", empty: "âˆ…", emptyset: "âˆ…", EmptySmallSquare: "â—»", emptyv: "âˆ…", EmptyVerySmallSquare: "â–«", emsp13: "â€„", emsp14: "â€…", emsp: "â€ƒ", ENG: "ÅŠ", eng: "Å‹", ensp: "â€‚", Eogon: "Ä˜", eogon: "Ä™", Eopf: "ð”¼", eopf: "ð•–", epar: "â‹•", eparsl: "â§£", eplus: "â©±", epsi: "Îµ", Epsilon: "Î•", epsilon: "Îµ", epsiv: "Ïµ", eqcirc: "â‰–", eqcolon: "â‰•", eqsim: "â‰‚", eqslantgtr: "âª–", eqslantless: "âª•", Equal: "â©µ", equals: "=", EqualTilde: "â‰‚", equest: "â‰Ÿ", Equilibrium: "â‡Œ", equiv: "â‰¡", equivDD: "â©¸", eqvparsl: "â§¥", erarr: "â¥±", erDot: "â‰“", escr: "â„¯", Escr: "â„°", esdot: "â‰", Esim: "â©³", esim: "â‰‚", Eta: "Î—", eta: "Î·", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", euro: "â‚¬", excl: "!", exist: "âˆƒ", Exists: "âˆƒ", expectation: "â„°", exponentiale: "â…‡", ExponentialE: "â…‡", fallingdotseq: "â‰’", Fcy: "Ð¤", fcy: "Ñ„", female: "â™€", ffilig: "ï¬ƒ", fflig: "ï¬€", ffllig: "ï¬„", Ffr: "ð”‰", ffr: "ð”£", filig: "ï¬", FilledSmallSquare: "â—¼", FilledVerySmallSquare: "â–ª", fjlig: "fj", flat: "â™­", fllig: "ï¬‚", fltns: "â–±", fnof: "Æ’", Fopf: "ð”½", fopf: "ð•—", forall: "âˆ€", ForAll: "âˆ€", fork: "â‹”", forkv: "â«™", Fouriertrf: "â„±", fpartint: "â¨", frac12: "Â½", frac13: "â…“", frac14: "Â¼", frac15: "â…•", frac16: "â…™", frac18: "â…›", frac23: "â…”", frac25: "â…–", frac34: "Â¾", frac35: "â…—", frac38: "â…œ", frac45: "â…˜", frac56: "â…š", frac58: "â…", frac78: "â…ž", frasl: "â„", frown: "âŒ¢", fscr: "ð’»", Fscr: "â„±", gacute: "Çµ", Gamma: "Î“", gamma: "Î³", Gammad: "Ïœ", gammad: "Ï", gap: "âª†", Gbreve: "Äž", gbreve: "ÄŸ", Gcedil: "Ä¢", Gcirc: "Äœ", gcirc: "Ä", Gcy: "Ð“", gcy: "Ð³", Gdot: "Ä ", gdot: "Ä¡", ge: "â‰¥", gE: "â‰§", gEl: "âªŒ", gel: "â‹›", geq: "â‰¥", geqq: "â‰§", geqslant: "â©¾", gescc: "âª©", ges: "â©¾", gesdot: "âª€", gesdoto: "âª‚", gesdotol: "âª„", gesl: "â‹›ï¸€", gesles: "âª”", Gfr: "ð”Š", gfr: "ð”¤", gg: "â‰«", Gg: "â‹™", ggg: "â‹™", gimel: "â„·", GJcy: "Ðƒ", gjcy: "Ñ“", gla: "âª¥", gl: "â‰·", glE: "âª’", glj: "âª¤", gnap: "âªŠ", gnapprox: "âªŠ", gne: "âªˆ", gnE: "â‰©", gneq: "âªˆ", gneqq: "â‰©", gnsim: "â‹§", Gopf: "ð”¾", gopf: "ð•˜", grave: "`", GreaterEqual: "â‰¥", GreaterEqualLess: "â‹›", GreaterFullEqual: "â‰§", GreaterGreater: "âª¢", GreaterLess: "â‰·", GreaterSlantEqual: "â©¾", GreaterTilde: "â‰³", Gscr: "ð’¢", gscr: "â„Š", gsim: "â‰³", gsime: "âªŽ", gsiml: "âª", gtcc: "âª§", gtcir: "â©º", gt: ">", GT: ">", Gt: "â‰«", gtdot: "â‹—", gtlPar: "â¦•", gtquest: "â©¼", gtrapprox: "âª†", gtrarr: "â¥¸", gtrdot: "â‹—", gtreqless: "â‹›", gtreqqless: "âªŒ", gtrless: "â‰·", gtrsim: "â‰³", gvertneqq: "â‰©ï¸€", gvnE: "â‰©ï¸€", Hacek: "Ë‡", hairsp: "â€Š", half: "Â½", hamilt: "â„‹", HARDcy: "Ðª", hardcy: "ÑŠ", harrcir: "â¥ˆ", harr: "â†”", hArr: "â‡”", harrw: "â†­", Hat: "^", hbar: "â„", Hcirc: "Ä¤", hcirc: "Ä¥", hearts: "â™¥", heartsuit: "â™¥", hellip: "â€¦", hercon: "âŠ¹", hfr: "ð”¥", Hfr: "â„Œ", HilbertSpace: "â„‹", hksearow: "â¤¥", hkswarow: "â¤¦", hoarr: "â‡¿", homtht: "âˆ»", hookleftarrow: "â†©", hookrightarrow: "â†ª", hopf: "ð•™", Hopf: "â„", horbar: "â€•", HorizontalLine: "â”€", hscr: "ð’½", Hscr: "â„‹", hslash: "â„", Hstrok: "Ä¦", hstrok: "Ä§", HumpDownHump: "â‰Ž", HumpEqual: "â‰", hybull: "âƒ", hyphen: "â€", Iacute: "Ã", iacute: "Ã­", ic: "â£", Icirc: "ÃŽ", icirc: "Ã®", Icy: "Ð˜", icy: "Ð¸", Idot: "Ä°", IEcy: "Ð•", iecy: "Ðµ", iexcl: "Â¡", iff: "â‡”", ifr: "ð”¦", Ifr: "â„‘", Igrave: "ÃŒ", igrave: "Ã¬", ii: "â…ˆ", iiiint: "â¨Œ", iiint: "âˆ­", iinfin: "â§œ", iiota: "â„©", IJlig: "Ä²", ijlig: "Ä³", Imacr: "Äª", imacr: "Ä«", image: "â„‘", ImaginaryI: "â…ˆ", imagline: "â„", imagpart: "â„‘", imath: "Ä±", Im: "â„‘", imof: "âŠ·", imped: "Æµ", Implies: "â‡’", incare: "â„…", in: "âˆˆ", infin: "âˆž", infintie: "â§", inodot: "Ä±", intcal: "âŠº", int: "âˆ«", Int: "âˆ¬", integers: "â„¤", Integral: "âˆ«", intercal: "âŠº", Intersection: "â‹‚", intlarhk: "â¨—", intprod: "â¨¼", InvisibleComma: "â£", InvisibleTimes: "â¢", IOcy: "Ð", iocy: "Ñ‘", Iogon: "Ä®", iogon: "Ä¯", Iopf: "ð•€", iopf: "ð•š", Iota: "Î™", iota: "Î¹", iprod: "â¨¼", iquest: "Â¿", iscr: "ð’¾", Iscr: "â„", isin: "âˆˆ", isindot: "â‹µ", isinE: "â‹¹", isins: "â‹´", isinsv: "â‹³", isinv: "âˆˆ", it: "â¢", Itilde: "Ä¨", itilde: "Ä©", Iukcy: "Ð†", iukcy: "Ñ–", Iuml: "Ã", iuml: "Ã¯", Jcirc: "Ä´", jcirc: "Äµ", Jcy: "Ð™", jcy: "Ð¹", Jfr: "ð”", jfr: "ð”§", jmath: "È·", Jopf: "ð•", jopf: "ð•›", Jscr: "ð’¥", jscr: "ð’¿", Jsercy: "Ðˆ", jsercy: "Ñ˜", Jukcy: "Ð„", jukcy: "Ñ”", Kappa: "Îš", kappa: "Îº", kappav: "Ï°", Kcedil: "Ä¶", kcedil: "Ä·", Kcy: "Ðš", kcy: "Ðº", Kfr: "ð”Ž", kfr: "ð”¨", kgreen: "Ä¸", KHcy: "Ð¥", khcy: "Ñ…", KJcy: "ÐŒ", kjcy: "Ñœ", Kopf: "ð•‚", kopf: "ð•œ", Kscr: "ð’¦", kscr: "ð“€", lAarr: "â‡š", Lacute: "Ä¹", lacute: "Äº", laemptyv: "â¦´", lagran: "â„’", Lambda: "Î›", lambda: "Î»", lang: "âŸ¨", Lang: "âŸª", langd: "â¦‘", langle: "âŸ¨", lap: "âª…", Laplacetrf: "â„’", laquo: "Â«", larrb: "â‡¤", larrbfs: "â¤Ÿ", larr: "â†", Larr: "â†ž", lArr: "â‡", larrfs: "â¤", larrhk: "â†©", larrlp: "â†«", larrpl: "â¤¹", larrsim: "â¥³", larrtl: "â†¢", latail: "â¤™", lAtail: "â¤›", lat: "âª«", late: "âª­", lates: "âª­ï¸€", lbarr: "â¤Œ", lBarr: "â¤Ž", lbbrk: "â²", lbrace: "{", lbrack: "[", lbrke: "â¦‹", lbrksld: "â¦", lbrkslu: "â¦", Lcaron: "Ä½", lcaron: "Ä¾", Lcedil: "Ä»", lcedil: "Ä¼", lceil: "âŒˆ", lcub: "{", Lcy: "Ð›", lcy: "Ð»", ldca: "â¤¶", ldquo: "â€œ", ldquor: "â€ž", ldrdhar: "â¥§", ldrushar: "â¥‹", ldsh: "â†²", le: "â‰¤", lE: "â‰¦", LeftAngleBracket: "âŸ¨", LeftArrowBar: "â‡¤", leftarrow: "â†", LeftArrow: "â†", Leftarrow: "â‡", LeftArrowRightArrow: "â‡†", leftarrowtail: "â†¢", LeftCeiling: "âŒˆ", LeftDoubleBracket: "âŸ¦", LeftDownTeeVector: "â¥¡", LeftDownVectorBar: "â¥™", LeftDownVector: "â‡ƒ", LeftFloor: "âŒŠ", leftharpoondown: "â†½", leftharpoonup: "â†¼", leftleftarrows: "â‡‡", leftrightarrow: "â†”", LeftRightArrow: "â†”", Leftrightarrow: "â‡”", leftrightarrows: "â‡†", leftrightharpoons: "â‡‹", leftrightsquigarrow: "â†­", LeftRightVector: "â¥Ž", LeftTeeArrow: "â†¤", LeftTee: "âŠ£", LeftTeeVector: "â¥š", leftthreetimes: "â‹‹", LeftTriangleBar: "â§", LeftTriangle: "âŠ²", LeftTriangleEqual: "âŠ´", LeftUpDownVector: "â¥‘", LeftUpTeeVector: "â¥ ", LeftUpVectorBar: "â¥˜", LeftUpVector: "â†¿", LeftVectorBar: "â¥’", LeftVector: "â†¼", lEg: "âª‹", leg: "â‹š", leq: "â‰¤", leqq: "â‰¦", leqslant: "â©½", lescc: "âª¨", les: "â©½", lesdot: "â©¿", lesdoto: "âª", lesdotor: "âªƒ", lesg: "â‹šï¸€", lesges: "âª“", lessapprox: "âª…", lessdot: "â‹–", lesseqgtr: "â‹š", lesseqqgtr: "âª‹", LessEqualGreater: "â‹š", LessFullEqual: "â‰¦", LessGreater: "â‰¶", lessgtr: "â‰¶", LessLess: "âª¡", lesssim: "â‰²", LessSlantEqual: "â©½", LessTilde: "â‰²", lfisht: "â¥¼", lfloor: "âŒŠ", Lfr: "ð”", lfr: "ð”©", lg: "â‰¶", lgE: "âª‘", lHar: "â¥¢", lhard: "â†½", lharu: "â†¼", lharul: "â¥ª", lhblk: "â–„", LJcy: "Ð‰", ljcy: "Ñ™", llarr: "â‡‡", ll: "â‰ª", Ll: "â‹˜", llcorner: "âŒž", Lleftarrow: "â‡š", llhard: "â¥«", lltri: "â—º", Lmidot: "Ä¿", lmidot: "Å€", lmoustache: "âŽ°", lmoust: "âŽ°", lnap: "âª‰", lnapprox: "âª‰", lne: "âª‡", lnE: "â‰¨", lneq: "âª‡", lneqq: "â‰¨", lnsim: "â‹¦", loang: "âŸ¬", loarr: "â‡½", lobrk: "âŸ¦", longleftarrow: "âŸµ", LongLeftArrow: "âŸµ", Longleftarrow: "âŸ¸", longleftrightarrow: "âŸ·", LongLeftRightArrow: "âŸ·", Longleftrightarrow: "âŸº", longmapsto: "âŸ¼", longrightarrow: "âŸ¶", LongRightArrow: "âŸ¶", Longrightarrow: "âŸ¹", looparrowleft: "â†«", looparrowright: "â†¬", lopar: "â¦…", Lopf: "ð•ƒ", lopf: "ð•", loplus: "â¨­", lotimes: "â¨´", lowast: "âˆ—", lowbar: "_", LowerLeftArrow: "â†™", LowerRightArrow: "â†˜", loz: "â—Š", lozenge: "â—Š", lozf: "â§«", lpar: "(", lparlt: "â¦“", lrarr: "â‡†", lrcorner: "âŒŸ", lrhar: "â‡‹", lrhard: "â¥­", lrm: "â€Ž", lrtri: "âŠ¿", lsaquo: "â€¹", lscr: "ð“", Lscr: "â„’", lsh: "â†°", Lsh: "â†°", lsim: "â‰²", lsime: "âª", lsimg: "âª", lsqb: "[", lsquo: "â€˜", lsquor: "â€š", Lstrok: "Å", lstrok: "Å‚", ltcc: "âª¦", ltcir: "â©¹", lt: "<", LT: "<", Lt: "â‰ª", ltdot: "â‹–", lthree: "â‹‹", ltimes: "â‹‰", ltlarr: "â¥¶", ltquest: "â©»", ltri: "â—ƒ", ltrie: "âŠ´", ltrif: "â—‚", ltrPar: "â¦–", lurdshar: "â¥Š", luruhar: "â¥¦", lvertneqq: "â‰¨ï¸€", lvnE: "â‰¨ï¸€", macr: "Â¯", male: "â™‚", malt: "âœ ", maltese: "âœ ", Map: "â¤…", map: "â†¦", mapsto: "â†¦", mapstodown: "â†§", mapstoleft: "â†¤", mapstoup: "â†¥", marker: "â–®", mcomma: "â¨©", Mcy: "Ðœ", mcy: "Ð¼", mdash: "â€”", mDDot: "âˆº", measuredangle: "âˆ¡", MediumSpace: "âŸ", Mellintrf: "â„³", Mfr: "ð”", mfr: "ð”ª", mho: "â„§", micro: "Âµ", midast: "*", midcir: "â«°", mid: "âˆ£", middot: "Â·", minusb: "âŠŸ", minus: "âˆ’", minusd: "âˆ¸", minusdu: "â¨ª", MinusPlus: "âˆ“", mlcp: "â«›", mldr: "â€¦", mnplus: "âˆ“", models: "âŠ§", Mopf: "ð•„", mopf: "ð•ž", mp: "âˆ“", mscr: "ð“‚", Mscr: "â„³", mstpos: "âˆ¾", Mu: "Îœ", mu: "Î¼", multimap: "âŠ¸", mumap: "âŠ¸", nabla: "âˆ‡", Nacute: "Åƒ", nacute: "Å„", nang: "âˆ âƒ’", nap: "â‰‰", napE: "â©°Ì¸", napid: "â‰‹Ì¸", napos: "Å‰", napprox: "â‰‰", natural: "â™®", naturals: "â„•", natur: "â™®", nbsp: "Â ", nbump: "â‰ŽÌ¸", nbumpe: "â‰Ì¸", ncap: "â©ƒ", Ncaron: "Å‡", ncaron: "Åˆ", Ncedil: "Å…", ncedil: "Å†", ncong: "â‰‡", ncongdot: "â©­Ì¸", ncup: "â©‚", Ncy: "Ð", ncy: "Ð½", ndash: "â€“", nearhk: "â¤¤", nearr: "â†—", neArr: "â‡—", nearrow: "â†—", ne: "â‰ ", nedot: "â‰Ì¸", NegativeMediumSpace: "â€‹", NegativeThickSpace: "â€‹", NegativeThinSpace: "â€‹", NegativeVeryThinSpace: "â€‹", nequiv: "â‰¢", nesear: "â¤¨", nesim: "â‰‚Ì¸", NestedGreaterGreater: "â‰«", NestedLessLess: "â‰ª", NewLine: `
`, nexist: "âˆ„", nexists: "âˆ„", Nfr: "ð”‘", nfr: "ð”«", ngE: "â‰§Ì¸", nge: "â‰±", ngeq: "â‰±", ngeqq: "â‰§Ì¸", ngeqslant: "â©¾Ì¸", nges: "â©¾Ì¸", nGg: "â‹™Ì¸", ngsim: "â‰µ", nGt: "â‰«âƒ’", ngt: "â‰¯", ngtr: "â‰¯", nGtv: "â‰«Ì¸", nharr: "â†®", nhArr: "â‡Ž", nhpar: "â«²", ni: "âˆ‹", nis: "â‹¼", nisd: "â‹º", niv: "âˆ‹", NJcy: "ÐŠ", njcy: "Ñš", nlarr: "â†š", nlArr: "â‡", nldr: "â€¥", nlE: "â‰¦Ì¸", nle: "â‰°", nleftarrow: "â†š", nLeftarrow: "â‡", nleftrightarrow: "â†®", nLeftrightarrow: "â‡Ž", nleq: "â‰°", nleqq: "â‰¦Ì¸", nleqslant: "â©½Ì¸", nles: "â©½Ì¸", nless: "â‰®", nLl: "â‹˜Ì¸", nlsim: "â‰´", nLt: "â‰ªâƒ’", nlt: "â‰®", nltri: "â‹ª", nltrie: "â‹¬", nLtv: "â‰ªÌ¸", nmid: "âˆ¤", NoBreak: "â ", NonBreakingSpace: "Â ", nopf: "ð•Ÿ", Nopf: "â„•", Not: "â«¬", not: "Â¬", NotCongruent: "â‰¢", NotCupCap: "â‰­", NotDoubleVerticalBar: "âˆ¦", NotElement: "âˆ‰", NotEqual: "â‰ ", NotEqualTilde: "â‰‚Ì¸", NotExists: "âˆ„", NotGreater: "â‰¯", NotGreaterEqual: "â‰±", NotGreaterFullEqual: "â‰§Ì¸", NotGreaterGreater: "â‰«Ì¸", NotGreaterLess: "â‰¹", NotGreaterSlantEqual: "â©¾Ì¸", NotGreaterTilde: "â‰µ", NotHumpDownHump: "â‰ŽÌ¸", NotHumpEqual: "â‰Ì¸", notin: "âˆ‰", notindot: "â‹µÌ¸", notinE: "â‹¹Ì¸", notinva: "âˆ‰", notinvb: "â‹·", notinvc: "â‹¶", NotLeftTriangleBar: "â§Ì¸", NotLeftTriangle: "â‹ª", NotLeftTriangleEqual: "â‹¬", NotLess: "â‰®", NotLessEqual: "â‰°", NotLessGreater: "â‰¸", NotLessLess: "â‰ªÌ¸", NotLessSlantEqual: "â©½Ì¸", NotLessTilde: "â‰´", NotNestedGreaterGreater: "âª¢Ì¸", NotNestedLessLess: "âª¡Ì¸", notni: "âˆŒ", notniva: "âˆŒ", notnivb: "â‹¾", notnivc: "â‹½", NotPrecedes: "âŠ€", NotPrecedesEqual: "âª¯Ì¸", NotPrecedesSlantEqual: "â‹ ", NotReverseElement: "âˆŒ", NotRightTriangleBar: "â§Ì¸", NotRightTriangle: "â‹«", NotRightTriangleEqual: "â‹­", NotSquareSubset: "âŠÌ¸", NotSquareSubsetEqual: "â‹¢", NotSquareSuperset: "âŠÌ¸", NotSquareSupersetEqual: "â‹£", NotSubset: "âŠ‚âƒ’", NotSubsetEqual: "âŠˆ", NotSucceeds: "âŠ", NotSucceedsEqual: "âª°Ì¸", NotSucceedsSlantEqual: "â‹¡", NotSucceedsTilde: "â‰¿Ì¸", NotSuperset: "âŠƒâƒ’", NotSupersetEqual: "âŠ‰", NotTilde: "â‰", NotTildeEqual: "â‰„", NotTildeFullEqual: "â‰‡", NotTildeTilde: "â‰‰", NotVerticalBar: "âˆ¤", nparallel: "âˆ¦", npar: "âˆ¦", nparsl: "â«½âƒ¥", npart: "âˆ‚Ì¸", npolint: "â¨”", npr: "âŠ€", nprcue: "â‹ ", nprec: "âŠ€", npreceq: "âª¯Ì¸", npre: "âª¯Ì¸", nrarrc: "â¤³Ì¸", nrarr: "â†›", nrArr: "â‡", nrarrw: "â†Ì¸", nrightarrow: "â†›", nRightarrow: "â‡", nrtri: "â‹«", nrtrie: "â‹­", nsc: "âŠ", nsccue: "â‹¡", nsce: "âª°Ì¸", Nscr: "ð’©", nscr: "ð“ƒ", nshortmid: "âˆ¤", nshortparallel: "âˆ¦", nsim: "â‰", nsime: "â‰„", nsimeq: "â‰„", nsmid: "âˆ¤", nspar: "âˆ¦", nsqsube: "â‹¢", nsqsupe: "â‹£", nsub: "âŠ„", nsubE: "â«…Ì¸", nsube: "âŠˆ", nsubset: "âŠ‚âƒ’", nsubseteq: "âŠˆ", nsubseteqq: "â«…Ì¸", nsucc: "âŠ", nsucceq: "âª°Ì¸", nsup: "âŠ…", nsupE: "â«†Ì¸", nsupe: "âŠ‰", nsupset: "âŠƒâƒ’", nsupseteq: "âŠ‰", nsupseteqq: "â«†Ì¸", ntgl: "â‰¹", Ntilde: "Ã‘", ntilde: "Ã±", ntlg: "â‰¸", ntriangleleft: "â‹ª", ntrianglelefteq: "â‹¬", ntriangleright: "â‹«", ntrianglerighteq: "â‹­", Nu: "Î", nu: "Î½", num: "#", numero: "â„–", numsp: "â€‡", nvap: "â‰âƒ’", nvdash: "âŠ¬", nvDash: "âŠ­", nVdash: "âŠ®", nVDash: "âŠ¯", nvge: "â‰¥âƒ’", nvgt: ">âƒ’", nvHarr: "â¤„", nvinfin: "â§ž", nvlArr: "â¤‚", nvle: "â‰¤âƒ’", nvlt: "<âƒ’", nvltrie: "âŠ´âƒ’", nvrArr: "â¤ƒ", nvrtrie: "âŠµâƒ’", nvsim: "âˆ¼âƒ’", nwarhk: "â¤£", nwarr: "â†–", nwArr: "â‡–", nwarrow: "â†–", nwnear: "â¤§", Oacute: "Ã“", oacute: "Ã³", oast: "âŠ›", Ocirc: "Ã”", ocirc: "Ã´", ocir: "âŠš", Ocy: "Ðž", ocy: "Ð¾", odash: "âŠ", Odblac: "Å", odblac: "Å‘", odiv: "â¨¸", odot: "âŠ™", odsold: "â¦¼", OElig: "Å’", oelig: "Å“", ofcir: "â¦¿", Ofr: "ð”’", ofr: "ð”¬", ogon: "Ë›", Ograve: "Ã’", ograve: "Ã²", ogt: "â§", ohbar: "â¦µ", ohm: "Î©", oint: "âˆ®", olarr: "â†º", olcir: "â¦¾", olcross: "â¦»", oline: "â€¾", olt: "â§€", Omacr: "ÅŒ", omacr: "Å", Omega: "Î©", omega: "Ï‰", Omicron: "ÎŸ", omicron: "Î¿", omid: "â¦¶", ominus: "âŠ–", Oopf: "ð•†", oopf: "ð• ", opar: "â¦·", OpenCurlyDoubleQuote: "â€œ", OpenCurlyQuote: "â€˜", operp: "â¦¹", oplus: "âŠ•", orarr: "â†»", Or: "â©”", or: "âˆ¨", ord: "â©", order: "â„´", orderof: "â„´", ordf: "Âª", ordm: "Âº", origof: "âŠ¶", oror: "â©–", orslope: "â©—", orv: "â©›", oS: "â“ˆ", Oscr: "ð’ª", oscr: "â„´", Oslash: "Ã˜", oslash: "Ã¸", osol: "âŠ˜", Otilde: "Ã•", otilde: "Ãµ", otimesas: "â¨¶", Otimes: "â¨·", otimes: "âŠ—", Ouml: "Ã–", ouml: "Ã¶", ovbar: "âŒ½", OverBar: "â€¾", OverBrace: "âž", OverBracket: "âŽ´", OverParenthesis: "âœ", para: "Â¶", parallel: "âˆ¥", par: "âˆ¥", parsim: "â«³", parsl: "â«½", part: "âˆ‚", PartialD: "âˆ‚", Pcy: "ÐŸ", pcy: "Ð¿", percnt: "%", period: ".", permil: "â€°", perp: "âŠ¥", pertenk: "â€±", Pfr: "ð”“", pfr: "ð”­", Phi: "Î¦", phi: "Ï†", phiv: "Ï•", phmmat: "â„³", phone: "â˜Ž", Pi: "Î ", pi: "Ï€", pitchfork: "â‹”", piv: "Ï–", planck: "â„", planckh: "â„Ž", plankv: "â„", plusacir: "â¨£", plusb: "âŠž", pluscir: "â¨¢", plus: "+", plusdo: "âˆ”", plusdu: "â¨¥", pluse: "â©²", PlusMinus: "Â±", plusmn: "Â±", plussim: "â¨¦", plustwo: "â¨§", pm: "Â±", Poincareplane: "â„Œ", pointint: "â¨•", popf: "ð•¡", Popf: "â„™", pound: "Â£", prap: "âª·", Pr: "âª»", pr: "â‰º", prcue: "â‰¼", precapprox: "âª·", prec: "â‰º", preccurlyeq: "â‰¼", Precedes: "â‰º", PrecedesEqual: "âª¯", PrecedesSlantEqual: "â‰¼", PrecedesTilde: "â‰¾", preceq: "âª¯", precnapprox: "âª¹", precneqq: "âªµ", precnsim: "â‹¨", pre: "âª¯", prE: "âª³", precsim: "â‰¾", prime: "â€²", Prime: "â€³", primes: "â„™", prnap: "âª¹", prnE: "âªµ", prnsim: "â‹¨", prod: "âˆ", Product: "âˆ", profalar: "âŒ®", profline: "âŒ’", profsurf: "âŒ“", prop: "âˆ", Proportional: "âˆ", Proportion: "âˆ·", propto: "âˆ", prsim: "â‰¾", prurel: "âŠ°", Pscr: "ð’«", pscr: "ð“…", Psi: "Î¨", psi: "Ïˆ", puncsp: "â€ˆ", Qfr: "ð””", qfr: "ð”®", qint: "â¨Œ", qopf: "ð•¢", Qopf: "â„š", qprime: "â—", Qscr: "ð’¬", qscr: "ð“†", quaternions: "â„", quatint: "â¨–", quest: "?", questeq: "â‰Ÿ", quot: '"', QUOT: '"', rAarr: "â‡›", race: "âˆ½Ì±", Racute: "Å”", racute: "Å•", radic: "âˆš", raemptyv: "â¦³", rang: "âŸ©", Rang: "âŸ«", rangd: "â¦’", range: "â¦¥", rangle: "âŸ©", raquo: "Â»", rarrap: "â¥µ", rarrb: "â‡¥", rarrbfs: "â¤ ", rarrc: "â¤³", rarr: "â†’", Rarr: "â† ", rArr: "â‡’", rarrfs: "â¤ž", rarrhk: "â†ª", rarrlp: "â†¬", rarrpl: "â¥…", rarrsim: "â¥´", Rarrtl: "â¤–", rarrtl: "â†£", rarrw: "â†", ratail: "â¤š", rAtail: "â¤œ", ratio: "âˆ¶", rationals: "â„š", rbarr: "â¤", rBarr: "â¤", RBarr: "â¤", rbbrk: "â³", rbrace: "}", rbrack: "]", rbrke: "â¦Œ", rbrksld: "â¦Ž", rbrkslu: "â¦", Rcaron: "Å˜", rcaron: "Å™", Rcedil: "Å–", rcedil: "Å—", rceil: "âŒ‰", rcub: "}", Rcy: "Ð ", rcy: "Ñ€", rdca: "â¤·", rdldhar: "â¥©", rdquo: "â€", rdquor: "â€", rdsh: "â†³", real: "â„œ", realine: "â„›", realpart: "â„œ", reals: "â„", Re: "â„œ", rect: "â–­", reg: "Â®", REG: "Â®", ReverseElement: "âˆ‹", ReverseEquilibrium: "â‡‹", ReverseUpEquilibrium: "â¥¯", rfisht: "â¥½", rfloor: "âŒ‹", rfr: "ð”¯", Rfr: "â„œ", rHar: "â¥¤", rhard: "â‡", rharu: "â‡€", rharul: "â¥¬", Rho: "Î¡", rho: "Ï", rhov: "Ï±", RightAngleBracket: "âŸ©", RightArrowBar: "â‡¥", rightarrow: "â†’", RightArrow: "â†’", Rightarrow: "â‡’", RightArrowLeftArrow: "â‡„", rightarrowtail: "â†£", RightCeiling: "âŒ‰", RightDoubleBracket: "âŸ§", RightDownTeeVector: "â¥", RightDownVectorBar: "â¥•", RightDownVector: "â‡‚", RightFloor: "âŒ‹", rightharpoondown: "â‡", rightharpoonup: "â‡€", rightleftarrows: "â‡„", rightleftharpoons: "â‡Œ", rightrightarrows: "â‡‰", rightsquigarrow: "â†", RightTeeArrow: "â†¦", RightTee: "âŠ¢", RightTeeVector: "â¥›", rightthreetimes: "â‹Œ", RightTriangleBar: "â§", RightTriangle: "âŠ³", RightTriangleEqual: "âŠµ", RightUpDownVector: "â¥", RightUpTeeVector: "â¥œ", RightUpVectorBar: "â¥”", RightUpVector: "â†¾", RightVectorBar: "â¥“", RightVector: "â‡€", ring: "Ëš", risingdotseq: "â‰“", rlarr: "â‡„", rlhar: "â‡Œ", rlm: "â€", rmoustache: "âŽ±", rmoust: "âŽ±", rnmid: "â«®", roang: "âŸ­", roarr: "â‡¾", robrk: "âŸ§", ropar: "â¦†", ropf: "ð•£", Ropf: "â„", roplus: "â¨®", rotimes: "â¨µ", RoundImplies: "â¥°", rpar: ")", rpargt: "â¦”", rppolint: "â¨’", rrarr: "â‡‰", Rrightarrow: "â‡›", rsaquo: "â€º", rscr: "ð“‡", Rscr: "â„›", rsh: "â†±", Rsh: "â†±", rsqb: "]", rsquo: "â€™", rsquor: "â€™", rthree: "â‹Œ", rtimes: "â‹Š", rtri: "â–¹", rtrie: "âŠµ", rtrif: "â–¸", rtriltri: "â§Ž", RuleDelayed: "â§´", ruluhar: "â¥¨", rx: "â„ž", Sacute: "Åš", sacute: "Å›", sbquo: "â€š", scap: "âª¸", Scaron: "Å ", scaron: "Å¡", Sc: "âª¼", sc: "â‰»", sccue: "â‰½", sce: "âª°", scE: "âª´", Scedil: "Åž", scedil: "ÅŸ", Scirc: "Åœ", scirc: "Å", scnap: "âªº", scnE: "âª¶", scnsim: "â‹©", scpolint: "â¨“", scsim: "â‰¿", Scy: "Ð¡", scy: "Ñ", sdotb: "âŠ¡", sdot: "â‹…", sdote: "â©¦", searhk: "â¤¥", searr: "â†˜", seArr: "â‡˜", searrow: "â†˜", sect: "Â§", semi: ";", seswar: "â¤©", setminus: "âˆ–", setmn: "âˆ–", sext: "âœ¶", Sfr: "ð”–", sfr: "ð”°", sfrown: "âŒ¢", sharp: "â™¯", SHCHcy: "Ð©", shchcy: "Ñ‰", SHcy: "Ð¨", shcy: "Ñˆ", ShortDownArrow: "â†“", ShortLeftArrow: "â†", shortmid: "âˆ£", shortparallel: "âˆ¥", ShortRightArrow: "â†’", ShortUpArrow: "â†‘", shy: "Â­", Sigma: "Î£", sigma: "Ïƒ", sigmaf: "Ï‚", sigmav: "Ï‚", sim: "âˆ¼", simdot: "â©ª", sime: "â‰ƒ", simeq: "â‰ƒ", simg: "âªž", simgE: "âª ", siml: "âª", simlE: "âªŸ", simne: "â‰†", simplus: "â¨¤", simrarr: "â¥²", slarr: "â†", SmallCircle: "âˆ˜", smallsetminus: "âˆ–", smashp: "â¨³", smeparsl: "â§¤", smid: "âˆ£", smile: "âŒ£", smt: "âªª", smte: "âª¬", smtes: "âª¬ï¸€", SOFTcy: "Ð¬", softcy: "ÑŒ", solbar: "âŒ¿", solb: "â§„", sol: "/", Sopf: "ð•Š", sopf: "ð•¤", spades: "â™ ", spadesuit: "â™ ", spar: "âˆ¥", sqcap: "âŠ“", sqcaps: "âŠ“ï¸€", sqcup: "âŠ”", sqcups: "âŠ”ï¸€", Sqrt: "âˆš", sqsub: "âŠ", sqsube: "âŠ‘", sqsubset: "âŠ", sqsubseteq: "âŠ‘", sqsup: "âŠ", sqsupe: "âŠ’", sqsupset: "âŠ", sqsupseteq: "âŠ’", square: "â–¡", Square: "â–¡", SquareIntersection: "âŠ“", SquareSubset: "âŠ", SquareSubsetEqual: "âŠ‘", SquareSuperset: "âŠ", SquareSupersetEqual: "âŠ’", SquareUnion: "âŠ”", squarf: "â–ª", squ: "â–¡", squf: "â–ª", srarr: "â†’", Sscr: "ð’®", sscr: "ð“ˆ", ssetmn: "âˆ–", ssmile: "âŒ£", sstarf: "â‹†", Star: "â‹†", star: "â˜†", starf: "â˜…", straightepsilon: "Ïµ", straightphi: "Ï•", strns: "Â¯", sub: "âŠ‚", Sub: "â‹", subdot: "âª½", subE: "â«…", sube: "âŠ†", subedot: "â«ƒ", submult: "â«", subnE: "â«‹", subne: "âŠŠ", subplus: "âª¿", subrarr: "â¥¹", subset: "âŠ‚", Subset: "â‹", subseteq: "âŠ†", subseteqq: "â«…", SubsetEqual: "âŠ†", subsetneq: "âŠŠ", subsetneqq: "â«‹", subsim: "â«‡", subsub: "â«•", subsup: "â«“", succapprox: "âª¸", succ: "â‰»", succcurlyeq: "â‰½", Succeeds: "â‰»", SucceedsEqual: "âª°", SucceedsSlantEqual: "â‰½", SucceedsTilde: "â‰¿", succeq: "âª°", succnapprox: "âªº", succneqq: "âª¶", succnsim: "â‹©", succsim: "â‰¿", SuchThat: "âˆ‹", sum: "âˆ‘", Sum: "âˆ‘", sung: "â™ª", sup1: "Â¹", sup2: "Â²", sup3: "Â³", sup: "âŠƒ", Sup: "â‹‘", supdot: "âª¾", supdsub: "â«˜", supE: "â«†", supe: "âŠ‡", supedot: "â«„", Superset: "âŠƒ", SupersetEqual: "âŠ‡", suphsol: "âŸ‰", suphsub: "â«—", suplarr: "â¥»", supmult: "â«‚", supnE: "â«Œ", supne: "âŠ‹", supplus: "â«€", supset: "âŠƒ", Supset: "â‹‘", supseteq: "âŠ‡", supseteqq: "â«†", supsetneq: "âŠ‹", supsetneqq: "â«Œ", supsim: "â«ˆ", supsub: "â«”", supsup: "â«–", swarhk: "â¤¦", swarr: "â†™", swArr: "â‡™", swarrow: "â†™", swnwar: "â¤ª", szlig: "ÃŸ", Tab: "	", target: "âŒ–", Tau: "Î¤", tau: "Ï„", tbrk: "âŽ´", Tcaron: "Å¤", tcaron: "Å¥", Tcedil: "Å¢", tcedil: "Å£", Tcy: "Ð¢", tcy: "Ñ‚", tdot: "âƒ›", telrec: "âŒ•", Tfr: "ð”—", tfr: "ð”±", there4: "âˆ´", therefore: "âˆ´", Therefore: "âˆ´", Theta: "Î˜", theta: "Î¸", thetasym: "Ï‘", thetav: "Ï‘", thickapprox: "â‰ˆ", thicksim: "âˆ¼", ThickSpace: "âŸâ€Š", ThinSpace: "â€‰", thinsp: "â€‰", thkap: "â‰ˆ", thksim: "âˆ¼", THORN: "Ãž", thorn: "Ã¾", tilde: "Ëœ", Tilde: "âˆ¼", TildeEqual: "â‰ƒ", TildeFullEqual: "â‰…", TildeTilde: "â‰ˆ", timesbar: "â¨±", timesb: "âŠ ", times: "Ã—", timesd: "â¨°", tint: "âˆ­", toea: "â¤¨", topbot: "âŒ¶", topcir: "â«±", top: "âŠ¤", Topf: "ð•‹", topf: "ð•¥", topfork: "â«š", tosa: "â¤©", tprime: "â€´", trade: "â„¢", TRADE: "â„¢", triangle: "â–µ", triangledown: "â–¿", triangleleft: "â—ƒ", trianglelefteq: "âŠ´", triangleq: "â‰œ", triangleright: "â–¹", trianglerighteq: "âŠµ", tridot: "â—¬", trie: "â‰œ", triminus: "â¨º", TripleDot: "âƒ›", triplus: "â¨¹", trisb: "â§", tritime: "â¨»", trpezium: "â¢", Tscr: "ð’¯", tscr: "ð“‰", TScy: "Ð¦", tscy: "Ñ†", TSHcy: "Ð‹", tshcy: "Ñ›", Tstrok: "Å¦", tstrok: "Å§", twixt: "â‰¬", twoheadleftarrow: "â†ž", twoheadrightarrow: "â† ", Uacute: "Ãš", uacute: "Ãº", uarr: "â†‘", Uarr: "â†Ÿ", uArr: "â‡‘", Uarrocir: "â¥‰", Ubrcy: "ÐŽ", ubrcy: "Ñž", Ubreve: "Å¬", ubreve: "Å­", Ucirc: "Ã›", ucirc: "Ã»", Ucy: "Ð£", ucy: "Ñƒ", udarr: "â‡…", Udblac: "Å°", udblac: "Å±", udhar: "â¥®", ufisht: "â¥¾", Ufr: "ð”˜", ufr: "ð”²", Ugrave: "Ã™", ugrave: "Ã¹", uHar: "â¥£", uharl: "â†¿", uharr: "â†¾", uhblk: "â–€", ulcorn: "âŒœ", ulcorner: "âŒœ", ulcrop: "âŒ", ultri: "â—¸", Umacr: "Åª", umacr: "Å«", uml: "Â¨", UnderBar: "_", UnderBrace: "âŸ", UnderBracket: "âŽµ", UnderParenthesis: "â", Union: "â‹ƒ", UnionPlus: "âŠŽ", Uogon: "Å²", uogon: "Å³", Uopf: "ð•Œ", uopf: "ð•¦", UpArrowBar: "â¤’", uparrow: "â†‘", UpArrow: "â†‘", Uparrow: "â‡‘", UpArrowDownArrow: "â‡…", updownarrow: "â†•", UpDownArrow: "â†•", Updownarrow: "â‡•", UpEquilibrium: "â¥®", upharpoonleft: "â†¿", upharpoonright: "â†¾", uplus: "âŠŽ", UpperLeftArrow: "â†–", UpperRightArrow: "â†—", upsi: "Ï…", Upsi: "Ï’", upsih: "Ï’", Upsilon: "Î¥", upsilon: "Ï…", UpTeeArrow: "â†¥", UpTee: "âŠ¥", upuparrows: "â‡ˆ", urcorn: "âŒ", urcorner: "âŒ", urcrop: "âŒŽ", Uring: "Å®", uring: "Å¯", urtri: "â—¹", Uscr: "ð’°", uscr: "ð“Š", utdot: "â‹°", Utilde: "Å¨", utilde: "Å©", utri: "â–µ", utrif: "â–´", uuarr: "â‡ˆ", Uuml: "Ãœ", uuml: "Ã¼", uwangle: "â¦§", vangrt: "â¦œ", varepsilon: "Ïµ", varkappa: "Ï°", varnothing: "âˆ…", varphi: "Ï•", varpi: "Ï–", varpropto: "âˆ", varr: "â†•", vArr: "â‡•", varrho: "Ï±", varsigma: "Ï‚", varsubsetneq: "âŠŠï¸€", varsubsetneqq: "â«‹ï¸€", varsupsetneq: "âŠ‹ï¸€", varsupsetneqq: "â«Œï¸€", vartheta: "Ï‘", vartriangleleft: "âŠ²", vartriangleright: "âŠ³", vBar: "â«¨", Vbar: "â««", vBarv: "â«©", Vcy: "Ð’", vcy: "Ð²", vdash: "âŠ¢", vDash: "âŠ¨", Vdash: "âŠ©", VDash: "âŠ«", Vdashl: "â«¦", veebar: "âŠ»", vee: "âˆ¨", Vee: "â‹", veeeq: "â‰š", vellip: "â‹®", verbar: "|", Verbar: "â€–", vert: "|", Vert: "â€–", VerticalBar: "âˆ£", VerticalLine: "|", VerticalSeparator: "â˜", VerticalTilde: "â‰€", VeryThinSpace: "â€Š", Vfr: "ð”™", vfr: "ð”³", vltri: "âŠ²", vnsub: "âŠ‚âƒ’", vnsup: "âŠƒâƒ’", Vopf: "ð•", vopf: "ð•§", vprop: "âˆ", vrtri: "âŠ³", Vscr: "ð’±", vscr: "ð“‹", vsubnE: "â«‹ï¸€", vsubne: "âŠŠï¸€", vsupnE: "â«Œï¸€", vsupne: "âŠ‹ï¸€", Vvdash: "âŠª", vzigzag: "â¦š", Wcirc: "Å´", wcirc: "Åµ", wedbar: "â©Ÿ", wedge: "âˆ§", Wedge: "â‹€", wedgeq: "â‰™", weierp: "â„˜", Wfr: "ð”š", wfr: "ð”´", Wopf: "ð•Ž", wopf: "ð•¨", wp: "â„˜", wr: "â‰€", wreath: "â‰€", Wscr: "ð’²", wscr: "ð“Œ", xcap: "â‹‚", xcirc: "â—¯", xcup: "â‹ƒ", xdtri: "â–½", Xfr: "ð”›", xfr: "ð”µ", xharr: "âŸ·", xhArr: "âŸº", Xi: "Îž", xi: "Î¾", xlarr: "âŸµ", xlArr: "âŸ¸", xmap: "âŸ¼", xnis: "â‹»", xodot: "â¨€", Xopf: "ð•", xopf: "ð•©", xoplus: "â¨", xotime: "â¨‚", xrarr: "âŸ¶", xrArr: "âŸ¹", Xscr: "ð’³", xscr: "ð“", xsqcup: "â¨†", xuplus: "â¨„", xutri: "â–³", xvee: "â‹", xwedge: "â‹€", Yacute: "Ã", yacute: "Ã½", YAcy: "Ð¯", yacy: "Ñ", Ycirc: "Å¶", ycirc: "Å·", Ycy: "Ð«", ycy: "Ñ‹", yen: "Â¥", Yfr: "ð”œ", yfr: "ð”¶", YIcy: "Ð‡", yicy: "Ñ—", Yopf: "ð•", yopf: "ð•ª", Yscr: "ð’´", yscr: "ð“Ž", YUcy: "Ð®", yucy: "ÑŽ", yuml: "Ã¿", Yuml: "Å¸", Zacute: "Å¹", zacute: "Åº", Zcaron: "Å½", zcaron: "Å¾", Zcy: "Ð—", zcy: "Ð·", Zdot: "Å»", zdot: "Å¼", zeetrf: "â„¨", ZeroWidthSpace: "â€‹", Zeta: "Î–", zeta: "Î¶", zfr: "ð”·", Zfr: "â„¨", ZHcy: "Ð–", zhcy: "Ð¶", zigrarr: "â‡", zopf: "ð•«", Zopf: "â„¤", Zscr: "ð’µ", zscr: "ð“", zwj: "â€", zwnj: "â€Œ" };
  }
}), coe = W({
  "../node_modules/entities/lib/maps/legacy.json"(e, t) {
    t.exports = { Aacute: "Ã", aacute: "Ã¡", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", AElig: "Ã†", aelig: "Ã¦", Agrave: "Ã€", agrave: "Ã ", amp: "&", AMP: "&", Aring: "Ã…", aring: "Ã¥", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", brvbar: "Â¦", Ccedil: "Ã‡", ccedil: "Ã§", cedil: "Â¸", cent: "Â¢", copy: "Â©", COPY: "Â©", curren: "Â¤", deg: "Â°", divide: "Ã·", Eacute: "Ã‰", eacute: "Ã©", Ecirc: "ÃŠ", ecirc: "Ãª", Egrave: "Ãˆ", egrave: "Ã¨", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", frac12: "Â½", frac14: "Â¼", frac34: "Â¾", gt: ">", GT: ">", Iacute: "Ã", iacute: "Ã­", Icirc: "ÃŽ", icirc: "Ã®", iexcl: "Â¡", Igrave: "ÃŒ", igrave: "Ã¬", iquest: "Â¿", Iuml: "Ã", iuml: "Ã¯", laquo: "Â«", lt: "<", LT: "<", macr: "Â¯", micro: "Âµ", middot: "Â·", nbsp: "Â ", not: "Â¬", Ntilde: "Ã‘", ntilde: "Ã±", Oacute: "Ã“", oacute: "Ã³", Ocirc: "Ã”", ocirc: "Ã´", Ograve: "Ã’", ograve: "Ã²", ordf: "Âª", ordm: "Âº", Oslash: "Ã˜", oslash: "Ã¸", Otilde: "Ã•", otilde: "Ãµ", Ouml: "Ã–", ouml: "Ã¶", para: "Â¶", plusmn: "Â±", pound: "Â£", quot: '"', QUOT: '"', raquo: "Â»", reg: "Â®", REG: "Â®", sect: "Â§", shy: "Â­", sup1: "Â¹", sup2: "Â²", sup3: "Â³", szlig: "ÃŸ", THORN: "Ãž", thorn: "Ã¾", times: "Ã—", Uacute: "Ãš", uacute: "Ãº", Ucirc: "Ã›", ucirc: "Ã»", Ugrave: "Ã™", ugrave: "Ã¹", uml: "Â¨", Uuml: "Ãœ", uuml: "Ã¼", Yacute: "Ã", yacute: "Ã½", yen: "Â¥", yuml: "Ã¿" };
  }
}), qD = W({
  "../node_modules/entities/lib/maps/xml.json"(e, t) {
    t.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
}), uoe = W({
  "../node_modules/entities/lib/maps/decode.json"(e, t) {
    t.exports = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
  }
}), doe = W({
  "../node_modules/entities/lib/decode_codepoint.js"(e) {
    var t = e && e.__importDefault || function(a) {
      return a && a.__esModule ? a : { default: a };
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    var r = t(uoe()), n = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(a) {
        var i = "";
        return a > 65535 && (a -= 65536, i += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), i += String.fromCharCode(a), i;
      }
    );
    function o(a) {
      return a >= 55296 && a <= 57343 || a > 1114111 ? "ï¿½" : (a in r.default && (a = r.default[a]), n(a));
    }
    c(o, "decodeCodePoint"), e.default = o;
  }
}), CP = W({
  "../node_modules/entities/lib/decode.js"(e) {
    var t = e && e.__importDefault || function(p) {
      return p && p.__esModule ? p : { default: p };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0;
    var r = t(DD()), n = t(coe()), o = t(qD()), a = t(doe()), i = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    e.decodeXML = s(o.default), e.decodeHTMLStrict = s(r.default);
    function s(p) {
      var f = l(p);
      return function(h) {
        return String(h).replace(i, f);
      };
    }
    c(s, "getStrictDecoder");
    var d = /* @__PURE__ */ c(function(p, f) {
      return p < f ? 1 : -1;
    }, "sorter");
    e.decodeHTML = (function() {
      for (var p = Object.keys(n.default).sort(d), f = Object.keys(r.default).sort(d), h = 0, m = 0; h < f.length; h++)
        p[m] === f[h] ? (f[h] += ";?", m++) : f[h] += ";";
      var g = new RegExp("&(?:" + f.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), w = l(r.default);
      function _(b) {
        return b.substr(-1) !== ";" && (b += ";"), w(b);
      }
      return c(_, "replacer"), function(b) {
        return String(b).replace(g, _);
      };
    })();
    function l(p) {
      return /* @__PURE__ */ c(function(f) {
        if (f.charAt(1) === "#") {
          var h = f.charAt(2);
          return h === "X" || h === "x" ? a.default(parseInt(f.substr(3), 16)) : a.default(parseInt(f.substr(2), 10));
        }
        return p[f.slice(1, -1)] || f;
      }, "replace");
    }
    c(l, "getReplacer");
  }
}), kP = W({
  "../node_modules/entities/lib/encode.js"(e) {
    var t = e && e.__importDefault || function(x) {
      return x && x.__esModule ? x : { default: x };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0;
    var r = t(qD()), n = d(r.default), o = l(n);
    e.encodeXML = b(n);
    var a = t(DD()), i = d(a.default), s = l(i);
    e.encodeHTML = m(i, s), e.encodeNonAsciiHTML = b(i);
    function d(x) {
      return Object.keys(x).sort().reduce(function(P, R) {
        return P[x[R]] = "&" + R + ";", P;
      }, {});
    }
    c(d, "getInverseObj");
    function l(x) {
      for (var P = [], R = [], N = 0, C = Object.keys(x); N < C.length; N++) {
        var A = C[N];
        A.length === 1 ? P.push("\\" + A) : R.push(A);
      }
      P.sort();
      for (var E = 0; E < P.length - 1; E++) {
        for (var T = E; T < P.length - 1 && P[T].charCodeAt(1) + 1 === P[T + 1].charCodeAt(1); )
          T += 1;
        var O = 1 + T - E;
        O < 3 || P.splice(E, O, P[E] + "-" + P[T]);
      }
      return R.unshift("[" + P.join("") + "]"), new RegExp(R.join("|"), "g");
    }
    c(l, "getInverseReplacer");
    var p = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, f = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (function(x) {
          return x.codePointAt(0);
        })
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (function(x) {
          return (x.charCodeAt(0) - 55296) * 1024 + x.charCodeAt(1) - 56320 + 65536;
        })
      )
    );
    function h(x) {
      return "&#x" + (x.length > 1 ? f(x) : x.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    c(h, "singleCharReplacer");
    function m(x, P) {
      return function(R) {
        return R.replace(P, function(N) {
          return x[N];
        }).replace(p, h);
      };
    }
    c(m, "getInverse");
    var g = new RegExp(o.source + "|" + p.source, "g");
    function w(x) {
      return x.replace(g, h);
    }
    c(w, "escape"), e.escape = w;
    function _(x) {
      return x.replace(o, h);
    }
    c(_, "escapeUTF8"), e.escapeUTF8 = _;
    function b(x) {
      return function(P) {
        return P.replace(g, function(R) {
          return x[R] || h(R);
        });
      };
    }
    c(b, "getASCIIEncoder");
  }
}), poe = W({
  "../node_modules/entities/lib/index.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeXMLStrict = e.decodeHTML5Strict = e.decodeHTML4Strict = e.decodeHTML5 = e.decodeHTML4 = e.decodeHTMLStrict = e.decodeHTML = e.decodeXML = e.encodeHTML5 = e.encodeHTML4 = e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = e.encode = e.decodeStrict = e.decode = void 0;
    var t = CP(), r = kP();
    function n(d, l) {
      return (!l || l <= 0 ? t.decodeXML : t.decodeHTML)(d);
    }
    c(n, "decode"), e.decode = n;
    function o(d, l) {
      return (!l || l <= 0 ? t.decodeXML : t.decodeHTMLStrict)(d);
    }
    c(o, "decodeStrict"), e.decodeStrict = o;
    function a(d, l) {
      return (!l || l <= 0 ? r.encodeXML : r.encodeHTML)(d);
    }
    c(a, "encode"), e.encode = a;
    var i = kP();
    Object.defineProperty(e, "encodeXML", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.encodeXML;
    }, "get") }), Object.defineProperty(e, "encodeHTML", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.encodeHTML;
    }, "get") }), Object.defineProperty(e, "encodeNonAsciiHTML", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.encodeNonAsciiHTML;
    }, "get") }), Object.defineProperty(e, "escape", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.escape;
    }, "get") }), Object.defineProperty(e, "escapeUTF8", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.escapeUTF8;
    }, "get") }), Object.defineProperty(e, "encodeHTML4", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.encodeHTML;
    }, "get") }), Object.defineProperty(e, "encodeHTML5", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return i.encodeHTML;
    }, "get") });
    var s = CP();
    Object.defineProperty(e, "decodeXML", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeXML;
    }, "get") }), Object.defineProperty(e, "decodeHTML", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTMLStrict", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeHTML4", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTML5", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTML4Strict", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeHTML5Strict", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeXMLStrict", { enumerable: !0, get: /* @__PURE__ */ c(function() {
      return s.decodeXML;
    }, "get") });
  }
}), foe = W({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(e, t) {
    function r($, I) {
      if (!($ instanceof I))
        throw new TypeError("Cannot call a class as a function");
    }
    c(r, "_classCallCheck");
    function n($, I) {
      for (var D = 0; D < I.length; D++) {
        var F = I[D];
        F.enumerable = F.enumerable || !1, F.configurable = !0, "value" in F && (F.writable = !0), Object.defineProperty($, F.key, F);
      }
    }
    c(n, "_defineProperties");
    function o($, I, D) {
      return I && n($.prototype, I), D && n($, D), $;
    }
    c(o, "_createClass");
    function a($, I) {
      var D = typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
      if (!D) {
        if (Array.isArray($) || (D = i($)) || I && $ && typeof $.length == "number") {
          D && ($ = D);
          var F = 0, J = /* @__PURE__ */ c(function() {
          }, "F");
          return { s: J, n: /* @__PURE__ */ c(function() {
            return F >= $.length ? { done: !0 } : { done: !1, value: $[F++] };
          }, "n"), e: /* @__PURE__ */ c(function(re) {
            throw re;
          }, "e"), f: J };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var oe = !0, ce = !1, le;
      return { s: /* @__PURE__ */ c(function() {
        D = D.call($);
      }, "s"), n: /* @__PURE__ */ c(function() {
        var re = D.next();
        return oe = re.done, re;
      }, "n"), e: /* @__PURE__ */ c(function(re) {
        ce = !0, le = re;
      }, "e"), f: /* @__PURE__ */ c(function() {
        try {
          !oe && D.return != null && D.return();
        } finally {
          if (ce) throw le;
        }
      }, "f") };
    }
    c(a, "_createForOfIteratorHelper");
    function i($, I) {
      if ($) {
        if (typeof $ == "string") return s($, I);
        var D = Object.prototype.toString.call($).slice(8, -1);
        if (D === "Object" && $.constructor && (D = $.constructor.name), D === "Map" || D === "Set") return Array.from($);
        if (D === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D)) return s($, I);
      }
    }
    c(i, "_unsupportedIterableToArray");
    function s($, I) {
      (I == null || I > $.length) && (I = $.length);
      for (var D = 0, F = new Array(I); D < I; D++)
        F[D] = $[D];
      return F;
    }
    c(s, "_arrayLikeToArray");
    var d = poe(), l = {
      fg: "#FFF",
      bg: "#000",
      newline: !1,
      escapeXML: !1,
      stream: !1,
      colors: p()
    };
    function p() {
      var $ = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      return x(0, 5).forEach(function(I) {
        x(0, 5).forEach(function(D) {
          x(0, 5).forEach(function(F) {
            return f(I, D, F, $);
          });
        });
      }), x(0, 23).forEach(function(I) {
        var D = I + 232, F = h(I * 10 + 8);
        $[D] = "#" + F + F + F;
      }), $;
    }
    c(p, "getDefaultColors");
    function f($, I, D, F) {
      var J = 16 + $ * 36 + I * 6 + D, oe = $ > 0 ? $ * 40 + 55 : 0, ce = I > 0 ? I * 40 + 55 : 0, le = D > 0 ? D * 40 + 55 : 0;
      F[J] = m([oe, ce, le]);
    }
    c(f, "setStyleColor");
    function h($) {
      for (var I = $.toString(16); I.length < 2; )
        I = "0" + I;
      return I;
    }
    c(h, "toHexString");
    function m($) {
      var I = [], D = a($), F;
      try {
        for (D.s(); !(F = D.n()).done; ) {
          var J = F.value;
          I.push(h(J));
        }
      } catch (oe) {
        D.e(oe);
      } finally {
        D.f();
      }
      return "#" + I.join("");
    }
    c(m, "toColorHexString");
    function g($, I, D, F) {
      var J;
      return I === "text" ? J = N(D, F) : I === "display" ? J = _($, D, F) : I === "xterm256Foreground" ? J = E($, F.colors[D]) : I === "xterm256Background" ? J = T($, F.colors[D]) : I === "rgb" && (J = w($, D)), J;
    }
    c(g, "generateOutput");
    function w($, I) {
      I = I.substring(2).slice(0, -1);
      var D = +I.substr(0, 2), F = I.substring(5).split(";"), J = F.map(function(oe) {
        return ("0" + Number(oe).toString(16)).substr(-2);
      }).join("");
      return A($, (D === 38 ? "color:#" : "background-color:#") + J);
    }
    c(w, "handleRgb");
    function _($, I, D) {
      I = parseInt(I, 10);
      var F = {
        "-1": /* @__PURE__ */ c(function() {
          return "<br/>";
        }, "_"),
        0: /* @__PURE__ */ c(function() {
          return $.length && b($);
        }, "_"),
        1: /* @__PURE__ */ c(function() {
          return C($, "b");
        }, "_"),
        3: /* @__PURE__ */ c(function() {
          return C($, "i");
        }, "_"),
        4: /* @__PURE__ */ c(function() {
          return C($, "u");
        }, "_"),
        8: /* @__PURE__ */ c(function() {
          return A($, "display:none");
        }, "_"),
        9: /* @__PURE__ */ c(function() {
          return C($, "strike");
        }, "_"),
        22: /* @__PURE__ */ c(function() {
          return A($, "font-weight:normal;text-decoration:none;font-style:normal");
        }, "_"),
        23: /* @__PURE__ */ c(function() {
          return O($, "i");
        }, "_"),
        24: /* @__PURE__ */ c(function() {
          return O($, "u");
        }, "_"),
        39: /* @__PURE__ */ c(function() {
          return E($, D.fg);
        }, "_"),
        49: /* @__PURE__ */ c(function() {
          return T($, D.bg);
        }, "_"),
        53: /* @__PURE__ */ c(function() {
          return A($, "text-decoration:overline");
        }, "_")
      }, J;
      return F[I] ? J = F[I]() : 4 < I && I < 7 ? J = C($, "blink") : 29 < I && I < 38 ? J = E($, D.colors[I - 30]) : 39 < I && I < 48 ? J = T($, D.colors[I - 40]) : 89 < I && I < 98 ? J = E($, D.colors[8 + (I - 90)]) : 99 < I && I < 108 && (J = T($, D.colors[8 + (I - 100)])), J;
    }
    c(_, "handleDisplay");
    function b($) {
      var I = $.slice(0);
      return $.length = 0, I.reverse().map(function(D) {
        return "</" + D + ">";
      }).join("");
    }
    c(b, "resetStyles");
    function x($, I) {
      for (var D = [], F = $; F <= I; F++)
        D.push(F);
      return D;
    }
    c(x, "range");
    function P($) {
      return function(I) {
        return ($ === null || I.category !== $) && $ !== "all";
      };
    }
    c(P, "notCategory");
    function R($) {
      $ = parseInt($, 10);
      var I = null;
      return $ === 0 ? I = "all" : $ === 1 ? I = "bold" : 2 < $ && $ < 5 ? I = "underline" : 4 < $ && $ < 7 ? I = "blink" : $ === 8 ? I = "hide" : $ === 9 ? I = "strike" : 29 < $ && $ < 38 || $ === 39 || 89 < $ && $ < 98 ? I = "foreground-color" : (39 < $ && $ < 48 || $ === 49 || 99 < $ && $ < 108) && (I = "background-color"), I;
    }
    c(R, "categoryForCode");
    function N($, I) {
      return I.escapeXML ? d.encodeXML($) : $;
    }
    c(N, "pushText");
    function C($, I, D) {
      return D || (D = ""), $.push(I), "<".concat(I).concat(D ? ' style="'.concat(D, '"') : "", ">");
    }
    c(C, "pushTag");
    function A($, I) {
      return C($, "span", I);
    }
    c(A, "pushStyle");
    function E($, I) {
      return C($, "span", "color:" + I);
    }
    c(E, "pushForegroundColor");
    function T($, I) {
      return C($, "span", "background-color:" + I);
    }
    c(T, "pushBackgroundColor");
    function O($, I) {
      var D;
      if ($.slice(-1)[0] === I && (D = $.pop()), D)
        return "</" + I + ">";
    }
    c(O, "closeTag");
    function k($, I, D) {
      var F = !1, J = 3;
      function oe() {
        return "";
      }
      c(oe, "remove");
      function ce(se, ye) {
        return D("xterm256Foreground", ye), "";
      }
      c(ce, "removeXterm256Foreground");
      function le(se, ye) {
        return D("xterm256Background", ye), "";
      }
      c(le, "removeXterm256Background");
      function re(se) {
        return I.newline ? D("display", -1) : D("text", se), "";
      }
      c(re, "newline");
      function we(se, ye) {
        F = !0, ye.trim().length === 0 && (ye = "0"), ye = ye.trimRight(";").split(";");
        var fe = a(ye), Ae;
        try {
          for (fe.s(); !(Ae = fe.n()).done; ) {
            var Fe = Ae.value;
            D("display", Fe);
          }
        } catch (dt) {
          fe.e(dt);
        } finally {
          fe.f();
        }
        return "";
      }
      c(we, "ansiMess");
      function _e(se) {
        return D("text", se), "";
      }
      c(_e, "realText");
      function de(se) {
        return D("rgb", se), "";
      }
      c(de, "rgb");
      var ne = [{
        pattern: /^\x08+/,
        sub: oe
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: oe
      }, {
        pattern: /^\x1b\[\(B/,
        sub: oe
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: de
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: ce
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: le
      }, {
        pattern: /^\n/,
        sub: re
      }, {
        pattern: /^\r+\n/,
        sub: re
      }, {
        pattern: /^\r/,
        sub: re
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: we
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: oe
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: oe
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: oe
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: _e
      }];
      function $e(se, ye) {
        ye > J && F || (F = !1, $ = $.replace(se.pattern, se.sub));
      }
      c($e, "process");
      var Se = [], nt = $, We = nt.length;
      e: for (; We > 0; ) {
        for (var q = 0, te = 0, ae = ne.length; te < ae; q = ++te) {
          var ue = ne[q];
          if ($e(ue, q), $.length !== We) {
            We = $.length;
            continue e;
          }
        }
        if ($.length === We)
          break;
        Se.push(0), We = $.length;
      }
      return Se;
    }
    c(k, "tokenize");
    function M($, I, D) {
      return I !== "text" && ($ = $.filter(P(R(D))), $.push({
        token: I,
        data: D,
        category: R(D)
      })), $;
    }
    c(M, "updateStickyStack");
    var L = (function() {
      function $(I) {
        r(this, $), I = I || {}, I.colors && (I.colors = Object.assign({}, l.colors, I.colors)), this.options = Object.assign({}, l, I), this.stack = [], this.stickyStack = [];
      }
      return c($, "Filter"), o($, [{
        key: "toHtml",
        value: /* @__PURE__ */ c(function(I) {
          var D = this;
          I = typeof I == "string" ? [I] : I;
          var F = this.stack, J = this.options, oe = [];
          return this.stickyStack.forEach(function(ce) {
            var le = g(F, ce.token, ce.data, J);
            le && oe.push(le);
          }), k(I.join(""), J, function(ce, le) {
            var re = g(F, ce, le, J);
            re && oe.push(re), J.stream && (D.stickyStack = M(D.stickyStack, ce, le));
          }), F.length && oe.push(b(F)), oe.join("");
        }, "toHtml")
      }]), $;
    })();
    t.exports = L;
  }
}), LD = W({
  "../node_modules/memoizerific/memoizerific.js"(e, t) {
    (function(r) {
      if (typeof e == "object" && typeof t < "u")
        t.exports = r();
      else if (typeof define == "function" && define.amd)
        define([], r);
      else {
        var n;
        typeof window < "u" ? n = window : typeof globalThis < "u" ? n = globalThis : typeof self < "u" ? n = self : n = this, n.memoizerific = r();
      }
    })(function() {
      return (/* @__PURE__ */ c(function r(n, o, a) {
        function i(l, p) {
          if (!o[l]) {
            if (!n[l]) {
              var f = typeof Up == "function" && Up;
              if (!p && f) return f(l, !0);
              if (s) return s(l, !0);
              var h = new Error("Cannot find module '" + l + "'");
              throw h.code = "MODULE_NOT_FOUND", h;
            }
            var m = o[l] = { exports: {} };
            n[l][0].call(m.exports, function(g) {
              var w = n[l][1][g];
              return i(w || g);
            }, m, m.exports, r, n, o, a);
          }
          return o[l].exports;
        }
        c(i, "s");
        for (var s = typeof Up == "function" && Up, d = 0; d < a.length; d++) i(a[d]);
        return i;
      }, "e"))({ 1: [function(r, n, o) {
        n.exports = function(a) {
          if (typeof Map != "function" || a) {
            var i = r("./similar");
            return new i();
          } else
            return /* @__PURE__ */ new Map();
        };
      }, { "./similar": 2 }], 2: [function(r, n, o) {
        function a() {
          return this.list = [], this.lastItem = void 0, this.size = 0, this;
        }
        c(a, "Similar"), a.prototype.get = function(i) {
          var s;
          if (this.lastItem && this.isEqual(this.lastItem.key, i))
            return this.lastItem.val;
          if (s = this.indexOf(i), s >= 0)
            return this.lastItem = this.list[s], this.list[s].val;
        }, a.prototype.set = function(i, s) {
          var d;
          return this.lastItem && this.isEqual(this.lastItem.key, i) ? (this.lastItem.val = s, this) : (d = this.indexOf(i), d >= 0 ? (this.lastItem = this.list[d], this.list[d].val = s, this) : (this.lastItem = { key: i, val: s }, this.list.push(this.lastItem), this.size++, this));
        }, a.prototype.delete = function(i) {
          var s;
          if (this.lastItem && this.isEqual(this.lastItem.key, i) && (this.lastItem = void 0), s = this.indexOf(i), s >= 0)
            return this.size--, this.list.splice(s, 1)[0];
        }, a.prototype.has = function(i) {
          var s;
          return this.lastItem && this.isEqual(this.lastItem.key, i) ? !0 : (s = this.indexOf(i), s >= 0 ? (this.lastItem = this.list[s], !0) : !1);
        }, a.prototype.forEach = function(i, s) {
          var d;
          for (d = 0; d < this.size; d++)
            i.call(s || this, this.list[d].val, this.list[d].key, this);
        }, a.prototype.indexOf = function(i) {
          var s;
          for (s = 0; s < this.size; s++)
            if (this.isEqual(this.list[s].key, i))
              return s;
          return -1;
        }, a.prototype.isEqual = function(i, s) {
          return i === s || i !== i && s !== s;
        }, n.exports = a;
      }, {}], 3: [function(r, n, o) {
        var a = r("map-or-similar");
        n.exports = function(l) {
          var p = new a(!1), f = [];
          return function(h) {
            var m = /* @__PURE__ */ c(function() {
              var g = p, w, _, b = arguments.length - 1, x = Array(b + 1), P = !0, R;
              if ((m.numArgs || m.numArgs === 0) && m.numArgs !== b + 1)
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              for (R = 0; R < b; R++) {
                if (x[R] = {
                  cacheItem: g,
                  arg: arguments[R]
                }, g.has(arguments[R])) {
                  g = g.get(arguments[R]);
                  continue;
                }
                P = !1, w = new a(!1), g.set(arguments[R], w), g = w;
              }
              return P && (g.has(arguments[b]) ? _ = g.get(arguments[b]) : P = !1), P || (_ = h.apply(null, arguments), g.set(arguments[b], _)), l > 0 && (x[b] = {
                cacheItem: g,
                arg: arguments[b]
              }, P ? i(f, x) : f.push(x), f.length > l && s(f.shift())), m.wasMemoized = P, m.numArgs = b + 1, _;
            }, "memoizerific");
            return m.limit = l, m.wasMemoized = !1, m.cache = p, m.lru = f, m;
          };
        };
        function i(l, p) {
          var f = l.length, h = p.length, m, g, w;
          for (g = 0; g < f; g++) {
            for (m = !0, w = 0; w < h; w++)
              if (!d(l[g][w].arg, p[w].arg)) {
                m = !1;
                break;
              }
            if (m)
              break;
          }
          l.push(l.splice(g, 1)[0]);
        }
        c(i, "moveToMostRecentLru");
        function s(l) {
          var p = l.length, f = l[p - 1], h, m;
          for (f.cacheItem.delete(f.arg), m = p - 2; m >= 0 && (f = l[m], h = f.cacheItem.get(f.arg), !h || !h.size); m--)
            f.cacheItem.delete(f.arg);
        }
        c(s, "removeCachedResult");
        function d(l, p) {
          return l === p || l !== l && p !== p;
        }
        c(d, "isEqual");
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
}), Ee = (() => {
  let e;
  return typeof window < "u" ? e = window : typeof globalThis < "u" || typeof globalThis < "u" ? e = globalThis : typeof self < "u" ? e = self : e = {}, e;
})(), PP = /* @__PURE__ */ new Map(), hoe = "UNIVERSAL_STORE:", rn = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, ti = class Re {
  constructor(t, r) {
    if (this.debugging = !1, this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]), this.getState = /* @__PURE__ */ c(() => (this.debug("getState", { state: this.state }), this.state), "getState"), this.subscribe = /* @__PURE__ */ c((n, o) => {
      const a = typeof n == "function", i = a ? "*" : n, s = a ? n : o;
      if (this.debug("subscribe", { eventType: i, listener: s }), !s)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(i) || this.listeners.set(i, /* @__PURE__ */ new Set()), this.listeners.get(i).add(s), () => {
        this.debug("unsubscribe", { eventType: i, listener: s }), this.listeners.has(i) && (this.listeners.get(i).delete(s), this.listeners.get(i)?.size === 0 && this.listeners.delete(i));
      };
    }, "subscribe"), this.send = /* @__PURE__ */ c((n) => {
      if (this.debug("send", { event: n }), this.status !== Re.Status.READY)
        throw new TypeError(
          Ue`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event: n,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(n, { actor: this.actor }), this.emitToChannel(n, { actor: this.actor });
    }, "send"), this.debugging = t.debug ?? !1, !Re.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (Re.isInternalConstructing = !1, this.id = t.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = t.leader ? Re.ActorType.LEADER : Re.ActorType.FOLLOWER, this.state = t.initialState, this.channelEventName = `${hoe}${this.id}`, this.debug("constructor", {
      options: t,
      environmentOverrides: r,
      channelEventName: this.channelEventName
    }), this.actor.type === Re.ActorType.LEADER)
      this.syncing = {
        state: rn.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let n, o;
      const a = new Promise((i, s) => {
        n = /* @__PURE__ */ c(() => {
          this.syncing.state === rn.PENDING && (this.syncing.state = rn.RESOLVED, i());
        }, "syncingResolve"), o = /* @__PURE__ */ c((d) => {
          this.syncing.state === rn.PENDING && (this.syncing.state = rn.REJECTED, s(d));
        }, "syncingReject");
      });
      this.syncing = {
        state: rn.PENDING,
        promise: a,
        resolve: n,
        reject: o
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(this), this.debug = this.debug.bind(this), this.channel = r?.channel ?? Re.preparation.channel, this.environment = r?.environment ?? Re.preparation.environment, this.channel && this.environment ? (Re.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis({ channel: this.channel, environment: this.environment })) : Re.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let t, r;
    const n = new Promise(
      (o, a) => {
        t = /* @__PURE__ */ c((i) => {
          o(i);
        }, "resolveRef"), r = /* @__PURE__ */ c((...i) => {
          a(i);
        }, "rejectRef");
      }
    );
    Re.preparation = {
      resolve: t,
      reject: r,
      promise: n
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? Re.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return Re.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case rn.PENDING:
      case void 0:
        return Re.Status.SYNCING;
      case rn.REJECTED:
        return Re.Status.ERROR;
      case rn.RESOLVED:
      default:
        return Re.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([Re.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(t) {
    if (!t || typeof t?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    t.debug && console.debug(
      Ue`[UniversalStore]
        create`,
      { options: t }
    );
    const r = PP.get(t.id);
    if (r)
      return console.warn(Ue`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), r;
    Re.isInternalConstructing = !0;
    const n = new Re(t);
    return PP.set(t.id, n), n;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(t, r) {
    Re.preparation.channel = t, Re.preparation.environment = r, Re.preparation.resolve({ channel: t, environment: r });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(t) {
    const r = this.state, n = typeof t == "function" ? t(r) : t;
    if (this.debug("setState", { newState: n, previousState: r, updater: t }), this.status !== Re.Status.READY)
      throw new TypeError(
        Ue`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState: n,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = n;
    const o = {
      type: Re.InternalEventType.SET_STATE,
      payload: {
        state: n,
        previousState: r
      }
    };
    this.emitToChannel(o, { actor: this.actor }), this.emitToListeners(o, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(t) {
    return this.debug("onStateChange", { listener: t }), this.subscribe(
      Re.InternalEventType.SET_STATE,
      ({ payload: r }, n) => {
        t(r.state, r.previousState, n);
      }
    );
  }
  emitToChannel(t, r) {
    this.debug("emitToChannel", { event: t, eventInfo: r, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event: t,
      eventInfo: r
    });
  }
  prepareThis({
    channel: t,
    environment: r
  }) {
    this.channel = t, this.environment = r, this.debug("prepared", { channel: !!t, environment: r }), this.channel.on(this.channelEventName, this.handleChannelEvents), this.actor.type === Re.ActorType.LEADER ? this.emitToChannel(
      { type: Re.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: Re.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: Re.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(t, r) {
    const n = this.listeners.get(t.type), o = this.listeners.get("*");
    this.debug("emitToListeners", {
      event: t,
      eventInfo: r,
      eventTypeListeners: n,
      everythingListeners: o
    }), [...n ?? [], ...o ?? []].forEach(
      (a) => a(t, r)
    );
  }
  handleChannelEvents(t) {
    const { event: r, eventInfo: n } = t;
    if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent: t });
      return;
    } else if (this.syncing?.state === rn.PENDING && r.type !== Re.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent: t });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent: t }), this.actor.type === Re.ActorType.LEADER) {
      let o = !0;
      switch (r.type) {
        case Re.InternalEventType.EXISTING_STATE_REQUEST:
          o = !1;
          const a = {
            type: Re.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent: a
          }), this.emitToChannel(a, { actor: this.actor }), this.emitToListeners(a, { actor: this.actor });
          break;
        case Re.InternalEventType.LEADER_CREATED:
          o = !1, this.syncing.state = rn.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event: r
          }), console.error(
            Ue`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`
          );
          break;
      }
      o && (this.debug("handleChannelEvents: forwarding event", { channelEvent: t }), this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === Re.ActorType.FOLLOWER)
      switch (r.type) {
        case Re.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event: r
          }), this.syncing?.state !== rn.PENDING)
            break;
          this.syncing.resolve?.();
          const o = {
            type: Re.InternalEventType.SET_STATE,
            payload: {
              state: r.payload,
              previousState: this.state
            }
          };
          this.state = r.payload, this.emitToListeners(o, n);
          break;
      }
    switch (r.type) {
      case Re.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event: r }), this.state = r.payload.state;
        break;
    }
    this.emitToListeners(r, { actor: n.actor });
  }
  debug(t, r) {
    this.debugging && console.debug(
      Ue`[UniversalStore::${this.id}::${this.environment ?? Re.Environment.UNKNOWN}]
        ${t}`,
      JSON.stringify(
        {
          data: r,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    Re.preparation.reject(new Error("reset")), Re.setupPreparationPromise(), Re.isInternalConstructing = !1;
  }
};
c(ti, "UniversalStore");
ti.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
};
ti.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
};
ti.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
};
ti.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
};
ti.isInternalConstructing = !1;
ti.setupPreparationPromise();
var Gb = ti, moe = Object.create, FD = Object.defineProperty, yoe = Object.getOwnPropertyDescriptor, UD = Object.getOwnPropertyNames, goe = Object.getPrototypeOf, boe = Object.prototype.hasOwnProperty, qe = /* @__PURE__ */ c((e, t) => /* @__PURE__ */ c(function() {
  return t || (0, e[UD(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, "__require"), "__commonJS"), voe = /* @__PURE__ */ c((e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of UD(t))
      !boe.call(e, o) && o !== r && FD(e, o, { get: /* @__PURE__ */ c(() => t[o], "get"), enumerable: !(n = yoe(t, o)) || n.enumerable });
  return e;
}, "__copyProps"), _E = /* @__PURE__ */ c((e, t, r) => (r = e != null ? moe(goe(e)) : {}, voe(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? FD(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), "__toESM"), woe = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
], _oe = ["detail"];
function BD(e) {
  const t = woe.filter((r) => e[r] !== void 0).reduce((r, n) => (r[n] = e[n], r), {});
  if (e instanceof CustomEvent)
    for (const r of _oe.filter(
      (n) => e[n] !== void 0
    ))
      t[r] = e[r];
  return t;
}
c(BD, "extractEventHiddenProperties");
var HD = qe({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(e, t) {
    t.exports = Object;
  }
}), Eoe = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(e, t) {
    t.exports = Error;
  }
}), xoe = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(e, t) {
    t.exports = EvalError;
  }
}), Soe = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(e, t) {
    t.exports = RangeError;
  }
}), Toe = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(e, t) {
    t.exports = ReferenceError;
  }
}), Aoe = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(e, t) {
    t.exports = SyntaxError;
  }
}), EE = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(e, t) {
    t.exports = TypeError;
  }
}), $oe = qe({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(e, t) {
    t.exports = URIError;
  }
}), Coe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(e, t) {
    t.exports = Math.abs;
  }
}), koe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(e, t) {
    t.exports = Math.floor;
  }
}), Poe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(e, t) {
    t.exports = Math.max;
  }
}), Ooe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(e, t) {
    t.exports = Math.min;
  }
}), Roe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(e, t) {
    t.exports = Math.pow;
  }
}), joe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(e, t) {
    t.exports = Math.round;
  }
}), Ioe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(e, t) {
    t.exports = Number.isNaN || /* @__PURE__ */ c(function(r) {
      return r !== r;
    }, "isNaN2");
  }
}), Noe = qe({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(e, t) {
    var r = Ioe();
    t.exports = /* @__PURE__ */ c(function(n) {
      return r(n) || n === 0 ? n : n < 0 ? -1 : 1;
    }, "sign");
  }
}), Moe = qe({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(e, t) {
    t.exports = Object.getOwnPropertyDescriptor;
  }
}), xE = qe({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(e, t) {
    var r = Moe();
    if (r)
      try {
        r([], "length");
      } catch {
        r = null;
      }
    t.exports = r;
  }
}), Doe = qe({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(e, t) {
    var r = Object.defineProperty || !1;
    if (r)
      try {
        r({}, "a", { value: 1 });
      } catch {
        r = !1;
      }
    t.exports = r;
  }
}), VD = qe({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(e, t) {
    t.exports = /* @__PURE__ */ c(function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
      if (typeof Symbol.iterator == "symbol")
        return !0;
      var r = {}, n = Symbol("test"), o = Object(n);
      if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]")
        return !1;
      var a = 42;
      r[n] = a;
      for (var i in r)
        return !1;
      if (typeof Object.keys == "function" && Object.keys(r).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r).length !== 0)
        return !1;
      var s = Object.getOwnPropertySymbols(r);
      if (s.length !== 1 || s[0] !== n || !Object.prototype.propertyIsEnumerable.call(r, n))
        return !1;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var d = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(r, n)
        );
        if (d.value !== a || d.enumerable !== !0)
          return !1;
      }
      return !0;
    }, "hasSymbols");
  }
}), zD = qe({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(e, t) {
    var r = typeof Symbol < "u" && Symbol, n = VD();
    t.exports = /* @__PURE__ */ c(function() {
      return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : n();
    }, "hasNativeSymbols");
  }
}), JD = qe({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
  }
}), WD = qe({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(e, t) {
    var r = HD();
    t.exports = r.getPrototypeOf || null;
  }
}), qoe = qe({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(e, t) {
    var r = "Function.prototype.bind called on incompatible ", n = Object.prototype.toString, o = Math.max, a = "[object Function]", i = /* @__PURE__ */ c(function(l, p) {
      for (var f = [], h = 0; h < l.length; h += 1)
        f[h] = l[h];
      for (var m = 0; m < p.length; m += 1)
        f[m + l.length] = p[m];
      return f;
    }, "concatty2"), s = /* @__PURE__ */ c(function(l, p) {
      for (var f = [], h = p || 0, m = 0; h < l.length; h += 1, m += 1)
        f[m] = l[h];
      return f;
    }, "slicy2"), d = /* @__PURE__ */ c(function(l, p) {
      for (var f = "", h = 0; h < l.length; h += 1)
        f += l[h], h + 1 < l.length && (f += p);
      return f;
    }, "joiny");
    t.exports = /* @__PURE__ */ c(function(l) {
      var p = this;
      if (typeof p != "function" || n.apply(p) !== a)
        throw new TypeError(r + p);
      for (var f = s(arguments, 1), h, m = /* @__PURE__ */ c(function() {
        if (this instanceof h) {
          var x = p.apply(
            this,
            i(f, arguments)
          );
          return Object(x) === x ? x : this;
        }
        return p.apply(
          l,
          i(f, arguments)
        );
      }, "binder"), g = o(0, p.length - f.length), w = [], _ = 0; _ < g; _++)
        w[_] = "$" + _;
      if (h = Function("binder", "return function (" + d(w, ",") + "){ return binder.apply(this,arguments); }")(m), p.prototype) {
        var b = /* @__PURE__ */ c(function() {
        }, "Empty2");
        b.prototype = p.prototype, h.prototype = new b(), b.prototype = null;
      }
      return h;
    }, "bind");
  }
}), Fm = qe({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(e, t) {
    var r = qoe();
    t.exports = Function.prototype.bind || r;
  }
}), SE = qe({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(e, t) {
    t.exports = Function.prototype.call;
  }
}), GD = qe({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(e, t) {
    t.exports = Function.prototype.apply;
  }
}), Loe = qe({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
  }
}), Foe = qe({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(e, t) {
    var r = Fm(), n = GD(), o = SE(), a = Loe();
    t.exports = a || r.call(o, n);
  }
}), KD = qe({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(e, t) {
    var r = Fm(), n = EE(), o = SE(), a = Foe();
    t.exports = /* @__PURE__ */ c(function(i) {
      if (i.length < 1 || typeof i[0] != "function")
        throw new n("a function is required");
      return a(r, o, i);
    }, "callBindBasic");
  }
}), Uoe = qe({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(e, t) {
    var r = KD(), n = xE(), o;
    try {
      o = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (d) {
      if (!d || typeof d != "object" || !("code" in d) || d.code !== "ERR_PROTO_ACCESS")
        throw d;
    }
    var a = !!o && n && n(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), i = Object, s = i.getPrototypeOf;
    t.exports = a && typeof a.get == "function" ? r([a.get]) : typeof s == "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ c(function(d) {
        return s(d == null ? d : i(d));
      }, "getDunder")
    ) : !1;
  }
}), Boe = qe({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(e, t) {
    var r = JD(), n = WD(), o = Uoe();
    t.exports = r ? /* @__PURE__ */ c(function(a) {
      return r(a);
    }, "getProto") : n ? /* @__PURE__ */ c(function(a) {
      if (!a || typeof a != "object" && typeof a != "function")
        throw new TypeError("getProto: not an object");
      return n(a);
    }, "getProto") : o ? /* @__PURE__ */ c(function(a) {
      return o(a);
    }, "getProto") : null;
  }
}), YD = qe({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(e, t) {
    var r = Function.prototype.call, n = Object.prototype.hasOwnProperty, o = Fm();
    t.exports = o.call(r, n);
  }
}), Hoe = qe({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(e, t) {
    var r, n = HD(), o = Eoe(), a = xoe(), i = Soe(), s = Toe(), d = Aoe(), l = EE(), p = $oe(), f = Coe(), h = koe(), m = Poe(), g = Ooe(), w = Roe(), _ = joe(), b = Noe(), x = Function, P = /* @__PURE__ */ c(function(q) {
      try {
        return x('"use strict"; return (' + q + ").constructor;")();
      } catch {
      }
    }, "getEvalledConstructor"), R = xE(), N = Doe(), C = /* @__PURE__ */ c(function() {
      throw new l();
    }, "throwTypeError"), A = R ? (function() {
      try {
        return arguments.callee, C;
      } catch {
        try {
          return R(arguments, "callee").get;
        } catch {
          return C;
        }
      }
    })() : C, E = zD()(), T = Boe(), O = WD(), k = JD(), M = GD(), L = SE(), $ = {}, I = typeof Uint8Array > "u" || !T ? r : T(Uint8Array), D = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
      "%ArrayIteratorPrototype%": E && T ? T([][Symbol.iterator]()) : r,
      "%AsyncFromSyncIteratorPrototype%": r,
      "%AsyncFunction%": $,
      "%AsyncGenerator%": $,
      "%AsyncGeneratorFunction%": $,
      "%AsyncIteratorPrototype%": $,
      "%Atomics%": typeof Atomics > "u" ? r : Atomics,
      "%BigInt%": typeof BigInt > "u" ? r : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? r : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": o,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": a,
      "%Float16Array%": typeof Float16Array > "u" ? r : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
      "%Function%": x,
      "%GeneratorFunction%": $,
      "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": E && T ? T(T([][Symbol.iterator]())) : r,
      "%JSON%": typeof JSON == "object" ? JSON : r,
      "%Map%": typeof Map > "u" ? r : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !E || !T ? r : T((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": n,
      "%Object.getOwnPropertyDescriptor%": R,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? r : Promise,
      "%Proxy%": typeof Proxy > "u" ? r : Proxy,
      "%RangeError%": i,
      "%ReferenceError%": s,
      "%Reflect%": typeof Reflect > "u" ? r : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? r : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !E || !T ? r : T((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": E && T ? T(""[Symbol.iterator]()) : r,
      "%Symbol%": E ? Symbol : r,
      "%SyntaxError%": d,
      "%ThrowTypeError%": A,
      "%TypedArray%": I,
      "%TypeError%": l,
      "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
      "%URIError%": p,
      "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet,
      "%Function.prototype.call%": L,
      "%Function.prototype.apply%": M,
      "%Object.defineProperty%": N,
      "%Object.getPrototypeOf%": O,
      "%Math.abs%": f,
      "%Math.floor%": h,
      "%Math.max%": m,
      "%Math.min%": g,
      "%Math.pow%": w,
      "%Math.round%": _,
      "%Math.sign%": b,
      "%Reflect.getPrototypeOf%": k
    };
    if (T)
      try {
        null.error;
      } catch (q) {
        F = T(T(q)), D["%Error.prototype%"] = F;
      }
    var F, J = /* @__PURE__ */ c(function q(te) {
      var ae;
      if (te === "%AsyncFunction%")
        ae = P("async function () {}");
      else if (te === "%GeneratorFunction%")
        ae = P("function* () {}");
      else if (te === "%AsyncGeneratorFunction%")
        ae = P("async function* () {}");
      else if (te === "%AsyncGenerator%") {
        var ue = q("%AsyncGeneratorFunction%");
        ue && (ae = ue.prototype);
      } else if (te === "%AsyncIteratorPrototype%") {
        var se = q("%AsyncGenerator%");
        se && T && (ae = T(se.prototype));
      }
      return D[te] = ae, ae;
    }, "doEval2"), oe = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, ce = Fm(), le = YD(), re = ce.call(L, Array.prototype.concat), we = ce.call(M, Array.prototype.splice), _e = ce.call(L, String.prototype.replace), de = ce.call(L, String.prototype.slice), ne = ce.call(L, RegExp.prototype.exec), $e = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Se = /\\(\\)?/g, nt = /* @__PURE__ */ c(function(q) {
      var te = de(q, 0, 1), ae = de(q, -1);
      if (te === "%" && ae !== "%")
        throw new d("invalid intrinsic syntax, expected closing `%`");
      if (ae === "%" && te !== "%")
        throw new d("invalid intrinsic syntax, expected opening `%`");
      var ue = [];
      return _e(q, $e, function(se, ye, fe, Ae) {
        ue[ue.length] = fe ? _e(Ae, Se, "$1") : ye || se;
      }), ue;
    }, "stringToPath3"), We = /* @__PURE__ */ c(function(q, te) {
      var ae = q, ue;
      if (le(oe, ae) && (ue = oe[ae], ae = "%" + ue[0] + "%"), le(D, ae)) {
        var se = D[ae];
        if (se === $ && (se = J(ae)), typeof se > "u" && !te)
          throw new l("intrinsic " + q + " exists, but is not available. Please file an issue!");
        return {
          alias: ue,
          name: ae,
          value: se
        };
      }
      throw new d("intrinsic " + q + " does not exist!");
    }, "getBaseIntrinsic2");
    t.exports = /* @__PURE__ */ c(function(q, te) {
      if (typeof q != "string" || q.length === 0)
        throw new l("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof te != "boolean")
        throw new l('"allowMissing" argument must be a boolean');
      if (ne(/^%?[^%]*%?$/, q) === null)
        throw new d("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var ae = nt(q), ue = ae.length > 0 ? ae[0] : "", se = We("%" + ue + "%", te), ye = se.name, fe = se.value, Ae = !1, Fe = se.alias;
      Fe && (ue = Fe[0], we(ae, re([0, 1], Fe)));
      for (var dt = 1, pt = !0; dt < ae.length; dt += 1) {
        var it = ae[dt], Ht = de(it, 0, 1), _t = de(it, -1);
        if ((Ht === '"' || Ht === "'" || Ht === "`" || _t === '"' || _t === "'" || _t === "`") && Ht !== _t)
          throw new d("property names with quotes must have matching quotes");
        if ((it === "constructor" || !pt) && (Ae = !0), ue += "." + it, ye = "%" + ue + "%", le(D, ye))
          fe = D[ye];
        else if (fe != null) {
          if (!(it in fe)) {
            if (!te)
              throw new l("base intrinsic for " + q + " exists, but the property is not available.");
            return;
          }
          if (R && dt + 1 >= ae.length) {
            var Et = R(fe, it);
            pt = !!Et, pt && "get" in Et && !("originalValue" in Et.get) ? fe = Et.get : fe = fe[it];
          } else
            pt = le(fe, it), fe = fe[it];
          pt && !Ae && (D[ye] = fe);
        }
      }
      return fe;
    }, "GetIntrinsic");
  }
}), TE = qe({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(e, t) {
    var r = Hoe(), n = KD(), o = n([r("%String.prototype.indexOf%")]);
    t.exports = /* @__PURE__ */ c(function(a, i) {
      var s = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        r(a, !!i)
      );
      return typeof s == "function" && o(a, ".prototype.") > -1 ? n(
        /** @type {const} */
        [s]
      ) : s;
    }, "callBoundIntrinsic");
  }
}), Voe = qe({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(e, t) {
    var r = VD();
    t.exports = /* @__PURE__ */ c(function() {
      return r() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
}), XD = qe({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(e, t) {
    var r = TE(), n = Voe()(), o = YD(), a = xE(), i;
    n ? (s = r("RegExp.prototype.exec"), d = {}, l = /* @__PURE__ */ c(function() {
      throw d;
    }, "throwRegexMarker"), p = {
      toString: l,
      valueOf: l
    }, typeof Symbol.toPrimitive == "symbol" && (p[Symbol.toPrimitive] = l), i = /* @__PURE__ */ c(function(m) {
      if (!m || typeof m != "object")
        return !1;
      var g = (
        /** @type {NonNullable<typeof gOPD>} */
        a(
          /** @type {{ lastIndex?: unknown }} */
          m,
          "lastIndex"
        )
      ), w = g && o(g, "value");
      if (!w)
        return !1;
      try {
        s(
          m,
          /** @type {string} */
          /** @type {unknown} */
          p
        );
      } catch (_) {
        return _ === d;
      }
    }, "isRegex")) : (f = r("Object.prototype.toString"), h = "[object RegExp]", i = /* @__PURE__ */ c(function(m) {
      return !m || typeof m != "object" && typeof m != "function" ? !1 : f(m) === h;
    }, "isRegex"));
    var s, d, l, p, f, h;
    t.exports = i;
  }
}), zoe = qe({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(e, t) {
    t.exports = n;
    var r = Object.prototype.toString;
    function n(o) {
      if (!o)
        return !1;
      var a = r.call(o);
      return a === "[object Function]" || typeof o == "function" && a !== "[object RegExp]" || typeof window < "u" && // IE8 and below
      (o === window.setTimeout || o === window.alert || o === window.confirm || o === window.prompt);
    }
    c(n, "isFunction3");
  }
}), Joe = qe({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(e, t) {
    var r = TE(), n = XD(), o = r("RegExp.prototype.exec"), a = EE();
    t.exports = /* @__PURE__ */ c(function(i) {
      if (!n(i))
        throw new a("`regex` must be a RegExp");
      return /* @__PURE__ */ c(function(s) {
        return o(i, s) !== null;
      }, "test");
    }, "regexTester");
  }
}), Woe = qe({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(e, t) {
    var r = TE(), n = r("Object.prototype.toString"), o = zD()(), a = Joe();
    o ? (i = r("Symbol.prototype.toString"), s = a(/^Symbol\(.*\)$/), d = /* @__PURE__ */ c(function(l) {
      return typeof l.valueOf() != "symbol" ? !1 : s(i(l));
    }, "isRealSymbolObject"), t.exports = /* @__PURE__ */ c(function(l) {
      if (typeof l == "symbol")
        return !0;
      if (!l || typeof l != "object" || n(l) !== "[object Symbol]")
        return !1;
      try {
        return d(l);
      } catch {
        return !1;
      }
    }, "isSymbol3")) : t.exports = /* @__PURE__ */ c(function(l) {
      return !1;
    }, "isSymbol3");
    var i, s, d;
  }
}), Goe = _E(XD()), Koe = _E(zoe()), Yoe = _E(Woe());
function QD(e) {
  return e != null && typeof e == "object" && Array.isArray(e) === !1;
}
c(QD, "isObject");
var Xoe = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, Qoe = Xoe, Zoe = typeof self == "object" && self && self.Object === Object && self, eae = Qoe || Zoe || Function("return this")(), AE = eae, tae = AE.Symbol, Rl = tae, ZD = Object.prototype, rae = ZD.hasOwnProperty, nae = ZD.toString, Zc = Rl ? Rl.toStringTag : void 0;
function eq(e) {
  var t = rae.call(e, Zc), r = e[Zc];
  try {
    e[Zc] = void 0;
    var n = !0;
  } catch {
  }
  var o = nae.call(e);
  return n && (t ? e[Zc] = r : delete e[Zc]), o;
}
c(eq, "getRawTag");
var oae = eq, aae = Object.prototype, iae = aae.toString;
function tq(e) {
  return iae.call(e);
}
c(tq, "objectToString");
var sae = tq, lae = "[object Null]", cae = "[object Undefined]", OP = Rl ? Rl.toStringTag : void 0;
function rq(e) {
  return e == null ? e === void 0 ? cae : lae : OP && OP in Object(e) ? oae(e) : sae(e);
}
c(rq, "baseGetTag");
var nq = rq;
function oq(e) {
  return e != null && typeof e == "object";
}
c(oq, "isObjectLike");
var uae = oq, dae = "[object Symbol]";
function aq(e) {
  return typeof e == "symbol" || uae(e) && nq(e) == dae;
}
c(aq, "isSymbol");
var $E = aq;
function iq(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, o = Array(n); ++r < n; )
    o[r] = t(e[r], r, e);
  return o;
}
c(iq, "arrayMap");
var pae = iq, fae = Array.isArray, CE = fae, RP = Rl ? Rl.prototype : void 0, jP = RP ? RP.toString : void 0;
function kE(e) {
  if (typeof e == "string")
    return e;
  if (CE(e))
    return pae(e, kE) + "";
  if ($E(e))
    return jP ? jP.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
c(kE, "baseToString");
var hae = kE;
function sq(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
c(sq, "isObject2");
var lq = sq, mae = "[object AsyncFunction]", yae = "[object Function]", gae = "[object GeneratorFunction]", bae = "[object Proxy]";
function cq(e) {
  if (!lq(e))
    return !1;
  var t = nq(e);
  return t == yae || t == gae || t == mae || t == bae;
}
c(cq, "isFunction");
var vae = cq, wae = AE["__core-js_shared__"], Kb = wae, IP = (function() {
  var e = /[^.]+$/.exec(Kb && Kb.keys && Kb.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function uq(e) {
  return !!IP && IP in e;
}
c(uq, "isMasked");
var _ae = uq, Eae = Function.prototype, xae = Eae.toString;
function dq(e) {
  if (e != null) {
    try {
      return xae.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
c(dq, "toSource");
var Sae = dq, Tae = /[\\^$.*+?()[\]{}|]/g, Aae = /^\[object .+?Constructor\]$/, $ae = Function.prototype, Cae = Object.prototype, kae = $ae.toString, Pae = Cae.hasOwnProperty, Oae = RegExp(
  "^" + kae.call(Pae).replace(Tae, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function pq(e) {
  if (!lq(e) || _ae(e))
    return !1;
  var t = vae(e) ? Oae : Aae;
  return t.test(Sae(e));
}
c(pq, "baseIsNative");
var Rae = pq;
function fq(e, t) {
  return e?.[t];
}
c(fq, "getValue");
var jae = fq;
function hq(e, t) {
  var r = jae(e, t);
  return Rae(r) ? r : void 0;
}
c(hq, "getNative");
var mq = hq;
function yq(e, t) {
  return e === t || e !== e && t !== t;
}
c(yq, "eq");
var Iae = yq, Nae = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Mae = /^\w*$/;
function gq(e, t) {
  if (CE(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || $E(e) ? !0 : Mae.test(e) || !Nae.test(e) || t != null && e in Object(t);
}
c(gq, "isKey");
var Dae = gq, qae = mq(Object, "create"), ad = qae;
function bq() {
  this.__data__ = ad ? ad(null) : {}, this.size = 0;
}
c(bq, "hashClear");
var Lae = bq;
function vq(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
c(vq, "hashDelete");
var Fae = vq, Uae = "__lodash_hash_undefined__", Bae = Object.prototype, Hae = Bae.hasOwnProperty;
function wq(e) {
  var t = this.__data__;
  if (ad) {
    var r = t[e];
    return r === Uae ? void 0 : r;
  }
  return Hae.call(t, e) ? t[e] : void 0;
}
c(wq, "hashGet");
var Vae = wq, zae = Object.prototype, Jae = zae.hasOwnProperty;
function _q(e) {
  var t = this.__data__;
  return ad ? t[e] !== void 0 : Jae.call(t, e);
}
c(_q, "hashHas");
var Wae = _q, Gae = "__lodash_hash_undefined__";
function Eq(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = ad && t === void 0 ? Gae : t, this;
}
c(Eq, "hashSet");
var Kae = Eq;
function As(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
c(As, "Hash");
As.prototype.clear = Lae;
As.prototype.delete = Fae;
As.prototype.get = Vae;
As.prototype.has = Wae;
As.prototype.set = Kae;
var NP = As;
function xq() {
  this.__data__ = [], this.size = 0;
}
c(xq, "listCacheClear");
var Yae = xq;
function Sq(e, t) {
  for (var r = e.length; r--; )
    if (Iae(e[r][0], t))
      return r;
  return -1;
}
c(Sq, "assocIndexOf");
var Um = Sq, Xae = Array.prototype, Qae = Xae.splice;
function Tq(e) {
  var t = this.__data__, r = Um(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : Qae.call(t, r, 1), --this.size, !0;
}
c(Tq, "listCacheDelete");
var Zae = Tq;
function Aq(e) {
  var t = this.__data__, r = Um(t, e);
  return r < 0 ? void 0 : t[r][1];
}
c(Aq, "listCacheGet");
var eie = Aq;
function $q(e) {
  return Um(this.__data__, e) > -1;
}
c($q, "listCacheHas");
var tie = $q;
function Cq(e, t) {
  var r = this.__data__, n = Um(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
c(Cq, "listCacheSet");
var rie = Cq;
function $s(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
c($s, "ListCache");
$s.prototype.clear = Yae;
$s.prototype.delete = Zae;
$s.prototype.get = eie;
$s.prototype.has = tie;
$s.prototype.set = rie;
var nie = $s, oie = mq(AE, "Map"), aie = oie;
function kq() {
  this.size = 0, this.__data__ = {
    hash: new NP(),
    map: new (aie || nie)(),
    string: new NP()
  };
}
c(kq, "mapCacheClear");
var iie = kq;
function Pq(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
c(Pq, "isKeyable");
var sie = Pq;
function Oq(e, t) {
  var r = e.__data__;
  return sie(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
c(Oq, "getMapData");
var Bm = Oq;
function Rq(e) {
  var t = Bm(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
c(Rq, "mapCacheDelete");
var lie = Rq;
function jq(e) {
  return Bm(this, e).get(e);
}
c(jq, "mapCacheGet");
var cie = jq;
function Iq(e) {
  return Bm(this, e).has(e);
}
c(Iq, "mapCacheHas");
var uie = Iq;
function Nq(e, t) {
  var r = Bm(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
c(Nq, "mapCacheSet");
var die = Nq;
function Cs(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
c(Cs, "MapCache");
Cs.prototype.clear = iie;
Cs.prototype.delete = lie;
Cs.prototype.get = cie;
Cs.prototype.has = uie;
Cs.prototype.set = die;
var Mq = Cs, pie = "Expected a function";
function Hm(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(pie);
  var r = /* @__PURE__ */ c(function() {
    var n = arguments, o = t ? t.apply(this, n) : n[0], a = r.cache;
    if (a.has(o))
      return a.get(o);
    var i = e.apply(this, n);
    return r.cache = a.set(o, i) || a, i;
  }, "memoized");
  return r.cache = new (Hm.Cache || Mq)(), r;
}
c(Hm, "memoize");
Hm.Cache = Mq;
var fie = Hm, hie = 500;
function Dq(e) {
  var t = fie(e, function(n) {
    return r.size === hie && r.clear(), n;
  }), r = t.cache;
  return t;
}
c(Dq, "memoizeCapped");
var mie = Dq, yie = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, gie = /\\(\\)?/g, bie = mie(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(yie, function(r, n, o, a) {
    t.push(o ? a.replace(gie, "$1") : n || r);
  }), t;
}), vie = bie;
function qq(e) {
  return e == null ? "" : hae(e);
}
c(qq, "toString");
var wie = qq;
function Lq(e, t) {
  return CE(e) ? e : Dae(e, t) ? [e] : vie(wie(e));
}
c(Lq, "castPath");
var _ie = Lq;
function Fq(e) {
  if (typeof e == "string" || $E(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
c(Fq, "toKey");
var Eie = Fq;
function Uq(e, t) {
  t = _ie(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[Eie(t[r++])];
  return r && r == n ? e : void 0;
}
c(Uq, "baseGet");
var xie = Uq;
function Bq(e, t, r) {
  var n = e == null ? void 0 : xie(e, t);
  return n === void 0 ? r : n;
}
c(Bq, "get");
var Sie = Bq, PE = QD, Tie = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, OE = /* @__PURE__ */ c((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), "isJSON");
function RE(e) {
  if (!PE(e))
    return e;
  let t = e, r = !1;
  return typeof Event < "u" && e instanceof Event && (t = BD(t), r = !0), t = Object.keys(t).reduce((n, o) => {
    try {
      t[o] && t[o].toJSON, n[o] = t[o];
    } catch {
      r = !0;
    }
    return n;
  }, {}), r ? t : e;
}
c(RE, "convertUnconventionalData");
var Aie = /* @__PURE__ */ c(function(e) {
  let t, r, n, o;
  return /* @__PURE__ */ c(function(a, i) {
    try {
      if (a === "")
        return o = [], t = /* @__PURE__ */ new Map([[i, "[]"]]), r = /* @__PURE__ */ new Map(), n = [], i;
      const s = r.get(this) || this;
      for (; n.length && s !== n[0]; )
        n.shift(), o.pop();
      if (typeof i == "boolean")
        return i;
      if (i === void 0)
        return e.allowUndefined ? "_undefined_" : void 0;
      if (i === null)
        return null;
      if (typeof i == "number")
        return i === Number.NEGATIVE_INFINITY ? "_-Infinity_" : i === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(i) ? "_NaN_" : i;
      if (typeof i == "bigint")
        return `_bigint_${i.toString()}`;
      if (typeof i == "string")
        return Tie.test(i) ? e.allowDate ? `_date_${i}` : void 0 : i;
      if ((0, Goe.default)(i))
        return e.allowRegExp ? `_regexp_${i.flags}|${i.source}` : void 0;
      if ((0, Koe.default)(i))
        return;
      if ((0, Yoe.default)(i)) {
        if (!e.allowSymbol)
          return;
        const l = Symbol.keyFor(i);
        return l !== void 0 ? `_gsymbol_${l}` : `_symbol_${i.toString().slice(7, -1)}`;
      }
      if (n.length >= e.maxDepth)
        return Array.isArray(i) ? `[Array(${i.length})]` : "[Object]";
      if (i === this)
        return `_duplicate_${JSON.stringify(o)}`;
      if (i instanceof Error && e.allowError)
        return {
          __isConvertedError__: !0,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...i.cause ? { cause: i.cause } : {},
            ...i,
            name: i.name,
            message: i.message,
            stack: i.stack,
            "_constructor-name_": i.constructor.name
          }
        };
      if (i?.constructor?.name && i.constructor.name !== "Object" && !Array.isArray(i)) {
        const l = t.get(i);
        if (!l) {
          const p = {
            __isClassInstance__: !0,
            __className__: i.constructor.name,
            ...Object.getOwnPropertyNames(i).reduce(
              (f, h) => {
                try {
                  f[h] = i[h];
                } catch {
                }
                return f;
              },
              {}
            )
          };
          return o.push(a), n.unshift(p), t.set(i, JSON.stringify(o)), i !== p && r.set(i, p), p;
        }
        return `_duplicate_${l}`;
      }
      const d = t.get(i);
      if (!d) {
        const l = Array.isArray(i) ? i : RE(i);
        return o.push(a), n.unshift(l), t.set(i, JSON.stringify(o)), i !== l && r.set(i, l), l;
      }
      return `_duplicate_${d}`;
    } catch {
      return;
    }
  }, "replace");
}, "replacer2"), $ie = /* @__PURE__ */ c(function(e) {
  const t = [];
  let r;
  return /* @__PURE__ */ c(function(n, o) {
    if (n === "" && (r = o, t.forEach(({ target: a, container: i, replacement: s }) => {
      const d = OE(s) ? JSON.parse(s) : s.split(".");
      d.length === 0 ? i[a] = r : i[a] = Sie(r, d);
    })), n === "_constructor-name_")
      return o;
    if (PE(o) && o.__isConvertedError__) {
      const { message: a, ...i } = o.errorProperties, s = new Error(a);
      return Object.assign(s, i), s;
    }
    if (typeof o == "string" && o.startsWith("_regexp_") && e.allowRegExp) {
      const [, a, i] = o.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(i, a);
    }
    return typeof o == "string" && o.startsWith("_date_") && e.allowDate ? new Date(o.replace("_date_", "")) : typeof o == "string" && o.startsWith("_duplicate_") ? (t.push({ target: n, container: this, replacement: o.replace(/^_duplicate_/, "") }), null) : typeof o == "string" && o.startsWith("_symbol_") && e.allowSymbol ? Symbol(o.replace("_symbol_", "")) : typeof o == "string" && o.startsWith("_gsymbol_") && e.allowSymbol ? Symbol.for(o.replace("_gsymbol_", "")) : typeof o == "string" && o === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof o == "string" && o === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof o == "string" && o === "_NaN_" ? Number.NaN : typeof o == "string" && o.startsWith("_bigint_") && typeof BigInt == "function" ? BigInt(o.replace("_bigint_", "")) : o;
  }, "revive");
}, "reviver2"), Hq = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: !0,
  allowDate: !0,
  allowError: !0,
  allowUndefined: !0,
  allowSymbol: !0
}, Vq = /* @__PURE__ */ c((e, t = {}) => {
  const r = { ...Hq, ...t };
  return JSON.stringify(RE(e), Aie(r), t.space);
}, "stringify"), Cie = /* @__PURE__ */ c(() => {
  const e = /* @__PURE__ */ new Map();
  return /* @__PURE__ */ c(function t(r) {
    PE(r) && Object.entries(r).forEach(([n, o]) => {
      o === "_undefined_" ? r[n] = void 0 : e.get(o) || (e.set(o, !0), t(o));
    }), Array.isArray(r) && r.forEach((n, o) => {
      n === "_undefined_" ? (e.set(n, !0), r[o] = void 0) : e.get(n) || (e.set(n, !0), t(n));
    });
  }, "mutateUndefined");
}, "mutator"), zq = /* @__PURE__ */ c((e, t = {}) => {
  const r = { ...Hq, ...t }, n = JSON.parse(e, $ie(r));
  return Cie()(n), n;
}, "parse"), { LOGLEVEL: kie } = Ee, _a = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
}, Pie = kie, Bs = _a[Pie] || _a.info, vt = {
  trace: /* @__PURE__ */ c((e, ...t) => {
    Bs <= _a.trace && console.trace(e, ...t);
  }, "trace"),
  debug: /* @__PURE__ */ c((e, ...t) => {
    Bs <= _a.debug && console.debug(e, ...t);
  }, "debug"),
  info: /* @__PURE__ */ c((e, ...t) => {
    Bs <= _a.info && console.info(e, ...t);
  }, "info"),
  warn: /* @__PURE__ */ c((e, ...t) => {
    Bs <= _a.warn && console.warn(e, ...t);
  }, "warn"),
  error: /* @__PURE__ */ c((e, ...t) => {
    Bs <= _a.error && console.error(e, ...t);
  }, "error"),
  log: /* @__PURE__ */ c((e, ...t) => {
    Bs < _a.silent && console.log(e, ...t);
  }, "log")
}, Qv = /* @__PURE__ */ new Set(), Mt = /* @__PURE__ */ c((e) => (t, ...r) => {
  if (!Qv.has(t))
    return Qv.add(t), vt[e](t, ...r);
}, "once");
Mt.clear = () => Qv.clear();
Mt.trace = Mt("trace");
Mt.debug = Mt("debug");
Mt.info = Mt("info");
Mt.warn = Mt("warn");
Mt.error = Mt("error");
Mt.log = Mt("log");
var Jq = Mt("warn"), gn = /* @__PURE__ */ c((e) => (...t) => {
  const r = [];
  if (t.length) {
    const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, o = /<\/span>/gi;
    let a;
    for (r.push(t[0].replace(n, "%c").replace(o, "%c")); a = n.exec(t[0]); )
      r.push(a[2]), r.push("");
    for (let i = 1; i < t.length; i++)
      r.push(t[i]);
  }
  vt[e].apply(vt, r);
}, "pretty");
gn.trace = gn("trace");
gn.debug = gn("debug");
gn.info = gn("info");
gn.warn = gn("warn");
gn.error = gn("error");
var jE = /* @__PURE__ */ ((e) => (e.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", e.CHANNEL_CREATED = "channelCreated", e.CONFIG_ERROR = "configError", e.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", e.STORY_SPECIFIED = "storySpecified", e.SET_CONFIG = "setConfig", e.SET_STORIES = "setStories", e.SET_INDEX = "setIndex", e.SET_CURRENT_STORY = "setCurrentStory", e.CURRENT_STORY_WAS_SET = "currentStoryWasSet", e.FORCE_RE_RENDER = "forceReRender", e.FORCE_REMOUNT = "forceRemount", e.PRELOAD_ENTRIES = "preloadStories", e.STORY_PREPARED = "storyPrepared", e.DOCS_PREPARED = "docsPrepared", e.STORY_CHANGED = "storyChanged", e.STORY_UNCHANGED = "storyUnchanged", e.STORY_RENDERED = "storyRendered", e.STORY_FINISHED = "storyFinished", e.STORY_MISSING = "storyMissing", e.STORY_ERRORED = "storyErrored", e.STORY_THREW_EXCEPTION = "storyThrewException", e.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", e.STORY_HOT_UPDATED = "storyHotUpdated", e.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", e.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", e.UPDATE_STORY_ARGS = "updateStoryArgs", e.STORY_ARGS_UPDATED = "storyArgsUpdated", e.RESET_STORY_ARGS = "resetStoryArgs", e.SET_FILTER = "setFilter", e.SET_GLOBALS = "setGlobals", e.UPDATE_GLOBALS = "updateGlobals", e.GLOBALS_UPDATED = "globalsUpdated", e.REGISTER_SUBSCRIPTION = "registerSubscription", e.PREVIEW_INITIALIZED = "previewInitialized", e.PREVIEW_KEYDOWN = "previewKeydown", e.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", e.SELECT_STORY = "selectStory", e.STORIES_COLLAPSE_ALL = "storiesCollapseAll", e.STORIES_EXPAND_ALL = "storiesExpandAll", e.DOCS_RENDERED = "docsRendered", e.SHARED_STATE_CHANGED = "sharedStateChanged", e.SHARED_STATE_SET = "sharedStateSet", e.NAVIGATE_URL = "navigateUrl", e.UPDATE_QUERY_PARAMS = "updateQueryParams", e.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", e.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", e.SET_WHATS_NEW_CACHE = "setWhatsNewCache", e.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", e.TELEMETRY_ERROR = "telemetryError", e.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", e.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", e.SAVE_STORY_REQUEST = "saveStoryRequest", e.SAVE_STORY_RESPONSE = "saveStoryResponse", e.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", e.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", e.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", e.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", e.OPEN_IN_EDITOR_REQUEST = "openInEditorRequest", e.OPEN_IN_EDITOR_RESPONSE = "openInEditorResponse", e))(jE || {}), Oie = jE, {
  CHANNEL_WS_DISCONNECT: Wq,
  CHANNEL_CREATED: Rie,
  CONFIG_ERROR: Gq,
  CREATE_NEW_STORYFILE_REQUEST: jie,
  CREATE_NEW_STORYFILE_RESPONSE: Iie,
  CURRENT_STORY_WAS_SET: Zv,
  DOCS_PREPARED: Kq,
  DOCS_RENDERED: IE,
  FILE_COMPONENT_SEARCH_REQUEST: Nie,
  FILE_COMPONENT_SEARCH_RESPONSE: Mie,
  FORCE_RE_RENDER: NE,
  FORCE_REMOUNT: Lf,
  GLOBALS_UPDATED: id,
  NAVIGATE_URL: Die,
  PLAY_FUNCTION_THREW_EXCEPTION: Yq,
  UNHANDLED_ERRORS_WHILE_PLAYING: Xq,
  PRELOAD_ENTRIES: Qq,
  PREVIEW_INITIALIZED: Zq,
  PREVIEW_BUILDER_PROGRESS: qie,
  PREVIEW_KEYDOWN: eL,
  REGISTER_SUBSCRIPTION: Lie,
  RESET_STORY_ARGS: ME,
  SELECT_STORY: Fie,
  SET_CONFIG: Uie,
  SET_CURRENT_STORY: DE,
  SET_FILTER: Bie,
  SET_GLOBALS: tL,
  SET_INDEX: Hie,
  SET_STORIES: Vie,
  SHARED_STATE_CHANGED: zie,
  SHARED_STATE_SET: Jie,
  STORIES_COLLAPSE_ALL: Wie,
  STORIES_EXPAND_ALL: Gie,
  STORY_ARGS_UPDATED: rL,
  STORY_CHANGED: nL,
  STORY_ERRORED: oL,
  STORY_INDEX_INVALIDATED: aL,
  STORY_MISSING: ew,
  STORY_PREPARED: iL,
  STORY_RENDER_PHASE_CHANGED: os,
  STORY_RENDERED: Ff,
  STORY_FINISHED: tw,
  STORY_SPECIFIED: sL,
  STORY_THREW_EXCEPTION: lL,
  STORY_UNCHANGED: cL,
  STORY_HOT_UPDATED: uL,
  UPDATE_GLOBALS: qE,
  UPDATE_QUERY_PARAMS: dL,
  UPDATE_STORY_ARGS: LE,
  REQUEST_WHATS_NEW_DATA: Kie,
  RESULT_WHATS_NEW_DATA: Yie,
  SET_WHATS_NEW_CACHE: Xie,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: Qie,
  TELEMETRY_ERROR: Zie,
  SAVE_STORY_REQUEST: ese,
  SAVE_STORY_RESPONSE: tse,
  ARGTYPES_INFO_REQUEST: pL,
  ARGTYPES_INFO_RESPONSE: rw,
  OPEN_IN_EDITOR_REQUEST: rse,
  OPEN_IN_EDITOR_RESPONSE: nse
} = jE;
const ose = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ARGTYPES_INFO_REQUEST: pL,
  ARGTYPES_INFO_RESPONSE: rw,
  CHANNEL_CREATED: Rie,
  CHANNEL_WS_DISCONNECT: Wq,
  CONFIG_ERROR: Gq,
  CREATE_NEW_STORYFILE_REQUEST: jie,
  CREATE_NEW_STORYFILE_RESPONSE: Iie,
  CURRENT_STORY_WAS_SET: Zv,
  DOCS_PREPARED: Kq,
  DOCS_RENDERED: IE,
  FILE_COMPONENT_SEARCH_REQUEST: Nie,
  FILE_COMPONENT_SEARCH_RESPONSE: Mie,
  FORCE_REMOUNT: Lf,
  FORCE_RE_RENDER: NE,
  GLOBALS_UPDATED: id,
  NAVIGATE_URL: Die,
  OPEN_IN_EDITOR_REQUEST: rse,
  OPEN_IN_EDITOR_RESPONSE: nse,
  PLAY_FUNCTION_THREW_EXCEPTION: Yq,
  PRELOAD_ENTRIES: Qq,
  PREVIEW_BUILDER_PROGRESS: qie,
  PREVIEW_INITIALIZED: Zq,
  PREVIEW_KEYDOWN: eL,
  REGISTER_SUBSCRIPTION: Lie,
  REQUEST_WHATS_NEW_DATA: Kie,
  RESET_STORY_ARGS: ME,
  RESULT_WHATS_NEW_DATA: Yie,
  SAVE_STORY_REQUEST: ese,
  SAVE_STORY_RESPONSE: tse,
  SELECT_STORY: Fie,
  SET_CONFIG: Uie,
  SET_CURRENT_STORY: DE,
  SET_FILTER: Bie,
  SET_GLOBALS: tL,
  SET_INDEX: Hie,
  SET_STORIES: Vie,
  SET_WHATS_NEW_CACHE: Xie,
  SHARED_STATE_CHANGED: zie,
  SHARED_STATE_SET: Jie,
  STORIES_COLLAPSE_ALL: Wie,
  STORIES_EXPAND_ALL: Gie,
  STORY_ARGS_UPDATED: rL,
  STORY_CHANGED: nL,
  STORY_ERRORED: oL,
  STORY_FINISHED: tw,
  STORY_HOT_UPDATED: uL,
  STORY_INDEX_INVALIDATED: aL,
  STORY_MISSING: ew,
  STORY_PREPARED: iL,
  STORY_RENDERED: Ff,
  STORY_RENDER_PHASE_CHANGED: os,
  STORY_SPECIFIED: sL,
  STORY_THREW_EXCEPTION: lL,
  STORY_UNCHANGED: cL,
  TELEMETRY_ERROR: Zie,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: Qie,
  UNHANDLED_ERRORS_WHILE_PLAYING: Xq,
  UPDATE_GLOBALS: qE,
  UPDATE_QUERY_PARAMS: dL,
  UPDATE_STORY_ARGS: LE,
  default: Oie
}, Symbol.toStringTag, { value: "Module" }));
var ase = /* @__PURE__ */ c((e) => e.transports !== void 0, "isMulti"), ise = /* @__PURE__ */ c(() => Math.random().toString(16).slice(2), "generateRandomId"), fL = class {
  constructor(t = {}) {
    this.sender = ise(), this.events = {}, this.data = {}, this.transports = [], this.isAsync = t.async || !1, ase(t) ? (this.transports = t.transports || [], this.transports.forEach((r) => {
      r.setHandler((n) => this.handleEvent(n));
    })) : this.transports = t.transport ? [t.transport] : [], this.transports.forEach((r) => {
      r.setHandler((n) => this.handleEvent(n));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(t, r) {
    this.events[t] = this.events[t] || [], this.events[t].push(r);
  }
  emit(t, ...r) {
    const n = { type: t, args: r, from: this.sender };
    let o = {};
    r.length >= 1 && r[0] && r[0].options && (o = r[0].options);
    const a = /* @__PURE__ */ c(() => {
      this.transports.forEach((i) => {
        i.send(n, o);
      }), this.handleEvent(n);
    }, "handler");
    this.isAsync ? setImmediate(a) : a();
  }
  last(t) {
    return this.data[t];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(t) {
    const r = this.listeners(t);
    return r ? r.length : 0;
  }
  listeners(t) {
    return this.events[t] || void 0;
  }
  once(t, r) {
    const n = this.onceListener(t, r);
    this.addListener(t, n);
  }
  removeAllListeners(t) {
    t ? this.events[t] && delete this.events[t] : this.events = {};
  }
  removeListener(t, r) {
    const n = this.listeners(t);
    n && (this.events[t] = n.filter((o) => o !== r));
  }
  on(t, r) {
    this.addListener(t, r);
  }
  off(t, r) {
    this.removeListener(t, r);
  }
  handleEvent(t) {
    const r = this.listeners(t.type);
    r && r.length && r.forEach((n) => {
      n.apply(t, t.args);
    }), this.data[t.type] = t.args;
  }
  onceListener(t, r) {
    const n = /* @__PURE__ */ c((...o) => (this.removeListener(t, n), r(...o)), "onceListener");
    return n;
  }
};
c(fL, "Channel");
var hL = fL, sse = /* @__PURE__ */ c((e) => {
  const t = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [r, ...n] = t.filter((a) => {
    try {
      return a.contentWindow?.location.origin === e.source.location.origin && a.contentWindow?.location.pathname === e.source.location.pathname;
    } catch {
    }
    try {
      return a.contentWindow === e.source;
    } catch {
    }
    const i = a.getAttribute("src");
    let s;
    try {
      if (!i)
        return !1;
      ({ origin: s } = new URL(i, document.location.toString()));
    } catch {
      return !1;
    }
    return s === e.origin;
  }), o = r?.getAttribute("src");
  if (o && n.length === 0) {
    const { protocol: a, host: i, pathname: s } = new URL(o, document.location.toString());
    return `${a}//${i}${s}`;
  }
  return n.length > 0 && vt.error("found multiple candidates for event source"), null;
}, "getEventSourceUrl"), { document: Yb, location: Xb } = Ee, MP = "storybook-channel", lse = { maxDepth: 25 }, mL = class {
  constructor(t) {
    if (this.config = t, this.connected = !1, this.buffer = [], typeof Ee?.addEventListener == "function" && Ee.addEventListener("message", this.handleEvent.bind(this), !1), t.page !== "manager" && t.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${t.page}"`);
  }
  setHandler(t) {
    this.handler = (...r) => {
      t.apply(this, r), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = !0);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(t, r) {
    const {
      target: n,
      // telejson options
      allowRegExp: o,
      allowSymbol: a,
      allowDate: i,
      allowError: s,
      allowUndefined: d,
      maxDepth: l,
      space: p
    } = r || {}, f = Object.fromEntries(
      Object.entries({
        allowRegExp: o,
        allowSymbol: a,
        allowDate: i,
        allowError: s,
        allowUndefined: d,
        maxDepth: l,
        space: p
      }).filter(([_, b]) => typeof b < "u")
    ), h = {
      ...lse,
      ...Ee.CHANNEL_OPTIONS || {},
      ...f
    }, m = this.getFrames(n), g = new URLSearchParams(Xb?.search || ""), w = Vq(
      {
        key: MP,
        event: t,
        refId: g.get("refId")
      },
      h
    );
    return m.length ? (this.buffer.length && this.flush(), m.forEach((_) => {
      try {
        _.postMessage(w, "*");
      } catch {
        vt.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((_, b) => {
      this.buffer.push({ event: t, resolve: _, reject: b });
    });
  }
  flush() {
    const { buffer: t } = this;
    this.buffer = [], t.forEach((r) => {
      this.send(r.event).then(r.resolve).catch(r.reject);
    });
  }
  getFrames(t) {
    if (this.config.page === "manager") {
      const r = Array.from(
        Yb.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((n) => {
        try {
          return n.contentWindow && n.dataset.isStorybook !== void 0 && n.id === t ? [n.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return r?.length ? r : this.getCurrentFrames();
    }
    return Ee && Ee.parent && Ee.parent !== Ee.self ? [Ee.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      Yb.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((t) => t.contentWindow ? [t.contentWindow] : []) : Ee && Ee.parent ? [Ee.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      Yb.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((t) => t.contentWindow ? [t.contentWindow] : []) : Ee && Ee.parent ? [Ee.parent] : [];
  }
  handleEvent(t) {
    try {
      const { data: r } = t, { key: n, event: o, refId: a } = typeof r == "string" && OE(r) ? zq(r, Ee.CHANNEL_OPTIONS || {}) : r;
      if (n === MP) {
        const i = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', s = Object.values(ose).includes(o.type) ? `<span style="color: #FF4785">${o.type}</span>` : `<span style="color: #FFAE00">${o.type}</span>`;
        if (a && (o.refId = a), o.source = this.config.page === "preview" ? t.origin : sse(t), !o.source) {
          gn.error(
            `${i} received ${s} but was unable to determine the source of the event`
          );
          return;
        }
        const d = `${i} received ${s} (${r.length})`;
        gn.debug(
          Xb.origin !== o.source ? d : `${d} <span style="color: gray">(on ${Xb.origin} from ${o.source})</span>`,
          ...o.args
        ), lo(this.handler, "ChannelHandler should be set"), this.handler(o);
      }
    } catch (r) {
      vt.error(r);
    }
  }
};
c(mL, "PostMessageTransport");
var cse = mL, { WebSocket: use } = Ee, dse = 15e3, pse = 5e3, yL = class {
  constructor({ url: t, onError: r, page: n }) {
    this.buffer = [], this.isReady = !1, this.isClosed = !1, this.pingTimeout = 0, this.socket = new use(t), this.socket.onopen = () => {
      this.isReady = !0, this.heartbeat(), this.flush();
    }, this.socket.onmessage = ({ data: o }) => {
      const a = typeof o == "string" && OE(o) ? zq(o) : o;
      lo(this.handler), this.handler(a), a.type === "ping" && (this.heartbeat(), this.send({ type: "pong" }));
    }, this.socket.onerror = (o) => {
      r && r(o);
    }, this.socket.onclose = (o) => {
      lo(this.handler), this.handler({
        type: Wq,
        args: [{ reason: o.reason, code: o.code }],
        from: n || "preview"
      }), this.isClosed = !0, clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, dse + pse);
  }
  setHandler(t) {
    this.handler = t;
  }
  send(t) {
    this.isClosed || (this.isReady ? this.sendNow(t) : this.sendLater(t));
  }
  sendLater(t) {
    this.buffer.push(t);
  }
  sendNow(t) {
    const r = Vq(t, {
      maxDepth: 15,
      ...Ee.CHANNEL_OPTIONS
    });
    this.socket.send(r);
  }
  flush() {
    const { buffer: t } = this;
    this.buffer = [], t.forEach((r) => this.send(r));
  }
};
c(yL, "WebsocketTransport");
var fse = yL, { CONFIG_TYPE: hse } = Ee;
function mse({ page: e, extraTransports: t = [] }) {
  const r = [new cse({ page: e }), ...t];
  if (hse === "DEVELOPMENT") {
    const o = window.location.protocol === "http:" ? "ws" : "wss", { hostname: a, port: i } = window.location, s = `${o}://${a}:${i}/storybook-server-channel`;
    r.push(new fse({ url: s, onError: /* @__PURE__ */ c(() => {
    }, "onError"), page: e }));
  }
  const n = new hL({ transports: r });
  return Gb.__prepare(
    n,
    e === "manager" ? Gb.Environment.MANAGER : Gb.Environment.PREVIEW
  ), n;
}
c(mse, "createBrowserChannel");
var Uf = "backgrounds", yse = "measureEnabled", gL = "outline", gse = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
}, Vm = "storybook/highlight", bse = `${Vm}/add`, vse = `${Vm}/remove`, wse = `${Vm}/reset`, _se = `${Vm}/scroll-into-view`, DP = 2147483647, Ea = 28, Ese = "storybook/actions", xse = `${Ese}/action-event`, Sse = {
  depth: 10,
  clearOnStoryChange: !0,
  limit: 50
}, bL = /* @__PURE__ */ c((e, t) => {
  const r = Object.getPrototypeOf(e);
  return !r || t(r) ? r : bL(r, t);
}, "findProto"), Tse = /* @__PURE__ */ c((e) => !!(typeof e == "object" && e && bL(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) && typeof e.persist == "function"), "isReactSyntheticEvent"), Ase = /* @__PURE__ */ c((e) => {
  if (Tse(e)) {
    const t = Object.create(
      e.constructor.prototype,
      Object.getOwnPropertyDescriptors(e)
    );
    t.persist();
    const r = Object.getOwnPropertyDescriptor(t, "view"), n = r?.value;
    return typeof n == "object" && n?.constructor.name === "Window" && Object.defineProperty(t, "view", {
      ...r,
      value: Object.create(n.constructor.prototype)
    }), t;
  }
  return e;
}, "serializeArg");
function zm(e, t = {}) {
  const r = {
    ...Sse,
    ...t
  }, n = /* @__PURE__ */ c(function(...o) {
    if (t.implicit) {
      const f = ("__STORYBOOK_PREVIEW__" in Ee ? Ee.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (h) => h.phase === "playing" || h.phase === "rendering"
      );
      if (f) {
        const h = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, m = new vne({
          phase: f.phase,
          name: e,
          deprecated: h
        });
        if (h)
          console.warn(m);
        else
          throw m;
      }
    }
    const a = Fn.getChannel(), i = Date.now().toString(36) + Math.random().toString(36).substring(2), s = 5, d = o.map(Ase), l = o.length > 1 ? d : d[0], p = {
      id: i,
      count: 0,
      data: { name: e, args: l },
      options: {
        ...r,
        maxDepth: s + (r.depth || 3)
      }
    };
    a.emit(xse, p);
  }, "actionHandler");
  return n.isAction = !0, n.implicit = t.implicit, n;
}
c(zm, "action");
var $se = "viewport", vL = W({
  "../node_modules/picocolors/picocolors.browser.js"(e, t) {
    var r = String, n = /* @__PURE__ */ c(function() {
      return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
    }, "create");
    t.exports = n(), t.exports.createColors = n;
  }
}), Cse = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, wL = Object.entries(Cse);
function Zd(e) {
  return String(e);
}
c(Zd, "a");
Zd.open = "";
Zd.close = "";
wL.reduce(
  (e, [t]) => (e[t] = Zd, e),
  { isColorSupported: !1 }
);
function _L(e = !1) {
  let t = typeof process < "u" ? process : void 0, r = t?.env || {}, n = t?.argv || [];
  return !("NO_COLOR" in r || n.includes("--no-color")) && ("FORCE_COLOR" in r || n.includes("--color") || t?.platform === "win32" || e && r.TERM !== "dumb" || "CI" in r) || typeof window < "u" && !!window.chrome;
}
c(_L, "C");
function EL(e = !1) {
  let t = _L(e), r = /* @__PURE__ */ c((i, s, d, l) => {
    let p = "", f = 0;
    do
      p += i.substring(f, l) + d, f = l + s.length, l = i.indexOf(s, f);
    while (~l);
    return p + i.substring(f);
  }, "i"), n = /* @__PURE__ */ c((i, s, d = i) => {
    let l = /* @__PURE__ */ c((p) => {
      let f = String(p), h = f.indexOf(s, i.length);
      return ~h ? i + r(f, s, d, h) + s : i + f + s;
    }, "o");
    return l.open = i, l.close = s, l;
  }, "g"), o = {
    isColorSupported: t
  }, a = /* @__PURE__ */ c((i) => `\x1B[${i}m`, "d");
  for (let [i, s] of wL)
    o[i] = t ? n(
      a(s[0]),
      a(s[1]),
      s[2]
    ) : Zd;
  return o;
}
c(EL, "p");
var Pt = EL();
function FE(e, t) {
  return t.forEach(function(r) {
    r && typeof r != "string" && !Array.isArray(r) && Object.keys(r).forEach(function(n) {
      if (n !== "default" && !(n in e)) {
        var o = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(e, n, o.get ? o : {
          enumerable: !0,
          get: /* @__PURE__ */ c(function() {
            return r[n];
          }, "get")
        });
      }
    });
  }), Object.freeze(e);
}
c(FE, "_mergeNamespaces");
function xL(e, t) {
  const r = Object.keys(e), n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (const o of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, o).enumerable && n.push(o);
  return n;
}
c(xL, "getKeysOfEnumerableProperties");
function wc(e, t, r, n, o, a, i = ": ") {
  let s = "", d = 0, l = e.next();
  if (!l.done) {
    s += t.spacingOuter;
    const p = r + t.indent;
    for (; !l.done; ) {
      if (s += p, d++ === t.maxWidth) {
        s += "â€¦";
        break;
      }
      const f = a(l.value[0], t, p, n, o), h = a(l.value[1], t, p, n, o);
      s += f + i + h, l = e.next(), l.done ? t.min || (s += ",") : s += `,${t.spacingInner}`;
    }
    s += t.spacingOuter + r;
  }
  return s;
}
c(wc, "printIteratorEntries");
function Jm(e, t, r, n, o, a) {
  let i = "", s = 0, d = e.next();
  if (!d.done) {
    i += t.spacingOuter;
    const l = r + t.indent;
    for (; !d.done; ) {
      if (i += l, s++ === t.maxWidth) {
        i += "â€¦";
        break;
      }
      i += a(d.value, t, l, n, o), d = e.next(), d.done ? t.min || (i += ",") : i += `,${t.spacingInner}`;
    }
    i += t.spacingOuter + r;
  }
  return i;
}
c(Jm, "printIteratorValues");
function sd(e, t, r, n, o, a) {
  let i = "";
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  const s = /* @__PURE__ */ c((l) => l instanceof DataView, "isDataView"), d = s(e) ? e.byteLength : e.length;
  if (d > 0) {
    i += t.spacingOuter;
    const l = r + t.indent;
    for (let p = 0; p < d; p++) {
      if (i += l, p === t.maxWidth) {
        i += "â€¦";
        break;
      }
      (s(e) || p in e) && (i += a(s(e) ? e.getInt8(p) : e[p], t, l, n, o)), p < d - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + r;
  }
  return i;
}
c(sd, "printListItems");
function Wm(e, t, r, n, o, a) {
  let i = "";
  const s = xL(e, t.compareKeys);
  if (s.length > 0) {
    i += t.spacingOuter;
    const d = r + t.indent;
    for (let l = 0; l < s.length; l++) {
      const p = s[l], f = a(p, t, d, n, o), h = a(e[p], t, d, n, o);
      i += `${d + f}: ${h}`, l < s.length - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + r;
  }
  return i;
}
c(Wm, "printObjectProperties");
var kse = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, Qb = " ", Pse = /* @__PURE__ */ c((e, t, r, n, o, a) => {
  const i = e.toString();
  if (i === "ArrayContaining" || i === "ArrayNotContaining")
    return ++n > t.maxDepth ? `[${i}]` : `${i + Qb}[${sd(e.sample, t, r, n, o, a)}]`;
  if (i === "ObjectContaining" || i === "ObjectNotContaining")
    return ++n > t.maxDepth ? `[${i}]` : `${i + Qb}{${Wm(e.sample, t, r, n, o, a)}}`;
  if (i === "StringMatching" || i === "StringNotMatching" || i === "StringContaining" || i === "StringNotContaining")
    return i + Qb + a(e.sample, t, r, n, o);
  if (typeof e.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`);
  return e.toAsymmetricMatcher();
}, "serialize$5"), Ose = /* @__PURE__ */ c((e) => e && e.$$typeof === kse, "test$5"), Rse = {
  serialize: Pse,
  test: Ose
}, jse = " ", SL = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), Ise = /^(?:HTML\w*Collection|NodeList)$/;
function TL(e) {
  return SL.has(e) || Ise.test(e);
}
c(TL, "testName");
var Nse = /* @__PURE__ */ c((e) => e && e.constructor && !!e.constructor.name && TL(e.constructor.name), "test$4");
function AL(e) {
  return e.constructor.name === "NamedNodeMap";
}
c(AL, "isNamedNodeMap");
var Mse = /* @__PURE__ */ c((e, t, r, n, o, a) => {
  const i = e.constructor.name;
  return ++n > t.maxDepth ? `[${i}]` : (t.min ? "" : i + jse) + (SL.has(i) ? `{${Wm(AL(e) ? [...e].reduce((s, d) => (s[d.name] = d.value, s), {}) : { ...e }, t, r, n, o, a)}}` : `[${sd([...e], t, r, n, o, a)}]`);
}, "serialize$4"), Dse = {
  serialize: Mse,
  test: Nse
};
function UE(e) {
  return e.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
c(UE, "escapeHTML");
function Gm(e, t, r, n, o, a, i) {
  const s = n + r.indent, d = r.colors;
  return e.map((l) => {
    const p = t[l];
    let f = i(p, r, s, o, a);
    return typeof p != "string" && (f.includes(`
`) && (f = r.spacingOuter + s + f + r.spacingOuter + n), f = `{${f}}`), `${r.spacingInner + n + d.prop.open + l + d.prop.close}=${d.value.open}${f}${d.value.close}`;
  }).join("");
}
c(Gm, "printProps");
function Km(e, t, r, n, o, a) {
  return e.map((i) => t.spacingOuter + r + (typeof i == "string" ? BE(i, t) : a(i, t, r, n, o))).join("");
}
c(Km, "printChildren");
function BE(e, t) {
  const r = t.colors.content;
  return r.open + UE(e) + r.close;
}
c(BE, "printText");
function $L(e, t) {
  const r = t.colors.comment;
  return `${r.open}<!--${UE(e)}-->${r.close}`;
}
c($L, "printComment");
function Ym(e, t, r, n, o) {
  const a = n.colors.tag;
  return `${a.open}<${e}${t && a.close + t + n.spacingOuter + o + a.open}${r ? `>${a.close}${r}${n.spacingOuter}${o}${a.open}</${e}` : `${t && !n.min ? "" : " "}/`}>${a.close}`;
}
c(Ym, "printElement");
function Xm(e, t) {
  const r = t.colors.tag;
  return `${r.open}<${e}${r.close} â€¦${r.open} />${r.close}`;
}
c(Xm, "printElementAsLeaf");
var qse = 1, CL = 3, kL = 8, PL = 11, Lse = /^(?:(?:HTML|SVG)\w*)?Element$/;
function OL(e) {
  try {
    return typeof e.hasAttribute == "function" && e.hasAttribute("is");
  } catch {
    return !1;
  }
}
c(OL, "testHasAttribute");
function RL(e) {
  const t = e.constructor.name, { nodeType: r, tagName: n } = e, o = typeof n == "string" && n.includes("-") || OL(e);
  return r === qse && (Lse.test(t) || o) || r === CL && t === "Text" || r === kL && t === "Comment" || r === PL && t === "DocumentFragment";
}
c(RL, "testNode");
var Fse = /* @__PURE__ */ c((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && RL(e);
}, "test$3");
function jL(e) {
  return e.nodeType === CL;
}
c(jL, "nodeIsText");
function IL(e) {
  return e.nodeType === kL;
}
c(IL, "nodeIsComment");
function rf(e) {
  return e.nodeType === PL;
}
c(rf, "nodeIsFragment");
var Use = /* @__PURE__ */ c((e, t, r, n, o, a) => {
  if (jL(e))
    return BE(e.data, t);
  if (IL(e))
    return $L(e.data, t);
  const i = rf(e) ? "DocumentFragment" : e.tagName.toLowerCase();
  return ++n > t.maxDepth ? Xm(i, t) : Ym(i, Gm(rf(e) ? [] : Array.from(e.attributes, (s) => s.name).sort(), rf(e) ? {} : [...e.attributes].reduce((s, d) => (s[d.name] = d.value, s), {}), t, r + t.indent, n, o, a), Km(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, o, a), t, r);
}, "serialize$3"), Bse = {
  serialize: Use,
  test: Fse
}, Hse = "@@__IMMUTABLE_ITERABLE__@@", Vse = "@@__IMMUTABLE_LIST__@@", zse = "@@__IMMUTABLE_KEYED__@@", Jse = "@@__IMMUTABLE_MAP__@@", qP = "@@__IMMUTABLE_ORDERED__@@", Wse = "@@__IMMUTABLE_RECORD__@@", Gse = "@@__IMMUTABLE_SEQ__@@", Kse = "@@__IMMUTABLE_SET__@@", Yse = "@@__IMMUTABLE_STACK__@@", jl = /* @__PURE__ */ c((e) => `Immutable.${e}`, "getImmutableName"), Qm = /* @__PURE__ */ c((e) => `[${e}]`, "printAsLeaf"), ld = " ", LP = "â€¦";
function NL(e, t, r, n, o, a, i) {
  return ++n > t.maxDepth ? Qm(jl(i)) : `${jl(i) + ld}{${wc(e.entries(), t, r, n, o, a)}}`;
}
c(NL, "printImmutableEntries");
function ML(e) {
  let t = 0;
  return { next() {
    if (t < e._keys.length) {
      const r = e._keys[t++];
      return {
        done: !1,
        value: [r, e.get(r)]
      };
    }
    return {
      done: !0,
      value: void 0
    };
  } };
}
c(ML, "getRecordEntries");
function DL(e, t, r, n, o, a) {
  const i = jl(e._name || "Record");
  return ++n > t.maxDepth ? Qm(i) : `${i + ld}{${wc(ML(e), t, r, n, o, a)}}`;
}
c(DL, "printImmutableRecord");
function qL(e, t, r, n, o, a) {
  const i = jl("Seq");
  return ++n > t.maxDepth ? Qm(i) : e[zse] ? `${i + ld}{${e._iter || e._object ? wc(e.entries(), t, r, n, o, a) : LP}}` : `${i + ld}[${e._iter || e._array || e._collection || e._iterable ? Jm(e.values(), t, r, n, o, a) : LP}]`;
}
c(qL, "printImmutableSeq");
function nf(e, t, r, n, o, a, i) {
  return ++n > t.maxDepth ? Qm(jl(i)) : `${jl(i) + ld}[${Jm(e.values(), t, r, n, o, a)}]`;
}
c(nf, "printImmutableValues");
var Xse = /* @__PURE__ */ c((e, t, r, n, o, a) => e[Jse] ? NL(e, t, r, n, o, a, e[qP] ? "OrderedMap" : "Map") : e[Vse] ? nf(e, t, r, n, o, a, "List") : e[Kse] ? nf(e, t, r, n, o, a, e[qP] ? "OrderedSet" : "Set") : e[Yse] ? nf(e, t, r, n, o, a, "Stack") : e[Gse] ? qL(e, t, r, n, o, a) : DL(e, t, r, n, o, a), "serialize$2"), Qse = /* @__PURE__ */ c((e) => e && (e[Hse] === !0 || e[Wse] === !0), "test$2"), Zse = {
  serialize: Xse,
  test: Qse
};
function HE(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
c(HE, "getDefaultExportFromCjs");
var FP = { exports: {} }, ct = {}, UP;
function LL() {
  if (UP) return ct;
  UP = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), i = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.view_transition"), m = Symbol.for("react.client.reference");
  function g(w) {
    if (typeof w == "object" && w !== null) {
      var _ = w.$$typeof;
      switch (_) {
        case e:
          switch (w = w.type, w) {
            case r:
            case o:
            case n:
            case d:
            case l:
            case h:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case i:
                case s:
                case f:
                case p:
                  return w;
                case a:
                  return w;
                default:
                  return _;
              }
          }
        case t:
          return _;
      }
    }
  }
  return c(g, "typeOf"), ct.ContextConsumer = a, ct.ContextProvider = i, ct.Element = e, ct.ForwardRef = s, ct.Fragment = r, ct.Lazy = f, ct.Memo = p, ct.Portal = t, ct.Profiler = o, ct.StrictMode = n, ct.Suspense = d, ct.SuspenseList = l, ct.isContextConsumer = function(w) {
    return g(w) === a;
  }, ct.isContextProvider = function(w) {
    return g(w) === i;
  }, ct.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === e;
  }, ct.isForwardRef = function(w) {
    return g(w) === s;
  }, ct.isFragment = function(w) {
    return g(w) === r;
  }, ct.isLazy = function(w) {
    return g(w) === f;
  }, ct.isMemo = function(w) {
    return g(w) === p;
  }, ct.isPortal = function(w) {
    return g(w) === t;
  }, ct.isProfiler = function(w) {
    return g(w) === o;
  }, ct.isStrictMode = function(w) {
    return g(w) === n;
  }, ct.isSuspense = function(w) {
    return g(w) === d;
  }, ct.isSuspenseList = function(w) {
    return g(w) === l;
  }, ct.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === o || w === n || w === d || w === l || typeof w == "object" && w !== null && (w.$$typeof === f || w.$$typeof === p || w.$$typeof === i || w.$$typeof === a || w.$$typeof === s || w.$$typeof === m || w.getModuleId !== void 0);
  }, ct.typeOf = g, ct;
}
c(LL, "requireReactIs_production");
var ele = {};
function tle() {
  return ele;
}
c(tle, "requireReactIs_development$1");
var BP;
function FL() {
  return BP || (BP = 1, FP.exports = LL()), FP.exports;
}
c(FL, "requireReactIs$1");
var UL = FL(), rle = HE(UL), nle = FE({
  __proto__: null,
  default: rle
}, [UL]), HP = { exports: {} }, ot = {}, VP;
function BL() {
  if (VP) return ot;
  VP = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), s = Symbol.for("react.server_context"), d = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), g;
  g = Symbol.for("react.module.reference");
  function w(_) {
    if (typeof _ == "object" && _ !== null) {
      var b = _.$$typeof;
      switch (b) {
        case e:
          switch (_ = _.type, _) {
            case r:
            case o:
            case n:
            case l:
            case p:
              return _;
            default:
              switch (_ = _ && _.$$typeof, _) {
                case s:
                case i:
                case d:
                case h:
                case f:
                case a:
                  return _;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return c(w, "v"), ot.ContextConsumer = i, ot.ContextProvider = a, ot.Element = e, ot.ForwardRef = d, ot.Fragment = r, ot.Lazy = h, ot.Memo = f, ot.Portal = t, ot.Profiler = o, ot.StrictMode = n, ot.Suspense = l, ot.SuspenseList = p, ot.isAsyncMode = function() {
    return !1;
  }, ot.isConcurrentMode = function() {
    return !1;
  }, ot.isContextConsumer = function(_) {
    return w(_) === i;
  }, ot.isContextProvider = function(_) {
    return w(_) === a;
  }, ot.isElement = function(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === e;
  }, ot.isForwardRef = function(_) {
    return w(_) === d;
  }, ot.isFragment = function(_) {
    return w(_) === r;
  }, ot.isLazy = function(_) {
    return w(_) === h;
  }, ot.isMemo = function(_) {
    return w(_) === f;
  }, ot.isPortal = function(_) {
    return w(_) === t;
  }, ot.isProfiler = function(_) {
    return w(_) === o;
  }, ot.isStrictMode = function(_) {
    return w(_) === n;
  }, ot.isSuspense = function(_) {
    return w(_) === l;
  }, ot.isSuspenseList = function(_) {
    return w(_) === p;
  }, ot.isValidElementType = function(_) {
    return typeof _ == "string" || typeof _ == "function" || _ === r || _ === o || _ === n || _ === l || _ === p || _ === m || typeof _ == "object" && _ !== null && (_.$$typeof === h || _.$$typeof === f || _.$$typeof === a || _.$$typeof === i || _.$$typeof === d || _.$$typeof === g || _.getModuleId !== void 0);
  }, ot.typeOf = w, ot;
}
c(BL, "requireReactIs_production_min");
var ole = {};
function ale() {
  return ole;
}
c(ale, "requireReactIs_development");
var zP;
function HL() {
  return zP || (zP = 1, HP.exports = BL()), HP.exports;
}
c(HL, "requireReactIs");
var VL = HL(), ile = HE(VL), sle = FE({
  __proto__: null,
  default: ile
}, [VL]), lle = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], Oi = Object.fromEntries(lle.map((e) => [e, (t) => sle[e](t) || nle[e](t)]));
function VE(e, t = []) {
  if (Array.isArray(e))
    for (const r of e)
      VE(r, t);
  else e != null && e !== !1 && e !== "" && t.push(e);
  return t;
}
c(VE, "getChildren");
function ow(e) {
  const t = e.type;
  if (typeof t == "string")
    return t;
  if (typeof t == "function")
    return t.displayName || t.name || "Unknown";
  if (Oi.isFragment(e))
    return "React.Fragment";
  if (Oi.isSuspense(e))
    return "React.Suspense";
  if (typeof t == "object" && t !== null) {
    if (Oi.isContextProvider(e))
      return "Context.Provider";
    if (Oi.isContextConsumer(e))
      return "Context.Consumer";
    if (Oi.isForwardRef(e)) {
      if (t.displayName)
        return t.displayName;
      const r = t.render.displayName || t.render.name || "";
      return r === "" ? "ForwardRef" : `ForwardRef(${r})`;
    }
    if (Oi.isMemo(e)) {
      const r = t.displayName || t.type.displayName || t.type.name || "";
      return r === "" ? "Memo" : `Memo(${r})`;
    }
  }
  return "UNDEFINED";
}
c(ow, "getType");
function zL(e) {
  const { props: t } = e;
  return Object.keys(t).filter((r) => r !== "children" && t[r] !== void 0).sort();
}
c(zL, "getPropKeys$1");
var cle = /* @__PURE__ */ c((e, t, r, n, o, a) => ++n > t.maxDepth ? Xm(ow(e), t) : Ym(ow(e), Gm(zL(e), e.props, t, r + t.indent, n, o, a), Km(VE(e.props.children), t, r + t.indent, n, o, a), t, r), "serialize$1"), ule = /* @__PURE__ */ c((e) => e != null && Oi.isElement(e), "test$1"), dle = {
  serialize: cle,
  test: ule
}, ple = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function JL(e) {
  const { props: t } = e;
  return t ? Object.keys(t).filter((r) => t[r] !== void 0).sort() : [];
}
c(JL, "getPropKeys");
var fle = /* @__PURE__ */ c((e, t, r, n, o, a) => ++n > t.maxDepth ? Xm(e.type, t) : Ym(e.type, e.props ? Gm(JL(e), e.props, t, r + t.indent, n, o, a) : "", e.children ? Km(e.children, t, r + t.indent, n, o, a) : "", t, r), "serialize"), hle = /* @__PURE__ */ c((e) => e && e.$$typeof === ple, "test"), mle = {
  serialize: fle,
  test: hle
}, WL = Object.prototype.toString, yle = Date.prototype.toISOString, gle = Error.prototype.toString, JP = RegExp.prototype.toString;
function Ou(e) {
  return typeof e.constructor == "function" && e.constructor.name || "Object";
}
c(Ou, "getConstructorName");
function GL(e) {
  return typeof window < "u" && e === window;
}
c(GL, "isWindow");
var ble = /^Symbol\((.*)\)(.*)$/, vle = /\n/g, KL = class extends Error {
  constructor(t, r) {
    super(t), this.stack = r, this.name = this.constructor.name;
  }
};
c(KL, "PrettyFormatPluginError");
var YL = KL;
function XL(e) {
  return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
}
c(XL, "isToStringedArrayType");
function QL(e) {
  return Object.is(e, -0) ? "-0" : String(e);
}
c(QL, "printNumber");
function ZL(e) {
  return `${e}n`;
}
c(ZL, "printBigInt");
function aw(e, t) {
  return t ? `[Function ${e.name || "anonymous"}]` : "[Function]";
}
c(aw, "printFunction");
function iw(e) {
  return String(e).replace(ble, "Symbol($1)");
}
c(iw, "printSymbol");
function sw(e) {
  return `[${gle.call(e)}]`;
}
c(sw, "printError");
function zE(e, t, r, n) {
  if (e === !0 || e === !1)
    return `${e}`;
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const o = typeof e;
  if (o === "number")
    return QL(e);
  if (o === "bigint")
    return ZL(e);
  if (o === "string")
    return n ? `"${e.replaceAll(/"|\\/g, "\\$&")}"` : `"${e}"`;
  if (o === "function")
    return aw(e, t);
  if (o === "symbol")
    return iw(e);
  const a = WL.call(e);
  return a === "[object WeakMap]" ? "WeakMap {}" : a === "[object WeakSet]" ? "WeakSet {}" : a === "[object Function]" || a === "[object GeneratorFunction]" ? aw(e, t) : a === "[object Symbol]" ? iw(e) : a === "[object Date]" ? Number.isNaN(+e) ? "Date { NaN }" : yle.call(e) : a === "[object Error]" ? sw(e) : a === "[object RegExp]" ? r ? JP.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : JP.call(e) : e instanceof Error ? sw(e) : null;
}
c(zE, "printBasicValue");
function JE(e, t, r, n, o, a) {
  if (o.includes(e))
    return "[Circular]";
  o = [...o], o.push(e);
  const i = ++n > t.maxDepth, s = t.min;
  if (t.callToJSON && !i && e.toJSON && typeof e.toJSON == "function" && !a)
    return Vo(e.toJSON(), t, r, n, o, !0);
  const d = WL.call(e);
  return d === "[object Arguments]" ? i ? "[Arguments]" : `${s ? "" : "Arguments "}[${sd(e, t, r, n, o, Vo)}]` : XL(d) ? i ? `[${e.constructor.name}]` : `${s || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : `${e.constructor.name} `}[${sd(e, t, r, n, o, Vo)}]` : d === "[object Map]" ? i ? "[Map]" : `Map {${wc(e.entries(), t, r, n, o, Vo, " => ")}}` : d === "[object Set]" ? i ? "[Set]" : `Set {${Jm(e.values(), t, r, n, o, Vo)}}` : i || GL(e) ? `[${Ou(e)}]` : `${s || !t.printBasicPrototype && Ou(e) === "Object" ? "" : `${Ou(e)} `}{${Wm(e, t, r, n, o, Vo)}}`;
}
c(JE, "printComplexValue");
var wle = {
  test: /* @__PURE__ */ c((e) => e && e instanceof Error, "test"),
  serialize(e, t, r, n, o, a) {
    if (o.includes(e))
      return "[Circular]";
    o = [...o, e];
    const i = ++n > t.maxDepth, { message: s, cause: d, ...l } = e, p = {
      message: s,
      ...typeof d < "u" ? { cause: d } : {},
      ...e instanceof AggregateError ? { errors: e.errors } : {},
      ...l
    }, f = e.name !== "Error" ? e.name : Ou(e);
    return i ? `[${f}]` : `${f} {${wc(Object.entries(p).values(), t, r, n, o, a)}}`;
  }
};
function e2(e) {
  return e.serialize != null;
}
c(e2, "isNewPlugin");
function WE(e, t, r, n, o, a) {
  let i;
  try {
    i = e2(e) ? e.serialize(t, r, n, o, a, Vo) : e.print(t, (s) => Vo(s, r, n, o, a), (s) => {
      const d = n + r.indent;
      return d + s.replaceAll(vle, `
${d}`);
    }, {
      edgeSpacing: r.spacingOuter,
      min: r.min,
      spacing: r.spacingInner
    }, r.colors);
  } catch (s) {
    throw new YL(s.message, s.stack);
  }
  if (typeof i != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof i}".`);
  return i;
}
c(WE, "printPlugin");
function GE(e, t) {
  for (const r of e)
    try {
      if (r.test(t))
        return r;
    } catch (n) {
      throw new YL(n.message, n.stack);
    }
  return null;
}
c(GE, "findPlugin");
function Vo(e, t, r, n, o, a) {
  const i = GE(t.plugins, e);
  if (i !== null)
    return WE(i, e, t, r, n, o);
  const s = zE(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return s !== null ? s : JE(e, t, r, n, o, a);
}
c(Vo, "printer");
var KE = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, t2 = Object.keys(KE), jn = {
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: KE
};
function r2(e) {
  for (const t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(jn, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
c(r2, "validateOptions");
function n2() {
  return t2.reduce((e, t) => {
    const r = KE[t], n = r && Pt[r];
    if (n && typeof n.close == "string" && typeof n.open == "string")
      e[t] = n;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`);
    return e;
  }, /* @__PURE__ */ Object.create(null));
}
c(n2, "getColorsHighlight");
function o2() {
  return t2.reduce((e, t) => (e[t] = {
    close: "",
    open: ""
  }, e), /* @__PURE__ */ Object.create(null));
}
c(o2, "getColorsEmpty");
function YE(e) {
  return e?.printFunctionName ?? jn.printFunctionName;
}
c(YE, "getPrintFunctionName");
function XE(e) {
  return e?.escapeRegex ?? jn.escapeRegex;
}
c(XE, "getEscapeRegex");
function QE(e) {
  return e?.escapeString ?? jn.escapeString;
}
c(QE, "getEscapeString");
function lw(e) {
  return {
    callToJSON: e?.callToJSON ?? jn.callToJSON,
    colors: e?.highlight ? n2() : o2(),
    compareKeys: typeof e?.compareKeys == "function" || e?.compareKeys === null ? e.compareKeys : jn.compareKeys,
    escapeRegex: XE(e),
    escapeString: QE(e),
    indent: e?.min ? "" : a2(e?.indent ?? jn.indent),
    maxDepth: e?.maxDepth ?? jn.maxDepth,
    maxWidth: e?.maxWidth ?? jn.maxWidth,
    min: e?.min ?? jn.min,
    plugins: e?.plugins ?? jn.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? !0,
    printFunctionName: YE(e),
    spacingInner: e?.min ? " " : `
`,
    spacingOuter: e?.min ? "" : `
`
  };
}
c(lw, "getConfig");
function a2(e) {
  return Array.from({ length: e + 1 }).join(" ");
}
c(a2, "createIndent");
function Dn(e, t) {
  if (t && (r2(t), t.plugins)) {
    const n = GE(t.plugins, e);
    if (n !== null)
      return WE(n, e, lw(t), "", 0, []);
  }
  const r = zE(e, YE(t), XE(t), QE(t));
  return r !== null ? r : JE(e, lw(t), "", 0, []);
}
c(Dn, "format");
var ZE = {
  AsymmetricMatcher: Rse,
  DOMCollection: Dse,
  DOMElement: Bse,
  Immutable: Zse,
  ReactElement: dle,
  ReactTestComponent: mle,
  Error: wle
}, WP = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, _le = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, Il = "â€¦";
function i2(e, t) {
  const r = WP[_le[t]] || WP[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
c(i2, "colorise");
function s2({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: n = !0,
  showProxy: o = !1,
  maxArrayLength: a = 1 / 0,
  breakLength: i = 1 / 0,
  seen: s = [],
  // eslint-disable-next-line no-shadow
  truncate: d = 1 / 0,
  stylize: l = String
} = {}, p) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(a),
    breakLength: Number(i),
    truncate: Number(d),
    seen: s,
    inspect: p,
    stylize: l
  };
  return f.colors && (f.stylize = i2), f;
}
c(s2, "normaliseOptions");
function l2(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
c(l2, "isHighSurrogate");
function sa(e, t, r = Il) {
  e = String(e);
  const n = r.length, o = e.length;
  if (n > t && o > n)
    return r;
  if (o > t && o > n) {
    let a = t - n;
    return a > 0 && l2(e[a - 1]) && (a = a - 1), `${e.slice(0, a)}${r}`;
  }
  return e;
}
c(sa, "truncate");
function bn(e, t, r, n = ", ") {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0)
    return "";
  const a = t.truncate;
  let i = "", s = "", d = "";
  for (let l = 0; l < o; l += 1) {
    const p = l + 1 === e.length, f = l + 2 === e.length;
    d = `${Il}(${e.length - l})`;
    const h = e[l];
    t.truncate = a - i.length - (p ? 0 : n.length);
    const m = s || r(h, t) + (p ? "" : n), g = i.length + m.length, w = g + d.length;
    if (p && g > a && i.length + d.length <= a || !p && !f && w > a || (s = p ? "" : r(e[l + 1], t) + (f ? "" : n), !p && f && w > a && g + s.length > a))
      break;
    if (i += m, !p && !f && g + s.length >= a) {
      d = `${Il}(${e.length - l - 1})`;
      break;
    }
    d = "";
  }
  return `${i}${d}`;
}
c(bn, "inspectList");
function c2(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
c(c2, "quoteComplexKey");
function Nl([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = c2(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
c(Nl, "inspectProperty");
function u2(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const n = bn(e, t);
  t.truncate -= n.length;
  let o = "";
  return r.length && (o = bn(r.map((a) => [a, e[a]]), t, Nl)), `[ ${n}${o ? `, ${o}` : ""} ]`;
}
c(u2, "inspectArray");
var Ele = /* @__PURE__ */ c((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function Kn(e, t) {
  const r = Ele(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let o = "";
  for (let i = 0; i < e.length; i++) {
    const s = `${t.stylize(sa(e[i], t.truncate), "number")}${i === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= s.length, e[i] !== e.length && t.truncate <= 3) {
      o += `${Il}(${e.length - e[i] + 1})`;
      break;
    }
    o += s;
  }
  let a = "";
  return n.length && (a = bn(n.map((i) => [i, e[i]]), t, Nl)), `${r}[ ${o}${a ? `, ${a}` : ""} ]`;
}
c(Kn, "inspectTypedArray");
function d2(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const n = r.split("T"), o = n[0];
  return t.stylize(`${o}T${sa(n[1], t.truncate - o.length - 1)}`, "date");
}
c(d2, "inspectDate");
function cw(e, t) {
  const r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${sa(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
c(cw, "inspectFunction");
function p2([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
c(p2, "inspectMapEntry");
function f2(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
c(f2, "mapToEntries");
function h2(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${bn(f2(e), t, p2)} }`);
}
c(h2, "inspectMap");
var xle = Number.isNaN || ((e) => e !== e);
function uw(e, t) {
  return xle(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(sa(String(e), t.truncate), "number");
}
c(uw, "inspectNumber");
function dw(e, t) {
  let r = sa(e.toString(), t.truncate - 1);
  return r !== Il && (r += "n"), t.stylize(r, "bigint");
}
c(dw, "inspectBigInt");
function m2(e, t) {
  const r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), o = e.source;
  return t.stylize(`/${sa(o, n)}/${r}`, "regexp");
}
c(m2, "inspectRegExp");
function y2(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
c(y2, "arrayFromSet");
function g2(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${bn(y2(e), t)} }`);
}
c(g2, "inspectSet");
var GP = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), Sle = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, Tle = 16;
function b2(e) {
  return Sle[e] || `\\u${`0000${e.charCodeAt(0).toString(Tle)}`.slice(-4)}`;
}
c(b2, "escape");
function pw(e, t) {
  return GP.test(e) && (e = e.replace(GP, b2)), t.stylize(`'${sa(e, t.truncate - 2)}'`, "string");
}
c(pw, "inspectString");
function fw(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
c(fw, "inspectSymbol");
var Ale = /* @__PURE__ */ c(() => "Promise{â€¦}", "getPromiseValue"), $le = Ale;
function Ru(e, t) {
  const r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const o = bn(r.map((s) => [s, e[s]]), t, Nl), a = bn(n.map((s) => [s, e[s]]), t, Nl);
  t.seen.pop();
  let i = "";
  return o && a && (i = ", "), `{ ${o}${i}${a} }`;
}
c(Ru, "inspectObject");
var Zb = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function v2(e, t) {
  let r = "";
  return Zb && Zb in e && (r = e[Zb]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${Ru(e, t)}`;
}
c(v2, "inspectClass");
function w2(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${bn(e, t)} ]`);
}
c(w2, "inspectArguments");
var Cle = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function _2(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((i) => Cle.indexOf(i) === -1), n = e.name;
  t.truncate -= n.length;
  let o = "";
  if (typeof e.message == "string" ? o = sa(e.message, t.truncate) : r.unshift("message"), o = o ? `: ${o}` : "", t.truncate -= o.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = bn(r.map((i) => [i, e[i]]), t, Nl);
  return `${n}${o}${a ? ` { ${a} }` : ""}`;
}
c(_2, "inspectObject");
function E2([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
c(E2, "inspectAttribute");
function Bf(e, t) {
  return bn(e, t, x2, `
`);
}
c(Bf, "inspectNodeCollection");
function x2(e, t) {
  switch (e.nodeType) {
    case 1:
      return ex(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
c(x2, "inspectNode");
function ex(e, t) {
  const r = e.getAttributeNames(), n = e.tagName.toLowerCase(), o = t.stylize(`<${n}`, "special"), a = t.stylize(">", "special"), i = t.stylize(`</${n}>`, "special");
  t.truncate -= n.length * 2 + 5;
  let s = "";
  r.length > 0 && (s += " ", s += bn(r.map((p) => [p, e.getAttribute(p)]), t, E2, " ")), t.truncate -= s.length;
  const d = t.truncate;
  let l = Bf(e.children, t);
  return l && l.length > d && (l = `${Il}(${e.children.length})`), `${o}${s}${a}${l}${i}`;
}
c(ex, "inspectHTML");
var kle = typeof Symbol == "function" && typeof Symbol.for == "function", ev = kle ? Symbol.for("chai/inspect") : "@@chai/inspect", tv = Symbol.for("nodejs.util.inspect.custom"), KP = /* @__PURE__ */ new WeakMap(), YP = {}, XP = {
  undefined: /* @__PURE__ */ c((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ c((e, t) => t.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ c((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ c((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: uw,
  Number: uw,
  bigint: dw,
  BigInt: dw,
  string: pw,
  String: pw,
  function: cw,
  Function: cw,
  symbol: fw,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: fw,
  Array: u2,
  Date: d2,
  Map: h2,
  Set: g2,
  RegExp: m2,
  Promise: $le,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ c((e, t) => t.stylize("WeakSet{â€¦}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ c((e, t) => t.stylize("WeakMap{â€¦}", "special"), "WeakMap"),
  Arguments: w2,
  Int8Array: Kn,
  Uint8Array: Kn,
  Uint8ClampedArray: Kn,
  Int16Array: Kn,
  Uint16Array: Kn,
  Int32Array: Kn,
  Uint32Array: Kn,
  Float32Array: Kn,
  Float64Array: Kn,
  Generator: /* @__PURE__ */ c(() => "", "Generator"),
  DataView: /* @__PURE__ */ c(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ c(() => "", "ArrayBuffer"),
  Error: _2,
  HTMLCollection: Bf,
  NodeList: Bf
}, Ple = /* @__PURE__ */ c((e, t, r, n) => ev in e && typeof e[ev] == "function" ? e[ev](t) : tv in e && typeof e[tv] == "function" ? e[tv](t.depth, t, n) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && KP.has(e.constructor) ? KP.get(e.constructor)(e, t) : YP[r] ? YP[r](e, t) : "", "inspectCustom"), Ole = Object.prototype.toString;
function ju(e, t = {}) {
  const r = s2(t, ju), { customInspect: n } = r;
  let o = e === null ? "null" : typeof e;
  if (o === "object" && (o = Ole.call(e).slice(8, -1)), o in XP)
    return XP[o](e, r);
  if (n && e) {
    const i = Ple(e, r, o, ju);
    if (i)
      return typeof i == "string" ? i : ju(i, r);
  }
  const a = e ? Object.getPrototypeOf(e) : !1;
  return a === Object.prototype || a === null ? Ru(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? ex(e, r) : "constructor" in e ? e.constructor !== Object ? v2(e, r) : Ru(e, r) : e === Object(e) ? Ru(e, r) : r.stylize(String(e), o);
}
c(ju, "inspect");
var { AsymmetricMatcher: Rle, DOMCollection: jle, DOMElement: Ile, Immutable: Nle, ReactElement: Mle, ReactTestComponent: Dle } = ZE, QP = [
  Dle,
  Mle,
  Ile,
  jle,
  Nle,
  Rle
];
function Pr(e, t = 10, { maxLength: r, ...n } = {}) {
  const o = r ?? 1e4;
  let a;
  try {
    a = Dn(e, {
      maxDepth: t,
      escapeString: !1,
      plugins: QP,
      ...n
    });
  } catch {
    a = Dn(e, {
      callToJSON: !1,
      maxDepth: t,
      escapeString: !1,
      plugins: QP,
      ...n
    });
  }
  return a.length >= o && t > 1 ? Pr(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength: r,
    ...n
  }) : a;
}
c(Pr, "stringify");
var qle = /%[sdjifoOc%]/g;
function S2(...e) {
  if (typeof e[0] != "string") {
    const a = [];
    for (let i = 0; i < e.length; i++)
      a.push(Gs(e[i], {
        depth: 0,
        colors: !1
      }));
    return a.join(" ");
  }
  const t = e.length;
  let r = 1;
  const n = e[0];
  let o = String(n).replace(qle, (a) => {
    if (a === "%%")
      return "%";
    if (r >= t)
      return a;
    switch (a) {
      case "%s": {
        const i = e[r++];
        return typeof i == "bigint" ? `${i.toString()}n` : typeof i == "number" && i === 0 && 1 / i < 0 ? "-0" : typeof i == "object" && i !== null ? typeof i.toString == "function" && i.toString !== Object.prototype.toString ? i.toString() : Gs(i, {
          depth: 0,
          colors: !1
        }) : String(i);
      }
      case "%d": {
        const i = e[r++];
        return typeof i == "bigint" ? `${i.toString()}n` : Number(i).toString();
      }
      case "%i": {
        const i = e[r++];
        return typeof i == "bigint" ? `${i.toString()}n` : Number.parseInt(String(i)).toString();
      }
      case "%f":
        return Number.parseFloat(String(e[r++])).toString();
      case "%o":
        return Gs(e[r++], {
          showHidden: !0,
          showProxy: !0
        });
      case "%O":
        return Gs(e[r++]);
      case "%c":
        return r++, "";
      case "%j":
        try {
          return JSON.stringify(e[r++]);
        } catch (i) {
          const s = i.message;
          if (s.includes("circular structure") || s.includes("cyclic structures") || s.includes("cyclic object"))
            return "[Circular]";
          throw i;
        }
      default:
        return a;
    }
  });
  for (let a = e[r]; r < t; a = e[++r])
    a === null || typeof a != "object" ? o += ` ${a}` : o += ` ${Gs(a)}`;
  return o;
}
c(S2, "format");
function Gs(e, t = {}) {
  return t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), ju(e, t);
}
c(Gs, "inspect");
function tx(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
c(tx, "getDefaultExportFromCjs");
function Yn(e, t, r) {
  const n = typeof e;
  if (!r.includes(n))
    throw new TypeError(`${t} value must be ${r.join(" or ")}, received "${n}"`);
}
c(Yn, "assertTypes");
function Iu(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
c(Iu, "isObject");
function T2(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
c(T2, "isFinalObj");
function cd(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
c(cd, "getType");
function A2(e, t) {
  const r = typeof t == "function" ? t : (n) => t.add(n);
  Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r);
}
c(A2, "collectOwnProperties");
function rx(e) {
  const t = /* @__PURE__ */ new Set();
  return T2(e) ? [] : (A2(e, t), Array.from(t));
}
c(rx, "getOwnProperties");
var $2 = { forceWritable: !1 };
function hw(e, t = $2) {
  return Hf(e, /* @__PURE__ */ new WeakMap(), t);
}
c(hw, "deepClone");
function Hf(e, t, r = $2) {
  let n, o;
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    for (o = Array.from({ length: n = e.length }), t.set(e, o); n--; )
      o[n] = Hf(e[n], t, r);
    return o;
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
    o = Object.create(Object.getPrototypeOf(e)), t.set(e, o);
    const a = rx(e);
    for (const i of a) {
      const s = Object.getOwnPropertyDescriptor(e, i);
      if (!s)
        continue;
      const d = Hf(e[i], t, r);
      r.forceWritable ? Object.defineProperty(o, i, {
        enumerable: s.enumerable,
        configurable: !0,
        writable: !0,
        value: d
      }) : "get" in s ? Object.defineProperty(o, i, {
        ...s,
        get() {
          return d;
        }
      }) : Object.defineProperty(o, i, {
        ...s,
        value: d
      });
    }
    return o;
  }
  return e;
}
c(Hf, "clone");
function C2() {
}
c(C2, "noop");
var _r = -1, cr = 1, Ct = 0, k2 = class {
  0;
  1;
  constructor(t, r) {
    this[0] = t, this[1] = r;
  }
};
c(k2, "Diff");
var At = k2;
function P2(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), o = n, a = 0;
  for (; r < o; )
    e.substring(a, o) === t.substring(a, o) ? (r = o, a = r) : n = o, o = Math.floor((n - r) / 2 + r);
  return o;
}
c(P2, "diff_commonPrefix");
function nx(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), o = n, a = 0;
  for (; r < o; )
    e.substring(e.length - o, e.length - a) === t.substring(t.length - o, t.length - a) ? (r = o, a = r) : n = o, o = Math.floor((n - r) / 2 + r);
  return o;
}
c(nx, "diff_commonSuffix");
function mw(e, t) {
  const r = e.length, n = t.length;
  if (r === 0 || n === 0)
    return 0;
  r > n ? e = e.substring(r - n) : r < n && (t = t.substring(0, r));
  const o = Math.min(r, n);
  if (e === t)
    return o;
  let a = 0, i = 1;
  for (; ; ) {
    const s = e.substring(o - i), d = t.indexOf(s);
    if (d === -1)
      return a;
    i += d, (d === 0 || e.substring(o - i) === t.substring(0, i)) && (a = i, i++);
  }
}
c(mw, "diff_commonOverlap_");
function O2(e) {
  let t = !1;
  const r = [];
  let n = 0, o = null, a = 0, i = 0, s = 0, d = 0, l = 0;
  for (; a < e.length; )
    e[a][0] === Ct ? (r[n++] = a, i = d, s = l, d = 0, l = 0, o = e[a][1]) : (e[a][0] === cr ? d += e[a][1].length : l += e[a][1].length, o && o.length <= Math.max(i, s) && o.length <= Math.max(d, l) && (e.splice(r[n - 1], 0, new At(_r, o)), e[r[n - 1] + 1][0] = cr, n--, n--, a = n > 0 ? r[n - 1] : -1, i = 0, s = 0, d = 0, l = 0, o = null, t = !0)), a++;
  for (t && ox(e), R2(e), a = 1; a < e.length; ) {
    if (e[a - 1][0] === _r && e[a][0] === cr) {
      const p = e[a - 1][1], f = e[a][1], h = mw(p, f), m = mw(f, p);
      h >= m ? (h >= p.length / 2 || h >= f.length / 2) && (e.splice(a, 0, new At(Ct, f.substring(0, h))), e[a - 1][1] = p.substring(0, p.length - h), e[a + 1][1] = f.substring(h), a++) : (m >= p.length / 2 || m >= f.length / 2) && (e.splice(a, 0, new At(Ct, p.substring(0, m))), e[a - 1][0] = cr, e[a - 1][1] = f.substring(0, f.length - m), e[a + 1][0] = _r, e[a + 1][1] = p.substring(m), a++), a++;
    }
    a++;
  }
}
c(O2, "diff_cleanupSemantic");
var ZP = /[^a-z0-9]/i, eO = /\s/, tO = /[\r\n]/, Lle = /\n\r?\n$/, Fle = /^\r?\n\r?\n/;
function R2(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === Ct && e[t + 1][0] === Ct) {
      let r = e[t - 1][1], n = e[t][1], o = e[t + 1][1];
      const a = nx(r, n);
      if (a) {
        const p = n.substring(n.length - a);
        r = r.substring(0, r.length - a), n = p + n.substring(0, n.length - a), o = p + o;
      }
      let i = r, s = n, d = o, l = pu(r, n) + pu(n, o);
      for (; n.charAt(0) === o.charAt(0); ) {
        r += n.charAt(0), n = n.substring(1) + o.charAt(0), o = o.substring(1);
        const p = pu(r, n) + pu(n, o);
        p >= l && (l = p, i = r, s = n, d = o);
      }
      e[t - 1][1] !== i && (i ? e[t - 1][1] = i : (e.splice(t - 1, 1), t--), e[t][1] = s, d ? e[t + 1][1] = d : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
c(R2, "diff_cleanupSemanticLossless");
function ox(e) {
  e.push(new At(Ct, ""));
  let t = 0, r = 0, n = 0, o = "", a = "", i;
  for (; t < e.length; )
    switch (e[t][0]) {
      case cr:
        n++, a += e[t][1], t++;
        break;
      case _r:
        r++, o += e[t][1], t++;
        break;
      case Ct:
        r + n > 1 ? (r !== 0 && n !== 0 && (i = P2(a, o), i !== 0 && (t - r - n > 0 && e[t - r - n - 1][0] === Ct ? e[t - r - n - 1][1] += a.substring(0, i) : (e.splice(0, 0, new At(Ct, a.substring(0, i))), t++), a = a.substring(i), o = o.substring(i)), i = nx(a, o), i !== 0 && (e[t][1] = a.substring(a.length - i) + e[t][1], a = a.substring(0, a.length - i), o = o.substring(0, o.length - i))), t -= r + n, e.splice(t, r + n), o.length && (e.splice(t, 0, new At(_r, o)), t++), a.length && (e.splice(t, 0, new At(cr, a)), t++), t++) : t !== 0 && e[t - 1][0] === Ct ? (e[t - 1][1] += e[t][1], e.splice(t, 1)) : t++, n = 0, r = 0, o = "", a = "";
        break;
    }
  e[e.length - 1][1] === "" && e.pop();
  let s = !1;
  for (t = 1; t < e.length - 1; )
    e[t - 1][0] === Ct && e[t + 1][0] === Ct && (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1] ? (e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length), e[t + 1][1] = e[t - 1][1] + e[t + 1][1], e.splice(t - 1, 1), s = !0) : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] && (e[t - 1][1] += e[t + 1][1], e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1], e.splice(t + 1, 1), s = !0)), t++;
  s && ox(e);
}
c(ox, "diff_cleanupMerge");
function pu(e, t) {
  if (!e || !t)
    return 6;
  const r = e.charAt(e.length - 1), n = t.charAt(0), o = r.match(ZP), a = n.match(ZP), i = o && r.match(eO), s = a && n.match(eO), d = i && r.match(tO), l = s && n.match(tO), p = d && e.match(Lle), f = l && t.match(Fle);
  return p || f ? 5 : d || l ? 4 : o && !i && s ? 3 : i || s ? 2 : o || a ? 1 : 0;
}
c(pu, "diff_cleanupSemanticScore_");
var j2 = "Compared values have no visual difference.", Ule = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", Bp = {}, rO;
function I2() {
  if (rO) return Bp;
  rO = 1, Object.defineProperty(Bp, "__esModule", {
    value: !0
  }), Bp.default = h;
  const e = "diff-sequences", t = 0, r = /* @__PURE__ */ c((m, g, w, _, b) => {
    let x = 0;
    for (; m < g && w < _ && b(m, w); )
      m += 1, w += 1, x += 1;
    return x;
  }, "countCommonItemsF"), n = /* @__PURE__ */ c((m, g, w, _, b) => {
    let x = 0;
    for (; m <= g && w <= _ && b(g, _); )
      g -= 1, _ -= 1, x += 1;
    return x;
  }, "countCommonItemsR"), o = /* @__PURE__ */ c((m, g, w, _, b, x, P) => {
    let R = 0, N = -m, C = x[R], A = C;
    x[R] += r(
      C + 1,
      g,
      _ + C - N + 1,
      w,
      b
    );
    const E = m < P ? m : P;
    for (R += 1, N += 2; R <= E; R += 1, N += 2) {
      if (R !== m && A < x[R])
        C = x[R];
      else if (C = A + 1, g <= C)
        return R - 1;
      A = x[R], x[R] = C + r(C + 1, g, _ + C - N + 1, w, b);
    }
    return P;
  }, "extendPathsF"), a = /* @__PURE__ */ c((m, g, w, _, b, x, P) => {
    let R = 0, N = m, C = x[R], A = C;
    x[R] -= n(
      g,
      C - 1,
      w,
      _ + C - N - 1,
      b
    );
    const E = m < P ? m : P;
    for (R += 1, N -= 2; R <= E; R += 1, N -= 2) {
      if (R !== m && x[R] < A)
        C = x[R];
      else if (C = A - 1, C < g)
        return R - 1;
      A = x[R], x[R] = C - n(
        g,
        C - 1,
        w,
        _ + C - N - 1,
        b
      );
    }
    return P;
  }, "extendPathsR"), i = /* @__PURE__ */ c((m, g, w, _, b, x, P, R, N, C, A) => {
    const E = _ - g, T = w - g, O = b - _ - T, k = -O - (m - 1), M = -O + (m - 1);
    let L = t;
    const $ = m < R ? m : R;
    for (let I = 0, D = -m; I <= $; I += 1, D += 2) {
      const F = I === 0 || I !== m && L < P[I], J = F ? P[I] : L, oe = F ? J : J + 1, ce = E + oe - D, le = r(
        oe + 1,
        w,
        ce + 1,
        b,
        x
      ), re = oe + le;
      if (L = P[I], P[I] = re, k <= D && D <= M) {
        const we = (m - 1 - (D + O)) / 2;
        if (we <= C && N[we] - 1 <= re) {
          const _e = E + J - (F ? D + 1 : D - 1), de = n(
            g,
            J,
            _,
            _e,
            x
          ), ne = J - de, $e = _e - de, Se = ne + 1, nt = $e + 1;
          A.nChangePreceding = m - 1, m - 1 === Se + nt - g - _ ? (A.aEndPreceding = g, A.bEndPreceding = _) : (A.aEndPreceding = Se, A.bEndPreceding = nt), A.nCommonPreceding = de, de !== 0 && (A.aCommonPreceding = Se, A.bCommonPreceding = nt), A.nCommonFollowing = le, le !== 0 && (A.aCommonFollowing = oe + 1, A.bCommonFollowing = ce + 1);
          const We = re + 1, q = ce + le + 1;
          return A.nChangeFollowing = m - 1, m - 1 === w + b - We - q ? (A.aStartFollowing = w, A.bStartFollowing = b) : (A.aStartFollowing = We, A.bStartFollowing = q), !0;
        }
      }
    }
    return !1;
  }, "extendOverlappablePathsF"), s = /* @__PURE__ */ c((m, g, w, _, b, x, P, R, N, C, A) => {
    const E = b - w, T = w - g, O = b - _ - T, k = O - m, M = O + m;
    let L = t;
    const $ = m < C ? m : C;
    for (let I = 0, D = m; I <= $; I += 1, D -= 2) {
      const F = I === 0 || I !== m && N[I] < L, J = F ? N[I] : L, oe = F ? J : J - 1, ce = E + oe - D, le = n(
        g,
        oe - 1,
        _,
        ce - 1,
        x
      ), re = oe - le;
      if (L = N[I], N[I] = re, k <= D && D <= M) {
        const we = (m + (D - O)) / 2;
        if (we <= R && re - 1 <= P[we]) {
          const _e = ce - le;
          if (A.nChangePreceding = m, m === re + _e - g - _ ? (A.aEndPreceding = g, A.bEndPreceding = _) : (A.aEndPreceding = re, A.bEndPreceding = _e), A.nCommonPreceding = le, le !== 0 && (A.aCommonPreceding = re, A.bCommonPreceding = _e), A.nChangeFollowing = m - 1, m === 1)
            A.nCommonFollowing = 0, A.aStartFollowing = w, A.bStartFollowing = b;
          else {
            const de = E + J - (F ? D - 1 : D + 1), ne = r(
              J,
              w,
              de,
              b,
              x
            );
            A.nCommonFollowing = ne, ne !== 0 && (A.aCommonFollowing = J, A.bCommonFollowing = de);
            const $e = J + ne, Se = de + ne;
            m - 1 === w + b - $e - Se ? (A.aStartFollowing = w, A.bStartFollowing = b) : (A.aStartFollowing = $e, A.bStartFollowing = Se);
          }
          return !0;
        }
      }
    }
    return !1;
  }, "extendOverlappablePathsR"), d = /* @__PURE__ */ c((m, g, w, _, b, x, P, R, N) => {
    const C = _ - g, A = b - w, E = w - g, T = b - _, O = T - E;
    let k = E, M = E;
    if (P[0] = g - 1, R[0] = w, O % 2 === 0) {
      const L = (m || O) / 2, $ = (E + T) / 2;
      for (let I = 1; I <= $; I += 1)
        if (k = o(I, w, b, C, x, P, k), I < L)
          M = a(I, g, _, A, x, R, M);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          s(
            I,
            g,
            w,
            _,
            b,
            x,
            P,
            k,
            R,
            M,
            N
          )
        )
          return;
    } else {
      const L = ((m || O) + 1) / 2, $ = (E + T + 1) / 2;
      let I = 1;
      for (k = o(I, w, b, C, x, P, k), I += 1; I <= $; I += 1)
        if (M = a(
          I - 1,
          g,
          _,
          A,
          x,
          R,
          M
        ), I < L)
          k = o(I, w, b, C, x, P, k);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          i(
            I,
            g,
            w,
            _,
            b,
            x,
            P,
            k,
            R,
            M,
            N
          )
        )
          return;
    }
    throw new Error(
      `${e}: no overlap aStart=${g} aEnd=${w} bStart=${_} bEnd=${b}`
    );
  }, "divide"), l = /* @__PURE__ */ c((m, g, w, _, b, x, P, R, N, C) => {
    if (b - _ < w - g) {
      if (x = !x, x && P.length === 1) {
        const { foundSubsequence: we, isCommon: _e } = P[0];
        P[1] = {
          foundSubsequence: /* @__PURE__ */ c((de, ne, $e) => {
            we(de, $e, ne);
          }, "foundSubsequence"),
          isCommon: /* @__PURE__ */ c((de, ne) => _e(ne, de), "isCommon")
        };
      }
      const le = g, re = w;
      g = _, w = b, _ = le, b = re;
    }
    const { foundSubsequence: A, isCommon: E } = P[x ? 1 : 0];
    d(
      m,
      g,
      w,
      _,
      b,
      E,
      R,
      N,
      C
    );
    const {
      nChangePreceding: T,
      aEndPreceding: O,
      bEndPreceding: k,
      nCommonPreceding: M,
      aCommonPreceding: L,
      bCommonPreceding: $,
      nCommonFollowing: I,
      aCommonFollowing: D,
      bCommonFollowing: F,
      nChangeFollowing: J,
      aStartFollowing: oe,
      bStartFollowing: ce
    } = C;
    g < O && _ < k && l(
      T,
      g,
      O,
      _,
      k,
      x,
      P,
      R,
      N,
      C
    ), M !== 0 && A(M, L, $), I !== 0 && A(I, D, F), oe < w && ce < b && l(
      J,
      oe,
      w,
      ce,
      b,
      x,
      P,
      R,
      N,
      C
    );
  }, "findSubsequences"), p = /* @__PURE__ */ c((m, g) => {
    if (typeof g != "number")
      throw new TypeError(`${e}: ${m} typeof ${typeof g} is not a number`);
    if (!Number.isSafeInteger(g))
      throw new RangeError(`${e}: ${m} value ${g} is not a safe integer`);
    if (g < 0)
      throw new RangeError(`${e}: ${m} value ${g} is a negative integer`);
  }, "validateLength"), f = /* @__PURE__ */ c((m, g) => {
    const w = typeof g;
    if (w !== "function")
      throw new TypeError(`${e}: ${m} typeof ${w} is not a function`);
  }, "validateCallback");
  function h(m, g, w, _) {
    p("aLength", m), p("bLength", g), f("isCommon", w), f("foundSubsequence", _);
    const b = r(0, m, 0, g, w);
    if (b !== 0 && _(b, 0, 0), m !== b || g !== b) {
      const x = b, P = b, R = n(
        x,
        m - 1,
        P,
        g - 1,
        w
      ), N = m - R, C = g - R, A = b + R;
      m !== A && g !== A && l(
        0,
        x,
        N,
        P,
        C,
        !1,
        [
          {
            foundSubsequence: _,
            isCommon: w
          }
        ],
        [t],
        [t],
        {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t
        }
      ), R !== 0 && _(R, N, C);
    }
  }
  return c(h, "diffSequence"), Bp;
}
c(I2, "requireBuild");
var Ble = I2(), N2 = tx(Ble);
function M2(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
c(M2, "formatTrailingSpaces");
function Zm(e, t, r, n, o, a) {
  return e.length !== 0 ? r(`${n} ${M2(e, o)}`) : n !== " " ? r(n) : t && a.length !== 0 ? r(`${n} ${a}`) : "";
}
c(Zm, "printDiffLine");
function ax(e, t, { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: a }) {
  return Zm(e, t, r, n, o, a);
}
c(ax, "printDeleteLine");
function ix(e, t, { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: a }) {
  return Zm(e, t, r, n, o, a);
}
c(ix, "printInsertLine");
function sx(e, t, { commonColor: r, commonIndicator: n, commonLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: a }) {
  return Zm(e, t, r, n, o, a);
}
c(sx, "printCommonLine");
function yw(e, t, r, n, { patchColor: o }) {
  return o(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
c(yw, "createPatchMark");
function D2(e, t) {
  const r = e.length, n = t.contextLines, o = n + n;
  let a = r, i = !1, s = 0, d = 0;
  for (; d !== r; ) {
    const R = d;
    for (; d !== r && e[d][0] === Ct; )
      d += 1;
    if (R !== d)
      if (R === 0)
        d > n && (a -= d - n, i = !0);
      else if (d === r) {
        const N = d - R;
        N > n && (a -= N - n, i = !0);
      } else {
        const N = d - R;
        N > o && (a -= N - o, s += 1);
      }
    for (; d !== r && e[d][0] !== Ct; )
      d += 1;
  }
  const l = s !== 0 || i;
  s !== 0 ? a += s + 1 : i && (a += 1);
  const p = a - 1, f = [];
  let h = 0;
  l && f.push("");
  let m = 0, g = 0, w = 0, _ = 0;
  const b = /* @__PURE__ */ c((R) => {
    const N = f.length;
    f.push(sx(R, N === 0 || N === p, t)), w += 1, _ += 1;
  }, "pushCommonLine"), x = /* @__PURE__ */ c((R) => {
    const N = f.length;
    f.push(ax(R, N === 0 || N === p, t)), w += 1;
  }, "pushDeleteLine"), P = /* @__PURE__ */ c((R) => {
    const N = f.length;
    f.push(ix(R, N === 0 || N === p, t)), _ += 1;
  }, "pushInsertLine");
  for (d = 0; d !== r; ) {
    let R = d;
    for (; d !== r && e[d][0] === Ct; )
      d += 1;
    if (R !== d)
      if (R === 0) {
        d > n && (R = d - n, m = R, g = R, w = m, _ = g);
        for (let N = R; N !== d; N += 1)
          b(e[N][1]);
      } else if (d === r) {
        const N = d - R > n ? R + n : d;
        for (let C = R; C !== N; C += 1)
          b(e[C][1]);
      } else {
        const N = d - R;
        if (N > o) {
          const C = R + n;
          for (let E = R; E !== C; E += 1)
            b(e[E][1]);
          f[h] = yw(m, w, g, _, t), h = f.length, f.push("");
          const A = N - o;
          m = w + A, g = _ + A, w = m, _ = g;
          for (let E = d - n; E !== d; E += 1)
            b(e[E][1]);
        } else
          for (let C = R; C !== d; C += 1)
            b(e[C][1]);
      }
    for (; d !== r && e[d][0] === _r; )
      x(e[d][1]), d += 1;
    for (; d !== r && e[d][0] === cr; )
      P(e[d][1]), d += 1;
  }
  return l && (f[h] = yw(m, w, g, _, t)), f.join(`
`);
}
c(D2, "joinAlignedDiffsNoExpand");
function q2(e, t) {
  return e.map((r, n, o) => {
    const a = r[1], i = n === 0 || n === o.length - 1;
    switch (r[0]) {
      case _r:
        return ax(a, i, t);
      case cr:
        return ix(a, i, t);
      default:
        return sx(a, i, t);
    }
  }).join(`
`);
}
c(q2, "joinAlignedDiffsExpand");
var rv = /* @__PURE__ */ c((e) => e, "noColor"), L2 = 5, Hle = 0;
function F2() {
  return {
    aAnnotation: "Expected",
    aColor: Pt.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: Pt.red,
    bIndicator: "+",
    changeColor: Pt.inverse,
    changeLineTrailingSpaceColor: rv,
    commonColor: Pt.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: rv,
    compareKeys: void 0,
    contextLines: L2,
    emptyFirstOrLastLinePlaceholder: "",
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: Pt.yellow,
    printBasicPrototype: !1,
    truncateThreshold: Hle,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: rv
  };
}
c(F2, "getDefaultOptions");
function U2(e) {
  return e && typeof e == "function" ? e : void 0;
}
c(U2, "getCompareKeys");
function B2(e) {
  return typeof e == "number" && Number.isSafeInteger(e) && e >= 0 ? e : L2;
}
c(B2, "getContextLines");
function ri(e = {}) {
  return {
    ...F2(),
    ...e,
    compareKeys: U2(e.compareKeys),
    contextLines: B2(e.contextLines)
  };
}
c(ri, "normalizeDiffOptions");
function Di(e) {
  return e.length === 1 && e[0].length === 0;
}
c(Di, "isEmptyString");
function H2(e) {
  let t = 0, r = 0;
  return e.forEach((n) => {
    switch (n[0]) {
      case _r:
        t += 1;
        break;
      case cr:
        r += 1;
        break;
    }
  }), {
    a: t,
    b: r
  };
}
c(H2, "countChanges");
function V2({ aAnnotation: e, aColor: t, aIndicator: r, bAnnotation: n, bColor: o, bIndicator: a, includeChangeCounts: i, omitAnnotationLines: s }, d) {
  if (s)
    return "";
  let l = "", p = "";
  if (i) {
    const m = String(d.a), g = String(d.b), w = n.length - e.length, _ = " ".repeat(Math.max(0, w)), b = " ".repeat(Math.max(0, -w)), x = g.length - m.length, P = " ".repeat(Math.max(0, x)), R = " ".repeat(Math.max(0, -x));
    l = `${_}  ${r} ${P}${m}`, p = `${b}  ${a} ${R}${g}`;
  }
  const f = `${r} ${e}${l}`, h = `${a} ${n}${p}`;
  return `${t(f)}
${o(h)}

`;
}
c(V2, "printAnnotation");
function ey(e, t, r) {
  return V2(r, H2(e)) + (r.expand ? q2(e, r) : D2(e, r)) + (t ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`) : "");
}
c(ey, "printDiffLines");
function ep(e, t, r) {
  const n = ri(r), [o, a] = lx(Di(e) ? [] : e, Di(t) ? [] : t, n);
  return ey(o, a, n);
}
c(ep, "diffLinesUnified");
function z2(e, t, r, n, o) {
  if (Di(e) && Di(r) && (e = [], r = []), Di(t) && Di(n) && (t = [], n = []), e.length !== r.length || t.length !== n.length)
    return ep(e, t, o);
  const [a, i] = lx(r, n, o);
  let s = 0, d = 0;
  return a.forEach((l) => {
    switch (l[0]) {
      case _r:
        l[1] = e[s], s += 1;
        break;
      case cr:
        l[1] = t[d], d += 1;
        break;
      default:
        l[1] = t[d], s += 1, d += 1;
    }
  }), ey(a, i, ri(o));
}
c(z2, "diffLinesUnified2");
function lx(e, t, r) {
  const n = r?.truncateThreshold ?? !1, o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0), a = n ? Math.min(e.length, o) : e.length, i = n ? Math.min(t.length, o) : t.length, s = a !== e.length || i !== t.length, d = /* @__PURE__ */ c((h, m) => e[h] === t[m], "isCommon"), l = [];
  let p = 0, f = 0;
  for (N2(a, i, d, /* @__PURE__ */ c((h, m, g) => {
    for (; p !== m; p += 1)
      l.push(new At(_r, e[p]));
    for (; f !== g; f += 1)
      l.push(new At(cr, t[f]));
    for (; h !== 0; h -= 1, p += 1, f += 1)
      l.push(new At(Ct, t[f]));
  }, "foundSubsequence")); p !== a; p += 1)
    l.push(new At(_r, e[p]));
  for (; f !== i; f += 1)
    l.push(new At(cr, t[f]));
  return [l, s];
}
c(lx, "diffLinesRaw");
function gw(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  if (Array.isArray(e))
    return "array";
  if (typeof e == "boolean")
    return "boolean";
  if (typeof e == "function")
    return "function";
  if (typeof e == "number")
    return "number";
  if (typeof e == "string")
    return "string";
  if (typeof e == "bigint")
    return "bigint";
  if (typeof e == "object") {
    if (e != null) {
      if (e.constructor === RegExp)
        return "regexp";
      if (e.constructor === Map)
        return "map";
      if (e.constructor === Set)
        return "set";
      if (e.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof e == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${e}`);
}
c(gw, "getType");
function bw(e) {
  return e.includes(`\r
`) ? `\r
` : `
`;
}
c(bw, "getNewLineSymbol");
function J2(e, t, r) {
  const n = r?.truncateThreshold ?? !1, o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
  let a = e.length, i = t.length;
  if (n) {
    const h = e.includes(`
`), m = t.includes(`
`), g = bw(e), w = bw(t), _ = h ? `${e.split(g, o).join(g)}
` : e, b = m ? `${t.split(w, o).join(w)}
` : t;
    a = _.length, i = b.length;
  }
  const s = a !== e.length || i !== t.length, d = /* @__PURE__ */ c((h, m) => e[h] === t[m], "isCommon");
  let l = 0, p = 0;
  const f = [];
  return N2(a, i, d, /* @__PURE__ */ c((h, m, g) => {
    l !== m && f.push(new At(_r, e.slice(l, m))), p !== g && f.push(new At(cr, t.slice(p, g))), l = m + h, p = g + h, f.push(new At(Ct, t.slice(g, p)));
  }, "foundSubsequence")), l !== a && f.push(new At(_r, e.slice(l))), p !== i && f.push(new At(cr, t.slice(p))), [f, s];
}
c(J2, "diffStrings");
function W2(e, t, r) {
  return t.reduce((n, o) => n + (o[0] === Ct ? o[1] : o[0] === e && o[1].length !== 0 ? r(o[1]) : ""), "");
}
c(W2, "concatenateRelevantDiffs");
var G2 = class {
  op;
  line;
  lines;
  changeColor;
  constructor(t, r) {
    this.op = t, this.line = [], this.lines = [], this.changeColor = r;
  }
  pushSubstring(t) {
    this.pushDiff(new At(this.op, t));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new At(this.op, W2(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new At(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(t) {
    this.line.push(t);
  }
  // Main input to buffer.
  align(t) {
    const r = t[1];
    if (r.includes(`
`)) {
      const n = r.split(`
`), o = n.length - 1;
      n.forEach((a, i) => {
        i < o ? (this.pushSubstring(a), this.pushLine()) : a.length !== 0 && this.pushSubstring(a);
      });
    } else
      this.pushDiff(t);
  }
  // Output from buffer.
  moveLinesTo(t) {
    this.isLineEmpty() || this.pushLine(), t.push(...this.lines), this.lines.length = 0;
  }
};
c(G2, "ChangeBuffer");
var nO = G2, K2 = class {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(t, r) {
    this.deleteBuffer = t, this.insertBuffer = r, this.lines = [];
  }
  pushDiffCommonLine(t) {
    this.lines.push(t);
  }
  pushDiffChangeLines(t) {
    const r = t[1].length === 0;
    (!r || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(t), (!r || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(t);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(t) {
    const r = t[0], n = t[1];
    if (n.includes(`
`)) {
      const o = n.split(`
`), a = o.length - 1;
      o.forEach((i, s) => {
        if (s === 0) {
          const d = new At(r, i);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(d)) : (this.pushDiffChangeLines(d), this.flushChangeLines());
        } else s < a ? this.pushDiffCommonLine(new At(r, i)) : i.length !== 0 && this.pushDiffChangeLines(new At(r, i));
      });
    } else
      this.pushDiffChangeLines(t);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
c(K2, "CommonBuffer");
var Vle = K2;
function Y2(e, t) {
  const r = new nO(_r, t), n = new nO(cr, t), o = new Vle(r, n);
  return e.forEach((a) => {
    switch (a[0]) {
      case _r:
        r.align(a);
        break;
      case cr:
        n.align(a);
        break;
      default:
        o.align(a);
    }
  }), o.getLines();
}
c(Y2, "getAlignedDiffs");
function X2(e, t) {
  if (t) {
    const r = e.length - 1;
    return e.some((n, o) => n[0] === Ct && (o !== r || n[1] !== `
`));
  }
  return e.some((r) => r[0] === Ct);
}
c(X2, "hasCommonDiff");
function Q2(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    const n = e.includes(`
`) || t.includes(`
`), [o, a] = cx(n ? `${e}
` : e, n ? `${t}
` : t, !0, r);
    if (X2(o, n)) {
      const i = ri(r), s = Y2(o, i.changeColor);
      return ey(s, a, i);
    }
  }
  return ep(e.split(`
`), t.split(`
`), r);
}
c(Q2, "diffStringsUnified");
function cx(e, t, r, n) {
  const [o, a] = J2(e, t, n);
  return r && O2(o), [o, a];
}
c(cx, "diffStringsRaw");
function Vf(e, t) {
  const { commonColor: r } = ri(t);
  return r(e);
}
c(Vf, "getCommonMessage");
var { AsymmetricMatcher: zle, DOMCollection: Jle, DOMElement: Wle, Immutable: Gle, ReactElement: Kle, ReactTestComponent: Yle } = ZE, Z2 = [
  Yle,
  Kle,
  Wle,
  Jle,
  Gle,
  zle,
  ZE.Error
], vw = {
  maxDepth: 20,
  plugins: Z2
}, eF = {
  callToJSON: !1,
  maxDepth: 8,
  plugins: Z2
};
function ks(e, t, r) {
  if (Object.is(e, t))
    return "";
  const n = gw(e);
  let o = n, a = !1;
  if (n === "object" && typeof e.asymmetricMatch == "function") {
    if (e.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof e.getExpectedType != "function")
      return;
    o = e.getExpectedType(), a = o === "string";
  }
  if (o !== gw(t)) {
    let i = function(P) {
      return P.length <= _ ? P : `${P.slice(0, _)}...`;
    };
    c(i, "truncate");
    const { aAnnotation: s, aColor: d, aIndicator: l, bAnnotation: p, bColor: f, bIndicator: h } = ri(r), m = zf(eF, r);
    let g = Dn(e, m), w = Dn(t, m);
    const _ = 1e5;
    g = i(g), w = i(w);
    const b = `${d(`${l} ${s}:`)} 
${g}`, x = `${f(`${h} ${p}:`)} 
${w}`;
    return `${b}

${x}`;
  }
  if (!a)
    switch (n) {
      case "string":
        return ep(e.split(`
`), t.split(`
`), r);
      case "boolean":
      case "number":
        return tF(e, t, r);
      case "map":
        return of(ww(e), ww(t), r);
      case "set":
        return of(_w(e), _w(t), r);
      default:
        return of(e, t, r);
    }
}
c(ks, "diff");
function tF(e, t, r) {
  const n = Dn(e, vw), o = Dn(t, vw);
  return n === o ? "" : ep(n.split(`
`), o.split(`
`), r);
}
c(tF, "comparePrimitive");
function ww(e) {
  return new Map(Array.from(e.entries()).sort());
}
c(ww, "sortMap");
function _w(e) {
  return new Set(Array.from(e.values()).sort());
}
c(_w, "sortSet");
function of(e, t, r) {
  let n, o = !1;
  try {
    const i = zf(vw, r);
    n = Ew(e, t, i, r);
  } catch {
    o = !0;
  }
  const a = Vf(j2, r);
  if (n === void 0 || n === a) {
    const i = zf(eF, r);
    n = Ew(e, t, i, r), n !== a && !o && (n = `${Vf(Ule, r)}

${n}`);
  }
  return n;
}
c(of, "compareObjects");
function zf(e, t) {
  const { compareKeys: r, printBasicPrototype: n, maxDepth: o } = ri(t);
  return {
    ...e,
    compareKeys: r,
    printBasicPrototype: n,
    maxDepth: o ?? e.maxDepth
  };
}
c(zf, "getFormatOptions");
function Ew(e, t, r, n) {
  const o = {
    ...r,
    indent: 0
  }, a = Dn(e, o), i = Dn(t, o);
  if (a === i)
    return Vf(j2, n);
  {
    const s = Dn(e, r), d = Dn(t, r);
    return z2(s.split(`
`), d.split(`
`), a.split(`
`), i.split(`
`), n);
  }
}
c(Ew, "getObjectsDifference");
var oO = 2e4;
function xw(e) {
  return cd(e) === "Object" && typeof e.asymmetricMatch == "function";
}
c(xw, "isAsymmetricMatcher");
function Sw(e, t) {
  const r = cd(e), n = cd(t);
  return r === n && (r === "Object" || r === "Array");
}
c(Sw, "isReplaceable");
function ux(e, t, r) {
  const { aAnnotation: n, bAnnotation: o } = ri(r);
  if (typeof t == "string" && typeof e == "string" && t.length > 0 && e.length > 0 && t.length <= oO && e.length <= oO && t !== e) {
    if (t.includes(`
`) || e.includes(`
`))
      return Q2(t, e, r);
    const [l] = cx(t, e, !0), p = l.some((g) => g[0] === Ct), f = rF(n, o), h = f(n) + oF(Tw(l, _r, p)), m = f(o) + nF(Tw(l, cr, p));
    return `${h}
${m}`;
  }
  const a = hw(t, { forceWritable: !0 }), i = hw(e, { forceWritable: !0 }), { replacedExpected: s, replacedActual: d } = dx(i, a);
  return ks(s, d, r);
}
c(ux, "printDiffOrStringify");
function dx(e, t, r = /* @__PURE__ */ new WeakSet(), n = /* @__PURE__ */ new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < "u" && typeof t.cause > "u" ? (delete e.cause, {
    replacedActual: e,
    replacedExpected: t
  }) : Sw(e, t) ? r.has(e) || n.has(t) ? {
    replacedActual: e,
    replacedExpected: t
  } : (r.add(e), n.add(t), rx(t).forEach((o) => {
    const a = t[o], i = e[o];
    if (xw(a))
      a.asymmetricMatch(i) && (e[o] = a);
    else if (xw(i))
      i.asymmetricMatch(a) && (t[o] = i);
    else if (Sw(i, a)) {
      const s = dx(i, a, r, n);
      e[o] = s.replacedActual, t[o] = s.replacedExpected;
    }
  }), {
    replacedActual: e,
    replacedExpected: t
  }) : {
    replacedActual: e,
    replacedExpected: t
  };
}
c(dx, "replaceAsymmetricMatcher");
function rF(...e) {
  const t = e.reduce((r, n) => n.length > r ? n.length : r, 0);
  return (r) => `${r}: ${" ".repeat(t - r.length)}`;
}
c(rF, "getLabelPrinter");
var Xle = "Â·";
function px(e) {
  return e.replace(/\s+$/gm, (t) => Xle.repeat(t.length));
}
c(px, "replaceTrailingSpaces");
function nF(e) {
  return Pt.red(px(Pr(e)));
}
c(nF, "printReceived");
function oF(e) {
  return Pt.green(px(Pr(e)));
}
c(oF, "printExpected");
function Tw(e, t, r) {
  return e.reduce((n, o) => n + (o[0] === Ct ? o[1] : o[0] === t ? r ? Pt.inverse(o[1]) : o[1] : ""), "");
}
c(Tw, "getCommonAndChangedSubstrings");
var Qle = "@@__IMMUTABLE_RECORD__@@", Zle = "@@__IMMUTABLE_ITERABLE__@@";
function aF(e) {
  return e && (e[Zle] || e[Qle]);
}
c(aF, "isImmutable");
var ece = Object.getPrototypeOf({});
function Aw(e) {
  return e instanceof Error ? `<unserializable>: ${e.message}` : typeof e == "string" ? `<unserializable>: ${e}` : "<unserializable>";
}
c(Aw, "getUnserializableMessage");
function zo(e, t = /* @__PURE__ */ new WeakMap()) {
  if (!e || typeof e == "string")
    return e;
  if (e instanceof Error && "toJSON" in e && typeof e.toJSON == "function") {
    const r = e.toJSON();
    return r && r !== e && typeof r == "object" && (typeof e.message == "string" && fu(() => r.message ?? (r.message = e.message)), typeof e.stack == "string" && fu(() => r.stack ?? (r.stack = e.stack)), typeof e.name == "string" && fu(() => r.name ?? (r.name = e.name)), e.cause != null && fu(() => r.cause ?? (r.cause = zo(e.cause, t)))), zo(r, t);
  }
  if (typeof e == "function")
    return `Function<${e.name || "anonymous"}>`;
  if (typeof e == "symbol")
    return e.toString();
  if (typeof e != "object")
    return e;
  if (typeof Buffer < "u" && e instanceof Buffer)
    return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < "u" && e instanceof Uint8Array)
    return `<Uint8Array(${e.length}) ...>`;
  if (aF(e))
    return zo(e.toJSON(), t);
  if (e instanceof Promise || e.constructor && e.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && e instanceof Element)
    return e.tagName;
  if (typeof e.asymmetricMatch == "function")
    return `${e.toString()} ${S2(e.sample)}`;
  if (typeof e.toJSON == "function")
    return zo(e.toJSON(), t);
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    const r = new Array(e.length);
    return t.set(e, r), e.forEach((n, o) => {
      try {
        r[o] = zo(n, t);
      } catch (a) {
        r[o] = Aw(a);
      }
    }), r;
  } else {
    const r = /* @__PURE__ */ Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== ece; )
      Object.getOwnPropertyNames(n).forEach((o) => {
        if (!(o in r))
          try {
            r[o] = zo(e[o], t);
          } catch (a) {
            delete r[o], r[o] = Aw(a);
          }
      }), n = Object.getPrototypeOf(n);
    return r;
  }
}
c(zo, "serializeValue");
function fu(e) {
  try {
    return e();
  } catch {
  }
}
c(fu, "safe");
function iF(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
c(iF, "normalizeErrorMessage");
function ty(e, t, r = /* @__PURE__ */ new WeakSet()) {
  if (!e || typeof e != "object")
    return { message: String(e) };
  const n = e;
  (n.showDiff || n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0) && (n.diff = ux(n.actual, n.expected, {
    ...t,
    ...n.diffOptions
  })), "expected" in n && typeof n.expected != "string" && (n.expected = Pr(n.expected, 10)), "actual" in n && typeof n.actual != "string" && (n.actual = Pr(n.actual, 10));
  try {
    typeof n.message == "string" && (n.message = iF(n.message));
  } catch {
  }
  try {
    !r.has(n) && typeof n.cause == "object" && (r.add(n), n.cause = ty(n.cause, t, r));
  } catch {
  }
  try {
    return zo(n);
  } catch (o) {
    return zo(new Error(`Failed to fully serialize error: ${o?.message}
Inner error message: ${n?.message}`));
  }
}
c(ty, "processError");
var Oo = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
}, nv = globalThis.__STORYBOOK_ADDONS_PREVIEW, tce = new Error(
  "This function ran after the play function completed. Did you forget to `await` it?"
), aO = /* @__PURE__ */ c((e) => Object.prototype.toString.call(e) === "[object Object]", "isObject"), rce = /* @__PURE__ */ c((e) => Object.prototype.toString.call(e) === "[object Module]", "isModule"), nce = /* @__PURE__ */ c((e) => {
  if (!aO(e) && !rce(e))
    return !1;
  if (e.constructor === void 0)
    return !0;
  const t = e.constructor.prototype;
  return !!aO(t);
}, "isInstrumentable"), oce = /* @__PURE__ */ c((e) => {
  try {
    return new e.constructor();
  } catch {
    return {};
  }
}, "construct"), ov = /* @__PURE__ */ c(() => ({
  renderPhase: "preparing",
  isDebugging: !1,
  isPlaying: !1,
  isLocked: !1,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), "getInitialState"), iO = /* @__PURE__ */ c((e, t = !1) => {
  const r = (t ? e.shadowCalls : e.calls).filter((o) => o.retain);
  if (!r.length)
    return;
  const n = new Map(
    Array.from(e.callRefsByResult.entries()).filter(([, o]) => o.retain)
  );
  return { cursor: r.length, calls: r, callRefsByResult: n };
}, "getRetainedState"), sF = class {
  constructor() {
    this.detached = !1, this.initialized = !1, this.state = {}, this.loadParentWindowState = /* @__PURE__ */ c(() => {
      try {
        this.state = Ee.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = !0;
      }
    }, "loadParentWindowState"), this.updateParentWindowState = /* @__PURE__ */ c(() => {
      try {
        Ee.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = !0;
      }
    }, "updateParentWindowState"), this.loadParentWindowState();
    const t = /* @__PURE__ */ c(({
      storyId: d,
      renderPhase: l,
      isPlaying: p = !0,
      isDebugging: f = !1
    }) => {
      const h = this.getState(d);
      this.setState(d, {
        ...ov(),
        ...iO(h, f),
        renderPhase: l || h.renderPhase,
        shadowCalls: f ? h.shadowCalls : [],
        chainedCallIds: f ? h.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: f ? h.playUntil : void 0,
        isPlaying: p,
        isDebugging: f
      }), this.sync(d);
    }, "resetState"), r = /* @__PURE__ */ c((d) => ({ storyId: l, playUntil: p }) => {
      this.getState(l).isDebugging || this.setState(l, ({ calls: h }) => ({
        calls: [],
        shadowCalls: h.map((m) => ({
          ...m,
          status: "waiting"
          /* WAITING */
        })),
        isDebugging: !0
      }));
      const f = this.getLog(l);
      this.setState(l, ({ shadowCalls: h }) => {
        if (p || !f.length)
          return { playUntil: p };
        const m = h.findIndex((g) => g.id === f[0].callId);
        return {
          playUntil: h.slice(0, m).filter((g) => g.interceptable && !g.ancestors?.length).slice(-1)[0]?.id
        };
      }), d.emit(Lf, { storyId: l, isDebugging: !0 });
    }, "start"), n = /* @__PURE__ */ c((d) => ({ storyId: l }) => {
      const p = this.getLog(l).filter((h) => !h.ancestors?.length), f = p.reduceRight((h, m, g) => h >= 0 || m.status === "waiting" ? h : g, -1);
      r(d)({ storyId: l, playUntil: p[f - 1]?.callId });
    }, "back"), o = /* @__PURE__ */ c((d) => ({ storyId: l, callId: p }) => {
      const { calls: f, shadowCalls: h, resolvers: m } = this.getState(l), g = f.find(({ id: _ }) => _ === p), w = h.find(({ id: _ }) => _ === p);
      if (!g && w && Object.values(m).length > 0) {
        const _ = this.getLog(l).find(
          (b) => b.status === "waiting"
          /* WAITING */
        )?.callId;
        w.id !== _ && this.setState(l, { playUntil: w.id }), Object.values(m).forEach((b) => b());
      } else
        r(d)({ storyId: l, playUntil: p });
    }, "goto"), a = /* @__PURE__ */ c((d) => ({ storyId: l }) => {
      const { resolvers: p } = this.getState(l);
      if (Object.values(p).length > 0)
        Object.values(p).forEach((f) => f());
      else {
        const f = this.getLog(l).find(
          (h) => h.status === "waiting"
          /* WAITING */
        )?.callId;
        f ? r(d)({ storyId: l, playUntil: f }) : i({ storyId: l });
      }
    }, "next"), i = /* @__PURE__ */ c(({ storyId: d }) => {
      this.setState(d, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(d).resolvers).forEach((l) => l());
    }, "end"), s = /* @__PURE__ */ c(({
      storyId: d,
      newPhase: l
    }) => {
      const { isDebugging: p } = this.getState(d);
      if (l === "preparing" && p)
        return t({ storyId: d, renderPhase: l, isDebugging: p });
      if (l === "playing")
        return t({ storyId: d, renderPhase: l, isDebugging: p });
      l === "played" ? this.setState(d, {
        renderPhase: l,
        isLocked: !1,
        isPlaying: !1,
        isDebugging: !1
      }) : l === "errored" ? this.setState(d, {
        renderPhase: l,
        isLocked: !1,
        isPlaying: !1
      }) : l === "aborted" ? this.setState(d, {
        renderPhase: l,
        isLocked: !0,
        isPlaying: !1
      }) : this.setState(d, {
        renderPhase: l
      }), this.sync(d);
    }, "renderPhaseChanged");
    nv && nv.ready().then(() => {
      this.channel = nv.getChannel(), this.channel.on(Lf, t), this.channel.on(os, s), this.channel.on(DE, () => {
        this.initialized ? this.cleanup() : this.initialized = !0;
      }), this.channel.on(Oo.START, r(this.channel)), this.channel.on(Oo.BACK, n(this.channel)), this.channel.on(Oo.GOTO, o(this.channel)), this.channel.on(Oo.NEXT, a(this.channel)), this.channel.on(Oo.END, i);
    });
  }
  getState(t) {
    return this.state[t] || ov();
  }
  setState(t, r) {
    if (t) {
      const n = this.getState(t), o = typeof r == "function" ? r(n) : r;
      this.state = { ...this.state, [t]: { ...n, ...o } }, this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (r, [n, o]) => {
        const a = iO(o);
        return a && (r[n] = Object.assign(ov(), a)), r;
      },
      {}
    );
    const t = { controlStates: {
      detached: this.detached,
      start: !1,
      back: !1,
      goto: !1,
      next: !1,
      end: !1
    }, logItems: [] };
    this.channel?.emit(Oo.SYNC, t), this.updateParentWindowState();
  }
  getLog(t) {
    const { calls: r, shadowCalls: n } = this.getState(t), o = [...n];
    r.forEach((i, s) => {
      o[s] = i;
    });
    const a = /* @__PURE__ */ new Set();
    return o.reduceRight((i, s) => (s.args.forEach((d) => {
      d?.__callId__ && a.add(d.__callId__);
    }), s.path.forEach((d) => {
      d.__callId__ && a.add(d.__callId__);
    }), (s.interceptable || s.exception) && !a.has(s.id) && (i.unshift({ callId: s.id, status: s.status, ancestors: s.ancestors }), a.add(s.id)), i), []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(t, r, n = 0) {
    if (!nce(t))
      return t;
    const { mutate: o = !1, path: a = [] } = r, i = r.getKeys ? r.getKeys(t, n) : Object.keys(t);
    return n += 1, i.reduce(
      (s, d) => {
        const l = lF(t, d);
        if (typeof l?.get == "function") {
          if (l.configurable) {
            const f = /* @__PURE__ */ c(() => l?.get?.bind(t)?.(), "getter");
            Object.defineProperty(s, d, {
              get: /* @__PURE__ */ c(() => this.instrument(f(), { ...r, path: a.concat(d) }, n), "get")
            });
          }
          return s;
        }
        const p = t[d];
        return typeof p != "function" ? (s[d] = this.instrument(p, { ...r, path: a.concat(d) }, n), s) : "__originalFn__" in p && typeof p.__originalFn__ == "function" ? (s[d] = p, s) : (s[d] = (...f) => this.track(d, p, t, f, r), s[d].__originalFn__ = p, Object.defineProperty(s[d], "name", { value: d, writable: !1 }), Object.keys(p).length > 0 && Object.assign(
          s[d],
          this.instrument({ ...p }, { ...r, path: a.concat(d) }, n)
        ), s);
      },
      o ? t : oce(t)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(t, r, n, o, a) {
    const i = o?.[0]?.__storyId__ || Ee.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor: s, ancestors: d } = this.getState(i);
    this.setState(i, { cursor: s + 1 });
    const l = `${d.slice(-1)[0] || i} [${s}] ${t}`, { path: p = [], intercept: f = !1, retain: h = !1 } = a, m = typeof f == "function" ? f(t, p) : f, g = { id: l, cursor: s, storyId: i, ancestors: d, path: p, method: t, args: o, interceptable: m, retain: h }, w = (m && !d.length ? this.intercept : this.invoke).call(this, r, n, g, a);
    return this.instrument(w, { ...a, mutate: !0, path: [{ __callId__: g.id }] });
  }
  intercept(t, r, n, o) {
    const { chainedCallIds: a, isDebugging: i, playUntil: s } = this.getState(n.storyId), d = a.has(n.id);
    return !i || d || s ? (s === n.id && this.setState(n.storyId, { playUntil: void 0 }), this.invoke(t, r, n, o)) : new Promise((l) => {
      this.setState(n.storyId, ({ resolvers: p }) => ({
        isLocked: !1,
        resolvers: { ...p, [n.id]: l }
      }));
    }).then(() => (this.setState(n.storyId, (l) => {
      const { [n.id]: p, ...f } = l.resolvers;
      return { isLocked: !0, resolvers: f };
    }), this.invoke(t, r, n, o)));
  }
  invoke(t, r, n, o) {
    const { callRefsByResult: a, renderPhase: i } = this.getState(n.storyId), s = 25, d = /* @__PURE__ */ c((f, h, m) => {
      if (m.includes(f))
        return "[Circular]";
      if (m = [...m, f], h > s)
        return "...";
      if (a.has(f))
        return a.get(f);
      if (f instanceof Array)
        return f.map((g) => d(g, ++h, m));
      if (f instanceof Date)
        return { __date__: { value: f.toISOString() } };
      if (f instanceof Error) {
        const { name: g, message: w, stack: _ } = f;
        return { __error__: { name: g, message: w, stack: _ } };
      }
      if (f instanceof RegExp) {
        const { flags: g, source: w } = f;
        return { __regexp__: { flags: g, source: w } };
      }
      if (f instanceof Ee.window?.HTMLElement) {
        const { prefix: g, localName: w, id: _, classList: b, innerText: x } = f, P = Array.from(b);
        return { __element__: { prefix: g, localName: w, id: _, classNames: P, innerText: x } };
      }
      return typeof f == "function" ? {
        __function__: { name: "getMockName" in f ? f.getMockName() : f.name }
      } : typeof f == "symbol" ? { __symbol__: { description: f.description } } : typeof f == "object" && f?.constructor?.name && f?.constructor?.name !== "Object" ? { __class__: { name: f.constructor.name } } : Object.prototype.toString.call(f) === "[object Object]" ? Object.fromEntries(
        Object.entries(f).map(([g, w]) => [g, d(w, ++h, m)])
      ) : f;
    }, "serializeValues"), l = {
      ...n,
      args: n.args.map((f) => d(f, 0, []))
    };
    n.path.forEach((f) => {
      f?.__callId__ && this.setState(n.storyId, ({ chainedCallIds: h }) => ({
        chainedCallIds: new Set(Array.from(h).concat(f.__callId__))
      }));
    });
    const p = /* @__PURE__ */ c((f) => {
      if (f instanceof Error) {
        const { name: h, message: m, stack: g, callId: w = n.id } = f, {
          showDiff: _ = void 0,
          diff: b = void 0,
          actual: x = void 0,
          expected: P = void 0
        } = f.name === "AssertionError" ? ty(f) : f, R = { name: h, message: m, stack: g, callId: w, showDiff: _, diff: b, actual: x, expected: P };
        if (this.update({ ...l, status: "error", exception: R }), this.setState(n.storyId, (N) => ({
          callRefsByResult: new Map([
            ...Array.from(N.callRefsByResult.entries()),
            [f, { __callId__: n.id, retain: n.retain }]
          ])
        })), n.ancestors?.length)
          throw Object.prototype.hasOwnProperty.call(f, "callId") || Object.defineProperty(f, "callId", { value: n.id }), f;
      }
      throw f;
    }, "handleException");
    try {
      if (i === "played" && !n.retain)
        throw tce;
      const f = (o.getArgs ? o.getArgs(n, this.getState(n.storyId)) : n.args).map((m) => typeof m != "function" || cF(m) || Object.keys(m).length ? m : (...g) => {
        const { cursor: w, ancestors: _ } = this.getState(n.storyId);
        this.setState(n.storyId, { cursor: 0, ancestors: [..._, n.id] });
        const b = /* @__PURE__ */ c(() => this.setState(n.storyId, { cursor: w, ancestors: _ }), "restore");
        let x = !1;
        try {
          const P = m(...g);
          return P instanceof Promise ? (x = !0, P.finally(b)) : P;
        } finally {
          x || b();
        }
      }), h = t.apply(r, f);
      return h && ["object", "function", "symbol"].includes(typeof h) && this.setState(n.storyId, (m) => ({
        callRefsByResult: new Map([
          ...Array.from(m.callRefsByResult.entries()),
          [h, { __callId__: n.id, retain: n.retain }]
        ])
      })), this.update({
        ...l,
        status: h instanceof Promise ? "active" : "done"
        /* DONE */
      }), h instanceof Promise ? h.then((m) => (this.update({
        ...l,
        status: "done"
        /* DONE */
      }), m), p) : h;
    } catch (f) {
      return p(f);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(t) {
    this.channel?.emit(Oo.CALL, t), this.setState(t.storyId, ({ calls: r }) => {
      const n = r.concat(t).reduce((o, a) => Object.assign(o, { [a.id]: a }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(n).sort(
          (o, a) => o.id.localeCompare(a.id, void 0, { numeric: !0 })
        )
      };
    }), this.sync(t.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(t) {
    const r = /* @__PURE__ */ c(() => {
      const { isLocked: n, isPlaying: o } = this.getState(t), a = this.getLog(t), i = a.filter(({ ancestors: p }) => !p.length).find(
        (p) => p.status === "waiting"
        /* WAITING */
      )?.callId, s = a.some(
        (p) => p.status === "active"
        /* ACTIVE */
      );
      if (this.detached || n || s || a.length === 0) {
        const p = { controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1
        }, logItems: a };
        this.channel?.emit(Oo.SYNC, p);
        return;
      }
      const d = a.some(
        (p) => p.status === "done" || p.status === "error"
        /* ERROR */
      ), l = { controlStates: {
        detached: this.detached,
        start: d,
        back: d,
        goto: !0,
        next: o,
        end: o
      }, logItems: a, pausedAt: i };
      this.channel?.emit(Oo.SYNC, l);
    }, "synchronize");
    this.setState(t, ({ syncTimeout: n }) => (clearTimeout(n), { syncTimeout: setTimeout(r, 0) }));
  }
};
c(sF, "Instrumenter");
var ace = sF;
function _c(e, t = {}) {
  try {
    let r = !1, n = !1;
    return Ee.window?.location?.search?.includes("instrument=true") ? r = !0 : Ee.window?.location?.search?.includes("instrument=false") && (n = !0), Ee.window?.parent === Ee.window && !r || n ? e : (Ee.window && !Ee.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (Ee.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new ace()), (Ee.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t));
  } catch (r) {
    return Mt.warn(r), e;
  }
}
c(_c, "instrument");
function lF(e, t) {
  let r = e;
  for (; r != null; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n)
      return n;
    r = Object.getPrototypeOf(r);
  }
}
c(lF, "getPropertyDescriptor");
function cF(e) {
  if (typeof e != "function")
    return !1;
  const t = Object.getOwnPropertyDescriptor(e, "prototype");
  return t ? !t.writable : !1;
}
c(cF, "isClass");
var ice = W({
  "../node_modules/min-indent/index.js"(e, t) {
    t.exports = (r) => {
      const n = r.match(/^[ \t]*(?=\S)/gm);
      return n ? n.reduce((o, a) => Math.min(o, a.length), 1 / 0) : 0;
    };
  }
}), sce = W({
  "../node_modules/strip-indent/index.js"(e, t) {
    var r = ice();
    t.exports = (n) => {
      const o = r(n);
      if (o === 0)
        return n;
      const a = new RegExp(`^[ \\t]{${o}}`, "gm");
      return n.replace(a, "");
    };
  }
}), lce = W({
  "../node_modules/indent-string/index.js"(e, t) {
    t.exports = (r, n = 1, o) => {
      if (o = {
        indent: " ",
        includeEmptyLines: !1,
        ...o
      }, typeof r != "string")
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof r}\``
        );
      if (typeof n != "number")
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof n}\``
        );
      if (typeof o.indent != "string")
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof o.indent}\``
        );
      if (n === 0)
        return r;
      const a = o.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return r.replace(a, o.indent.repeat(n));
    };
  }
}), uF = W({
  "../node_modules/redent/index.js"(e, t) {
    var r = sce(), n = lce();
    t.exports = (o, a = 0, i) => n(r(o), a, i);
  }
}), cce = W({
  "../node_modules/aria-query/lib/util/iteratorProxy.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    function t() {
      var r = this, n = 0, o = {
        "@@iterator": /* @__PURE__ */ c(function() {
          return o;
        }, "iterator"),
        next: /* @__PURE__ */ c(function() {
          if (n < r.length) {
            var a = r[n];
            return n = n + 1, {
              done: !1,
              value: a
            };
          } else
            return {
              done: !0
            };
        }, "next")
      };
      return o;
    }
    c(t, "iteratorProxy"), e.default = t;
  }
}), tp = W({
  "../node_modules/aria-query/lib/util/iterationDecorator.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = o;
    var t = r(cce());
    function r(a) {
      return a && a.__esModule ? a : { default: a };
    }
    c(r, "_interopRequireDefault");
    function n(a) {
      "@babel/helpers - typeof";
      return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
        return typeof i;
      } : function(i) {
        return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
      }, n(a);
    }
    c(n, "_typeof");
    function o(a, i) {
      return typeof Symbol == "function" && n(Symbol.iterator) === "symbol" && Object.defineProperty(a, Symbol.iterator, {
        value: t.default.bind(i)
      }), a;
    }
    c(o, "iterationDecorator");
  }
}), uce = W({
  "../node_modules/aria-query/lib/ariaPropsMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = r(tp());
    function r(f) {
      return f && f.__esModule ? f : { default: f };
    }
    c(r, "_interopRequireDefault");
    function n(f, h) {
      return d(f) || s(f, h) || a(f, h) || o();
    }
    c(n, "_slicedToArray");
    function o() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    c(o, "_nonIterableRest");
    function a(f, h) {
      if (f) {
        if (typeof f == "string") return i(f, h);
        var m = {}.toString.call(f).slice(8, -1);
        return m === "Object" && f.constructor && (m = f.constructor.name), m === "Map" || m === "Set" ? Array.from(f) : m === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(m) ? i(f, h) : void 0;
      }
    }
    c(a, "_unsupportedIterableToArray");
    function i(f, h) {
      (h == null || h > f.length) && (h = f.length);
      for (var m = 0, g = Array(h); m < h; m++) g[m] = f[m];
      return g;
    }
    c(i, "_arrayLikeToArray");
    function s(f, h) {
      var m = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (m != null) {
        var g, w, _, b, x = [], P = !0, R = !1;
        try {
          if (_ = (m = m.call(f)).next, h === 0) {
            if (Object(m) !== m) return;
            P = !1;
          } else for (; !(P = (g = _.call(m)).done) && (x.push(g.value), x.length !== h); P = !0) ;
        } catch (N) {
          R = !0, w = N;
        } finally {
          try {
            if (!P && m.return != null && (b = m.return(), Object(b) !== b)) return;
          } finally {
            if (R) throw w;
          }
        }
        return x;
      }
    }
    c(s, "_iterableToArrayLimit");
    function d(f) {
      if (Array.isArray(f)) return f;
    }
    c(d, "_arrayWithHoles");
    var l = [["aria-activedescendant", {
      type: "id"
    }], ["aria-atomic", {
      type: "boolean"
    }], ["aria-autocomplete", {
      type: "token",
      values: ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      type: "string"
    }], ["aria-brailleroledescription", {
      type: "string"
    }], ["aria-busy", {
      type: "boolean"
    }], ["aria-checked", {
      type: "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      type: "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", !0, !1]
    }], ["aria-describedby", {
      type: "idlist"
    }], ["aria-description", {
      type: "string"
    }], ["aria-details", {
      type: "id"
    }], ["aria-disabled", {
      type: "boolean"
    }], ["aria-dropeffect", {
      type: "tokenlist",
      values: ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      type: "id"
    }], ["aria-expanded", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-flowto", {
      type: "idlist"
    }], ["aria-grabbed", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-haspopup", {
      type: "token",
      values: [!1, !0, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-invalid", {
      type: "token",
      values: ["grammar", !1, "spelling", !0]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      type: "string"
    }], ["aria-labelledby", {
      type: "idlist"
    }], ["aria-level", {
      type: "integer"
    }], ["aria-live", {
      type: "token",
      values: ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      type: "boolean"
    }], ["aria-multiselectable", {
      type: "boolean"
    }], ["aria-orientation", {
      type: "token",
      values: ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      type: "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      type: "integer"
    }], ["aria-pressed", {
      type: "tristate"
    }], ["aria-readonly", {
      type: "boolean"
    }], ["aria-relevant", {
      type: "tokenlist",
      values: ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      type: "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-setsize", {
      type: "integer"
    }], ["aria-sort", {
      type: "token",
      values: ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      type: "number"
    }], ["aria-valuemin", {
      type: "number"
    }], ["aria-valuenow", {
      type: "number"
    }], ["aria-valuetext", {
      type: "string"
    }]], p = {
      entries: /* @__PURE__ */ c(function() {
        return l;
      }, "entries"),
      forEach: /* @__PURE__ */ c(function(f) {
        for (var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, m = 0, g = l; m < g.length; m++) {
          var w = n(g[m], 2), _ = w[0], b = w[1];
          f.call(h, b, _, l);
        }
      }, "forEach"),
      get: /* @__PURE__ */ c(function(f) {
        var h = l.filter(function(m) {
          return m[0] === f;
        })[0];
        return h && h[1];
      }, "get"),
      has: /* @__PURE__ */ c(function(f) {
        return !!p.get(f);
      }, "has"),
      keys: /* @__PURE__ */ c(function() {
        return l.map(function(f) {
          var h = n(f, 1), m = h[0];
          return m;
        });
      }, "keys"),
      values: /* @__PURE__ */ c(function() {
        return l.map(function(f) {
          var h = n(f, 2), m = h[1];
          return m;
        });
      }, "values")
    };
    e.default = (0, t.default)(p, p.entries());
  }
}), dce = W({
  "../node_modules/aria-query/lib/domMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = r(tp());
    function r(f) {
      return f && f.__esModule ? f : { default: f };
    }
    c(r, "_interopRequireDefault");
    function n(f, h) {
      return d(f) || s(f, h) || a(f, h) || o();
    }
    c(n, "_slicedToArray");
    function o() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    c(o, "_nonIterableRest");
    function a(f, h) {
      if (f) {
        if (typeof f == "string") return i(f, h);
        var m = {}.toString.call(f).slice(8, -1);
        return m === "Object" && f.constructor && (m = f.constructor.name), m === "Map" || m === "Set" ? Array.from(f) : m === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(m) ? i(f, h) : void 0;
      }
    }
    c(a, "_unsupportedIterableToArray");
    function i(f, h) {
      (h == null || h > f.length) && (h = f.length);
      for (var m = 0, g = Array(h); m < h; m++) g[m] = f[m];
      return g;
    }
    c(i, "_arrayLikeToArray");
    function s(f, h) {
      var m = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (m != null) {
        var g, w, _, b, x = [], P = !0, R = !1;
        try {
          if (_ = (m = m.call(f)).next, h === 0) {
            if (Object(m) !== m) return;
            P = !1;
          } else for (; !(P = (g = _.call(m)).done) && (x.push(g.value), x.length !== h); P = !0) ;
        } catch (N) {
          R = !0, w = N;
        } finally {
          try {
            if (!P && m.return != null && (b = m.return(), Object(b) !== b)) return;
          } finally {
            if (R) throw w;
          }
        }
        return x;
      }
    }
    c(s, "_iterableToArrayLimit");
    function d(f) {
      if (Array.isArray(f)) return f;
    }
    c(d, "_arrayWithHoles");
    var l = [["a", {
      reserved: !1
    }], ["abbr", {
      reserved: !1
    }], ["acronym", {
      reserved: !1
    }], ["address", {
      reserved: !1
    }], ["applet", {
      reserved: !1
    }], ["area", {
      reserved: !1
    }], ["article", {
      reserved: !1
    }], ["aside", {
      reserved: !1
    }], ["audio", {
      reserved: !1
    }], ["b", {
      reserved: !1
    }], ["base", {
      reserved: !0
    }], ["bdi", {
      reserved: !1
    }], ["bdo", {
      reserved: !1
    }], ["big", {
      reserved: !1
    }], ["blink", {
      reserved: !1
    }], ["blockquote", {
      reserved: !1
    }], ["body", {
      reserved: !1
    }], ["br", {
      reserved: !1
    }], ["button", {
      reserved: !1
    }], ["canvas", {
      reserved: !1
    }], ["caption", {
      reserved: !1
    }], ["center", {
      reserved: !1
    }], ["cite", {
      reserved: !1
    }], ["code", {
      reserved: !1
    }], ["col", {
      reserved: !0
    }], ["colgroup", {
      reserved: !0
    }], ["content", {
      reserved: !1
    }], ["data", {
      reserved: !1
    }], ["datalist", {
      reserved: !1
    }], ["dd", {
      reserved: !1
    }], ["del", {
      reserved: !1
    }], ["details", {
      reserved: !1
    }], ["dfn", {
      reserved: !1
    }], ["dialog", {
      reserved: !1
    }], ["dir", {
      reserved: !1
    }], ["div", {
      reserved: !1
    }], ["dl", {
      reserved: !1
    }], ["dt", {
      reserved: !1
    }], ["em", {
      reserved: !1
    }], ["embed", {
      reserved: !1
    }], ["fieldset", {
      reserved: !1
    }], ["figcaption", {
      reserved: !1
    }], ["figure", {
      reserved: !1
    }], ["font", {
      reserved: !1
    }], ["footer", {
      reserved: !1
    }], ["form", {
      reserved: !1
    }], ["frame", {
      reserved: !1
    }], ["frameset", {
      reserved: !1
    }], ["h1", {
      reserved: !1
    }], ["h2", {
      reserved: !1
    }], ["h3", {
      reserved: !1
    }], ["h4", {
      reserved: !1
    }], ["h5", {
      reserved: !1
    }], ["h6", {
      reserved: !1
    }], ["head", {
      reserved: !0
    }], ["header", {
      reserved: !1
    }], ["hgroup", {
      reserved: !1
    }], ["hr", {
      reserved: !1
    }], ["html", {
      reserved: !0
    }], ["i", {
      reserved: !1
    }], ["iframe", {
      reserved: !1
    }], ["img", {
      reserved: !1
    }], ["input", {
      reserved: !1
    }], ["ins", {
      reserved: !1
    }], ["kbd", {
      reserved: !1
    }], ["keygen", {
      reserved: !1
    }], ["label", {
      reserved: !1
    }], ["legend", {
      reserved: !1
    }], ["li", {
      reserved: !1
    }], ["link", {
      reserved: !0
    }], ["main", {
      reserved: !1
    }], ["map", {
      reserved: !1
    }], ["mark", {
      reserved: !1
    }], ["marquee", {
      reserved: !1
    }], ["menu", {
      reserved: !1
    }], ["menuitem", {
      reserved: !1
    }], ["meta", {
      reserved: !0
    }], ["meter", {
      reserved: !1
    }], ["nav", {
      reserved: !1
    }], ["noembed", {
      reserved: !0
    }], ["noscript", {
      reserved: !0
    }], ["object", {
      reserved: !1
    }], ["ol", {
      reserved: !1
    }], ["optgroup", {
      reserved: !1
    }], ["option", {
      reserved: !1
    }], ["output", {
      reserved: !1
    }], ["p", {
      reserved: !1
    }], ["param", {
      reserved: !0
    }], ["picture", {
      reserved: !0
    }], ["pre", {
      reserved: !1
    }], ["progress", {
      reserved: !1
    }], ["q", {
      reserved: !1
    }], ["rp", {
      reserved: !1
    }], ["rt", {
      reserved: !1
    }], ["rtc", {
      reserved: !1
    }], ["ruby", {
      reserved: !1
    }], ["s", {
      reserved: !1
    }], ["samp", {
      reserved: !1
    }], ["script", {
      reserved: !0
    }], ["section", {
      reserved: !1
    }], ["select", {
      reserved: !1
    }], ["small", {
      reserved: !1
    }], ["source", {
      reserved: !0
    }], ["spacer", {
      reserved: !1
    }], ["span", {
      reserved: !1
    }], ["strike", {
      reserved: !1
    }], ["strong", {
      reserved: !1
    }], ["style", {
      reserved: !0
    }], ["sub", {
      reserved: !1
    }], ["summary", {
      reserved: !1
    }], ["sup", {
      reserved: !1
    }], ["table", {
      reserved: !1
    }], ["tbody", {
      reserved: !1
    }], ["td", {
      reserved: !1
    }], ["textarea", {
      reserved: !1
    }], ["tfoot", {
      reserved: !1
    }], ["th", {
      reserved: !1
    }], ["thead", {
      reserved: !1
    }], ["time", {
      reserved: !1
    }], ["title", {
      reserved: !0
    }], ["tr", {
      reserved: !1
    }], ["track", {
      reserved: !0
    }], ["tt", {
      reserved: !1
    }], ["u", {
      reserved: !1
    }], ["ul", {
      reserved: !1
    }], ["var", {
      reserved: !1
    }], ["video", {
      reserved: !1
    }], ["wbr", {
      reserved: !1
    }], ["xmp", {
      reserved: !1
    }]], p = {
      entries: /* @__PURE__ */ c(function() {
        return l;
      }, "entries"),
      forEach: /* @__PURE__ */ c(function(f) {
        for (var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, m = 0, g = l; m < g.length; m++) {
          var w = n(g[m], 2), _ = w[0], b = w[1];
          f.call(h, b, _, l);
        }
      }, "forEach"),
      get: /* @__PURE__ */ c(function(f) {
        var h = l.filter(function(m) {
          return m[0] === f;
        })[0];
        return h && h[1];
      }, "get"),
      has: /* @__PURE__ */ c(function(f) {
        return !!p.get(f);
      }, "has"),
      keys: /* @__PURE__ */ c(function() {
        return l.map(function(f) {
          var h = n(f, 1), m = h[0];
          return m;
        });
      }, "keys"),
      values: /* @__PURE__ */ c(function() {
        return l.map(function(f) {
          var h = n(f, 2), m = h[1];
          return m;
        });
      }, "values")
    };
    e.default = (0, t.default)(p, p.entries());
  }
}), pce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), fce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), hce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), mce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), yce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), gce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    e.default = t;
  }
}), bce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), vce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), wce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), _ce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), Ece = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), xce = W({
  "../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), Sce = W({
  "../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = m(pce()), r = m(fce()), n = m(hce()), o = m(mce()), a = m(yce()), i = m(gce()), s = m(bce()), d = m(vce()), l = m(wce()), p = m(_ce()), f = m(Ece()), h = m(xce());
    function m(w) {
      return w && w.__esModule ? w : { default: w };
    }
    c(m, "_interopRequireDefault");
    var g = [["command", t.default], ["composite", r.default], ["input", n.default], ["landmark", o.default], ["range", a.default], ["roletype", i.default], ["section", s.default], ["sectionhead", d.default], ["select", l.default], ["structure", p.default], ["widget", f.default], ["window", h.default]];
    e.default = g;
  }
}), Tce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Ace = W({
  "../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    e.default = t;
  }
}), $ce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), Cce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    e.default = t;
  }
}), kce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Pce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Oce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), Rce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), jce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Ice = W({
  "../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), Nce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Mce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), Dce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), qce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Lce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Fce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Uce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Bce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    e.default = t;
  }
}), Hce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    e.default = t;
  }
}), Vce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), zce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Jce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    e.default = t;
  }
}), Wce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Gce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Kce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), Yce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    e.default = t;
  }
}), Xce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), Qce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Zce = W({
  "../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), eue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), tue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), rue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), nue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), oue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), aue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), iue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), sue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), lue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), cue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), uue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), due = W({
  "../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), pue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    e.default = t;
  }
}), fue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), hue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    e.default = t;
  }
}), mue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    e.default = t;
  }
}), yue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), gue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), bue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    e.default = t;
  }
}), vue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), wue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), _ue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Eue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), xue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), Sue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), Tue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), Aue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), $ue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), Cue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), kue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), Pue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), Oue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Rue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    e.default = t;
  }
}), jue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), Iue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), Nue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), Mue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Due = W({
  "../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), que = W({
  "../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Lue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Fue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    e.default = t;
  }
}), Uue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), Bue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Hue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    e.default = t;
  }
}), Vue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), zue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Jue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), Wue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Gue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    e.default = t;
  }
}), Kue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), Yue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Xue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), Que = W({
  "../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    e.default = t;
  }
}), Zue = W({
  "../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    e.default = t;
  }
}), ede = W({
  "../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = K(Tce()), r = K(Ace()), n = K($ce()), o = K(Cce()), a = K(kce()), i = K(Pce()), s = K(Oce()), d = K(Rce()), l = K(jce()), p = K(Ice()), f = K(Nce()), h = K(Mce()), m = K(Dce()), g = K(qce()), w = K(Lce()), _ = K(Fce()), b = K(Uce()), x = K(Bce()), P = K(Hce()), R = K(Vce()), N = K(zce()), C = K(Jce()), A = K(Wce()), E = K(Gce()), T = K(Kce()), O = K(Yce()), k = K(Xce()), M = K(Qce()), L = K(Zce()), $ = K(eue()), I = K(tue()), D = K(rue()), F = K(nue()), J = K(oue()), oe = K(aue()), ce = K(iue()), le = K(sue()), re = K(lue()), we = K(cue()), _e = K(uue()), de = K(due()), ne = K(pue()), $e = K(fue()), Se = K(hue()), nt = K(mue()), We = K(yue()), q = K(gue()), te = K(bue()), ae = K(vue()), ue = K(wue()), se = K(_ue()), ye = K(Eue()), fe = K(xue()), Ae = K(Sue()), Fe = K(Tue()), dt = K(Aue()), pt = K($ue()), it = K(Cue()), Ht = K(kue()), _t = K(Pue()), Et = K(Oue()), Nr = K(Rue()), To = K(jue()), di = K(Iue()), Ao = K(Nue()), pi = K(Mue()), fi = K(Due()), hi = K(que()), $o = K(Lue()), mi = K(Fue()), yi = K(Uue()), gi = K(Bue()), bi = K(Hue()), vi = K(Vue()), wi = K(zue()), _i = K(Jue()), Ei = K(Wue()), xi = K(Gue()), Si = K(Kue()), Ti = K(Yue()), Ai = K(Xue()), $n = K(Que()), Co = K(Zue());
    function K(sr) {
      return sr && sr.__esModule ? sr : { default: sr };
    }
    c(K, "_interopRequireDefault");
    var Ce = [["alert", t.default], ["alertdialog", r.default], ["application", n.default], ["article", o.default], ["banner", a.default], ["blockquote", i.default], ["button", s.default], ["caption", d.default], ["cell", l.default], ["checkbox", p.default], ["code", f.default], ["columnheader", h.default], ["combobox", m.default], ["complementary", g.default], ["contentinfo", w.default], ["definition", _.default], ["deletion", b.default], ["dialog", x.default], ["directory", P.default], ["document", R.default], ["emphasis", N.default], ["feed", C.default], ["figure", A.default], ["form", E.default], ["generic", T.default], ["grid", O.default], ["gridcell", k.default], ["group", M.default], ["heading", L.default], ["img", $.default], ["insertion", I.default], ["link", D.default], ["list", F.default], ["listbox", J.default], ["listitem", oe.default], ["log", ce.default], ["main", le.default], ["mark", re.default], ["marquee", we.default], ["math", _e.default], ["menu", de.default], ["menubar", ne.default], ["menuitem", $e.default], ["menuitemcheckbox", Se.default], ["menuitemradio", nt.default], ["meter", We.default], ["navigation", q.default], ["none", te.default], ["note", ae.default], ["option", ue.default], ["paragraph", se.default], ["presentation", ye.default], ["progressbar", fe.default], ["radio", Ae.default], ["radiogroup", Fe.default], ["region", dt.default], ["row", pt.default], ["rowgroup", it.default], ["rowheader", Ht.default], ["scrollbar", _t.default], ["search", Et.default], ["searchbox", Nr.default], ["separator", To.default], ["slider", di.default], ["spinbutton", Ao.default], ["status", pi.default], ["strong", fi.default], ["subscript", hi.default], ["superscript", $o.default], ["switch", mi.default], ["tab", yi.default], ["table", gi.default], ["tablist", bi.default], ["tabpanel", vi.default], ["term", wi.default], ["textbox", _i.default], ["time", Ei.default], ["timer", xi.default], ["toolbar", Si.default], ["tooltip", Ti.default], ["tree", Ai.default], ["treegrid", $n.default], ["treeitem", Co.default]];
    e.default = Ce;
  }
}), tde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), rde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), nde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), ode = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), ade = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), ide = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    e.default = t;
  }
}), sde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), lde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), cde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), ude = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), dde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), pde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    e.default = t;
  }
}), fde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), hde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), mde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), yde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    e.default = t;
  }
}), gde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), bde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), vde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), wde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), _de = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Ede = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), xde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Sde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Tde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), Ade = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), $de = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Cde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), kde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    e.default = t;
  }
}), Pde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    e.default = t;
  }
}), Ode = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Rde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), jde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), Ide = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Nde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Mde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Dde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    e.default = t;
  }
}), qde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Lde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), Fde = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    e.default = t;
  }
}), Ude = W({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), Bde = W({
  "../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = ne(tde()), r = ne(rde()), n = ne(nde()), o = ne(ode()), a = ne(ade()), i = ne(ide()), s = ne(sde()), d = ne(lde()), l = ne(cde()), p = ne(ude()), f = ne(dde()), h = ne(pde()), m = ne(fde()), g = ne(hde()), w = ne(mde()), _ = ne(yde()), b = ne(gde()), x = ne(bde()), P = ne(vde()), R = ne(wde()), N = ne(_de()), C = ne(Ede()), A = ne(xde()), E = ne(Sde()), T = ne(Tde()), O = ne(Ade()), k = ne($de()), M = ne(Cde()), L = ne(kde()), $ = ne(Pde()), I = ne(Ode()), D = ne(Rde()), F = ne(jde()), J = ne(Ide()), oe = ne(Nde()), ce = ne(Mde()), le = ne(Dde()), re = ne(qde()), we = ne(Lde()), _e = ne(Fde()), de = ne(Ude());
    function ne(Se) {
      return Se && Se.__esModule ? Se : { default: Se };
    }
    c(ne, "_interopRequireDefault");
    var $e = [["doc-abstract", t.default], ["doc-acknowledgments", r.default], ["doc-afterword", n.default], ["doc-appendix", o.default], ["doc-backlink", a.default], ["doc-biblioentry", i.default], ["doc-bibliography", s.default], ["doc-biblioref", d.default], ["doc-chapter", l.default], ["doc-colophon", p.default], ["doc-conclusion", f.default], ["doc-cover", h.default], ["doc-credit", m.default], ["doc-credits", g.default], ["doc-dedication", w.default], ["doc-endnote", _.default], ["doc-endnotes", b.default], ["doc-epigraph", x.default], ["doc-epilogue", P.default], ["doc-errata", R.default], ["doc-example", N.default], ["doc-footnote", C.default], ["doc-foreword", A.default], ["doc-glossary", E.default], ["doc-glossref", T.default], ["doc-index", O.default], ["doc-introduction", k.default], ["doc-noteref", M.default], ["doc-notice", L.default], ["doc-pagebreak", $.default], ["doc-pagefooter", I.default], ["doc-pageheader", D.default], ["doc-pagelist", F.default], ["doc-part", J.default], ["doc-preface", oe.default], ["doc-prologue", ce.default], ["doc-pullquote", le.default], ["doc-qna", re.default], ["doc-subtitle", we.default], ["doc-tip", _e.default], ["doc-toc", de.default]];
    e.default = $e;
  }
}), Hde = W({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    e.default = t;
  }
}), Vde = W({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), zde = W({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    e.default = t;
  }
}), Jde = W({
  "../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = o(Hde()), r = o(Vde()), n = o(zde());
    function o(i) {
      return i && i.__esModule ? i : { default: i };
    }
    c(o, "_interopRequireDefault");
    var a = [["graphics-document", t.default], ["graphics-object", r.default], ["graphics-symbol", n.default]];
    e.default = a;
  }
}), fx = W({
  "../node_modules/aria-query/lib/rolesMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = i(Sce()), r = i(ede()), n = i(Bde()), o = i(Jde()), a = i(tp());
    function i(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    c(i, "_interopRequireDefault");
    function s(_, b) {
      var x = typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
      if (!x) {
        if (Array.isArray(_) || (x = p(_)) || b && _ && typeof _.length == "number") {
          x && (_ = x);
          var P = 0, R = /* @__PURE__ */ c(function() {
          }, "F");
          return { s: R, n: /* @__PURE__ */ c(function() {
            return P >= _.length ? { done: !0 } : { done: !1, value: _[P++] };
          }, "n"), e: /* @__PURE__ */ c(function(E) {
            throw E;
          }, "e"), f: R };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var N, C = !0, A = !1;
      return { s: /* @__PURE__ */ c(function() {
        x = x.call(_);
      }, "s"), n: /* @__PURE__ */ c(function() {
        var E = x.next();
        return C = E.done, E;
      }, "n"), e: /* @__PURE__ */ c(function(E) {
        A = !0, N = E;
      }, "e"), f: /* @__PURE__ */ c(function() {
        try {
          C || x.return == null || x.return();
        } finally {
          if (A) throw N;
        }
      }, "f") };
    }
    c(s, "_createForOfIteratorHelper");
    function d(_, b) {
      return m(_) || h(_, b) || p(_, b) || l();
    }
    c(d, "_slicedToArray");
    function l() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    c(l, "_nonIterableRest");
    function p(_, b) {
      if (_) {
        if (typeof _ == "string") return f(_, b);
        var x = {}.toString.call(_).slice(8, -1);
        return x === "Object" && _.constructor && (x = _.constructor.name), x === "Map" || x === "Set" ? Array.from(_) : x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x) ? f(_, b) : void 0;
      }
    }
    c(p, "_unsupportedIterableToArray");
    function f(_, b) {
      (b == null || b > _.length) && (b = _.length);
      for (var x = 0, P = Array(b); x < b; x++) P[x] = _[x];
      return P;
    }
    c(f, "_arrayLikeToArray");
    function h(_, b) {
      var x = _ == null ? null : typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
      if (x != null) {
        var P, R, N, C, A = [], E = !0, T = !1;
        try {
          if (N = (x = x.call(_)).next, b === 0) {
            if (Object(x) !== x) return;
            E = !1;
          } else for (; !(E = (P = N.call(x)).done) && (A.push(P.value), A.length !== b); E = !0) ;
        } catch (O) {
          T = !0, R = O;
        } finally {
          try {
            if (!E && x.return != null && (C = x.return(), Object(C) !== C)) return;
          } finally {
            if (T) throw R;
          }
        }
        return A;
      }
    }
    c(h, "_iterableToArrayLimit");
    function m(_) {
      if (Array.isArray(_)) return _;
    }
    c(m, "_arrayWithHoles");
    var g = [].concat(t.default, r.default, n.default, o.default);
    g.forEach(function(_) {
      var b = d(_, 2), x = b[1], P = s(x.superClass), R;
      try {
        for (P.s(); !(R = P.n()).done; ) {
          var N = R.value, C = s(N), A;
          try {
            var E = /* @__PURE__ */ c(function() {
              var T = A.value, O = g.filter(function(I) {
                var D = d(I, 1), F = D[0];
                return F === T;
              })[0];
              if (O)
                for (var k = O[1], M = 0, L = Object.keys(k.props); M < L.length; M++) {
                  var $ = L[M];
                  Object.prototype.hasOwnProperty.call(x.props, $) || (x.props[$] = k.props[$]);
                }
            }, "_loop");
            for (C.s(); !(A = C.n()).done; )
              E();
          } catch (T) {
            C.e(T);
          } finally {
            C.f();
          }
        }
      } catch (T) {
        P.e(T);
      } finally {
        P.f();
      }
    });
    var w = {
      entries: /* @__PURE__ */ c(function() {
        return g;
      }, "entries"),
      forEach: /* @__PURE__ */ c(function(_) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, x = s(g), P;
        try {
          for (x.s(); !(P = x.n()).done; ) {
            var R = d(P.value, 2), N = R[0], C = R[1];
            _.call(b, C, N, g);
          }
        } catch (A) {
          x.e(A);
        } finally {
          x.f();
        }
      }, "forEach"),
      get: /* @__PURE__ */ c(function(_) {
        var b = g.filter(function(x) {
          return x[0] === _;
        })[0];
        return b && b[1];
      }, "get"),
      has: /* @__PURE__ */ c(function(_) {
        return !!w.get(_);
      }, "has"),
      keys: /* @__PURE__ */ c(function() {
        return g.map(function(_) {
          var b = d(_, 1), x = b[0];
          return x;
        });
      }, "keys"),
      values: /* @__PURE__ */ c(function() {
        return g.map(function(_) {
          var b = d(_, 2), x = b[1];
          return x;
        });
      }, "values")
    };
    e.default = (0, a.default)(w, w.entries());
  }
}), Wde = W({
  "../node_modules/aria-query/lib/elementRoleMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = n(tp()), r = n(fx());
    function n(C) {
      return C && C.__esModule ? C : { default: C };
    }
    c(n, "_interopRequireDefault");
    function o(C, A) {
      return l(C) || d(C, A) || i(C, A) || a();
    }
    c(o, "_slicedToArray");
    function a() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    c(a, "_nonIterableRest");
    function i(C, A) {
      if (C) {
        if (typeof C == "string") return s(C, A);
        var E = {}.toString.call(C).slice(8, -1);
        return E === "Object" && C.constructor && (E = C.constructor.name), E === "Map" || E === "Set" ? Array.from(C) : E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E) ? s(C, A) : void 0;
      }
    }
    c(i, "_unsupportedIterableToArray");
    function s(C, A) {
      (A == null || A > C.length) && (A = C.length);
      for (var E = 0, T = Array(A); E < A; E++) T[E] = C[E];
      return T;
    }
    c(s, "_arrayLikeToArray");
    function d(C, A) {
      var E = C == null ? null : typeof Symbol < "u" && C[Symbol.iterator] || C["@@iterator"];
      if (E != null) {
        var T, O, k, M, L = [], $ = !0, I = !1;
        try {
          if (k = (E = E.call(C)).next, A === 0) {
            if (Object(E) !== E) return;
            $ = !1;
          } else for (; !($ = (T = k.call(E)).done) && (L.push(T.value), L.length !== A); $ = !0) ;
        } catch (D) {
          I = !0, O = D;
        } finally {
          try {
            if (!$ && E.return != null && (M = E.return(), Object(M) !== M)) return;
          } finally {
            if (I) throw O;
          }
        }
        return L;
      }
    }
    c(d, "_iterableToArrayLimit");
    function l(C) {
      if (Array.isArray(C)) return C;
    }
    c(l, "_arrayWithHoles");
    var p = [], f = r.default.keys();
    for (b = 0; b < f.length; b++)
      if (h = f[b], m = r.default.get(h), m)
        for (g = [].concat(m.baseConcepts, m.relatedConcepts), w = /* @__PURE__ */ c(function() {
          var C = g[_];
          if (C.module === "HTML") {
            var A = C.concept;
            if (A) {
              var E = p.filter(function(M) {
                return P(M[0], A);
              })[0], T;
              E ? T = E[1] : T = [];
              for (var O = !0, k = 0; k < T.length; k++)
                if (T[k] === h) {
                  O = !1;
                  break;
                }
              O && T.push(h), E || p.push([A, T]);
            }
          }
        }, "_loop"), _ = 0; _ < g.length; _++)
          w();
    var h, m, g, w, _, b, x = {
      entries: /* @__PURE__ */ c(function() {
        return p;
      }, "entries"),
      forEach: /* @__PURE__ */ c(function(C) {
        for (var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, E = 0, T = p; E < T.length; E++) {
          var O = o(T[E], 2), k = O[0], M = O[1];
          C.call(A, M, k, p);
        }
      }, "forEach"),
      get: /* @__PURE__ */ c(function(C) {
        var A = p.filter(function(E) {
          return C.name === E[0].name && N(C.attributes, E[0].attributes);
        })[0];
        return A && A[1];
      }, "get"),
      has: /* @__PURE__ */ c(function(C) {
        return !!x.get(C);
      }, "has"),
      keys: /* @__PURE__ */ c(function() {
        return p.map(function(C) {
          var A = o(C, 1), E = A[0];
          return E;
        });
      }, "keys"),
      values: /* @__PURE__ */ c(function() {
        return p.map(function(C) {
          var A = o(C, 2), E = A[1];
          return E;
        });
      }, "values")
    };
    function P(C, A) {
      return C.name === A.name && R(C.constraints, A.constraints) && N(C.attributes, A.attributes);
    }
    c(P, "ariaRoleRelationConceptEquals");
    function R(C, A) {
      if (C === void 0 && A !== void 0 || C !== void 0 && A === void 0)
        return !1;
      if (C !== void 0 && A !== void 0) {
        if (C.length !== A.length)
          return !1;
        for (var E = 0; E < C.length; E++)
          if (C[E] !== A[E])
            return !1;
      }
      return !0;
    }
    c(R, "ariaRoleRelationConstraintsEquals");
    function N(C, A) {
      if (C === void 0 && A !== void 0 || C !== void 0 && A === void 0)
        return !1;
      if (C !== void 0 && A !== void 0) {
        if (C.length !== A.length)
          return !1;
        for (var E = 0; E < C.length; E++) {
          if (C[E].name !== A[E].name || C[E].value !== A[E].value || C[E].constraints === void 0 && A[E].constraints !== void 0 || C[E].constraints !== void 0 && A[E].constraints === void 0)
            return !1;
          if (C[E].constraints !== void 0 && A[E].constraints !== void 0) {
            if (C[E].constraints.length !== A[E].constraints.length)
              return !1;
            for (var T = 0; T < C[E].constraints.length; T++)
              if (C[E].constraints[T] !== A[E].constraints[T])
                return !1;
          }
        }
      }
      return !0;
    }
    c(N, "ariaRoleRelationConceptAttributeEquals"), e.default = (0, t.default)(x, x.entries());
  }
}), Gde = W({
  "../node_modules/aria-query/lib/roleElementMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = n(tp()), r = n(fx());
    function n(N) {
      return N && N.__esModule ? N : { default: N };
    }
    c(n, "_interopRequireDefault");
    function o(N, C) {
      return l(N) || d(N, C) || i(N, C) || a();
    }
    c(o, "_slicedToArray");
    function a() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    c(a, "_nonIterableRest");
    function i(N, C) {
      if (N) {
        if (typeof N == "string") return s(N, C);
        var A = {}.toString.call(N).slice(8, -1);
        return A === "Object" && N.constructor && (A = N.constructor.name), A === "Map" || A === "Set" ? Array.from(N) : A === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A) ? s(N, C) : void 0;
      }
    }
    c(i, "_unsupportedIterableToArray");
    function s(N, C) {
      (C == null || C > N.length) && (C = N.length);
      for (var A = 0, E = Array(C); A < C; A++) E[A] = N[A];
      return E;
    }
    c(s, "_arrayLikeToArray");
    function d(N, C) {
      var A = N == null ? null : typeof Symbol < "u" && N[Symbol.iterator] || N["@@iterator"];
      if (A != null) {
        var E, T, O, k, M = [], L = !0, $ = !1;
        try {
          if (O = (A = A.call(N)).next, C === 0) {
            if (Object(A) !== A) return;
            L = !1;
          } else for (; !(L = (E = O.call(A)).done) && (M.push(E.value), M.length !== C); L = !0) ;
        } catch (I) {
          $ = !0, T = I;
        } finally {
          try {
            if (!L && A.return != null && (k = A.return(), Object(k) !== k)) return;
          } finally {
            if ($) throw T;
          }
        }
        return M;
      }
    }
    c(d, "_iterableToArrayLimit");
    function l(N) {
      if (Array.isArray(N)) return N;
    }
    c(l, "_arrayWithHoles");
    var p = [], f = r.default.keys();
    for (P = 0; P < f.length; P++)
      if (h = f[P], m = r.default.get(h), g = [], m) {
        for (w = [].concat(m.baseConcepts, m.relatedConcepts), x = 0; x < w.length; x++)
          _ = w[x], _.module === "HTML" && (b = _.concept, b != null && g.push(b));
        g.length > 0 && p.push([h, g]);
      }
    var h, m, g, w, _, b, x, P, R = {
      entries: /* @__PURE__ */ c(function() {
        return p;
      }, "entries"),
      forEach: /* @__PURE__ */ c(function(N) {
        for (var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, A = 0, E = p; A < E.length; A++) {
          var T = o(E[A], 2), O = T[0], k = T[1];
          N.call(C, k, O, p);
        }
      }, "forEach"),
      get: /* @__PURE__ */ c(function(N) {
        var C = p.filter(function(A) {
          return A[0] === N;
        })[0];
        return C && C[1];
      }, "get"),
      has: /* @__PURE__ */ c(function(N) {
        return !!R.get(N);
      }, "has"),
      keys: /* @__PURE__ */ c(function() {
        return p.map(function(N) {
          var C = o(N, 1), A = C[0];
          return A;
        });
      }, "keys"),
      values: /* @__PURE__ */ c(function() {
        return p.map(function(N) {
          var C = o(N, 2), A = C[1];
          return A;
        });
      }, "values")
    };
    e.default = (0, t.default)(R, R.entries());
  }
}), hx = W({
  "../node_modules/aria-query/lib/index.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0;
    var t = i(uce()), r = i(dce()), n = i(fx()), o = i(Wde()), a = i(Gde());
    function i(s) {
      return s && s.__esModule ? s : { default: s };
    }
    c(i, "_interopRequireDefault"), e.aria = t.default, e.dom = r.default, e.roles = n.default, e.elementRoles = o.default, e.roleElements = a.default;
  }
}), dF = W({
  "../node_modules/css.escape/css.escape.js"(e, t) {
    (function(r, n) {
      typeof e == "object" ? t.exports = n(r) : typeof define == "function" && define.amd ? define([], n.bind(r, r)) : n(r);
    })(typeof globalThis < "u" ? globalThis : e, function(r) {
      if (r.CSS && r.CSS.escape)
        return r.CSS.escape;
      var n = /* @__PURE__ */ c(function(o) {
        if (arguments.length == 0)
          throw new TypeError("`CSS.escape` requires an argument.");
        for (var a = String(o), i = a.length, s = -1, d, l = "", p = a.charCodeAt(0); ++s < i; ) {
          if (d = a.charCodeAt(s), d == 0) {
            l += "ï¿½";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, [â€¦]
            d >= 1 && d <= 31 || d == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), [â€¦]
            s == 0 && d >= 48 && d <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), [â€¦]
            s == 1 && d >= 48 && d <= 57 && p == 45
          ) {
            l += "\\" + d.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, [â€¦]
            s == 0 && i == 1 && d == 45
          ) {
            l += "\\" + a.charAt(s);
            continue;
          }
          if (d >= 128 || d == 45 || d == 95 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122) {
            l += a.charAt(s);
            continue;
          }
          l += "\\" + a.charAt(s);
        }
        return l;
      }, "cssEscape");
      return r.CSS || (r.CSS = {}), r.CSS.escape = n, n;
    });
  }
}), pF = W({
  "../node_modules/pretty-format/node_modules/ansi-styles/index.js"(e, t) {
    var r = 10, n = /* @__PURE__ */ c((i = 0) => (s) => `\x1B[${38 + i};5;${s}m`, "wrapAnsi256"), o = /* @__PURE__ */ c((i = 0) => (s, d, l) => `\x1B[${38 + i};2;${s};${d};${l}m`, "wrapAnsi16m");
    function a() {
      const i = /* @__PURE__ */ new Map(), s = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      s.color.gray = s.color.blackBright, s.bgColor.bgGray = s.bgColor.bgBlackBright, s.color.grey = s.color.blackBright, s.bgColor.bgGrey = s.bgColor.bgBlackBright;
      for (const [d, l] of Object.entries(s)) {
        for (const [p, f] of Object.entries(l))
          s[p] = {
            open: `\x1B[${f[0]}m`,
            close: `\x1B[${f[1]}m`
          }, l[p] = s[p], i.set(f[0], f[1]);
        Object.defineProperty(s, d, {
          value: l,
          enumerable: !1
        });
      }
      return Object.defineProperty(s, "codes", {
        value: i,
        enumerable: !1
      }), s.color.close = "\x1B[39m", s.bgColor.close = "\x1B[49m", s.color.ansi256 = n(), s.color.ansi16m = o(), s.bgColor.ansi256 = n(r), s.bgColor.ansi16m = o(r), Object.defineProperties(s, {
        rgbToAnsi256: {
          value: /* @__PURE__ */ c((d, l, p) => d === l && l === p ? d < 8 ? 16 : d > 248 ? 231 : Math.round((d - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(d / 255 * 5) + 6 * Math.round(l / 255 * 5) + Math.round(p / 255 * 5), "value"),
          enumerable: !1
        },
        hexToRgb: {
          value: /* @__PURE__ */ c((d) => {
            const l = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(d.toString(16));
            if (!l)
              return [0, 0, 0];
            let { colorString: p } = l.groups;
            p.length === 3 && (p = p.split("").map((h) => h + h).join(""));
            const f = Number.parseInt(p, 16);
            return [
              f >> 16 & 255,
              f >> 8 & 255,
              f & 255
            ];
          }, "value"),
          enumerable: !1
        },
        hexToAnsi256: {
          value: /* @__PURE__ */ c((d) => s.rgbToAnsi256(...s.hexToRgb(d)), "value"),
          enumerable: !1
        }
      }), s;
    }
    c(a, "assembleStyles"), Object.defineProperty(t, "exports", {
      enumerable: !0,
      get: a
    });
  }
}), ry = W({
  "../node_modules/pretty-format/build/collections.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.printIteratorEntries = r, e.printIteratorValues = n, e.printListItems = o, e.printObjectProperties = a;
    var t = /* @__PURE__ */ c((i, s) => {
      const d = Object.keys(i).sort(s);
      return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(i).forEach((l) => {
        Object.getOwnPropertyDescriptor(i, l).enumerable && d.push(l);
      }), d;
    }, "getKeysOfEnumerableProperties");
    function r(i, s, d, l, p, f, h = ": ") {
      let m = "", g = i.next();
      if (!g.done) {
        m += s.spacingOuter;
        const w = d + s.indent;
        for (; !g.done; ) {
          const _ = f(
            g.value[0],
            s,
            w,
            l,
            p
          ), b = f(
            g.value[1],
            s,
            w,
            l,
            p
          );
          m += w + _ + h + b, g = i.next(), g.done ? s.min || (m += ",") : m += "," + s.spacingInner;
        }
        m += s.spacingOuter + d;
      }
      return m;
    }
    c(r, "printIteratorEntries");
    function n(i, s, d, l, p, f) {
      let h = "", m = i.next();
      if (!m.done) {
        h += s.spacingOuter;
        const g = d + s.indent;
        for (; !m.done; )
          h += g + f(m.value, s, g, l, p), m = i.next(), m.done ? s.min || (h += ",") : h += "," + s.spacingInner;
        h += s.spacingOuter + d;
      }
      return h;
    }
    c(n, "printIteratorValues");
    function o(i, s, d, l, p, f) {
      let h = "";
      if (i.length) {
        h += s.spacingOuter;
        const m = d + s.indent;
        for (let g = 0; g < i.length; g++)
          h += m, g in i && (h += f(i[g], s, m, l, p)), g < i.length - 1 ? h += "," + s.spacingInner : s.min || (h += ",");
        h += s.spacingOuter + d;
      }
      return h;
    }
    c(o, "printListItems");
    function a(i, s, d, l, p, f) {
      let h = "";
      const m = t(i, s.compareKeys);
      if (m.length) {
        h += s.spacingOuter;
        const g = d + s.indent;
        for (let w = 0; w < m.length; w++) {
          const _ = m[w], b = f(_, s, g, l, p), x = f(i[_], s, g, l, p);
          h += g + b + ": " + x, w < m.length - 1 ? h += "," + s.spacingInner : s.min || (h += ",");
        }
        h += s.spacingOuter + d;
      }
      return h;
    }
    c(a, "printObjectProperties");
  }
}), Kde = W({
  "../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = ry(), r = (function() {
      return typeof globalThis < "u" ? globalThis : typeof r < "u" ? r : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), n = r["jest-symbol-do-not-touch"] || r.Symbol, o = typeof n == "function" && n.for ? n.for("jest.asymmetricMatcher") : 1267621, a = " ", i = /* @__PURE__ */ c((p, f, h, m, g, w) => {
      const _ = p.toString();
      return _ === "ArrayContaining" || _ === "ArrayNotContaining" ? ++m > f.maxDepth ? "[" + _ + "]" : _ + a + "[" + (0, t.printListItems)(
        p.sample,
        f,
        h,
        m,
        g,
        w
      ) + "]" : _ === "ObjectContaining" || _ === "ObjectNotContaining" ? ++m > f.maxDepth ? "[" + _ + "]" : _ + a + "{" + (0, t.printObjectProperties)(
        p.sample,
        f,
        h,
        m,
        g,
        w
      ) + "}" : _ === "StringMatching" || _ === "StringNotMatching" || _ === "StringContaining" || _ === "StringNotContaining" ? _ + a + w(p.sample, f, h, m, g) : p.toAsymmetricMatcher();
    }, "serialize");
    e.serialize = i;
    var s = /* @__PURE__ */ c((p) => p && p.$$typeof === o, "test");
    e.test = s;
    var d = {
      serialize: i,
      test: s
    }, l = d;
    e.default = l;
  }
}), Yde = W({
  "../node_modules/pretty-format/node_modules/ansi-regex/index.js"(e, t) {
    t.exports = ({ onlyFirst: r = !1 } = {}) => {
      const n = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(n, r ? void 0 : "g");
    };
  }
}), Xde = W({
  "../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = n(Yde()), r = n(pF());
    function n(l) {
      return l && l.__esModule ? l : { default: l };
    }
    c(n, "_interopRequireDefault");
    var o = /* @__PURE__ */ c((l) => l.replace((0, t.default)(), (p) => {
      switch (p) {
        case r.default.red.close:
        case r.default.green.close:
        case r.default.cyan.close:
        case r.default.gray.close:
        case r.default.white.close:
        case r.default.yellow.close:
        case r.default.bgRed.close:
        case r.default.bgGreen.close:
        case r.default.bgYellow.close:
        case r.default.inverse.close:
        case r.default.dim.close:
        case r.default.bold.close:
        case r.default.reset.open:
        case r.default.reset.close:
          return "</>";
        case r.default.red.open:
          return "<red>";
        case r.default.green.open:
          return "<green>";
        case r.default.cyan.open:
          return "<cyan>";
        case r.default.gray.open:
          return "<gray>";
        case r.default.white.open:
          return "<white>";
        case r.default.yellow.open:
          return "<yellow>";
        case r.default.bgRed.open:
          return "<bgRed>";
        case r.default.bgGreen.open:
          return "<bgGreen>";
        case r.default.bgYellow.open:
          return "<bgYellow>";
        case r.default.inverse.open:
          return "<inverse>";
        case r.default.dim.open:
          return "<dim>";
        case r.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    }), "toHumanReadableAnsi"), a = /* @__PURE__ */ c((l) => typeof l == "string" && !!l.match((0, t.default)()), "test");
    e.test = a;
    var i = /* @__PURE__ */ c((l, p, f, h, m, g) => g(o(l), p, f, h, m), "serialize");
    e.serialize = i;
    var s = {
      serialize: i,
      test: a
    }, d = s;
    e.default = d;
  }
}), Qde = W({
  "../node_modules/pretty-format/build/plugins/DOMCollection.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = ry(), r = " ", n = ["DOMStringMap", "NamedNodeMap"], o = /^(HTML\w*Collection|NodeList)$/, a = /* @__PURE__ */ c((f) => n.indexOf(f) !== -1 || o.test(f), "testName"), i = /* @__PURE__ */ c((f) => f && f.constructor && !!f.constructor.name && a(f.constructor.name), "test");
    e.test = i;
    var s = /* @__PURE__ */ c((f) => f.constructor.name === "NamedNodeMap", "isNamedNodeMap"), d = /* @__PURE__ */ c((f, h, m, g, w, _) => {
      const b = f.constructor.name;
      return ++g > h.maxDepth ? "[" + b + "]" : (h.min ? "" : b + r) + (n.indexOf(b) !== -1 ? "{" + (0, t.printObjectProperties)(
        s(f) ? Array.from(f).reduce((x, P) => (x[P.name] = P.value, x), {}) : { ...f },
        h,
        m,
        g,
        w,
        _
      ) + "}" : "[" + (0, t.printListItems)(
        Array.from(f),
        h,
        m,
        g,
        w,
        _
      ) + "]");
    }, "serialize");
    e.serialize = d;
    var l = {
      serialize: d,
      test: i
    }, p = l;
    e.default = p;
  }
}), Zde = W({
  "../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = t;
    function t(r) {
      return r.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    c(t, "escapeHTML");
  }
}), mx = W({
  "../node_modules/pretty-format/build/plugins/lib/markup.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.printText = e.printProps = e.printElementAsLeaf = e.printElement = e.printComment = e.printChildren = void 0;
    var t = r(Zde());
    function r(l) {
      return l && l.__esModule ? l : { default: l };
    }
    c(r, "_interopRequireDefault");
    var n = /* @__PURE__ */ c((l, p, f, h, m, g, w) => {
      const _ = h + f.indent, b = f.colors;
      return l.map((x) => {
        const P = p[x];
        let R = w(P, f, _, m, g);
        return typeof P != "string" && (R.indexOf(`
`) !== -1 && (R = f.spacingOuter + _ + R + f.spacingOuter + h), R = "{" + R + "}"), f.spacingInner + h + b.prop.open + x + b.prop.close + "=" + b.value.open + R + b.value.close;
      }).join("");
    }, "printProps");
    e.printProps = n;
    var o = /* @__PURE__ */ c((l, p, f, h, m, g) => l.map(
      (w) => p.spacingOuter + f + (typeof w == "string" ? a(w, p) : g(w, p, f, h, m))
    ).join(""), "printChildren");
    e.printChildren = o;
    var a = /* @__PURE__ */ c((l, p) => {
      const f = p.colors.content;
      return f.open + (0, t.default)(l) + f.close;
    }, "printText");
    e.printText = a;
    var i = /* @__PURE__ */ c((l, p) => {
      const f = p.colors.comment;
      return f.open + "<!--" + (0, t.default)(l) + "-->" + f.close;
    }, "printComment");
    e.printComment = i;
    var s = /* @__PURE__ */ c((l, p, f, h, m) => {
      const g = h.colors.tag;
      return g.open + "<" + l + (p && g.close + p + h.spacingOuter + m + g.open) + (f ? ">" + g.close + f + h.spacingOuter + m + g.open + "</" + l : (p && !h.min ? "" : " ") + "/") + ">" + g.close;
    }, "printElement");
    e.printElement = s;
    var d = /* @__PURE__ */ c((l, p) => {
      const f = p.colors.tag;
      return f.open + "<" + l + f.close + " â€¦" + f.open + " />" + f.close;
    }, "printElementAsLeaf");
    e.printElementAsLeaf = d;
  }
}), epe = W({
  "../node_modules/pretty-format/build/plugins/DOMElement.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = mx(), r = 1, n = 3, o = 8, a = 11, i = /^((HTML|SVG)\w*)?Element$/, s = /* @__PURE__ */ c((_) => {
      try {
        return typeof _.hasAttribute == "function" && _.hasAttribute("is");
      } catch {
        return !1;
      }
    }, "testHasAttribute"), d = /* @__PURE__ */ c((_) => {
      const b = _.constructor.name, { nodeType: x, tagName: P } = _, R = typeof P == "string" && P.includes("-") || s(_);
      return x === r && (i.test(b) || R) || x === n && b === "Text" || x === o && b === "Comment" || x === a && b === "DocumentFragment";
    }, "testNode"), l = /* @__PURE__ */ c((_) => {
      var b;
      return (_ == null || (b = _.constructor) === null || b === void 0 ? void 0 : b.name) && d(_);
    }, "test");
    e.test = l;
    function p(_) {
      return _.nodeType === n;
    }
    c(p, "nodeIsText");
    function f(_) {
      return _.nodeType === o;
    }
    c(f, "nodeIsComment");
    function h(_) {
      return _.nodeType === a;
    }
    c(h, "nodeIsFragment");
    var m = /* @__PURE__ */ c((_, b, x, P, R, N) => {
      if (p(_))
        return (0, t.printText)(_.data, b);
      if (f(_))
        return (0, t.printComment)(_.data, b);
      const C = h(_) ? "DocumentFragment" : _.tagName.toLowerCase();
      return ++P > b.maxDepth ? (0, t.printElementAsLeaf)(C, b) : (0, t.printElement)(
        C,
        (0, t.printProps)(
          h(_) ? [] : Array.from(_.attributes).map((A) => A.name).sort(),
          h(_) ? {} : Array.from(_.attributes).reduce((A, E) => (A[E.name] = E.value, A), {}),
          b,
          x + b.indent,
          P,
          R,
          N
        ),
        (0, t.printChildren)(
          Array.prototype.slice.call(_.childNodes || _.children),
          b,
          x + b.indent,
          P,
          R,
          N
        ),
        b,
        x
      );
    }, "serialize");
    e.serialize = m;
    var g = {
      serialize: m,
      test: l
    }, w = g;
    e.default = w;
  }
}), tpe = W({
  "../node_modules/pretty-format/build/plugins/Immutable.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = ry(), r = "@@__IMMUTABLE_ITERABLE__@@", n = "@@__IMMUTABLE_LIST__@@", o = "@@__IMMUTABLE_KEYED__@@", a = "@@__IMMUTABLE_MAP__@@", i = "@@__IMMUTABLE_ORDERED__@@", s = "@@__IMMUTABLE_RECORD__@@", d = "@@__IMMUTABLE_SEQ__@@", l = "@@__IMMUTABLE_SET__@@", p = "@@__IMMUTABLE_STACK__@@", f = /* @__PURE__ */ c((E) => "Immutable." + E, "getImmutableName"), h = /* @__PURE__ */ c((E) => "[" + E + "]", "printAsLeaf"), m = " ", g = "â€¦", w = /* @__PURE__ */ c((E, T, O, k, M, L, $) => ++k > T.maxDepth ? h(f($)) : f($) + m + "{" + (0, t.printIteratorEntries)(
      E.entries(),
      T,
      O,
      k,
      M,
      L
    ) + "}", "printImmutableEntries");
    function _(E) {
      let T = 0;
      return {
        next() {
          if (T < E._keys.length) {
            const O = E._keys[T++];
            return {
              done: !1,
              value: [O, E.get(O)]
            };
          }
          return {
            done: !0,
            value: void 0
          };
        }
      };
    }
    c(_, "getRecordEntries");
    var b = /* @__PURE__ */ c((E, T, O, k, M, L) => {
      const $ = f(E._name || "Record");
      return ++k > T.maxDepth ? h($) : $ + m + "{" + (0, t.printIteratorEntries)(
        _(E),
        T,
        O,
        k,
        M,
        L
      ) + "}";
    }, "printImmutableRecord"), x = /* @__PURE__ */ c((E, T, O, k, M, L) => {
      const $ = f("Seq");
      return ++k > T.maxDepth ? h($) : E[o] ? $ + m + "{" + // from Immutable collection of entries or from ECMAScript object
      (E._iter || E._object ? (0, t.printIteratorEntries)(
        E.entries(),
        T,
        O,
        k,
        M,
        L
      ) : g) + "}" : $ + m + "[" + (E._iter || // from Immutable collection of values
      E._array || // from ECMAScript array
      E._collection || // from ECMAScript collection in immutable v4
      E._iterable ? (0, t.printIteratorValues)(
        E.values(),
        T,
        O,
        k,
        M,
        L
      ) : g) + "]";
    }, "printImmutableSeq"), P = /* @__PURE__ */ c((E, T, O, k, M, L, $) => ++k > T.maxDepth ? h(f($)) : f($) + m + "[" + (0, t.printIteratorValues)(
      E.values(),
      T,
      O,
      k,
      M,
      L
    ) + "]", "printImmutableValues"), R = /* @__PURE__ */ c((E, T, O, k, M, L) => E[a] ? w(
      E,
      T,
      O,
      k,
      M,
      L,
      E[i] ? "OrderedMap" : "Map"
    ) : E[n] ? P(
      E,
      T,
      O,
      k,
      M,
      L,
      "List"
    ) : E[l] ? P(
      E,
      T,
      O,
      k,
      M,
      L,
      E[i] ? "OrderedSet" : "Set"
    ) : E[p] ? P(
      E,
      T,
      O,
      k,
      M,
      L,
      "Stack"
    ) : E[d] ? x(E, T, O, k, M, L) : b(E, T, O, k, M, L), "serialize");
    e.serialize = R;
    var N = /* @__PURE__ */ c((E) => E && (E[r] === !0 || E[s] === !0), "test");
    e.test = N;
    var C = {
      serialize: R,
      test: N
    }, A = C;
    e.default = A;
  }
}), rpe = W({
  "../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js"(e) {
    var t = 60103, r = 60106, n = 60107, o = 60108, a = 60114, i = 60109, s = 60110, d = 60112, l = 60113, p = 60120, f = 60115, h = 60116, m = 60121, g = 60122, w = 60117, _ = 60129, b = 60131;
    typeof Symbol == "function" && Symbol.for && (x = Symbol.for, t = x("react.element"), r = x("react.portal"), n = x("react.fragment"), o = x("react.strict_mode"), a = x("react.profiler"), i = x("react.provider"), s = x("react.context"), d = x("react.forward_ref"), l = x("react.suspense"), p = x("react.suspense_list"), f = x("react.memo"), h = x("react.lazy"), m = x("react.block"), g = x("react.server.block"), w = x("react.fundamental"), _ = x("react.debug_trace_mode"), b = x("react.legacy_hidden"));
    var x;
    function P($) {
      if (typeof $ == "object" && $ !== null) {
        var I = $.$$typeof;
        switch (I) {
          case t:
            switch ($ = $.type, $) {
              case n:
              case a:
              case o:
              case l:
              case p:
                return $;
              default:
                switch ($ = $ && $.$$typeof, $) {
                  case s:
                  case d:
                  case h:
                  case f:
                  case i:
                    return $;
                  default:
                    return I;
                }
            }
          case r:
            return I;
        }
      }
    }
    c(P, "y");
    var R = i, N = t, C = d, A = n, E = h, T = f, O = r, k = a, M = o, L = l;
    e.ContextConsumer = s, e.ContextProvider = R, e.Element = N, e.ForwardRef = C, e.Fragment = A, e.Lazy = E, e.Memo = T, e.Portal = O, e.Profiler = k, e.StrictMode = M, e.Suspense = L, e.isAsyncMode = function() {
      return !1;
    }, e.isConcurrentMode = function() {
      return !1;
    }, e.isContextConsumer = function($) {
      return P($) === s;
    }, e.isContextProvider = function($) {
      return P($) === i;
    }, e.isElement = function($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === t;
    }, e.isForwardRef = function($) {
      return P($) === d;
    }, e.isFragment = function($) {
      return P($) === n;
    }, e.isLazy = function($) {
      return P($) === h;
    }, e.isMemo = function($) {
      return P($) === f;
    }, e.isPortal = function($) {
      return P($) === r;
    }, e.isProfiler = function($) {
      return P($) === a;
    }, e.isStrictMode = function($) {
      return P($) === o;
    }, e.isSuspense = function($) {
      return P($) === l;
    }, e.isValidElementType = function($) {
      return typeof $ == "string" || typeof $ == "function" || $ === n || $ === a || $ === _ || $ === o || $ === l || $ === p || $ === b || typeof $ == "object" && $ !== null && ($.$$typeof === h || $.$$typeof === f || $.$$typeof === i || $.$$typeof === s || $.$$typeof === d || $.$$typeof === w || $.$$typeof === m || $[0] === g);
    }, e.typeOf = P;
  }
}), npe = W({
  "../node_modules/pretty-format/node_modules/react-is/index.js"(e, t) {
    t.exports = rpe();
  }
}), ope = W({
  "../node_modules/pretty-format/build/plugins/ReactElement.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = o(npe()), r = mx();
    function n(h) {
      if (typeof WeakMap != "function") return null;
      var m = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
      return (n = /* @__PURE__ */ c(function(w) {
        return w ? g : m;
      }, "_getRequireWildcardCache"))(h);
    }
    c(n, "_getRequireWildcardCache");
    function o(h, m) {
      if (!m && h && h.__esModule)
        return h;
      if (h === null || typeof h != "object" && typeof h != "function")
        return { default: h };
      var g = n(m);
      if (g && g.has(h))
        return g.get(h);
      var w = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b in h)
        if (b !== "default" && Object.prototype.hasOwnProperty.call(h, b)) {
          var x = _ ? Object.getOwnPropertyDescriptor(h, b) : null;
          x && (x.get || x.set) ? Object.defineProperty(w, b, x) : w[b] = h[b];
        }
      return w.default = h, g && g.set(h, w), w;
    }
    c(o, "_interopRequireWildcard");
    var a = /* @__PURE__ */ c((h, m = []) => (Array.isArray(h) ? h.forEach((g) => {
      a(g, m);
    }) : h != null && h !== !1 && m.push(h), m), "getChildren"), i = /* @__PURE__ */ c((h) => {
      const m = h.type;
      if (typeof m == "string")
        return m;
      if (typeof m == "function")
        return m.displayName || m.name || "Unknown";
      if (t.isFragment(h))
        return "React.Fragment";
      if (t.isSuspense(h))
        return "React.Suspense";
      if (typeof m == "object" && m !== null) {
        if (t.isContextProvider(h))
          return "Context.Provider";
        if (t.isContextConsumer(h))
          return "Context.Consumer";
        if (t.isForwardRef(h)) {
          if (m.displayName)
            return m.displayName;
          const g = m.render.displayName || m.render.name || "";
          return g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef";
        }
        if (t.isMemo(h)) {
          const g = m.displayName || m.type.displayName || m.type.name || "";
          return g !== "" ? "Memo(" + g + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    }, "getType"), s = /* @__PURE__ */ c((h) => {
      const { props: m } = h;
      return Object.keys(m).filter((g) => g !== "children" && m[g] !== void 0).sort();
    }, "getPropKeys"), d = /* @__PURE__ */ c((h, m, g, w, _, b) => ++w > m.maxDepth ? (0, r.printElementAsLeaf)(i(h), m) : (0, r.printElement)(
      i(h),
      (0, r.printProps)(
        s(h),
        h.props,
        m,
        g + m.indent,
        w,
        _,
        b
      ),
      (0, r.printChildren)(
        a(h.props.children),
        m,
        g + m.indent,
        w,
        _,
        b
      ),
      m,
      g
    ), "serialize");
    e.serialize = d;
    var l = /* @__PURE__ */ c((h) => h != null && t.isElement(h), "test");
    e.test = l;
    var p = {
      serialize: d,
      test: l
    }, f = p;
    e.default = f;
  }
}), ape = W({
  "../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = mx(), r = (function() {
      return typeof globalThis < "u" ? globalThis : typeof r < "u" ? r : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), n = r["jest-symbol-do-not-touch"] || r.Symbol, o = typeof n == "function" && n.for ? n.for("react.test.json") : 245830487, a = /* @__PURE__ */ c((p) => {
      const { props: f } = p;
      return f ? Object.keys(f).filter((h) => f[h] !== void 0).sort() : [];
    }, "getPropKeys"), i = /* @__PURE__ */ c((p, f, h, m, g, w) => ++m > f.maxDepth ? (0, t.printElementAsLeaf)(p.type, f) : (0, t.printElement)(
      p.type,
      p.props ? (0, t.printProps)(
        a(p),
        p.props,
        f,
        h + f.indent,
        m,
        g,
        w
      ) : "",
      p.children ? (0, t.printChildren)(
        p.children,
        f,
        h + f.indent,
        m,
        g,
        w
      ) : "",
      f,
      h
    ), "serialize");
    e.serialize = i;
    var s = /* @__PURE__ */ c((p) => p && p.$$typeof === o, "test");
    e.test = s;
    var d = {
      serialize: i,
      test: s
    }, l = d;
    e.default = l;
  }
}), ipe = W({
  "../node_modules/pretty-format/build/index.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = e.DEFAULT_OPTIONS = void 0, e.format = Se, e.plugins = void 0;
    var t = p(pF()), r = ry(), n = p(
      Kde()
    ), o = p(Xde()), a = p(Qde()), i = p(epe()), s = p(tpe()), d = p(ope()), l = p(
      ape()
    );
    function p(q) {
      return q && q.__esModule ? q : { default: q };
    }
    c(p, "_interopRequireDefault");
    var f = Object.prototype.toString, h = Date.prototype.toISOString, m = Error.prototype.toString, g = RegExp.prototype.toString, w = /* @__PURE__ */ c((q) => typeof q.constructor == "function" && q.constructor.name || "Object", "getConstructorName"), _ = /* @__PURE__ */ c((q) => typeof window < "u" && q === window, "isWindow"), b = /^Symbol\((.*)\)(.*)$/, x = /\n/gi, P = class extends Error {
      constructor(q, te) {
        super(q), this.stack = te, this.name = this.constructor.name;
      }
    };
    c(P, "PrettyFormatPluginError");
    var R = P;
    function N(q) {
      return q === "[object Array]" || q === "[object ArrayBuffer]" || q === "[object DataView]" || q === "[object Float32Array]" || q === "[object Float64Array]" || q === "[object Int8Array]" || q === "[object Int16Array]" || q === "[object Int32Array]" || q === "[object Uint8Array]" || q === "[object Uint8ClampedArray]" || q === "[object Uint16Array]" || q === "[object Uint32Array]";
    }
    c(N, "isToStringedArrayType");
    function C(q) {
      return Object.is(q, -0) ? "-0" : String(q);
    }
    c(C, "printNumber");
    function A(q) {
      return `${q}n`;
    }
    c(A, "printBigInt");
    function E(q, te) {
      return te ? "[Function " + (q.name || "anonymous") + "]" : "[Function]";
    }
    c(E, "printFunction");
    function T(q) {
      return String(q).replace(b, "Symbol($1)");
    }
    c(T, "printSymbol");
    function O(q) {
      return "[" + m.call(q) + "]";
    }
    c(O, "printError");
    function k(q, te, ae, ue) {
      if (q === !0 || q === !1)
        return "" + q;
      if (q === void 0)
        return "undefined";
      if (q === null)
        return "null";
      const se = typeof q;
      if (se === "number")
        return C(q);
      if (se === "bigint")
        return A(q);
      if (se === "string")
        return ue ? '"' + q.replace(/"|\\/g, "\\$&") + '"' : '"' + q + '"';
      if (se === "function")
        return E(q, te);
      if (se === "symbol")
        return T(q);
      const ye = f.call(q);
      return ye === "[object WeakMap]" ? "WeakMap {}" : ye === "[object WeakSet]" ? "WeakSet {}" : ye === "[object Function]" || ye === "[object GeneratorFunction]" ? E(q, te) : ye === "[object Symbol]" ? T(q) : ye === "[object Date]" ? isNaN(+q) ? "Date { NaN }" : h.call(q) : ye === "[object Error]" ? O(q) : ye === "[object RegExp]" ? ae ? g.call(q).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : g.call(q) : q instanceof Error ? O(q) : null;
    }
    c(k, "printBasicValue");
    function M(q, te, ae, ue, se, ye) {
      if (se.indexOf(q) !== -1)
        return "[Circular]";
      se = se.slice(), se.push(q);
      const fe = ++ue > te.maxDepth, Ae = te.min;
      if (te.callToJSON && !fe && q.toJSON && typeof q.toJSON == "function" && !ye)
        return D(q.toJSON(), te, ae, ue, se, !0);
      const Fe = f.call(q);
      return Fe === "[object Arguments]" ? fe ? "[Arguments]" : (Ae ? "" : "Arguments ") + "[" + (0, r.printListItems)(
        q,
        te,
        ae,
        ue,
        se,
        D
      ) + "]" : N(Fe) ? fe ? "[" + q.constructor.name + "]" : (Ae || !te.printBasicPrototype && q.constructor.name === "Array" ? "" : q.constructor.name + " ") + "[" + (0, r.printListItems)(
        q,
        te,
        ae,
        ue,
        se,
        D
      ) + "]" : Fe === "[object Map]" ? fe ? "[Map]" : "Map {" + (0, r.printIteratorEntries)(
        q.entries(),
        te,
        ae,
        ue,
        se,
        D,
        " => "
      ) + "}" : Fe === "[object Set]" ? fe ? "[Set]" : "Set {" + (0, r.printIteratorValues)(
        q.values(),
        te,
        ae,
        ue,
        se,
        D
      ) + "}" : fe || _(q) ? "[" + w(q) + "]" : (Ae || !te.printBasicPrototype && w(q) === "Object" ? "" : w(q) + " ") + "{" + (0, r.printObjectProperties)(
        q,
        te,
        ae,
        ue,
        se,
        D
      ) + "}";
    }
    c(M, "printComplexValue");
    function L(q) {
      return q.serialize != null;
    }
    c(L, "isNewPlugin");
    function $(q, te, ae, ue, se, ye) {
      let fe;
      try {
        fe = L(q) ? q.serialize(te, ae, ue, se, ye, D) : q.print(
          te,
          (Ae) => D(Ae, ae, ue, se, ye),
          (Ae) => {
            const Fe = ue + ae.indent;
            return Fe + Ae.replace(x, `
` + Fe);
          },
          {
            edgeSpacing: ae.spacingOuter,
            min: ae.min,
            spacing: ae.spacingInner
          },
          ae.colors
        );
      } catch (Ae) {
        throw new R(Ae.message, Ae.stack);
      }
      if (typeof fe != "string")
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof fe}".`
        );
      return fe;
    }
    c($, "printPlugin");
    function I(q, te) {
      for (let ae = 0; ae < q.length; ae++)
        try {
          if (q[ae].test(te))
            return q[ae];
        } catch (ue) {
          throw new R(ue.message, ue.stack);
        }
      return null;
    }
    c(I, "findPlugin");
    function D(q, te, ae, ue, se, ye) {
      const fe = I(te.plugins, q);
      if (fe !== null)
        return $(fe, q, te, ae, ue, se);
      const Ae = k(
        q,
        te.printFunctionName,
        te.escapeRegex,
        te.escapeString
      );
      return Ae !== null ? Ae : M(
        q,
        te,
        ae,
        ue,
        se,
        ye
      );
    }
    c(D, "printer");
    var F = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    }, J = Object.keys(F), oe = {
      callToJSON: !0,
      compareKeys: void 0,
      escapeRegex: !1,
      escapeString: !0,
      highlight: !1,
      indent: 2,
      maxDepth: 1 / 0,
      min: !1,
      plugins: [],
      printBasicPrototype: !0,
      printFunctionName: !0,
      theme: F
    };
    e.DEFAULT_OPTIONS = oe;
    function ce(q) {
      if (Object.keys(q).forEach((te) => {
        if (!oe.hasOwnProperty(te))
          throw new Error(`pretty-format: Unknown option "${te}".`);
      }), q.min && q.indent !== void 0 && q.indent !== 0)
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      if (q.theme !== void 0) {
        if (q.theme === null)
          throw new Error('pretty-format: Option "theme" must not be null.');
        if (typeof q.theme != "object")
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof q.theme}".`
          );
      }
    }
    c(ce, "validateOptions");
    var le = /* @__PURE__ */ c((q) => J.reduce((te, ae) => {
      const ue = q.theme && q.theme[ae] !== void 0 ? q.theme[ae] : F[ae], se = ue && t.default[ue];
      if (se && typeof se.close == "string" && typeof se.open == "string")
        te[ae] = se;
      else
        throw new Error(
          `pretty-format: Option "theme" has a key "${ae}" whose value "${ue}" is undefined in ansi-styles.`
        );
      return te;
    }, /* @__PURE__ */ Object.create(null)), "getColorsHighlight"), re = /* @__PURE__ */ c(() => J.reduce((q, te) => (q[te] = {
      close: "",
      open: ""
    }, q), /* @__PURE__ */ Object.create(null)), "getColorsEmpty"), we = /* @__PURE__ */ c((q) => q && q.printFunctionName !== void 0 ? q.printFunctionName : oe.printFunctionName, "getPrintFunctionName"), _e = /* @__PURE__ */ c((q) => q && q.escapeRegex !== void 0 ? q.escapeRegex : oe.escapeRegex, "getEscapeRegex"), de = /* @__PURE__ */ c((q) => q && q.escapeString !== void 0 ? q.escapeString : oe.escapeString, "getEscapeString"), ne = /* @__PURE__ */ c((q) => {
      var te;
      return {
        callToJSON: q && q.callToJSON !== void 0 ? q.callToJSON : oe.callToJSON,
        colors: q && q.highlight ? le(q) : re(),
        compareKeys: q && typeof q.compareKeys == "function" ? q.compareKeys : oe.compareKeys,
        escapeRegex: _e(q),
        escapeString: de(q),
        indent: q && q.min ? "" : $e(
          q && q.indent !== void 0 ? q.indent : oe.indent
        ),
        maxDepth: q && q.maxDepth !== void 0 ? q.maxDepth : oe.maxDepth,
        min: q && q.min !== void 0 ? q.min : oe.min,
        plugins: q && q.plugins !== void 0 ? q.plugins : oe.plugins,
        printBasicPrototype: (te = q?.printBasicPrototype) !== null && te !== void 0 ? te : !0,
        printFunctionName: we(q),
        spacingInner: q && q.min ? " " : `
`,
        spacingOuter: q && q.min ? "" : `
`
      };
    }, "getConfig");
    function $e(q) {
      return new Array(q + 1).join(" ");
    }
    c($e, "createIndent");
    function Se(q, te) {
      if (te && (ce(te), te.plugins)) {
        const ue = I(te.plugins, q);
        if (ue !== null)
          return $(ue, q, ne(te), "", 0, []);
      }
      const ae = k(
        q,
        we(te),
        _e(te),
        de(te)
      );
      return ae !== null ? ae : M(q, ne(te), "", 0, []);
    }
    c(Se, "format");
    var nt = {
      AsymmetricMatcher: n.default,
      ConvertAnsi: o.default,
      DOMCollection: a.default,
      DOMElement: i.default,
      Immutable: s.default,
      ReactElement: d.default,
      ReactTestComponent: l.default
    };
    e.plugins = nt;
    var We = Se;
    e.default = We;
  }
}), spe = W({
  "../node_modules/lz-string/libs/lz-string.js"(e, t) {
    var r = (function() {
      var n = String.fromCharCode, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", i = {};
      function s(l, p) {
        if (!i[l]) {
          i[l] = {};
          for (var f = 0; f < l.length; f++)
            i[l][l.charAt(f)] = f;
        }
        return i[l][p];
      }
      c(s, "getBaseValue");
      var d = {
        compressToBase64: /* @__PURE__ */ c(function(l) {
          if (l == null) return "";
          var p = d._compress(l, 6, function(f) {
            return o.charAt(f);
          });
          switch (p.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return p;
            case 1:
              return p + "===";
            case 2:
              return p + "==";
            case 3:
              return p + "=";
          }
        }, "compressToBase64"),
        decompressFromBase64: /* @__PURE__ */ c(function(l) {
          return l == null ? "" : l == "" ? null : d._decompress(l.length, 32, function(p) {
            return s(o, l.charAt(p));
          });
        }, "decompressFromBase64"),
        compressToUTF16: /* @__PURE__ */ c(function(l) {
          return l == null ? "" : d._compress(l, 15, function(p) {
            return n(p + 32);
          }) + " ";
        }, "compressToUTF16"),
        decompressFromUTF16: /* @__PURE__ */ c(function(l) {
          return l == null ? "" : l == "" ? null : d._decompress(l.length, 16384, function(p) {
            return l.charCodeAt(p) - 32;
          });
        }, "decompressFromUTF16"),
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: /* @__PURE__ */ c(function(l) {
          for (var p = d.compress(l), f = new Uint8Array(p.length * 2), h = 0, m = p.length; h < m; h++) {
            var g = p.charCodeAt(h);
            f[h * 2] = g >>> 8, f[h * 2 + 1] = g % 256;
          }
          return f;
        }, "compressToUint8Array"),
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: /* @__PURE__ */ c(function(l) {
          if (l == null)
            return d.decompress(l);
          for (var p = new Array(l.length / 2), f = 0, h = p.length; f < h; f++)
            p[f] = l[f * 2] * 256 + l[f * 2 + 1];
          var m = [];
          return p.forEach(function(g) {
            m.push(n(g));
          }), d.decompress(m.join(""));
        }, "decompressFromUint8Array"),
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: /* @__PURE__ */ c(function(l) {
          return l == null ? "" : d._compress(l, 6, function(p) {
            return a.charAt(p);
          });
        }, "compressToEncodedURIComponent"),
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: /* @__PURE__ */ c(function(l) {
          return l == null ? "" : l == "" ? null : (l = l.replace(/ /g, "+"), d._decompress(l.length, 32, function(p) {
            return s(a, l.charAt(p));
          }));
        }, "decompressFromEncodedURIComponent"),
        compress: /* @__PURE__ */ c(function(l) {
          return d._compress(l, 16, function(p) {
            return n(p);
          });
        }, "compress"),
        _compress: /* @__PURE__ */ c(function(l, p, f) {
          if (l == null) return "";
          var h, m, g = {}, w = {}, _ = "", b = "", x = "", P = 2, R = 3, N = 2, C = [], A = 0, E = 0, T;
          for (T = 0; T < l.length; T += 1)
            if (_ = l.charAt(T), Object.prototype.hasOwnProperty.call(g, _) || (g[_] = R++, w[_] = !0), b = x + _, Object.prototype.hasOwnProperty.call(g, b))
              x = b;
            else {
              if (Object.prototype.hasOwnProperty.call(w, x)) {
                if (x.charCodeAt(0) < 256) {
                  for (h = 0; h < N; h++)
                    A = A << 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++;
                  for (m = x.charCodeAt(0), h = 0; h < 8; h++)
                    A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
                } else {
                  for (m = 1, h = 0; h < N; h++)
                    A = A << 1 | m, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = 0;
                  for (m = x.charCodeAt(0), h = 0; h < 16; h++)
                    A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
                }
                P--, P == 0 && (P = Math.pow(2, N), N++), delete w[x];
              } else
                for (m = g[x], h = 0; h < N; h++)
                  A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
              P--, P == 0 && (P = Math.pow(2, N), N++), g[b] = R++, x = String(_);
            }
          if (x !== "") {
            if (Object.prototype.hasOwnProperty.call(w, x)) {
              if (x.charCodeAt(0) < 256) {
                for (h = 0; h < N; h++)
                  A = A << 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++;
                for (m = x.charCodeAt(0), h = 0; h < 8; h++)
                  A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
              } else {
                for (m = 1, h = 0; h < N; h++)
                  A = A << 1 | m, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = 0;
                for (m = x.charCodeAt(0), h = 0; h < 16; h++)
                  A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
              }
              P--, P == 0 && (P = Math.pow(2, N), N++), delete w[x];
            } else
              for (m = g[x], h = 0; h < N; h++)
                A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
            P--, P == 0 && (P = Math.pow(2, N), N++);
          }
          for (m = 2, h = 0; h < N; h++)
            A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
          for (; ; )
            if (A = A << 1, E == p - 1) {
              C.push(f(A));
              break;
            } else E++;
          return C.join("");
        }, "_compress"),
        decompress: /* @__PURE__ */ c(function(l) {
          return l == null ? "" : l == "" ? null : d._decompress(l.length, 32768, function(p) {
            return l.charCodeAt(p);
          });
        }, "decompress"),
        _decompress: /* @__PURE__ */ c(function(l, p, f) {
          var h = [], m = 4, g = 4, w = 3, _ = "", b = [], x, P, R, N, C, A, E, T = { val: f(0), position: p, index: 1 };
          for (x = 0; x < 3; x += 1)
            h[x] = x;
          for (R = 0, C = Math.pow(2, 2), A = 1; A != C; )
            N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
          switch (R) {
            case 0:
              for (R = 0, C = Math.pow(2, 8), A = 1; A != C; )
                N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
              E = n(R);
              break;
            case 1:
              for (R = 0, C = Math.pow(2, 16), A = 1; A != C; )
                N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
              E = n(R);
              break;
            case 2:
              return "";
          }
          for (h[3] = E, P = E, b.push(E); ; ) {
            if (T.index > l)
              return "";
            for (R = 0, C = Math.pow(2, w), A = 1; A != C; )
              N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
            switch (E = R) {
              case 0:
                for (R = 0, C = Math.pow(2, 8), A = 1; A != C; )
                  N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
                h[g++] = n(R), E = g - 1, m--;
                break;
              case 1:
                for (R = 0, C = Math.pow(2, 16), A = 1; A != C; )
                  N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
                h[g++] = n(R), E = g - 1, m--;
                break;
              case 2:
                return b.join("");
            }
            if (m == 0 && (m = Math.pow(2, w), w++), h[E])
              _ = h[E];
            else if (E === g)
              _ = P + P.charAt(0);
            else
              return null;
            b.push(_), h[g++] = P + _.charAt(0), m--, P = _, m == 0 && (m = Math.pow(2, w), w++);
          }
        }, "_decompress")
      };
      return d;
    })();
    typeof define == "function" && define.amd ? define(function() {
      return r;
    }) : typeof t < "u" && t != null ? t.exports = r : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
      return r;
    });
  }
}), fF = Object.defineProperty, Z = /* @__PURE__ */ c((e, t) => fF(e, "name", { value: t, configurable: !0 }), "__name"), yx = /* @__PURE__ */ c((e, t) => {
  for (var r in t)
    fF(e, r, { get: t[r], enumerable: !0 });
}, "__export"), to = {};
yx(to, {
  addChainableMethod: /* @__PURE__ */ c(() => hy, "addChainableMethod"),
  addLengthGuard: /* @__PURE__ */ c(() => Sc, "addLengthGuard"),
  addMethod: /* @__PURE__ */ c(() => dy, "addMethod"),
  addProperty: /* @__PURE__ */ c(() => uy, "addProperty"),
  checkError: /* @__PURE__ */ c(() => Hr, "checkError"),
  compareByInspect: /* @__PURE__ */ c(() => fd, "compareByInspect"),
  eql: /* @__PURE__ */ c(() => mF, "eql"),
  expectTypes: /* @__PURE__ */ c(() => xx, "expectTypes"),
  flag: /* @__PURE__ */ c(() => Ie, "flag"),
  getActual: /* @__PURE__ */ c(() => np, "getActual"),
  getMessage: /* @__PURE__ */ c(() => ay, "getMessage"),
  getName: /* @__PURE__ */ c(() => ap, "getName"),
  getOperator: /* @__PURE__ */ c(() => by, "getOperator"),
  getOwnEnumerableProperties: /* @__PURE__ */ c(() => gy, "getOwnEnumerableProperties"),
  getOwnEnumerablePropertySymbols: /* @__PURE__ */ c(() => yy, "getOwnEnumerablePropertySymbols"),
  getPathInfo: /* @__PURE__ */ c(() => cy, "getPathInfo"),
  hasProperty: /* @__PURE__ */ c(() => op, "hasProperty"),
  inspect: /* @__PURE__ */ c(() => ze, "inspect"),
  isNaN: /* @__PURE__ */ c(() => ih, "isNaN"),
  isNumeric: /* @__PURE__ */ c(() => Zt, "isNumeric"),
  isProxyEnabled: /* @__PURE__ */ c(() => xc, "isProxyEnabled"),
  isRegExp: /* @__PURE__ */ c(() => hd, "isRegExp"),
  objDisplay: /* @__PURE__ */ c(() => Oa, "objDisplay"),
  overwriteChainableMethod: /* @__PURE__ */ c(() => my, "overwriteChainableMethod"),
  overwriteMethod: /* @__PURE__ */ c(() => fy, "overwriteMethod"),
  overwriteProperty: /* @__PURE__ */ c(() => py, "overwriteProperty"),
  proxify: /* @__PURE__ */ c(() => Ps, "proxify"),
  test: /* @__PURE__ */ c(() => ny, "test"),
  transferFlags: /* @__PURE__ */ c(() => vn, "transferFlags"),
  type: /* @__PURE__ */ c(() => st, "type")
});
var Hr = {};
yx(Hr, {
  compatibleConstructor: /* @__PURE__ */ c(() => vx, "compatibleConstructor"),
  compatibleInstance: /* @__PURE__ */ c(() => bx, "compatibleInstance"),
  compatibleMessage: /* @__PURE__ */ c(() => wx, "compatibleMessage"),
  getConstructorName: /* @__PURE__ */ c(() => _x, "getConstructorName"),
  getMessage: /* @__PURE__ */ c(() => Ex, "getMessage")
});
function rp(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
c(rp, "isErrorInstance");
Z(rp, "isErrorInstance");
function gx(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
c(gx, "isRegExp");
Z(gx, "isRegExp");
function bx(e, t) {
  return rp(t) && e === t;
}
c(bx, "compatibleInstance");
Z(bx, "compatibleInstance");
function vx(e, t) {
  return rp(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : !1;
}
c(vx, "compatibleConstructor");
Z(vx, "compatibleConstructor");
function wx(e, t) {
  const r = typeof e == "string" ? e : e.message;
  return gx(t) ? t.test(r) : typeof t == "string" ? r.indexOf(t) !== -1 : !1;
}
c(wx, "compatibleMessage");
Z(wx, "compatibleMessage");
function _x(e) {
  let t = e;
  return rp(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
c(_x, "getConstructorName");
Z(_x, "getConstructorName");
function Ex(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
c(Ex, "getMessage");
Z(Ex, "getMessage");
function Ie(e, t, r) {
  let n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    n[t] = r;
  else
    return n[t];
}
c(Ie, "flag");
Z(Ie, "flag");
function ny(e, t) {
  let r = Ie(e, "negate"), n = t[0];
  return r ? !n : n;
}
c(ny, "test");
Z(ny, "test");
function st(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
c(st, "type");
Z(st, "type");
var lpe = "captureStackTrace" in Error, eu, tt = (eu = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(e = "Unspecified AssertionError", t, r) {
    super(e), this.message = e, lpe && Error.captureStackTrace(this, r || eu);
    for (const n in t)
      n in this || (this[n] = t[n]);
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, c(eu, "_AssertionError"), Z(eu, "AssertionError"), eu);
function xx(e, t) {
  let r = Ie(e, "message"), n = Ie(e, "ssfi");
  r = r ? r + ": " : "", e = Ie(e, "object"), t = t.map(function(i) {
    return i.toLowerCase();
  }), t.sort();
  let o = t.map(function(i, s) {
    let d = ~["a", "e", "i", "o", "u"].indexOf(i.charAt(0)) ? "an" : "a";
    return (t.length > 1 && s === t.length - 1 ? "or " : "") + d + " " + i;
  }).join(", "), a = st(e).toLowerCase();
  if (!t.some(function(i) {
    return a === i;
  }))
    throw new tt(
      r + "object tested must be " + o + ", but " + a + " given",
      void 0,
      n
    );
}
c(xx, "expectTypes");
Z(xx, "expectTypes");
function np(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
c(np, "getActual");
Z(np, "getActual");
var sO = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, cpe = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, Ml = "â€¦";
function Sx(e, t) {
  const r = sO[cpe[t]] || sO[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
c(Sx, "colorise");
Z(Sx, "colorise");
function Tx({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: n = !0,
  showProxy: o = !1,
  maxArrayLength: a = 1 / 0,
  breakLength: i = 1 / 0,
  seen: s = [],
  // eslint-disable-next-line no-shadow
  truncate: d = 1 / 0,
  stylize: l = String
} = {}, p) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(a),
    breakLength: Number(i),
    truncate: Number(d),
    seen: s,
    inspect: p,
    stylize: l
  };
  return f.colors && (f.stylize = Sx), f;
}
c(Tx, "normaliseOptions");
Z(Tx, "normaliseOptions");
function Ax(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
c(Ax, "isHighSurrogate");
Z(Ax, "isHighSurrogate");
function go(e, t, r = Ml) {
  e = String(e);
  const n = r.length, o = e.length;
  if (n > t && o > n)
    return r;
  if (o > t && o > n) {
    let a = t - n;
    return a > 0 && Ax(e[a - 1]) && (a = a - 1), `${e.slice(0, a)}${r}`;
  }
  return e;
}
c(go, "truncate");
Z(go, "truncate");
function Xr(e, t, r, n = ", ") {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0)
    return "";
  const a = t.truncate;
  let i = "", s = "", d = "";
  for (let l = 0; l < o; l += 1) {
    const p = l + 1 === e.length, f = l + 2 === e.length;
    d = `${Ml}(${e.length - l})`;
    const h = e[l];
    t.truncate = a - i.length - (p ? 0 : n.length);
    const m = s || r(h, t) + (p ? "" : n), g = i.length + m.length, w = g + d.length;
    if (p && g > a && i.length + d.length <= a || !p && !f && w > a || (s = p ? "" : r(e[l + 1], t) + (f ? "" : n), !p && f && w > a && g + s.length > a))
      break;
    if (i += m, !p && !f && g + s.length >= a) {
      d = `${Ml}(${e.length - l - 1})`;
      break;
    }
    d = "";
  }
  return `${i}${d}`;
}
c(Xr, "inspectList");
Z(Xr, "inspectList");
function $x(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
c($x, "quoteComplexKey");
Z($x, "quoteComplexKey");
function as([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = $x(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
c(as, "inspectProperty");
Z(as, "inspectProperty");
function Cx(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const n = Xr(e, t);
  t.truncate -= n.length;
  let o = "";
  return r.length && (o = Xr(r.map((a) => [a, e[a]]), t, as)), `[ ${n}${o ? `, ${o}` : ""} ]`;
}
c(Cx, "inspectArray");
Z(Cx, "inspectArray");
var upe = Z((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function On(e, t) {
  const r = upe(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let o = "";
  for (let i = 0; i < e.length; i++) {
    const s = `${t.stylize(go(e[i], t.truncate), "number")}${i === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= s.length, e[i] !== e.length && t.truncate <= 3) {
      o += `${Ml}(${e.length - e[i] + 1})`;
      break;
    }
    o += s;
  }
  let a = "";
  return n.length && (a = Xr(n.map((i) => [i, e[i]]), t, as)), `${r}[ ${o}${a ? `, ${a}` : ""} ]`;
}
c(On, "inspectTypedArray");
Z(On, "inspectTypedArray");
function kx(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const n = r.split("T"), o = n[0];
  return t.stylize(`${o}T${go(n[1], t.truncate - o.length - 1)}`, "date");
}
c(kx, "inspectDate");
Z(kx, "inspectDate");
function Jf(e, t) {
  const r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${go(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
c(Jf, "inspectFunction");
Z(Jf, "inspectFunction");
function Px([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
c(Px, "inspectMapEntry");
Z(Px, "inspectMapEntry");
function Ox(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
c(Ox, "mapToEntries");
Z(Ox, "mapToEntries");
function Rx(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Xr(Ox(e), t, Px)} }`);
}
c(Rx, "inspectMap");
Z(Rx, "inspectMap");
var dpe = Number.isNaN || ((e) => e !== e);
function Wf(e, t) {
  return dpe(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(go(String(e), t.truncate), "number");
}
c(Wf, "inspectNumber");
Z(Wf, "inspectNumber");
function Gf(e, t) {
  let r = go(e.toString(), t.truncate - 1);
  return r !== Ml && (r += "n"), t.stylize(r, "bigint");
}
c(Gf, "inspectBigInt");
Z(Gf, "inspectBigInt");
function jx(e, t) {
  const r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), o = e.source;
  return t.stylize(`/${go(o, n)}/${r}`, "regexp");
}
c(jx, "inspectRegExp");
Z(jx, "inspectRegExp");
function Ix(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
c(Ix, "arrayFromSet");
Z(Ix, "arrayFromSet");
function Nx(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Xr(Ix(e), t)} }`);
}
c(Nx, "inspectSet");
Z(Nx, "inspectSet");
var lO = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), ppe = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, fpe = 16;
function Mx(e) {
  return ppe[e] || `\\u${`0000${e.charCodeAt(0).toString(fpe)}`.slice(-4)}`;
}
c(Mx, "escape");
Z(Mx, "escape");
function Kf(e, t) {
  return lO.test(e) && (e = e.replace(lO, Mx)), t.stylize(`'${go(e, t.truncate - 2)}'`, "string");
}
c(Kf, "inspectString");
Z(Kf, "inspectString");
function Yf(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
c(Yf, "inspectSymbol");
Z(Yf, "inspectSymbol");
var hpe = Z(() => "Promise{â€¦}", "getPromiseValue"), mpe = hpe;
function bl(e, t) {
  const r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const o = Xr(r.map((s) => [s, e[s]]), t, as), a = Xr(n.map((s) => [s, e[s]]), t, as);
  t.seen.pop();
  let i = "";
  return o && a && (i = ", "), `{ ${o}${i}${a} }`;
}
c(bl, "inspectObject");
Z(bl, "inspectObject");
var av = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function Dx(e, t) {
  let r = "";
  return av && av in e && (r = e[av]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${bl(e, t)}`;
}
c(Dx, "inspectClass");
Z(Dx, "inspectClass");
function qx(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Xr(e, t)} ]`);
}
c(qx, "inspectArguments");
Z(qx, "inspectArguments");
var ype = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function Lx(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((i) => ype.indexOf(i) === -1), n = e.name;
  t.truncate -= n.length;
  let o = "";
  if (typeof e.message == "string" ? o = go(e.message, t.truncate) : r.unshift("message"), o = o ? `: ${o}` : "", t.truncate -= o.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = Xr(r.map((i) => [i, e[i]]), t, as);
  return `${n}${o}${a ? ` { ${a} }` : ""}`;
}
c(Lx, "inspectObject2");
Z(Lx, "inspectObject");
function Fx([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
c(Fx, "inspectAttribute");
Z(Fx, "inspectAttribute");
function ud(e, t) {
  return Xr(e, t, Ux, `
`);
}
c(ud, "inspectNodeCollection");
Z(ud, "inspectNodeCollection");
function Ux(e, t) {
  switch (e.nodeType) {
    case 1:
      return oy(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
c(Ux, "inspectNode");
Z(Ux, "inspectNode");
function oy(e, t) {
  const r = e.getAttributeNames(), n = e.tagName.toLowerCase(), o = t.stylize(`<${n}`, "special"), a = t.stylize(">", "special"), i = t.stylize(`</${n}>`, "special");
  t.truncate -= n.length * 2 + 5;
  let s = "";
  r.length > 0 && (s += " ", s += Xr(r.map((p) => [p, e.getAttribute(p)]), t, Fx, " ")), t.truncate -= s.length;
  const d = t.truncate;
  let l = ud(e.children, t);
  return l && l.length > d && (l = `${Ml}(${e.children.length})`), `${o}${s}${a}${l}${i}`;
}
c(oy, "inspectHTML");
Z(oy, "inspectHTML");
var gpe = typeof Symbol == "function" && typeof Symbol.for == "function", iv = gpe ? Symbol.for("chai/inspect") : "@@chai/inspect", sv = Symbol.for("nodejs.util.inspect.custom"), cO = /* @__PURE__ */ new WeakMap(), uO = {}, dO = {
  undefined: Z((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: Z((e, t) => t.stylize("null", "null"), "null"),
  boolean: Z((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: Z((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: Wf,
  Number: Wf,
  bigint: Gf,
  BigInt: Gf,
  string: Kf,
  String: Kf,
  function: Jf,
  Function: Jf,
  symbol: Yf,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: Yf,
  Array: Cx,
  Date: kx,
  Map: Rx,
  Set: Nx,
  RegExp: jx,
  Promise: mpe,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: Z((e, t) => t.stylize("WeakSet{â€¦}", "special"), "WeakSet"),
  WeakMap: Z((e, t) => t.stylize("WeakMap{â€¦}", "special"), "WeakMap"),
  Arguments: qx,
  Int8Array: On,
  Uint8Array: On,
  Uint8ClampedArray: On,
  Int16Array: On,
  Uint16Array: On,
  Int32Array: On,
  Uint32Array: On,
  Float32Array: On,
  Float64Array: On,
  Generator: Z(() => "", "Generator"),
  DataView: Z(() => "", "DataView"),
  ArrayBuffer: Z(() => "", "ArrayBuffer"),
  Error: Lx,
  HTMLCollection: ud,
  NodeList: ud
}, bpe = Z((e, t, r) => iv in e && typeof e[iv] == "function" ? e[iv](t) : sv in e && typeof e[sv] == "function" ? e[sv](t.depth, t) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && cO.has(e.constructor) ? cO.get(e.constructor)(e, t) : uO[r] ? uO[r](e, t) : "", "inspectCustom"), vpe = Object.prototype.toString;
function dd(e, t = {}) {
  const r = Tx(t, dd), { customInspect: n } = r;
  let o = e === null ? "null" : typeof e;
  if (o === "object" && (o = vpe.call(e).slice(8, -1)), o in dO)
    return dO[o](e, r);
  if (n && e) {
    const i = bpe(e, r, o);
    if (i)
      return typeof i == "string" ? i : dd(i, r);
  }
  const a = e ? Object.getPrototypeOf(e) : !1;
  return a === Object.prototype || a === null ? bl(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? oy(e, r) : "constructor" in e ? e.constructor !== Object ? Dx(e, r) : bl(e, r) : e === Object(e) ? bl(e, r) : r.stylize(String(e), o);
}
c(dd, "inspect");
Z(dd, "inspect");
var Sr = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function ze(e, t, r, n) {
  let o = {
    colors: n,
    depth: typeof r > "u" ? 2 : r,
    showHidden: t,
    truncate: Sr.truncateThreshold ? Sr.truncateThreshold : 1 / 0
  };
  return dd(e, o);
}
c(ze, "inspect2");
Z(ze, "inspect");
function Oa(e) {
  let t = ze(e), r = Object.prototype.toString.call(e);
  if (Sr.truncateThreshold && t.length >= Sr.truncateThreshold) {
    if (r === "[object Function]")
      return !e.name || e.name === "" ? "[Function]" : "[Function: " + e.name + "]";
    if (r === "[object Array]")
      return "[ Array(" + e.length + ") ]";
    if (r === "[object Object]") {
      let n = Object.keys(e);
      return "{ Object (" + (n.length > 2 ? n.splice(0, 2).join(", ") + ", ..." : n.join(", ")) + ") }";
    } else
      return t;
  } else
    return t;
}
c(Oa, "objDisplay");
Z(Oa, "objDisplay");
function ay(e, t) {
  let r = Ie(e, "negate"), n = Ie(e, "object"), o = t[3], a = np(e, t), i = r ? t[2] : t[1], s = Ie(e, "message");
  return typeof i == "function" && (i = i()), i = i || "", i = i.replace(/#\{this\}/g, function() {
    return Oa(n);
  }).replace(/#\{act\}/g, function() {
    return Oa(a);
  }).replace(/#\{exp\}/g, function() {
    return Oa(o);
  }), s ? s + ": " + i : i;
}
c(ay, "getMessage2");
Z(ay, "getMessage");
function vn(e, t, r) {
  let n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), r = arguments.length === 3 ? r : !0;
  for (let o in n)
    (r || o !== "object" && o !== "ssfi" && o !== "lockSsfi" && o != "message") && (t.__flags[o] = n[o]);
}
c(vn, "transferFlags");
Z(vn, "transferFlags");
function Xf(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
c(Xf, "type2");
Z(Xf, "type");
function iy() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
c(iy, "FakeMap");
Z(iy, "FakeMap");
iy.prototype = {
  get: Z(/* @__PURE__ */ c(function(e) {
    return e[this._key];
  }, "get"), "get"),
  set: Z(/* @__PURE__ */ c(function(e, t) {
    Object.isExtensible(e) && Object.defineProperty(e, this._key, {
      value: t,
      configurable: !0
    });
  }, "set"), "set")
};
var hF = typeof WeakMap == "function" ? WeakMap : iy;
function Qf(e, t, r) {
  if (!r || Ha(e) || Ha(t))
    return null;
  var n = r.get(e);
  if (n) {
    var o = n.get(t);
    if (typeof o == "boolean")
      return o;
  }
  return null;
}
c(Qf, "memoizeCompare");
Z(Qf, "memoizeCompare");
function sl(e, t, r, n) {
  if (!(!r || Ha(e) || Ha(t))) {
    var o = r.get(e);
    o ? o.set(t, n) : (o = new hF(), o.set(t, n), r.set(e, o));
  }
}
c(sl, "memoizeSet");
Z(sl, "memoizeSet");
var mF = Ec;
function Ec(e, t, r) {
  if (r && r.comparator)
    return Zf(e, t, r);
  var n = sy(e, t);
  return n !== null ? n : Zf(e, t, r);
}
c(Ec, "deepEqual");
Z(Ec, "deepEqual");
function sy(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? !0 : Ha(e) || Ha(t) ? !1 : null;
}
c(sy, "simpleEqual");
Z(sy, "simpleEqual");
function Zf(e, t, r) {
  r = r || {}, r.memoize = r.memoize === !1 ? !1 : r.memoize || new hF();
  var n = r && r.comparator, o = Qf(e, t, r.memoize);
  if (o !== null)
    return o;
  var a = Qf(t, e, r.memoize);
  if (a !== null)
    return a;
  if (n) {
    var i = n(e, t);
    if (i === !1 || i === !0)
      return sl(e, t, r.memoize, i), i;
    var s = sy(e, t);
    if (s !== null)
      return s;
  }
  var d = Xf(e);
  if (d !== Xf(t))
    return sl(e, t, r.memoize, !1), !1;
  sl(e, t, r.memoize, !0);
  var l = Bx(e, t, d, r);
  return sl(e, t, r.memoize, l), l;
}
c(Zf, "extensiveDeepEqual");
Z(Zf, "extensiveDeepEqual");
function Bx(e, t, r, n) {
  switch (r) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Ec(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return ly(e, t, ["name", "message", "code"], n);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return ea(e, t, n);
    case "RegExp":
      return Hx(e, t);
    case "Generator":
      return Vx(e, t, n);
    case "DataView":
      return ea(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case "ArrayBuffer":
      return ea(new Uint8Array(e), new Uint8Array(t), n);
    case "Set":
      return eh(e, t, n);
    case "Map":
      return eh(e, t, n);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return Jx(e, t, n);
  }
}
c(Bx, "extensiveDeepEqualByType");
Z(Bx, "extensiveDeepEqualByType");
function Hx(e, t) {
  return e.toString() === t.toString();
}
c(Hx, "regexpEqual");
Z(Hx, "regexpEqual");
function eh(e, t, r) {
  try {
    if (e.size !== t.size)
      return !1;
    if (e.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var n = [], o = [];
  return e.forEach(Z(/* @__PURE__ */ c(function(a, i) {
    n.push([a, i]);
  }, "gatherEntries"), "gatherEntries")), t.forEach(Z(/* @__PURE__ */ c(function(a, i) {
    o.push([a, i]);
  }, "gatherEntries"), "gatherEntries")), ea(n.sort(), o.sort(), r);
}
c(eh, "entriesEqual");
Z(eh, "entriesEqual");
function ea(e, t, r) {
  var n = e.length;
  if (n !== t.length)
    return !1;
  if (n === 0)
    return !0;
  for (var o = -1; ++o < n; )
    if (Ec(e[o], t[o], r) === !1)
      return !1;
  return !0;
}
c(ea, "iterableEqual");
Z(ea, "iterableEqual");
function Vx(e, t, r) {
  return ea(pd(e), pd(t), r);
}
c(Vx, "generatorEqual");
Z(Vx, "generatorEqual");
function zx(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
c(zx, "hasIteratorFunction");
Z(zx, "hasIteratorFunction");
function th(e) {
  if (zx(e))
    try {
      return pd(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
c(th, "getIteratorEntries");
Z(th, "getIteratorEntries");
function pd(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; )
    t = e.next(), r.push(t.value);
  return r;
}
c(pd, "getGeneratorEntries");
Z(pd, "getGeneratorEntries");
function rh(e) {
  var t = [];
  for (var r in e)
    t.push(r);
  return t;
}
c(rh, "getEnumerableKeys");
Z(rh, "getEnumerableKeys");
function nh(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var o = r[n];
    Object.getOwnPropertyDescriptor(e, o).enumerable && t.push(o);
  }
  return t;
}
c(nh, "getEnumerableSymbols");
Z(nh, "getEnumerableSymbols");
function ly(e, t, r, n) {
  var o = r.length;
  if (o === 0)
    return !0;
  for (var a = 0; a < o; a += 1)
    if (Ec(e[r[a]], t[r[a]], n) === !1)
      return !1;
  return !0;
}
c(ly, "keysEqual");
Z(ly, "keysEqual");
function Jx(e, t, r) {
  var n = rh(e), o = rh(t), a = nh(e), i = nh(t);
  if (n = n.concat(a), o = o.concat(i), n.length && n.length === o.length)
    return ea(oh(n).sort(), oh(o).sort()) === !1 ? !1 : ly(e, t, n, r);
  var s = th(e), d = th(t);
  return s.length && s.length === d.length ? (s.sort(), d.sort(), ea(s, d, r)) : n.length === 0 && s.length === 0 && o.length === 0 && d.length === 0;
}
c(Jx, "objectEqual");
Z(Jx, "objectEqual");
function Ha(e) {
  return e === null || typeof e != "object";
}
c(Ha, "isPrimitive");
Z(Ha, "isPrimitive");
function oh(e) {
  return e.map(Z(/* @__PURE__ */ c(function(t) {
    return typeof t == "symbol" ? t.toString() : t;
  }, "mapSymbol"), "mapSymbol"));
}
c(oh, "mapSymbols");
Z(oh, "mapSymbols");
function op(e, t) {
  return typeof e > "u" || e === null ? !1 : t in Object(e);
}
c(op, "hasProperty");
Z(op, "hasProperty");
function Wx(e) {
  return e.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((t) => {
    if (t === "constructor" || t === "__proto__" || t === "prototype")
      return {};
    const r = /^\[(\d+)\]$/.exec(t);
    let n = null;
    return r ? n = { i: parseFloat(r[1]) } : n = { p: t.replace(/\\([.[\]])/g, "$1") }, n;
  });
}
c(Wx, "parsePath");
Z(Wx, "parsePath");
function ah(e, t, r) {
  let n = e, o = null;
  r = typeof r > "u" ? t.length : r;
  for (let a = 0; a < r; a++) {
    const i = t[a];
    n && (typeof i.p > "u" ? n = n[i.i] : n = n[i.p], a === r - 1 && (o = n));
  }
  return o;
}
c(ah, "internalGetPathValue");
Z(ah, "internalGetPathValue");
function cy(e, t) {
  const r = Wx(t), n = r[r.length - 1], o = {
    parent: r.length > 1 ? ah(e, r, r.length - 1) : e,
    name: n.p || n.i,
    value: ah(e, r)
  };
  return o.exists = op(o.parent, o.name), o;
}
c(cy, "getPathInfo");
Z(cy, "getPathInfo");
var tu, V = (tu = class {
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(e, t, r, n) {
    return Ie(this, "ssfi", r || tu), Ie(this, "lockSsfi", n), Ie(this, "object", e), Ie(this, "message", t), Ie(this, "eql", Sr.deepEqual || mF), Ps(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), Sr.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(e) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), Sr.includeStack = e;
  }
  /** @returns {boolean} */
  static get showDiff() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), Sr.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(e) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), Sr.showDiff = e;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(e, t) {
    uy(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(e, t) {
    dy(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(e, t, r) {
    hy(this.prototype, e, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(e, t) {
    py(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(e, t) {
    fy(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(e, t, r) {
    my(this.prototype, e, t, r);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(e, t, r, n, o, a) {
    const i = ny(this, arguments);
    if (a !== !1 && (a = !0), n === void 0 && o === void 0 && (a = !1), Sr.showDiff !== !0 && (a = !1), !i) {
      t = ay(this, arguments);
      const s = {
        actual: np(this, arguments),
        expected: n,
        showDiff: a
      }, d = by(this, arguments);
      throw d && (s.operator = d), new tt(
        t,
        s,
        // @ts-expect-error Not sure what to do about these types yet
        Sr.includeStack ? this.assert : Ie(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return Ie(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(e) {
    Ie(this, "object", e);
  }
}, c(tu, "_Assertion"), Z(tu, "Assertion"), tu);
function xc() {
  return Sr.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
c(xc, "isProxyEnabled");
Z(xc, "isProxyEnabled");
function uy(e, t, r) {
  r = r === void 0 ? function() {
  } : r, Object.defineProperty(e, t, {
    get: Z(/* @__PURE__ */ c(function n() {
      !xc() && !Ie(this, "lockSsfi") && Ie(this, "ssfi", n);
      let o = r.call(this);
      if (o !== void 0) return o;
      let a = new V();
      return vn(this, a), a;
    }, "propertyGetter"), "propertyGetter"),
    configurable: !0
  });
}
c(uy, "addProperty");
Z(uy, "addProperty");
var wpe = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Sc(e, t, r) {
  return wpe.configurable && Object.defineProperty(e, "length", {
    get: Z(function() {
      throw Error(
        r ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".'
      );
    }, "get")
  }), e;
}
c(Sc, "addLengthGuard");
Z(Sc, "addLengthGuard");
function Gx(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(o) {
    t.indexOf(o) === -1 && t.push(o);
  }
  c(r, "addProperty2"), Z(r, "addProperty");
  let n = Object.getPrototypeOf(e);
  for (; n !== null; )
    Object.getOwnPropertyNames(n).forEach(r), n = Object.getPrototypeOf(n);
  return t;
}
c(Gx, "getProperties");
Z(Gx, "getProperties");
var pO = ["__flags", "__methods", "_obj", "assert"];
function Ps(e, t) {
  return xc() ? new Proxy(e, {
    get: Z(/* @__PURE__ */ c(function r(n, o) {
      if (typeof o == "string" && Sr.proxyExcludedKeys.indexOf(o) === -1 && !Reflect.has(n, o)) {
        if (t)
          throw Error(
            "Invalid Chai property: " + t + "." + o + '. See docs for proper usage of "' + t + '".'
          );
        let a = null, i = 4;
        throw Gx(n).forEach(function(s) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(s) && pO.indexOf(s) === -1
          ) {
            let d = Kx(o, s, i);
            d < i && (a = s, i = d);
          }
        }), Error(
          a !== null ? "Invalid Chai property: " + o + '. Did you mean "' + a + '"?' : "Invalid Chai property: " + o
        );
      }
      return pO.indexOf(o) === -1 && !Ie(n, "lockSsfi") && Ie(n, "ssfi", r), Reflect.get(n, o);
    }, "proxyGetter"), "proxyGetter")
  }) : e;
}
c(Ps, "proxify");
Z(Ps, "proxify");
function Kx(e, t, r) {
  if (Math.abs(e.length - t.length) >= r)
    return r;
  let n = [];
  for (let o = 0; o <= e.length; o++)
    n[o] = Array(t.length + 1).fill(0), n[o][0] = o;
  for (let o = 0; o < t.length; o++)
    n[0][o] = o;
  for (let o = 1; o <= e.length; o++) {
    let a = e.charCodeAt(o - 1);
    for (let i = 1; i <= t.length; i++) {
      if (Math.abs(o - i) >= r) {
        n[o][i] = r;
        continue;
      }
      n[o][i] = Math.min(
        n[o - 1][i] + 1,
        n[o][i - 1] + 1,
        n[o - 1][i - 1] + (a === t.charCodeAt(i - 1) ? 0 : 1)
      );
    }
  }
  return n[e.length][t.length];
}
c(Kx, "stringDistanceCapped");
Z(Kx, "stringDistanceCapped");
function dy(e, t, r) {
  let n = Z(function() {
    Ie(this, "lockSsfi") || Ie(this, "ssfi", n);
    let o = r.apply(this, arguments);
    if (o !== void 0) return o;
    let a = new V();
    return vn(this, a), a;
  }, "methodWrapper");
  Sc(n, t, !1), e[t] = Ps(n, t);
}
c(dy, "addMethod");
Z(dy, "addMethod");
function py(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e, t), o = Z(function() {
  }, "_super");
  n && typeof n.get == "function" && (o = n.get), Object.defineProperty(e, t, {
    get: Z(/* @__PURE__ */ c(function a() {
      !xc() && !Ie(this, "lockSsfi") && Ie(this, "ssfi", a);
      let i = Ie(this, "lockSsfi");
      Ie(this, "lockSsfi", !0);
      let s = r(o).call(this);
      if (Ie(this, "lockSsfi", i), s !== void 0)
        return s;
      let d = new V();
      return vn(this, d), d;
    }, "overwritingPropertyGetter"), "overwritingPropertyGetter"),
    configurable: !0
  });
}
c(py, "overwriteProperty");
Z(py, "overwriteProperty");
function fy(e, t, r) {
  let n = e[t], o = Z(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  n && typeof n == "function" && (o = n);
  let a = Z(function() {
    Ie(this, "lockSsfi") || Ie(this, "ssfi", a);
    let i = Ie(this, "lockSsfi");
    Ie(this, "lockSsfi", !0);
    let s = r(o).apply(this, arguments);
    if (Ie(this, "lockSsfi", i), s !== void 0)
      return s;
    let d = new V();
    return vn(this, d), d;
  }, "overwritingMethodWrapper");
  Sc(a, t, !1), e[t] = Ps(a, t);
}
c(fy, "overwriteMethod");
Z(fy, "overwriteMethod");
var _pe = typeof Object.setPrototypeOf == "function", fO = Z(function() {
}, "testFn"), Epe = Object.getOwnPropertyNames(fO).filter(function(e) {
  let t = Object.getOwnPropertyDescriptor(fO, e);
  return typeof t != "object" ? !0 : !t.configurable;
}), xpe = Function.prototype.call, Spe = Function.prototype.apply;
function hy(e, t, r, n) {
  typeof n != "function" && (n = Z(function() {
  }, "chainingBehavior"));
  let o = {
    method: r,
    chainingBehavior: n
  };
  e.__methods || (e.__methods = {}), e.__methods[t] = o, Object.defineProperty(e, t, {
    get: Z(/* @__PURE__ */ c(function() {
      o.chainingBehavior.call(this);
      let a = Z(function() {
        Ie(this, "lockSsfi") || Ie(this, "ssfi", a);
        let i = o.method.apply(this, arguments);
        if (i !== void 0)
          return i;
        let s = new V();
        return vn(this, s), s;
      }, "chainableMethodWrapper");
      if (Sc(a, t, !0), _pe) {
        let i = Object.create(this);
        i.call = xpe, i.apply = Spe, Object.setPrototypeOf(a, i);
      } else
        Object.getOwnPropertyNames(e).forEach(function(i) {
          if (Epe.indexOf(i) !== -1)
            return;
          let s = Object.getOwnPropertyDescriptor(e, i);
          Object.defineProperty(a, i, s);
        });
      return vn(this, a), Ps(a);
    }, "chainableMethodGetter"), "chainableMethodGetter"),
    configurable: !0
  });
}
c(hy, "addChainableMethod");
Z(hy, "addChainableMethod");
function my(e, t, r, n) {
  let o = e.__methods[t], a = o.chainingBehavior;
  o.chainingBehavior = Z(/* @__PURE__ */ c(function() {
    let s = n(a).call(this);
    if (s !== void 0)
      return s;
    let d = new V();
    return vn(this, d), d;
  }, "overwritingChainableMethodGetter"), "overwritingChainableMethodGetter");
  let i = o.method;
  o.method = Z(/* @__PURE__ */ c(function() {
    let s = r(i).apply(this, arguments);
    if (s !== void 0)
      return s;
    let d = new V();
    return vn(this, d), d;
  }, "overwritingChainableMethodWrapper"), "overwritingChainableMethodWrapper");
}
c(my, "overwriteChainableMethod");
Z(my, "overwriteChainableMethod");
function fd(e, t) {
  return ze(e) < ze(t) ? -1 : 1;
}
c(fd, "compareByInspect");
Z(fd, "compareByInspect");
function yy(e) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.getOwnPropertyDescriptor(e, t).enumerable;
  });
}
c(yy, "getOwnEnumerablePropertySymbols");
Z(yy, "getOwnEnumerablePropertySymbols");
function gy(e) {
  return Object.keys(e).concat(yy(e));
}
c(gy, "getOwnEnumerableProperties");
Z(gy, "getOwnEnumerableProperties");
var ih = Number.isNaN;
function Yx(e) {
  let t = st(e);
  return ["Array", "Object", "Function"].indexOf(t) !== -1;
}
c(Yx, "isObjectType");
Z(Yx, "isObjectType");
function by(e, t) {
  let r = Ie(e, "operator"), n = Ie(e, "negate"), o = t[3], a = n ? t[2] : t[1];
  if (r)
    return r;
  if (typeof a == "function" && (a = a()), a = a || "", !a || /\shave\s/.test(a))
    return;
  let i = Yx(o);
  return /\snot\s/.test(a) ? i ? "notDeepStrictEqual" : "notStrictEqual" : i ? "deepStrictEqual" : "strictEqual";
}
c(by, "getOperator");
Z(by, "getOperator");
function ap(e) {
  return e.name;
}
c(ap, "getName");
Z(ap, "getName");
function hd(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
c(hd, "isRegExp2");
Z(hd, "isRegExp");
function Zt(e) {
  return ["Number", "BigInt"].includes(st(e));
}
c(Zt, "isNumeric");
Z(Zt, "isNumeric");
var { flag: Y } = to;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(e) {
  V.addProperty(e);
});
V.addProperty("not", function() {
  Y(this, "negate", !0);
});
V.addProperty("deep", function() {
  Y(this, "deep", !0);
});
V.addProperty("nested", function() {
  Y(this, "nested", !0);
});
V.addProperty("own", function() {
  Y(this, "own", !0);
});
V.addProperty("ordered", function() {
  Y(this, "ordered", !0);
});
V.addProperty("any", function() {
  Y(this, "any", !0), Y(this, "all", !1);
});
V.addProperty("all", function() {
  Y(this, "all", !0), Y(this, "any", !1);
});
var hO = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function vy(e, t) {
  t && Y(this, "message", t), e = e.toLowerCase();
  let r = Y(this, "object"), n = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a ";
  const o = st(r).toLowerCase();
  hO.function.includes(e) ? this.assert(
    hO[e].includes(o),
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  ) : this.assert(
    e === o,
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  );
}
c(vy, "an");
Z(vy, "an");
V.addChainableMethod("an", vy);
V.addChainableMethod("a", vy);
function Xx(e, t) {
  return ih(e) && ih(t) || e === t;
}
c(Xx, "SameValueZero");
Z(Xx, "SameValueZero");
function Tc() {
  Y(this, "contains", !0);
}
c(Tc, "includeChainingBehavior");
Z(Tc, "includeChainingBehavior");
function Ac(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = st(r).toLowerCase(), o = Y(this, "message"), a = Y(this, "negate"), i = Y(this, "ssfi"), s = Y(this, "deep"), d = s ? "deep " : "", l = s ? Y(this, "eql") : Xx;
  o = o ? o + ": " : "";
  let p = !1;
  switch (n) {
    case "string":
      p = r.indexOf(e) !== -1;
      break;
    case "weakset":
      if (s)
        throw new tt(
          o + "unable to use .deep.include with WeakSet",
          void 0,
          i
        );
      p = r.has(e);
      break;
    case "map":
      r.forEach(function(f) {
        p = p || l(f, e);
      });
      break;
    case "set":
      s ? r.forEach(function(f) {
        p = p || l(f, e);
      }) : p = r.has(e);
      break;
    case "array":
      s ? p = r.some(function(f) {
        return l(f, e);
      }) : p = r.indexOf(e) !== -1;
      break;
    default: {
      if (e !== Object(e))
        throw new tt(
          o + "the given combination of arguments (" + n + " and " + st(e).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + st(e).toLowerCase(),
          void 0,
          i
        );
      let f = Object.keys(e), h = null, m = 0;
      if (f.forEach(function(g) {
        let w = new V(r);
        if (vn(this, w, !0), Y(w, "lockSsfi", !0), !a || f.length === 1) {
          w.property(g, e[g]);
          return;
        }
        try {
          w.property(g, e[g]);
        } catch (_) {
          if (!Hr.compatibleConstructor(_, tt))
            throw _;
          h === null && (h = _), m++;
        }
      }, this), a && f.length > 1 && m === f.length)
        throw h;
      return;
    }
  }
  this.assert(
    p,
    "expected #{this} to " + d + "include " + ze(e),
    "expected #{this} to not " + d + "include " + ze(e)
  );
}
c(Ac, "include");
Z(Ac, "include");
V.addChainableMethod("include", Ac, Tc);
V.addChainableMethod("contain", Ac, Tc);
V.addChainableMethod("contains", Ac, Tc);
V.addChainableMethod("includes", Ac, Tc);
V.addProperty("ok", function() {
  this.assert(
    Y(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
V.addProperty("true", function() {
  this.assert(
    Y(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !Y(this, "negate")
  );
});
V.addProperty("numeric", function() {
  const e = Y(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(st(e)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !Y(this, "negate")
  );
});
V.addProperty("callable", function() {
  const e = Y(this, "object"), t = Y(this, "ssfi"), r = Y(this, "message"), n = r ? `${r}: ` : "", o = Y(this, "negate"), a = o ? `${n}expected ${ze(e)} not to be a callable function` : `${n}expected ${ze(e)} to be a callable function`, i = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(st(e));
  if (i && o || !i && !o)
    throw new tt(a, void 0, t);
});
V.addProperty("false", function() {
  this.assert(
    Y(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!Y(this, "negate")
  );
});
V.addProperty("null", function() {
  this.assert(
    Y(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
V.addProperty("undefined", function() {
  this.assert(
    Y(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
V.addProperty("NaN", function() {
  this.assert(
    ih(Y(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function wy() {
  let e = Y(this, "object");
  this.assert(
    e != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
c(wy, "assertExist");
Z(wy, "assertExist");
V.addProperty("exist", wy);
V.addProperty("exists", wy);
V.addProperty("empty", function() {
  let e = Y(this, "object"), t = Y(this, "ssfi"), r = Y(this, "message"), n;
  switch (r = r ? r + ": " : "", st(e).toLowerCase()) {
    case "array":
    case "string":
      n = e.length;
      break;
    case "map":
    case "set":
      n = e.size;
      break;
    case "weakmap":
    case "weakset":
      throw new tt(
        r + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function": {
      const o = r + ".empty was passed a function " + ap(e);
      throw new tt(o.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new tt(
          r + ".empty was passed non-string primitive " + ze(e),
          void 0,
          t
        );
      n = Object.keys(e).length;
  }
  this.assert(
    n === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function _y() {
  let e = Y(this, "object"), t = st(e);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
c(_y, "checkArguments");
Z(_y, "checkArguments");
V.addProperty("arguments", _y);
V.addProperty("Arguments", _y);
function ip(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object");
  if (Y(this, "deep")) {
    let n = Y(this, "lockSsfi");
    Y(this, "lockSsfi", !0), this.eql(e), Y(this, "lockSsfi", n);
  } else
    this.assert(
      e === r,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      e,
      this._obj,
      !0
    );
}
c(ip, "assertEqual");
Z(ip, "assertEqual");
V.addMethod("equal", ip);
V.addMethod("equals", ip);
V.addMethod("eq", ip);
function Ey(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "eql");
  this.assert(
    r(e, Y(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    e,
    this._obj,
    !0
  );
}
c(Ey, "assertEql");
Z(Ey, "assertEql");
V.addMethod("eql", Ey);
V.addMethod("eqls", Ey);
function sp(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "doLength"), o = Y(this, "message"), a = o ? o + ": " : "", i = Y(this, "ssfi"), s = st(r).toLowerCase(), d = st(e).toLowerCase();
  if (n && s !== "map" && s !== "set" && new V(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    throw new tt(
      a + "the argument to above must be a date",
      void 0,
      i
    );
  if (!Zt(e) && (n || Zt(r)))
    throw new tt(
      a + "the argument to above must be a number",
      void 0,
      i
    );
  if (!n && s !== "date" && !Zt(r)) {
    let l = s === "string" ? "'" + r + "'" : r;
    throw new tt(
      a + "expected " + l + " to be a number or a date",
      void 0,
      i
    );
  }
  if (n) {
    let l = "length", p;
    s === "map" || s === "set" ? (l = "size", p = r.size) : p = r.length, this.assert(
      p > e,
      "expected #{this} to have a " + l + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + l + " above #{exp}",
      e,
      p
    );
  } else
    this.assert(
      r > e,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      e
    );
}
c(sp, "assertAbove");
Z(sp, "assertAbove");
V.addMethod("above", sp);
V.addMethod("gt", sp);
V.addMethod("greaterThan", sp);
function lp(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "doLength"), o = Y(this, "message"), a = o ? o + ": " : "", i = Y(this, "ssfi"), s = st(r).toLowerCase(), d = st(e).toLowerCase(), l, p = !0;
  if (n && s !== "map" && s !== "set" && new V(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    l = a + "the argument to least must be a date";
  else if (!Zt(e) && (n || Zt(r)))
    l = a + "the argument to least must be a number";
  else if (!n && s !== "date" && !Zt(r)) {
    let f = s === "string" ? "'" + r + "'" : r;
    l = a + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new tt(l, void 0, i);
  if (n) {
    let f = "length", h;
    s === "map" || s === "set" ? (f = "size", h = r.size) : h = r.length, this.assert(
      h >= e,
      "expected #{this} to have a " + f + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + f + " below #{exp}",
      e,
      h
    );
  } else
    this.assert(
      r >= e,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      e
    );
}
c(lp, "assertLeast");
Z(lp, "assertLeast");
V.addMethod("least", lp);
V.addMethod("gte", lp);
V.addMethod("greaterThanOrEqual", lp);
function cp(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "doLength"), o = Y(this, "message"), a = o ? o + ": " : "", i = Y(this, "ssfi"), s = st(r).toLowerCase(), d = st(e).toLowerCase(), l, p = !0;
  if (n && s !== "map" && s !== "set" && new V(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    l = a + "the argument to below must be a date";
  else if (!Zt(e) && (n || Zt(r)))
    l = a + "the argument to below must be a number";
  else if (!n && s !== "date" && !Zt(r)) {
    let f = s === "string" ? "'" + r + "'" : r;
    l = a + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new tt(l, void 0, i);
  if (n) {
    let f = "length", h;
    s === "map" || s === "set" ? (f = "size", h = r.size) : h = r.length, this.assert(
      h < e,
      "expected #{this} to have a " + f + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + f + " below #{exp}",
      e,
      h
    );
  } else
    this.assert(
      r < e,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      e
    );
}
c(cp, "assertBelow");
Z(cp, "assertBelow");
V.addMethod("below", cp);
V.addMethod("lt", cp);
V.addMethod("lessThan", cp);
function up(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "doLength"), o = Y(this, "message"), a = o ? o + ": " : "", i = Y(this, "ssfi"), s = st(r).toLowerCase(), d = st(e).toLowerCase(), l, p = !0;
  if (n && s !== "map" && s !== "set" && new V(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    l = a + "the argument to most must be a date";
  else if (!Zt(e) && (n || Zt(r)))
    l = a + "the argument to most must be a number";
  else if (!n && s !== "date" && !Zt(r)) {
    let f = s === "string" ? "'" + r + "'" : r;
    l = a + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new tt(l, void 0, i);
  if (n) {
    let f = "length", h;
    s === "map" || s === "set" ? (f = "size", h = r.size) : h = r.length, this.assert(
      h <= e,
      "expected #{this} to have a " + f + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + f + " above #{exp}",
      e,
      h
    );
  } else
    this.assert(
      r <= e,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      e
    );
}
c(up, "assertMost");
Z(up, "assertMost");
V.addMethod("most", up);
V.addMethod("lte", up);
V.addMethod("lessThanOrEqual", up);
V.addMethod("within", function(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "object"), o = Y(this, "doLength"), a = Y(this, "message"), i = a ? a + ": " : "", s = Y(this, "ssfi"), d = st(n).toLowerCase(), l = st(e).toLowerCase(), p = st(t).toLowerCase(), f, h = !0, m = l === "date" && p === "date" ? e.toISOString() + ".." + t.toISOString() : e + ".." + t;
  if (o && d !== "map" && d !== "set" && new V(n, a, s, !0).to.have.property("length"), !o && d === "date" && (l !== "date" || p !== "date"))
    f = i + "the arguments to within must be dates";
  else if ((!Zt(e) || !Zt(t)) && (o || Zt(n)))
    f = i + "the arguments to within must be numbers";
  else if (!o && d !== "date" && !Zt(n)) {
    let g = d === "string" ? "'" + n + "'" : n;
    f = i + "expected " + g + " to be a number or a date";
  } else
    h = !1;
  if (h)
    throw new tt(f, void 0, s);
  if (o) {
    let g = "length", w;
    d === "map" || d === "set" ? (g = "size", w = n.size) : w = n.length, this.assert(
      w >= e && w <= t,
      "expected #{this} to have a " + g + " within " + m,
      "expected #{this} to not have a " + g + " within " + m
    );
  } else
    this.assert(
      n >= e && n <= t,
      "expected #{this} to be within " + m,
      "expected #{this} to not be within " + m
    );
});
function xy(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "ssfi"), o = Y(this, "message"), a;
  try {
    a = r instanceof e;
  } catch (s) {
    throw s instanceof TypeError ? (o = o ? o + ": " : "", new tt(
      o + "The instanceof assertion needs a constructor but " + st(e) + " was given.",
      void 0,
      n
    )) : s;
  }
  let i = ap(e);
  i == null && (i = "an unnamed constructor"), this.assert(
    a,
    "expected #{this} to be an instance of " + i,
    "expected #{this} to not be an instance of " + i
  );
}
c(xy, "assertInstanceOf");
Z(xy, "assertInstanceOf");
V.addMethod("instanceof", xy);
V.addMethod("instanceOf", xy);
function Sy(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "nested"), o = Y(this, "own"), a = Y(this, "message"), i = Y(this, "object"), s = Y(this, "ssfi"), d = typeof e;
  if (a = a ? a + ": " : "", n) {
    if (d !== "string")
      throw new tt(
        a + "the argument to property must be a string when using nested syntax",
        void 0,
        s
      );
  } else if (d !== "string" && d !== "number" && d !== "symbol")
    throw new tt(
      a + "the argument to property must be a string, number, or symbol",
      void 0,
      s
    );
  if (n && o)
    throw new tt(
      a + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      s
    );
  if (i == null)
    throw new tt(
      a + "Target cannot be null or undefined.",
      void 0,
      s
    );
  let l = Y(this, "deep"), p = Y(this, "negate"), f = n ? cy(i, e) : null, h = n ? f.value : i[e], m = l ? Y(this, "eql") : (_, b) => _ === b, g = "";
  l && (g += "deep "), o && (g += "own "), n && (g += "nested "), g += "property ";
  let w;
  o ? w = Object.prototype.hasOwnProperty.call(i, e) : n ? w = f.exists : w = op(i, e), (!p || arguments.length === 1) && this.assert(
    w,
    "expected #{this} to have " + g + ze(e),
    "expected #{this} to not have " + g + ze(e)
  ), arguments.length > 1 && this.assert(
    w && m(t, h),
    "expected #{this} to have " + g + ze(e) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + g + ze(e) + " of #{act}",
    t,
    h
  ), Y(this, "object", h);
}
c(Sy, "assertProperty");
Z(Sy, "assertProperty");
V.addMethod("property", Sy);
function Ty(e, t, r) {
  Y(this, "own", !0), Sy.apply(this, arguments);
}
c(Ty, "assertOwnProperty");
Z(Ty, "assertOwnProperty");
V.addMethod("ownProperty", Ty);
V.addMethod("haveOwnProperty", Ty);
function Ay(e, t, r) {
  typeof t == "string" && (r = t, t = null), r && Y(this, "message", r);
  let n = Y(this, "object"), o = Object.getOwnPropertyDescriptor(Object(n), e), a = Y(this, "eql");
  o && t ? this.assert(
    a(t, o),
    "expected the own property descriptor for " + ze(e) + " on #{this} to match " + ze(t) + ", got " + ze(o),
    "expected the own property descriptor for " + ze(e) + " on #{this} to not match " + ze(t),
    t,
    o,
    !0
  ) : this.assert(
    o,
    "expected #{this} to have an own property descriptor for " + ze(e),
    "expected #{this} to not have an own property descriptor for " + ze(e)
  ), Y(this, "object", o);
}
c(Ay, "assertOwnPropertyDescriptor");
Z(Ay, "assertOwnPropertyDescriptor");
V.addMethod("ownPropertyDescriptor", Ay);
V.addMethod("haveOwnPropertyDescriptor", Ay);
function $y() {
  Y(this, "doLength", !0);
}
c($y, "assertLengthChain");
Z($y, "assertLengthChain");
function Cy(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = st(r).toLowerCase(), o = Y(this, "message"), a = Y(this, "ssfi"), i = "length", s;
  switch (n) {
    case "map":
    case "set":
      i = "size", s = r.size;
      break;
    default:
      new V(r, o, a, !0).to.have.property("length"), s = r.length;
  }
  this.assert(
    s == e,
    "expected #{this} to have a " + i + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + i + " of #{act}",
    e,
    s
  );
}
c(Cy, "assertLength");
Z(Cy, "assertLength");
V.addChainableMethod("length", Cy, $y);
V.addChainableMethod("lengthOf", Cy, $y);
function ky(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object");
  this.assert(
    e.exec(r),
    "expected #{this} to match " + e,
    "expected #{this} not to match " + e
  );
}
c(ky, "assertMatch");
Z(ky, "assertMatch");
V.addMethod("match", ky);
V.addMethod("matches", ky);
V.addMethod("string", function(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "message"), o = Y(this, "ssfi");
  new V(r, n, o, !0).is.a("string"), this.assert(
    ~r.indexOf(e),
    "expected #{this} to contain " + ze(e),
    "expected #{this} to not contain " + ze(e)
  );
});
function Py(e) {
  let t = Y(this, "object"), r = st(t), n = st(e), o = Y(this, "ssfi"), a = Y(this, "deep"), i, s = "", d, l = !0, p = Y(this, "message");
  p = p ? p + ": " : "";
  let f = p + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (r === "Map" || r === "Set")
    s = a ? "deeply " : "", d = [], t.forEach(function(b, x) {
      d.push(x);
    }), n !== "Array" && (e = Array.prototype.slice.call(arguments));
  else {
    switch (d = gy(t), n) {
      case "Array":
        if (arguments.length > 1)
          throw new tt(f, void 0, o);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new tt(f, void 0, o);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function(b) {
      return typeof b == "symbol" ? b : String(b);
    });
  }
  if (!e.length)
    throw new tt(p + "keys required", void 0, o);
  let h = e.length, m = Y(this, "any"), g = Y(this, "all"), w = e, _ = a ? Y(this, "eql") : (b, x) => b === x;
  if (!m && !g && (g = !0), m && (l = w.some(function(b) {
    return d.some(function(x) {
      return _(b, x);
    });
  })), g && (l = w.every(function(b) {
    return d.some(function(x) {
      return _(b, x);
    });
  }), Y(this, "contains") || (l = l && e.length == d.length)), h > 1) {
    e = e.map(function(x) {
      return ze(x);
    });
    let b = e.pop();
    g && (i = e.join(", ") + ", and " + b), m && (i = e.join(", ") + ", or " + b);
  } else
    i = ze(e[0]);
  i = (h > 1 ? "keys " : "key ") + i, i = (Y(this, "contains") ? "contain " : "have ") + i, this.assert(
    l,
    "expected #{this} to " + s + i,
    "expected #{this} to not " + s + i,
    w.slice(0).sort(fd),
    d.sort(fd),
    !0
  );
}
c(Py, "assertKeys");
Z(Py, "assertKeys");
V.addMethod("keys", Py);
V.addMethod("key", Py);
function dp(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "object"), o = Y(this, "ssfi"), a = Y(this, "message"), i = Y(this, "negate") || !1;
  new V(n, a, o, !0).is.a("function"), (hd(e) || typeof e == "string") && (t = e, e = null);
  let s, d = !1;
  try {
    n();
  } catch (m) {
    d = !0, s = m;
  }
  let l = e === void 0 && t === void 0, p = !!(e && t), f = !1, h = !1;
  if (l || !l && !i) {
    let m = "an error";
    e instanceof Error ? m = "#{exp}" : e && (m = Hr.getConstructorName(e));
    let g = s;
    if (s instanceof Error)
      g = s.toString();
    else if (typeof s == "string")
      g = s;
    else if (s && (typeof s == "object" || typeof s == "function"))
      try {
        g = Hr.getConstructorName(s);
      } catch {
      }
    this.assert(
      d,
      "expected #{this} to throw " + m,
      "expected #{this} to not throw an error but #{act} was thrown",
      e && e.toString(),
      g
    );
  }
  if (e && s && (e instanceof Error && Hr.compatibleInstance(
    s,
    e
  ) === i && (p && i ? f = !0 : this.assert(
    i,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (s && !i ? " but #{act} was thrown" : ""),
    e.toString(),
    s.toString()
  )), Hr.compatibleConstructor(
    s,
    e
  ) === i && (p && i ? f = !0 : this.assert(
    i,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (s ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && Hr.getConstructorName(e),
    s instanceof Error ? s.toString() : s && Hr.getConstructorName(s)
  ))), s && t !== void 0 && t !== null) {
    let m = "including";
    hd(t) && (m = "matching"), Hr.compatibleMessage(
      s,
      t
    ) === i && (p && i ? h = !0 : this.assert(
      i,
      "expected #{this} to throw error " + m + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + m + " #{exp}",
      t,
      Hr.getMessage(s)
    ));
  }
  f && h && this.assert(
    i,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (s ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && Hr.getConstructorName(e),
    s instanceof Error ? s.toString() : s && Hr.getConstructorName(s)
  ), Y(this, "object", s);
}
c(dp, "assertThrows");
Z(dp, "assertThrows");
V.addMethod("throw", dp);
V.addMethod("throws", dp);
V.addMethod("Throw", dp);
function Oy(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "itself"), o = typeof r == "function" && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof o == "function",
    "expected #{this} to respond to " + ze(e),
    "expected #{this} to not respond to " + ze(e)
  );
}
c(Oy, "respondTo");
Z(Oy, "respondTo");
V.addMethod("respondTo", Oy);
V.addMethod("respondsTo", Oy);
V.addProperty("itself", function() {
  Y(this, "itself", !0);
});
function Ry(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = e(r);
  this.assert(
    n,
    "expected #{this} to satisfy " + Oa(e),
    "expected #{this} to not satisfy" + Oa(e),
    !Y(this, "negate"),
    n
  );
}
c(Ry, "satisfy");
Z(Ry, "satisfy");
V.addMethod("satisfy", Ry);
V.addMethod("satisfies", Ry);
function jy(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "object"), o = Y(this, "message"), a = Y(this, "ssfi");
  new V(n, o, a, !0).is.numeric;
  let i = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new tt(
      o ? `${o}: ${i}` : i,
      void 0,
      a
    );
  if (new V(t, o, a, !0).is.numeric, i = "A `expected` value is required for `closeTo`", e == null)
    throw new tt(
      o ? `${o}: ${i}` : i,
      void 0,
      a
    );
  new V(e, o, a, !0).is.numeric;
  const s = Z((l) => l < 0n ? -l : l, "abs"), d = Z((l) => parseFloat(parseFloat(l).toPrecision(12)), "strip");
  this.assert(
    d(s(n - e)) <= t,
    "expected #{this} to be close to " + e + " +/- " + t,
    "expected #{this} not to be close to " + e + " +/- " + t
  );
}
c(jy, "closeTo");
Z(jy, "closeTo");
V.addMethod("closeTo", jy);
V.addMethod("approximately", jy);
function Qx(e, t, r, n, o) {
  let a = Array.from(t), i = Array.from(e);
  if (!n) {
    if (i.length !== a.length) return !1;
    a = a.slice();
  }
  return i.every(function(s, d) {
    if (o) return r ? r(s, a[d]) : s === a[d];
    if (!r) {
      let l = a.indexOf(s);
      return l === -1 ? !1 : (n || a.splice(l, 1), !0);
    }
    return a.some(function(l, p) {
      return r(s, l) ? (n || a.splice(p, 1), !0) : !1;
    });
  });
}
c(Qx, "isSubsetOf");
Z(Qx, "isSubsetOf");
V.addMethod("members", function(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "message"), o = Y(this, "ssfi");
  new V(r, n, o, !0).to.be.iterable, new V(e, n, o, !0).to.be.iterable;
  let a = Y(this, "contains"), i = Y(this, "ordered"), s, d, l;
  a ? (s = i ? "an ordered superset" : "a superset", d = "expected #{this} to be " + s + " of #{exp}", l = "expected #{this} to not be " + s + " of #{exp}") : (s = i ? "ordered members" : "members", d = "expected #{this} to have the same " + s + " as #{exp}", l = "expected #{this} to not have the same " + s + " as #{exp}");
  let p = Y(this, "deep") ? Y(this, "eql") : void 0;
  this.assert(
    Qx(e, r, p, a, i),
    d,
    l,
    e,
    r,
    !0
  );
});
V.addProperty("iterable", function(e) {
  e && Y(this, "message", e);
  let t = Y(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function Zx(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "object"), n = Y(this, "message"), o = Y(this, "ssfi"), a = Y(this, "contains"), i = Y(this, "deep"), s = Y(this, "eql");
  new V(e, n, o, !0).to.be.an("array"), a ? this.assert(
    e.some(function(d) {
      return r.indexOf(d) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    e,
    r
  ) : i ? this.assert(
    e.some(function(d) {
      return s(r, d);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    e,
    r
  ) : this.assert(
    e.indexOf(r) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    e,
    r
  );
}
c(Zx, "oneOf");
Z(Zx, "oneOf");
V.addMethod("oneOf", Zx);
function Iy(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "object"), o = Y(this, "message"), a = Y(this, "ssfi");
  new V(n, o, a, !0).is.a("function");
  let i;
  t ? (new V(e, o, a, !0).to.have.property(t), i = e[t]) : (new V(e, o, a, !0).is.a("function"), i = e()), n();
  let s = t == null ? e() : e[t], d = t == null ? i : "." + t;
  Y(this, "deltaMsgObj", d), Y(this, "initialDeltaValue", i), Y(this, "finalDeltaValue", s), Y(this, "deltaBehavior", "change"), Y(this, "realDelta", s !== i), this.assert(
    i !== s,
    "expected " + d + " to change",
    "expected " + d + " to not change"
  );
}
c(Iy, "assertChanges");
Z(Iy, "assertChanges");
V.addMethod("change", Iy);
V.addMethod("changes", Iy);
function Ny(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "object"), o = Y(this, "message"), a = Y(this, "ssfi");
  new V(n, o, a, !0).is.a("function");
  let i;
  t ? (new V(e, o, a, !0).to.have.property(t), i = e[t]) : (new V(e, o, a, !0).is.a("function"), i = e()), new V(i, o, a, !0).is.a("number"), n();
  let s = t == null ? e() : e[t], d = t == null ? i : "." + t;
  Y(this, "deltaMsgObj", d), Y(this, "initialDeltaValue", i), Y(this, "finalDeltaValue", s), Y(this, "deltaBehavior", "increase"), Y(this, "realDelta", s - i), this.assert(
    s - i > 0,
    "expected " + d + " to increase",
    "expected " + d + " to not increase"
  );
}
c(Ny, "assertIncreases");
Z(Ny, "assertIncreases");
V.addMethod("increase", Ny);
V.addMethod("increases", Ny);
function My(e, t, r) {
  r && Y(this, "message", r);
  let n = Y(this, "object"), o = Y(this, "message"), a = Y(this, "ssfi");
  new V(n, o, a, !0).is.a("function");
  let i;
  t ? (new V(e, o, a, !0).to.have.property(t), i = e[t]) : (new V(e, o, a, !0).is.a("function"), i = e()), new V(i, o, a, !0).is.a("number"), n();
  let s = t == null ? e() : e[t], d = t == null ? i : "." + t;
  Y(this, "deltaMsgObj", d), Y(this, "initialDeltaValue", i), Y(this, "finalDeltaValue", s), Y(this, "deltaBehavior", "decrease"), Y(this, "realDelta", i - s), this.assert(
    s - i < 0,
    "expected " + d + " to decrease",
    "expected " + d + " to not decrease"
  );
}
c(My, "assertDecreases");
Z(My, "assertDecreases");
V.addMethod("decrease", My);
V.addMethod("decreases", My);
function eS(e, t) {
  t && Y(this, "message", t);
  let r = Y(this, "deltaMsgObj"), n = Y(this, "initialDeltaValue"), o = Y(this, "finalDeltaValue"), a = Y(this, "deltaBehavior"), i = Y(this, "realDelta"), s;
  a === "change" ? s = Math.abs(o - n) === Math.abs(e) : s = i === Math.abs(e), this.assert(
    s,
    "expected " + r + " to " + a + " by " + e,
    "expected " + r + " to not " + a + " by " + e
  );
}
c(eS, "assertDelta");
Z(eS, "assertDelta");
V.addMethod("by", eS);
V.addProperty("extensible", function() {
  let e = Y(this, "object"), t = e === Object(e) && Object.isExtensible(e);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
V.addProperty("sealed", function() {
  let e = Y(this, "object"), t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
V.addProperty("frozen", function() {
  let e = Y(this, "object"), t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
V.addProperty("finite", function(e) {
  let t = Y(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function md(e, t) {
  return e === t ? !0 : typeof t != typeof e ? !1 : typeof e != "object" || e === null ? e === t : t ? Array.isArray(e) ? Array.isArray(t) ? e.every(function(r) {
    return t.some(function(n) {
      return md(r, n);
    });
  }) : !1 : e instanceof Date ? t instanceof Date ? e.getTime() === t.getTime() : !1 : Object.keys(e).every(function(r) {
    let n = e[r], o = t[r];
    return typeof n == "object" && n !== null && o !== null ? md(n, o) : typeof n == "function" ? n(o) : o === n;
  }) : !1;
}
c(md, "compareSubset");
Z(md, "compareSubset");
V.addMethod("containSubset", function(e) {
  const t = Ie(this, "object"), r = Sr.showDiff;
  this.assert(
    md(e, t),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    e,
    t,
    r
  );
});
function Ra(e, t) {
  return new V(e, t);
}
c(Ra, "expect");
Z(Ra, "expect");
Ra.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "expect.fail()", new tt(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    Ra.fail
  );
};
var yF = {};
yx(yF, {
  Should: /* @__PURE__ */ c(() => Ape, "Should"),
  should: /* @__PURE__ */ c(() => Tpe, "should")
});
function Dy() {
  function e() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new V(this.valueOf(), null, e) : new V(this, null, e);
  }
  c(e, "shouldGetter"), Z(e, "shouldGetter");
  function t(n) {
    Object.defineProperty(this, "should", {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  c(t, "shouldSetter"), Z(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: e,
    configurable: !0
  });
  let r = {};
  return r.fail = function(n, o, a, i) {
    throw arguments.length < 2 && (a = n, n = void 0), a = a || "should.fail()", new tt(
      a,
      {
        actual: n,
        expected: o,
        operator: i
      },
      r.fail
    );
  }, r.equal = function(n, o, a) {
    new V(n, a).to.equal(o);
  }, r.Throw = function(n, o, a, i) {
    new V(n, i).to.Throw(o, a);
  }, r.exist = function(n, o) {
    new V(n, o).to.exist;
  }, r.not = {}, r.not.equal = function(n, o, a) {
    new V(n, a).to.not.equal(o);
  }, r.not.Throw = function(n, o, a, i) {
    new V(n, i).to.not.Throw(o, a);
  }, r.not.exist = function(n, o) {
    new V(n, o).to.not.exist;
  }, r.throw = r.Throw, r.not.throw = r.not.Throw, r;
}
c(Dy, "loadShould");
Z(Dy, "loadShould");
var Tpe = Dy, Ape = Dy;
function B(e, t) {
  new V(null, null, B, !0).assert(e, t, "[ negation message unavailable ]");
}
c(B, "assert");
Z(B, "assert");
B.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "assert.fail()", new tt(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    B.fail
  );
};
B.isOk = function(e, t) {
  new V(e, t, B.isOk, !0).is.ok;
};
B.isNotOk = function(e, t) {
  new V(e, t, B.isNotOk, !0).is.not.ok;
};
B.equal = function(e, t, r) {
  let n = new V(e, r, B.equal, !0);
  n.assert(
    t == Ie(n, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    e,
    !0
  );
};
B.notEqual = function(e, t, r) {
  let n = new V(e, r, B.notEqual, !0);
  n.assert(
    t != Ie(n, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    e,
    !0
  );
};
B.strictEqual = function(e, t, r) {
  new V(e, r, B.strictEqual, !0).to.equal(t);
};
B.notStrictEqual = function(e, t, r) {
  new V(e, r, B.notStrictEqual, !0).to.not.equal(t);
};
B.deepEqual = B.deepStrictEqual = function(e, t, r) {
  new V(e, r, B.deepEqual, !0).to.eql(t);
};
B.notDeepEqual = function(e, t, r) {
  new V(e, r, B.notDeepEqual, !0).to.not.eql(t);
};
B.isAbove = function(e, t, r) {
  new V(e, r, B.isAbove, !0).to.be.above(t);
};
B.isAtLeast = function(e, t, r) {
  new V(e, r, B.isAtLeast, !0).to.be.least(t);
};
B.isBelow = function(e, t, r) {
  new V(e, r, B.isBelow, !0).to.be.below(t);
};
B.isAtMost = function(e, t, r) {
  new V(e, r, B.isAtMost, !0).to.be.most(t);
};
B.isTrue = function(e, t) {
  new V(e, t, B.isTrue, !0).is.true;
};
B.isNotTrue = function(e, t) {
  new V(e, t, B.isNotTrue, !0).to.not.equal(!0);
};
B.isFalse = function(e, t) {
  new V(e, t, B.isFalse, !0).is.false;
};
B.isNotFalse = function(e, t) {
  new V(e, t, B.isNotFalse, !0).to.not.equal(!1);
};
B.isNull = function(e, t) {
  new V(e, t, B.isNull, !0).to.equal(null);
};
B.isNotNull = function(e, t) {
  new V(e, t, B.isNotNull, !0).to.not.equal(null);
};
B.isNaN = function(e, t) {
  new V(e, t, B.isNaN, !0).to.be.NaN;
};
B.isNotNaN = function(e, t) {
  new V(e, t, B.isNotNaN, !0).not.to.be.NaN;
};
B.exists = function(e, t) {
  new V(e, t, B.exists, !0).to.exist;
};
B.notExists = function(e, t) {
  new V(e, t, B.notExists, !0).to.not.exist;
};
B.isUndefined = function(e, t) {
  new V(e, t, B.isUndefined, !0).to.equal(void 0);
};
B.isDefined = function(e, t) {
  new V(e, t, B.isDefined, !0).to.not.equal(void 0);
};
B.isCallable = function(e, t) {
  new V(e, t, B.isCallable, !0).is.callable;
};
B.isNotCallable = function(e, t) {
  new V(e, t, B.isNotCallable, !0).is.not.callable;
};
B.isObject = function(e, t) {
  new V(e, t, B.isObject, !0).to.be.a("object");
};
B.isNotObject = function(e, t) {
  new V(e, t, B.isNotObject, !0).to.not.be.a("object");
};
B.isArray = function(e, t) {
  new V(e, t, B.isArray, !0).to.be.an("array");
};
B.isNotArray = function(e, t) {
  new V(e, t, B.isNotArray, !0).to.not.be.an("array");
};
B.isString = function(e, t) {
  new V(e, t, B.isString, !0).to.be.a("string");
};
B.isNotString = function(e, t) {
  new V(e, t, B.isNotString, !0).to.not.be.a("string");
};
B.isNumber = function(e, t) {
  new V(e, t, B.isNumber, !0).to.be.a("number");
};
B.isNotNumber = function(e, t) {
  new V(e, t, B.isNotNumber, !0).to.not.be.a("number");
};
B.isNumeric = function(e, t) {
  new V(e, t, B.isNumeric, !0).is.numeric;
};
B.isNotNumeric = function(e, t) {
  new V(e, t, B.isNotNumeric, !0).is.not.numeric;
};
B.isFinite = function(e, t) {
  new V(e, t, B.isFinite, !0).to.be.finite;
};
B.isBoolean = function(e, t) {
  new V(e, t, B.isBoolean, !0).to.be.a("boolean");
};
B.isNotBoolean = function(e, t) {
  new V(e, t, B.isNotBoolean, !0).to.not.be.a("boolean");
};
B.typeOf = function(e, t, r) {
  new V(e, r, B.typeOf, !0).to.be.a(t);
};
B.notTypeOf = function(e, t, r) {
  new V(e, r, B.notTypeOf, !0).to.not.be.a(t);
};
B.instanceOf = function(e, t, r) {
  new V(e, r, B.instanceOf, !0).to.be.instanceOf(t);
};
B.notInstanceOf = function(e, t, r) {
  new V(e, r, B.notInstanceOf, !0).to.not.be.instanceOf(
    t
  );
};
B.include = function(e, t, r) {
  new V(e, r, B.include, !0).include(t);
};
B.notInclude = function(e, t, r) {
  new V(e, r, B.notInclude, !0).not.include(t);
};
B.deepInclude = function(e, t, r) {
  new V(e, r, B.deepInclude, !0).deep.include(t);
};
B.notDeepInclude = function(e, t, r) {
  new V(e, r, B.notDeepInclude, !0).not.deep.include(t);
};
B.nestedInclude = function(e, t, r) {
  new V(e, r, B.nestedInclude, !0).nested.include(t);
};
B.notNestedInclude = function(e, t, r) {
  new V(e, r, B.notNestedInclude, !0).not.nested.include(
    t
  );
};
B.deepNestedInclude = function(e, t, r) {
  new V(e, r, B.deepNestedInclude, !0).deep.nested.include(
    t
  );
};
B.notDeepNestedInclude = function(e, t, r) {
  new V(
    e,
    r,
    B.notDeepNestedInclude,
    !0
  ).not.deep.nested.include(t);
};
B.ownInclude = function(e, t, r) {
  new V(e, r, B.ownInclude, !0).own.include(t);
};
B.notOwnInclude = function(e, t, r) {
  new V(e, r, B.notOwnInclude, !0).not.own.include(t);
};
B.deepOwnInclude = function(e, t, r) {
  new V(e, r, B.deepOwnInclude, !0).deep.own.include(t);
};
B.notDeepOwnInclude = function(e, t, r) {
  new V(e, r, B.notDeepOwnInclude, !0).not.deep.own.include(
    t
  );
};
B.match = function(e, t, r) {
  new V(e, r, B.match, !0).to.match(t);
};
B.notMatch = function(e, t, r) {
  new V(e, r, B.notMatch, !0).to.not.match(t);
};
B.property = function(e, t, r) {
  new V(e, r, B.property, !0).to.have.property(t);
};
B.notProperty = function(e, t, r) {
  new V(e, r, B.notProperty, !0).to.not.have.property(t);
};
B.propertyVal = function(e, t, r, n) {
  new V(e, n, B.propertyVal, !0).to.have.property(t, r);
};
B.notPropertyVal = function(e, t, r, n) {
  new V(e, n, B.notPropertyVal, !0).to.not.have.property(
    t,
    r
  );
};
B.deepPropertyVal = function(e, t, r, n) {
  new V(e, n, B.deepPropertyVal, !0).to.have.deep.property(
    t,
    r
  );
};
B.notDeepPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.notDeepPropertyVal,
    !0
  ).to.not.have.deep.property(t, r);
};
B.ownProperty = function(e, t, r) {
  new V(e, r, B.ownProperty, !0).to.have.own.property(t);
};
B.notOwnProperty = function(e, t, r) {
  new V(e, r, B.notOwnProperty, !0).to.not.have.own.property(
    t
  );
};
B.ownPropertyVal = function(e, t, r, n) {
  new V(e, n, B.ownPropertyVal, !0).to.have.own.property(
    t,
    r
  );
};
B.notOwnPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.notOwnPropertyVal,
    !0
  ).to.not.have.own.property(t, r);
};
B.deepOwnPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.deepOwnPropertyVal,
    !0
  ).to.have.deep.own.property(t, r);
};
B.notDeepOwnPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.notDeepOwnPropertyVal,
    !0
  ).to.not.have.deep.own.property(t, r);
};
B.nestedProperty = function(e, t, r) {
  new V(e, r, B.nestedProperty, !0).to.have.nested.property(
    t
  );
};
B.notNestedProperty = function(e, t, r) {
  new V(
    e,
    r,
    B.notNestedProperty,
    !0
  ).to.not.have.nested.property(t);
};
B.nestedPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.nestedPropertyVal,
    !0
  ).to.have.nested.property(t, r);
};
B.notNestedPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.notNestedPropertyVal,
    !0
  ).to.not.have.nested.property(t, r);
};
B.deepNestedPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.deepNestedPropertyVal,
    !0
  ).to.have.deep.nested.property(t, r);
};
B.notDeepNestedPropertyVal = function(e, t, r, n) {
  new V(
    e,
    n,
    B.notDeepNestedPropertyVal,
    !0
  ).to.not.have.deep.nested.property(t, r);
};
B.lengthOf = function(e, t, r) {
  new V(e, r, B.lengthOf, !0).to.have.lengthOf(t);
};
B.hasAnyKeys = function(e, t, r) {
  new V(e, r, B.hasAnyKeys, !0).to.have.any.keys(t);
};
B.hasAllKeys = function(e, t, r) {
  new V(e, r, B.hasAllKeys, !0).to.have.all.keys(t);
};
B.containsAllKeys = function(e, t, r) {
  new V(e, r, B.containsAllKeys, !0).to.contain.all.keys(
    t
  );
};
B.doesNotHaveAnyKeys = function(e, t, r) {
  new V(e, r, B.doesNotHaveAnyKeys, !0).to.not.have.any.keys(
    t
  );
};
B.doesNotHaveAllKeys = function(e, t, r) {
  new V(e, r, B.doesNotHaveAllKeys, !0).to.not.have.all.keys(
    t
  );
};
B.hasAnyDeepKeys = function(e, t, r) {
  new V(e, r, B.hasAnyDeepKeys, !0).to.have.any.deep.keys(
    t
  );
};
B.hasAllDeepKeys = function(e, t, r) {
  new V(e, r, B.hasAllDeepKeys, !0).to.have.all.deep.keys(
    t
  );
};
B.containsAllDeepKeys = function(e, t, r) {
  new V(
    e,
    r,
    B.containsAllDeepKeys,
    !0
  ).to.contain.all.deep.keys(t);
};
B.doesNotHaveAnyDeepKeys = function(e, t, r) {
  new V(
    e,
    r,
    B.doesNotHaveAnyDeepKeys,
    !0
  ).to.not.have.any.deep.keys(t);
};
B.doesNotHaveAllDeepKeys = function(e, t, r) {
  new V(
    e,
    r,
    B.doesNotHaveAllDeepKeys,
    !0
  ).to.not.have.all.deep.keys(t);
};
B.throws = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null);
  let o = new V(e, n, B.throws, !0).to.throw(
    t,
    r
  );
  return Ie(o, "object");
};
B.doesNotThrow = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null), new V(e, n, B.doesNotThrow, !0).to.not.throw(
    t,
    r
  );
};
B.operator = function(e, t, r, n) {
  let o;
  switch (t) {
    case "==":
      o = e == r;
      break;
    case "===":
      o = e === r;
      break;
    case ">":
      o = e > r;
      break;
    case ">=":
      o = e >= r;
      break;
    case "<":
      o = e < r;
      break;
    case "<=":
      o = e <= r;
      break;
    case "!=":
      o = e != r;
      break;
    case "!==":
      o = e !== r;
      break;
    default:
      throw n = n && n + ": ", new tt(
        n + 'Invalid operator "' + t + '"',
        void 0,
        B.operator
      );
  }
  let a = new V(o, n, B.operator, !0);
  a.assert(
    Ie(a, "object") === !0,
    "expected " + ze(e) + " to be " + t + " " + ze(r),
    "expected " + ze(e) + " to not be " + t + " " + ze(r)
  );
};
B.closeTo = function(e, t, r, n) {
  new V(e, n, B.closeTo, !0).to.be.closeTo(t, r);
};
B.approximately = function(e, t, r, n) {
  new V(e, n, B.approximately, !0).to.be.approximately(
    t,
    r
  );
};
B.sameMembers = function(e, t, r) {
  new V(e, r, B.sameMembers, !0).to.have.same.members(t);
};
B.notSameMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notSameMembers,
    !0
  ).to.not.have.same.members(t);
};
B.sameDeepMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.sameDeepMembers,
    !0
  ).to.have.same.deep.members(t);
};
B.notSameDeepMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notSameDeepMembers,
    !0
  ).to.not.have.same.deep.members(t);
};
B.sameOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.sameOrderedMembers,
    !0
  ).to.have.same.ordered.members(t);
};
B.notSameOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notSameOrderedMembers,
    !0
  ).to.not.have.same.ordered.members(t);
};
B.sameDeepOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.sameDeepOrderedMembers,
    !0
  ).to.have.same.deep.ordered.members(t);
};
B.notSameDeepOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notSameDeepOrderedMembers,
    !0
  ).to.not.have.same.deep.ordered.members(t);
};
B.includeMembers = function(e, t, r) {
  new V(e, r, B.includeMembers, !0).to.include.members(
    t
  );
};
B.notIncludeMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notIncludeMembers,
    !0
  ).to.not.include.members(t);
};
B.includeDeepMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.includeDeepMembers,
    !0
  ).to.include.deep.members(t);
};
B.notIncludeDeepMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notIncludeDeepMembers,
    !0
  ).to.not.include.deep.members(t);
};
B.includeOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.includeOrderedMembers,
    !0
  ).to.include.ordered.members(t);
};
B.notIncludeOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notIncludeOrderedMembers,
    !0
  ).to.not.include.ordered.members(t);
};
B.includeDeepOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.includeDeepOrderedMembers,
    !0
  ).to.include.deep.ordered.members(t);
};
B.notIncludeDeepOrderedMembers = function(e, t, r) {
  new V(
    e,
    r,
    B.notIncludeDeepOrderedMembers,
    !0
  ).to.not.include.deep.ordered.members(t);
};
B.oneOf = function(e, t, r) {
  new V(e, r, B.oneOf, !0).to.be.oneOf(t);
};
B.isIterable = function(e, t) {
  if (e == null || !e[Symbol.iterator])
    throw t = t ? `${t} expected ${ze(e)} to be an iterable` : `expected ${ze(e)} to be an iterable`, new tt(t, void 0, B.isIterable);
};
B.changes = function(e, t, r, n) {
  arguments.length === 3 && typeof t == "function" && (n = r, r = null), new V(e, n, B.changes, !0).to.change(t, r);
};
B.changesBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new V(e, o, B.changesBy, !0).to.change(t, r).by(n);
};
B.doesNotChange = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new V(e, n, B.doesNotChange, !0).to.not.change(
    t,
    r
  );
};
B.changesButNotBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new V(e, o, B.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
B.increases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new V(e, n, B.increases, !0).to.increase(t, r);
};
B.increasesBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new V(e, o, B.increasesBy, !0).to.increase(t, r).by(n);
};
B.doesNotIncrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new V(e, n, B.doesNotIncrease, !0).to.not.increase(
    t,
    r
  );
};
B.increasesButNotBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new V(e, o, B.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
B.decreases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new V(e, n, B.decreases, !0).to.decrease(t, r);
};
B.decreasesBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new V(e, o, B.decreasesBy, !0).to.decrease(t, r).by(n);
};
B.doesNotDecrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new V(e, n, B.doesNotDecrease, !0).to.not.decrease(
    t,
    r
  );
};
B.doesNotDecreaseBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  return new V(e, o, B.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
B.decreasesButNotBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new V(e, o, B.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
B.ifError = function(e) {
  if (e)
    throw e;
};
B.isExtensible = function(e, t) {
  new V(e, t, B.isExtensible, !0).to.be.extensible;
};
B.isNotExtensible = function(e, t) {
  new V(e, t, B.isNotExtensible, !0).to.not.be.extensible;
};
B.isSealed = function(e, t) {
  new V(e, t, B.isSealed, !0).to.be.sealed;
};
B.isNotSealed = function(e, t) {
  new V(e, t, B.isNotSealed, !0).to.not.be.sealed;
};
B.isFrozen = function(e, t) {
  new V(e, t, B.isFrozen, !0).to.be.frozen;
};
B.isNotFrozen = function(e, t) {
  new V(e, t, B.isNotFrozen, !0).to.not.be.frozen;
};
B.isEmpty = function(e, t) {
  new V(e, t, B.isEmpty, !0).to.be.empty;
};
B.isNotEmpty = function(e, t) {
  new V(e, t, B.isNotEmpty, !0).to.not.be.empty;
};
B.containsSubset = function(e, t, r) {
  new V(e, r).to.containSubset(t);
};
B.doesNotContainSubset = function(e, t, r) {
  new V(e, r).to.not.containSubset(t);
};
var $pe = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (const [e, t] of $pe)
  B[t] = B[e];
var mO = [];
function Gi(e) {
  const t = {
    use: Gi,
    AssertionError: tt,
    util: to,
    config: Sr,
    expect: Ra,
    assert: B,
    Assertion: V,
    ...yF
  };
  return ~mO.indexOf(e) || (e(t, to), mO.push(e)), t;
}
c(Gi, "use");
Z(Gi, "use");
var gF = {};
Qd(gF, {
  toBeChecked: () => NS,
  toBeDisabled: () => $S,
  toBeEmpty: () => pS,
  toBeEmptyDOMElement: () => fS,
  toBeEnabled: () => CS,
  toBeInTheDOM: () => lh,
  toBeInTheDocument: () => dS,
  toBeInvalid: () => OS,
  toBePartiallyChecked: () => DS,
  toBePartiallyPressed: () => BS,
  toBePressed: () => US,
  toBeRequired: () => kS,
  toBeValid: () => RS,
  toBeVisible: () => ES,
  toContainElement: () => ch,
  toContainHTML: () => hS,
  toHaveAccessibleDescription: () => uh,
  toHaveAccessibleErrorMessage: () => yS,
  toHaveAccessibleName: () => ph,
  toHaveAttribute: () => gS,
  toHaveClass: () => bS,
  toHaveDescription: () => qS,
  toHaveDisplayValue: () => IS,
  toHaveErrorMessage: () => LS,
  toHaveFocus: () => vS,
  toHaveFormValues: () => wS,
  toHaveRole: () => dh,
  toHaveSelection: () => FS,
  toHaveStyle: () => fh,
  toHaveTextContent: () => mS,
  toHaveValue: () => jS
});
var yO = or(uF(), 1), bF = class extends Error {
  reason;
  filename;
  line;
  column;
  source;
  constructor(t, r, n, o, a) {
    super(`${t}:${n}:${o}: ${r}`), this.reason = r, this.filename = t, this.line = n, this.column = o, this.source = a;
  }
};
c(bF, "t");
var Cpe = bF, vF = class {
  start;
  end;
  source;
  constructor(t, r, n) {
    this.start = t, this.end = r, this.source = n;
  }
};
c(vF, "e");
var kpe = vF, Wt;
(function(e) {
  e.stylesheet = "stylesheet", e.rule = "rule", e.declaration = "declaration", e.comment = "comment", e.container = "container", e.charset = "charset", e.document = "document", e.customMedia = "custom-media", e.fontFace = "font-face", e.host = "host", e.import = "import", e.keyframes = "keyframes", e.keyframe = "keyframe", e.layer = "layer", e.media = "media", e.namespace = "namespace", e.page = "page", e.startingStyle = "starting-style", e.supports = "supports";
})(Wt || (Wt = {}));
var gO = /* @__PURE__ */ c((e, t, r) => {
  let n = r, o = 1e4;
  do {
    const a = t.map((d) => e.indexOf(d, n));
    a.push(e.indexOf("\\", n));
    const i = a.filter((d) => d !== -1);
    if (i.length === 0) return -1;
    const s = Math.min(...i);
    if (e[s] !== "\\") return s;
    n = s + 2, o--;
  } while (o > 0);
  throw new Error("Too many escaping");
}, "s"), $w = /* @__PURE__ */ c((e, t, r) => {
  let n = r, o = 1e4;
  do {
    const a = t.map((d) => e.indexOf(d, n));
    a.push(e.indexOf("(", n)), a.push(e.indexOf('"', n)), a.push(e.indexOf("'", n)), a.push(e.indexOf("\\", n));
    const i = a.filter((d) => d !== -1);
    if (i.length === 0) return -1;
    const s = Math.min(...i);
    switch (e[s]) {
      case "\\":
        n = s + 2;
        break;
      case "(":
        {
          const d = $w(e, [")"], s + 1);
          if (d === -1) return -1;
          n = d + 1;
        }
        break;
      case '"':
        {
          const d = gO(e, ['"'], s + 1);
          if (d === -1) return -1;
          n = d + 1;
        }
        break;
      case "'":
        {
          const d = gO(e, ["'"], s + 1);
          if (d === -1) return -1;
          n = d + 1;
        }
        break;
      default:
        return s;
    }
    o--;
  } while (o > 0);
  throw new Error("Too many escaping");
}, "n"), lv = /\/\*[^]*?(?:\*\/|$)/g;
function qr(e) {
  return e ? e.trim() : "";
}
c(qr, "o");
function sh(e, t) {
  const r = e && typeof e.type == "string", n = r ? e : t;
  for (const o in e) {
    const a = e[o];
    Array.isArray(a) ? a.forEach((i) => {
      sh(i, n);
    }) : a && typeof a == "object" && sh(a, n);
  }
  return r && Object.defineProperty(e, "parent", { configurable: !0, writable: !0, enumerable: !1, value: t || null }), e;
}
c(sh, "c");
var Ppe = /* @__PURE__ */ c((e, t) => {
  t = t || {};
  let r = 1, n = 1;
  function o() {
    const E = { line: r, column: n };
    return (T) => (T.position = new kpe(E, { line: r, column: n }, t?.source || ""), f(), T);
  }
  c(o, "u");
  const a = [];
  function i(E) {
    const T = new Cpe(t?.source || "", E, r, n, e);
    if (!t?.silent) throw T;
    a.push(T);
  }
  c(i, "l");
  function s() {
    const E = /^{\s*/.exec(e);
    return !!E && (p(E), !0);
  }
  c(s, "f");
  function d() {
    const E = /^}/.exec(e);
    return !!E && (p(E), !0);
  }
  c(d, "d");
  function l() {
    let E;
    const T = [];
    for (f(), h(T); e.length && e.charAt(0) !== "}" && (E = C() || A(), E); ) T.push(E), h(T);
    return T;
  }
  c(l, "y");
  function p(E) {
    const T = E[0];
    return (function(O) {
      const k = O.match(/\n/g);
      k && (r += k.length);
      const M = O.lastIndexOf(`
`);
      n = ~M ? O.length - M : n + O.length;
    })(T), e = e.slice(T.length), E;
  }
  c(p, "g");
  function f() {
    const E = /^\s*/.exec(e);
    E && p(E);
  }
  c(f, "$");
  function h(E) {
    E = E || [];
    let T = m();
    for (; T; ) E.push(T), T = m();
    return E;
  }
  c(h, "x");
  function m() {
    const E = o();
    if (e.charAt(0) !== "/" || e.charAt(1) !== "*") return;
    const T = /^\/\*[^]*?\*\//.exec(e);
    return T ? (p(T), E({ type: Wt.comment, comment: T[0].slice(2, -2) })) : i("End of comment missing");
  }
  c(m, "V");
  function g() {
    const E = /^([^{]+)/.exec(e);
    if (E)
      return p(E), ((T, O) => {
        const k = [];
        let M = 0;
        for (; M < T.length; ) {
          const L = $w(T, O, M);
          if (L === -1) return k.push(T.substring(M)), k;
          k.push(T.substring(M, L)), M = L + 1;
        }
        return k;
      })(qr(E[0]).replace(lv, ""), [","]).map((T) => qr(T));
  }
  c(g, "k");
  function w() {
    const E = o(), T = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
    if (!T) return;
    p(T);
    const O = qr(T[0]), k = /^:\s*/.exec(e);
    if (!k) return i("property missing ':'");
    p(k);
    let M = "";
    const L = $w(e, [";", "}"]);
    L !== -1 && (M = e.substring(0, L), p([M]), M = qr(M).replace(lv, ""));
    const $ = E({ type: Wt.declaration, property: O.replace(lv, ""), value: M }), I = /^[;\s]*/.exec(e);
    return I && p(I), $;
  }
  c(w, "v");
  function _() {
    const E = [];
    if (!s()) return i("missing '{'");
    h(E);
    let T = w();
    for (; T; ) E.push(T), h(E), T = w();
    return d() ? E : i("missing '}'");
  }
  c(_, "w");
  function b() {
    const E = [], T = o();
    let O = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
    for (; O; ) {
      const k = p(O);
      E.push(k[1]);
      const M = /^,\s*/.exec(e);
      M && p(M), O = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
    }
    if (E.length) return T({ type: Wt.keyframe, values: E, declarations: _() || [] });
  }
  c(b, "b");
  const x = N("import"), P = N("charset"), R = N("namespace");
  function N(E) {
    const T = new RegExp("^@" + E + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return () => {
      const O = o(), k = T.exec(e);
      if (!k) return;
      const M = p(k), L = { type: E };
      return L[E] = M[1].trim(), O(L);
    };
  }
  c(N, "M");
  function C() {
    if (e[0] === "@") return (function() {
      const E = o(), T = /^@([-\w]+)?keyframes\s*/.exec(e);
      if (!T) return;
      const O = p(T)[1], k = /^([-\w]+)\s*/.exec(e);
      if (!k) return i("@keyframes missing name");
      const M = p(k)[1];
      if (!s()) return i("@keyframes missing '{'");
      let L = h(), $ = b();
      for (; $; ) L.push($), L = L.concat(h()), $ = b();
      return d() ? E({ type: Wt.keyframes, name: M, vendor: O, keyframes: L }) : i("@keyframes missing '}'");
    })() || (function() {
      const E = o(), T = /^@media *([^{]+)/.exec(e);
      if (!T) return;
      const O = qr(p(T)[1]);
      if (!s()) return i("@media missing '{'");
      const k = h().concat(l());
      return d() ? E({ type: Wt.media, media: O, rules: k }) : i("@media missing '}'");
    })() || (function() {
      const E = o(), T = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
      if (!T) return;
      const O = p(T);
      return E({ type: Wt.customMedia, name: qr(O[1]), media: qr(O[2]) });
    })() || (function() {
      const E = o(), T = /^@supports *([^{]+)/.exec(e);
      if (!T) return;
      const O = qr(p(T)[1]);
      if (!s()) return i("@supports missing '{'");
      const k = h().concat(l());
      return d() ? E({ type: Wt.supports, supports: O, rules: k }) : i("@supports missing '}'");
    })() || x() || P() || R() || (function() {
      const E = o(), T = /^@([-\w]+)?document *([^{]+)/.exec(e);
      if (!T) return;
      const O = p(T), k = qr(O[1]), M = qr(O[2]);
      if (!s()) return i("@document missing '{'");
      const L = h().concat(l());
      return d() ? E({ type: Wt.document, document: M, vendor: k, rules: L }) : i("@document missing '}'");
    })() || (function() {
      const E = o(), T = /^@page */.exec(e);
      if (!T) return;
      p(T);
      const O = g() || [];
      if (!s()) return i("@page missing '{'");
      let k = h(), M = w();
      for (; M; ) k.push(M), k = k.concat(h()), M = w();
      return d() ? E({ type: Wt.page, selectors: O, declarations: k }) : i("@page missing '}'");
    })() || (function() {
      const E = o(), T = /^@host\s*/.exec(e);
      if (!T) return;
      if (p(T), !s()) return i("@host missing '{'");
      const O = h().concat(l());
      return d() ? E({ type: Wt.host, rules: O }) : i("@host missing '}'");
    })() || (function() {
      const E = o(), T = /^@font-face\s*/.exec(e);
      if (!T) return;
      if (p(T), !s()) return i("@font-face missing '{'");
      let O = h(), k = w();
      for (; k; ) O.push(k), O = O.concat(h()), k = w();
      return d() ? E({ type: Wt.fontFace, declarations: O }) : i("@font-face missing '}'");
    })() || (function() {
      const E = o(), T = /^@container *([^{]+)/.exec(e);
      if (!T) return;
      const O = qr(p(T)[1]);
      if (!s()) return i("@container missing '{'");
      const k = h().concat(l());
      return d() ? E({ type: Wt.container, container: O, rules: k }) : i("@container missing '}'");
    })() || (function() {
      const E = o(), T = /^@starting-style\s*/.exec(e);
      if (!T) return;
      if (p(T), !s()) return i("@starting-style missing '{'");
      const O = h().concat(l());
      return d() ? E({ type: Wt.startingStyle, rules: O }) : i("@starting-style missing '}'");
    })() || (function() {
      const E = o(), T = /^@layer *([^{;@]+)/.exec(e);
      if (!T) return;
      const O = qr(p(T)[1]);
      if (!s()) {
        const M = /^[;\s]*/.exec(e);
        return M && p(M), E({ type: Wt.layer, layer: O });
      }
      const k = h().concat(l());
      return d() ? E({ type: Wt.layer, layer: O, rules: k }) : i("@layer missing '}'");
    })();
  }
  c(C, "A");
  function A() {
    const E = o(), T = g();
    return T ? (h(), E({ type: Wt.rule, selectors: T, declarations: _() || [] })) : i("selector missing");
  }
  return c(A, "S"), sh((function() {
    const E = l();
    return { type: Wt.stylesheet, stylesheet: { source: t?.source, rules: E, parsingErrors: a } };
  })());
}, "m"), Ope = Object.prototype.toString;
function Cw(e) {
  return typeof e == "function" || Ope.call(e) === "[object Function]";
}
c(Cw, "isCallable");
function wF(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
c(wF, "toInteger");
var Rpe = Math.pow(2, 53) - 1;
function _F(e) {
  var t = wF(e);
  return Math.min(Math.max(t, 0), Rpe);
}
c(_F, "toLength");
function cn(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !Cw(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var o = _F(n.length), a = Cw(r) ? Object(new r(o)) : new Array(o), i = 0, s; i < o; )
    s = n[i], t ? a[i] = t(s, i) : a[i] = s, i += 1;
  return a.length = o, a;
}
c(cn, "arrayFrom");
function Dl(e) {
  "@babel/helpers - typeof";
  return Dl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Dl(e);
}
c(Dl, "_typeof");
function EF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
c(EF, "_classCallCheck");
function kw(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, tS(n.key), n);
  }
}
c(kw, "_defineProperties");
function xF(e, t, r) {
  return t && kw(e.prototype, t), r && kw(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
c(xF, "_createClass");
function SF(e, t, r) {
  return t = tS(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
c(SF, "_defineProperty");
function tS(e) {
  var t = TF(e, "string");
  return Dl(t) === "symbol" ? t : String(t);
}
c(tS, "_toPropertyKey");
function TF(e, t) {
  if (Dl(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (Dl(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
c(TF, "_toPrimitive");
var jpe = (function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    EF(this, e), SF(this, "items", void 0), this.items = t;
  }
  return c(e, "SetLike"), xF(e, [{
    key: "add",
    value: /* @__PURE__ */ c(function(t) {
      return this.has(t) === !1 && this.items.push(t), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ c(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ c(function(t) {
      var r = this.items.length;
      return this.items = this.items.filter(function(n) {
        return n !== t;
      }), r !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ c(function(t) {
      var r = this;
      this.items.forEach(function(n) {
        t(n, n, r);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ c(function(t) {
      return this.items.indexOf(t) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ c(function() {
      return this.items.length;
    }, "get")
  }]), e;
})(), Ipe = typeof Set > "u" ? Set : jpe;
function dr(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
c(dr, "getLocalName");
var Npe = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, Mpe = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function AF(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = Mpe[t]) !== null && n !== void 0 && n.has(r));
  });
}
c(AF, "hasGlobalAriaAttributes");
function rS(e, t) {
  return AF(e, t);
}
c(rS, "ignorePresentationalRole");
function $F(e) {
  var t = kF(e);
  if (t === null || Pw.indexOf(t) !== -1) {
    var r = CF(e);
    if (Pw.indexOf(t || "") === -1 || rS(e, r || ""))
      return r;
  }
  return t;
}
c($F, "getRole");
function CF(e) {
  var t = Npe[dr(e)];
  if (t !== void 0)
    return t;
  switch (dr(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !rS(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
c(CF, "getImplicitRole");
function kF(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
c(kF, "getExplicitRole");
var Pw = ["presentation", "none"];
function mt(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
c(mt, "isElement");
function nS(e) {
  return mt(e) && dr(e) === "caption";
}
c(nS, "isHTMLTableCaptionElement");
function Nu(e) {
  return mt(e) && dr(e) === "input";
}
c(Nu, "isHTMLInputElement");
function PF(e) {
  return mt(e) && dr(e) === "optgroup";
}
c(PF, "isHTMLOptGroupElement");
function OF(e) {
  return mt(e) && dr(e) === "select";
}
c(OF, "isHTMLSelectElement");
function RF(e) {
  return mt(e) && dr(e) === "table";
}
c(RF, "isHTMLTableElement");
function jF(e) {
  return mt(e) && dr(e) === "textarea";
}
c(jF, "isHTMLTextAreaElement");
function IF(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
c(IF, "safeWindow");
function NF(e) {
  return mt(e) && dr(e) === "fieldset";
}
c(NF, "isHTMLFieldSetElement");
function MF(e) {
  return mt(e) && dr(e) === "legend";
}
c(MF, "isHTMLLegendElement");
function DF(e) {
  return mt(e) && dr(e) === "slot";
}
c(DF, "isHTMLSlotElement");
function qF(e) {
  return mt(e) && e.ownerSVGElement !== void 0;
}
c(qF, "isSVGElement");
function LF(e) {
  return mt(e) && dr(e) === "svg";
}
c(LF, "isSVGSVGElement");
function FF(e) {
  return qF(e) && dr(e) === "title";
}
c(FF, "isSVGTitleElement");
function yd(e, t) {
  if (mt(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(o) {
      return n.getElementById(o);
    }).filter(
      function(o) {
        return o !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
c(yd, "queryIdRefs");
function ro(e, t) {
  return mt(e) ? t.indexOf($F(e)) !== -1 : !1;
}
c(ro, "hasAnyConcreteRoles");
function UF(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
c(UF, "asFlatString");
function BF(e, t) {
  if (!mt(e))
    return !1;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return !0;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
c(BF, "isHidden");
function HF(e) {
  return ro(e, ["button", "combobox", "listbox", "textbox"]) || oS(e, "range");
}
c(HF, "isControl");
function oS(e, t) {
  if (!mt(e))
    return !1;
  switch (t) {
    case "range":
      return ro(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
c(oS, "hasAbstractRole");
function Ow(e, t) {
  var r = cn(e.querySelectorAll(t));
  return yd(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, cn(n.querySelectorAll(t)));
  }), r;
}
c(Ow, "querySelectorAllSubtree");
function VF(e) {
  return OF(e) ? e.selectedOptions || Ow(e, "[selected]") : Ow(e, '[aria-selected="true"]');
}
c(VF, "querySelectedOptions");
function zF(e) {
  return ro(e, Pw);
}
c(zF, "isMarkedPresentational");
function JF(e) {
  return nS(e);
}
c(JF, "isNativeHostLanguageTextAlternativeElement");
function WF(e) {
  return ro(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
c(WF, "allowsNameFromContent");
function GF(e) {
  return !1;
}
c(GF, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function KF(e) {
  return Nu(e) || jF(e) ? e.value : e.textContent || "";
}
c(KF, "getValueOfTextbox");
function Rw(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
c(Rw, "getTextualContent");
function aS(e) {
  var t = dr(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
c(aS, "isLabelableElement");
function iS(e) {
  if (aS(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && mt(r)) {
      var n = iS(r);
      n !== null && (t = n);
    }
  }), t;
}
c(iS, "findLabelableElement");
function YF(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : iS(e);
}
c(YF, "getControlOfLabel");
function XF(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return cn(t);
  if (!aS(e))
    return null;
  var r = e.ownerDocument;
  return cn(r.querySelectorAll("label")).filter(function(n) {
    return YF(n) === e;
  });
}
c(XF, "getLabels");
function QF(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? cn(e.childNodes) : t;
}
c(QF, "getSlotContents");
function sS(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new Ipe(), n = IF(e), o = t.compute, a = o === void 0 ? "name" : o, i = t.computedStyleSupportsPseudoElements, s = i === void 0 ? t.getComputedStyle !== void 0 : i, d = t.getComputedStyle, l = d === void 0 ? n.getComputedStyle.bind(n) : d, p = t.hidden, f = p === void 0 ? !1 : p;
  function h(b, x) {
    var P = "";
    if (mt(b) && s) {
      var R = l(b, "::before"), N = Rw(R);
      P = "".concat(N, " ").concat(P);
    }
    var C = DF(b) ? QF(b) : cn(b.childNodes).concat(yd(b, "aria-owns"));
    if (C.forEach(function(T) {
      var O = _(T, {
        isEmbeddedInLabel: x.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), k = mt(T) ? l(T).getPropertyValue("display") : "inline", M = k !== "inline" ? " " : "";
      P += "".concat(M).concat(O).concat(M);
    }), mt(b) && s) {
      var A = l(b, "::after"), E = Rw(A);
      P = "".concat(P, " ").concat(E);
    }
    return P.trim();
  }
  c(h, "computeMiscTextAlternative");
  function m(b, x) {
    var P = b.getAttributeNode(x);
    return P !== null && !r.has(P) && P.value.trim() !== "" ? (r.add(P), P.value) : null;
  }
  c(m, "useAttribute");
  function g(b) {
    return mt(b) ? m(b, "title") : null;
  }
  c(g, "computeTooltipAttributeValue");
  function w(b) {
    if (!mt(b))
      return null;
    if (NF(b)) {
      r.add(b);
      for (var x = cn(b.childNodes), P = 0; P < x.length; P += 1) {
        var R = x[P];
        if (MF(R))
          return _(R, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (RF(b)) {
      r.add(b);
      for (var N = cn(b.childNodes), C = 0; C < N.length; C += 1) {
        var A = N[C];
        if (nS(A))
          return _(A, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (LF(b)) {
      r.add(b);
      for (var E = cn(b.childNodes), T = 0; T < E.length; T += 1) {
        var O = E[T];
        if (FF(O))
          return O.textContent;
      }
      return null;
    } else if (dr(b) === "img" || dr(b) === "area") {
      var k = m(b, "alt");
      if (k !== null)
        return k;
    } else if (PF(b)) {
      var M = m(b, "label");
      if (M !== null)
        return M;
    }
    if (Nu(b) && (b.type === "button" || b.type === "submit" || b.type === "reset")) {
      var L = m(b, "value");
      if (L !== null)
        return L;
      if (b.type === "submit")
        return "Submit";
      if (b.type === "reset")
        return "Reset";
    }
    var $ = XF(b);
    if ($ !== null && $.length !== 0)
      return r.add(b), cn($).map(function(J) {
        return _(J, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(J) {
        return J.length > 0;
      }).join(" ");
    if (Nu(b) && b.type === "image") {
      var I = m(b, "alt");
      if (I !== null)
        return I;
      var D = m(b, "title");
      return D !== null ? D : "Submit Query";
    }
    if (ro(b, ["button"])) {
      var F = h(b, {
        isEmbeddedInLabel: !1
      });
      if (F !== "")
        return F;
    }
    return null;
  }
  c(w, "computeElementTextAlternative");
  function _(b, x) {
    if (r.has(b))
      return "";
    if (!f && BF(b, l) && !x.isReferenced)
      return r.add(b), "";
    var P = mt(b) ? b.getAttributeNode("aria-labelledby") : null, R = P !== null && !r.has(P) ? yd(b, "aria-labelledby") : [];
    if (a === "name" && !x.isReferenced && R.length > 0)
      return r.add(P), R.map(function(k) {
        return _(k, {
          isEmbeddedInLabel: x.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var N = x.recursion && HF(b) && a === "name";
    if (!N) {
      var C = (mt(b) && b.getAttribute("aria-label") || "").trim();
      if (C !== "" && a === "name")
        return r.add(b), C;
      if (!zF(b)) {
        var A = w(b);
        if (A !== null)
          return r.add(b), A;
      }
    }
    if (ro(b, ["menu"]))
      return r.add(b), "";
    if (N || x.isEmbeddedInLabel || x.isReferenced) {
      if (ro(b, ["combobox", "listbox"])) {
        r.add(b);
        var E = VF(b);
        return E.length === 0 ? Nu(b) ? b.value : "" : cn(E).map(function(k) {
          return _(k, {
            isEmbeddedInLabel: x.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (oS(b, "range"))
        return r.add(b), b.hasAttribute("aria-valuetext") ? b.getAttribute("aria-valuetext") : b.hasAttribute("aria-valuenow") ? b.getAttribute("aria-valuenow") : b.getAttribute("value") || "";
      if (ro(b, ["textbox"]))
        return r.add(b), KF(b);
    }
    if (WF(b) || mt(b) && x.isReferenced || JF(b) || GF()) {
      var T = h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
      if (T !== "")
        return r.add(b), T;
    }
    if (b.nodeType === b.TEXT_NODE)
      return r.add(b), b.textContent || "";
    if (x.recursion)
      return r.add(b), h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
    var O = g(b);
    return O !== null ? (r.add(b), O) : (r.add(b), "");
  }
  return c(_, "computeTextAlternative"), UF(_(e, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: a === "description",
    recursion: !1
  }));
}
c(sS, "computeTextAlternative");
function ql(e) {
  "@babel/helpers - typeof";
  return ql = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ql(e);
}
c(ql, "_typeof");
function jw(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
c(jw, "ownKeys");
function Iw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jw(Object(r), !0).forEach(function(n) {
      ZF(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : jw(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
c(Iw, "_objectSpread");
function ZF(e, t, r) {
  return t = e5(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
c(ZF, "_defineProperty");
function e5(e) {
  var t = t5(e, "string");
  return ql(t) === "symbol" ? t : String(t);
}
c(e5, "_toPropertyKey");
function t5(e, t) {
  if (ql(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (ql(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
c(t5, "_toPrimitive");
function r5(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = yd(e, "aria-describedby").map(function(a) {
    return sS(a, Iw(Iw({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("aria-description");
    r = n === null ? "" : n;
  }
  if (r === "") {
    var o = e.getAttribute("title");
    r = o === null ? "" : o;
  }
  return r;
}
c(r5, "computeAccessibleDescription");
function n5(e) {
  return ro(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
c(n5, "prohibitsNaming");
function o5(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return n5(e) ? "" : sS(e, t);
}
c(o5, "computeAccessibleName");
var lS = or(hx(), 1), Dpe = or(vL(), 1), qpe = or(dF(), 1), a5 = class extends Error {
  constructor(t, r, n, o) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, n);
    let a = "";
    try {
      a = o.utils.printWithType(
        "Received",
        r,
        o.utils.printReceived
      );
    } catch {
    }
    this.message = [
      o.utils.matcherHint(
        `${o.isNot ? ".not" : ""}.${n.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${o.utils.RECEIVED_COLOR(
        "received"
      )} value must ${t}.`,
      a
    ].join(`
`);
  }
};
c(a5, "GenericTypeError");
var i5 = a5, s5 = class extends i5 {
  constructor(...t) {
    super("be an HTMLElement or an SVGElement", ...t);
  }
};
c(s5, "HtmlElementTypeError");
var bO = s5, l5 = class extends i5 {
  constructor(...t) {
    super("be a Node", ...t);
  }
};
c(l5, "NodeTypeError");
var vO = l5;
function cS(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView)
    throw new t(e, ...r);
}
c(cS, "checkHasWindow");
function c5(e, ...t) {
  cS(e, vO, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node))
    throw new vO(e, ...t);
}
c(c5, "checkNode");
function Xe(e, ...t) {
  cS(e, bO, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement))
    throw new bO(e, ...t);
}
c(Xe, "checkHtmlElement");
var u5 = class extends Error {
  constructor(t, r, n) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, r), this.message = [
      t.message,
      "",
      // eslint-disable-next-line new-cap
      n.utils.RECEIVED_COLOR("Failing css:"),
      // eslint-disable-next-line new-cap
      n.utils.RECEIVED_COLOR(`${t.css}`)
    ].join(`
`);
  }
};
c(u5, "InvalidCSSError");
var Lpe = u5;
function d5(e, ...t) {
  const r = Ppe(`selector { ${e} }`, { silent: !0 }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    const { reason: n, line: o } = r.parsingErrors[0];
    throw new Lpe(
      {
        css: e,
        message: `Syntax error parsing expected css: ${n} on line: ${o}`
      },
      ...t
    );
  }
  return r.rules[0].declarations.filter((n) => n.type === "declaration").reduce(
    (n, { property: o, value: a }) => Object.assign(n, { [o]: a }),
    {}
  );
}
c(d5, "parseCSS");
function Nw(e, t) {
  return typeof t == "string" ? t : e.utils.stringify(t);
}
c(Nw, "display");
function Dt(e, t, r, n, o, a) {
  return [
    `${t}
`,
    // eslint-disable-next-line new-cap
    `${r}:
${e.utils.EXPECTED_COLOR(
      (0, yO.default)(Nw(e, n), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${o}:
${e.utils.RECEIVED_COLOR(
      (0, yO.default)(Nw(e, a), 2)
    )}`
  ].join(`
`);
}
c(Dt, "getMessage");
function p5(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
c(p5, "matches");
function pp(e, t) {
  console.warn(
    `Warning: ${e} has been deprecated and will be removed in future updates.`,
    t
  );
}
c(pp, "deprecate");
function fp(e) {
  return e.replace(/\s+/g, " ").trim();
}
c(fp, "normalize");
function ta(e) {
  return e.tagName && e.tagName.toLowerCase();
}
c(ta, "getTag");
function f5({ multiple: e, options: t }) {
  const r = [...t].filter((n) => n.selected);
  if (e)
    return [...r].map((n) => n.value);
  if (r.length !== 0)
    return r[0].value;
}
c(f5, "getSelectValue");
function h5(e) {
  switch (e.type) {
    case "number":
      return e.value === "" ? null : Number(e.value);
    case "checkbox":
      return e.checked;
    default:
      return e.value;
  }
}
c(h5, "getInputValue");
var Fpe = ["meter", "progressbar", "slider", "spinbutton"];
function m5(e) {
  if (Fpe.includes(e.getAttribute("role")))
    return Number(e.getAttribute("aria-valuenow"));
}
c(m5, "getAccessibleValue");
function uS(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case "input":
        return h5(e);
      case "select":
        return f5(e);
      default:
        return e.value ?? m5(e);
    }
}
c(uS, "getSingleElementValue");
function y5(e, { wordConnector: t = ", ", lastWordConnector: r = " and " } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(
    e.length > 1 ? r : ""
  );
}
c(y5, "toSentence");
function qy(e, t) {
  return Array.isArray(e) && Array.isArray(t) ? [...new Set(e)].every((r) => new Set(t).has(r)) : e === t;
}
c(qy, "compareAsSet");
function lh(e, t) {
  return pp(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  ), e && Xe(e, lh, this), t && Xe(t, lh, this), {
    pass: t ? t.contains(e) : !!e,
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(
        e && e.cloneNode(!1)
      )}`
    ].join(`
`), "message")
  };
}
c(lh, "toBeInTheDOM");
function dS(e) {
  (e !== null || !this.isNot) && Xe(e, dS, this);
  const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }), r = /* @__PURE__ */ c(() => `expected document not to contain element, found ${this.utils.stringify(
    e.cloneNode(!0)
  )} instead`, "errorFound"), n = /* @__PURE__ */ c(() => "element could not be found in the document", "errorNotFound");
  return {
    pass: t,
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
        "element",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(this.isNot ? r() : n())
    ].join(`
`), "message")
  };
}
c(dS, "toBeInTheDocument");
function pS(e) {
  return pp(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  ), Xe(e, pS, this), {
    pass: e.innerHTML === "",
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmpty`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
c(pS, "toBeEmpty");
function fS(e) {
  return Xe(e, fS, this), {
    pass: g5(e),
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
c(fS, "toBeEmptyDOMElement");
function g5(e) {
  return [...e.childNodes].filter((t) => t.nodeType !== 8).length === 0;
}
c(g5, "isEmptyElement");
function ch(e, t) {
  return Xe(e, ch, this), t !== null && Xe(t, ch, this), {
    pass: e.contains(t),
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainElement`,
        "element",
        "element"
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(`${this.utils.stringify(
        e.cloneNode(!1)
      )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(t && t.cloneNode(!1))}
        `)
    ].join(`
`), "message")
  };
}
c(ch, "toContainElement");
function b5(e, t) {
  const r = e.ownerDocument.createElement("div");
  return r.innerHTML = t, r.innerHTML;
}
c(b5, "getNormalizedHtml");
function hS(e, t) {
  if (Xe(e, hS, this), typeof t != "string")
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(b5(e, t)),
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainHTML`,
        "element",
        ""
      ),
      "Expected:",
      // eslint-disable-next-line new-cap
      `  ${this.utils.EXPECTED_COLOR(t)}`,
      "Received:",
      `  ${this.utils.printReceived(e.cloneNode(!0))}`
    ].join(`
`), "message")
  };
}
c(hS, "toContainHTML");
function mS(e, t, r = { normalizeWhitespace: !0 }) {
  c5(e, mS, this);
  const n = r.normalizeWhitespace ? fp(e.textContent) : e.textContent.replace(/\u00a0/g, " "), o = n !== "" && t === "";
  return {
    pass: !o && p5(n, t),
    message: /* @__PURE__ */ c(() => {
      const a = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        o ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${a} have text content`,
        t,
        "Received",
        n
      );
    }, "message")
  };
}
c(mS, "toHaveTextContent");
function uh(e, t) {
  Xe(e, uh, this);
  const r = r5(e), n = arguments.length === 1;
  let o = !1;
  return n ? o = r !== "" : o = t instanceof RegExp ? t.test(r) : this.equals(
    r,
    t
  ), {
    pass: o,
    message: /* @__PURE__ */ c(() => {
      const a = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${uh.name}`,
          "element",
          ""
        ),
        `Expected element ${a} have accessible description`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
c(uh, "toHaveAccessibleDescription");
var ru = "aria-invalid", Upe = ["false"];
function yS(e, t) {
  Xe(e, yS, this);
  const r = this.isNot ? "not to" : "to", n = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", o = e.getAttribute("aria-errormessage");
  if (o && /\s+/.test(o))
    return {
      pass: !1,
      message: /* @__PURE__ */ c(() => Dt(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
        "",
        "Received",
        `aria-errormessage="${o}"`
      ), "message")
    };
  const a = e.getAttribute(ru);
  if (!e.hasAttribute(ru) || Upe.includes(a))
    return {
      pass: !1,
      message: /* @__PURE__ */ c(() => Dt(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element to be marked as invalid with attribute",
        `${ru}="${String(!0)}"`,
        "Received",
        e.hasAttribute("aria-invalid") ? `${ru}="${e.getAttribute(ru)}` : null
      ), "message")
    };
  const i = fp(
    e.ownerDocument.getElementById(o)?.textContent ?? ""
  );
  return {
    pass: t === void 0 ? !!i : t instanceof RegExp ? t.test(i) : this.equals(i, t),
    message: /* @__PURE__ */ c(() => Dt(
      this,
      this.utils.matcherHint(n, "element"),
      `Expected element ${r} have accessible error message`,
      t ?? "",
      "Received",
      i
    ), "message")
  };
}
c(yS, "toHaveAccessibleErrorMessage");
var Bpe = _5(lS.elementRoles);
function dh(e, t) {
  Xe(e, dh, this);
  const r = v5(e);
  return {
    pass: r.some((n) => n === t),
    message: /* @__PURE__ */ c(() => {
      const n = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${dh.name}`,
          "element",
          ""
        ),
        `Expected element ${n} have role`,
        t,
        "Received",
        r.join(", ")
      );
    }, "message")
  };
}
c(dh, "toHaveRole");
function v5(e) {
  return e.hasAttribute("role") ? e.getAttribute("role").split(" ").filter(Boolean) : w5(e);
}
c(v5, "getExplicitOrImplicitRoles");
function w5(e) {
  for (const { match: t, roles: r } of Bpe)
    if (t(e))
      return [...r];
  return [];
}
c(w5, "getImplicitAriaRoles");
function _5(e) {
  function t({ name: i, attributes: s }) {
    return `${i}${s.map(({ name: d, value: l, constraints: p = [] }) => p.indexOf("undefined") !== -1 ? `:not([${d}])` : l ? `[${d}="${l}"]` : `[${d}]`).join("")}`;
  }
  c(t, "makeElementSelector");
  function r({ attributes: i = [] }) {
    return i.length;
  }
  c(r, "getSelectorSpecificity");
  function n({ specificity: i }, { specificity: s }) {
    return s - i;
  }
  c(n, "bySelectorSpecificity");
  function o(i) {
    let { attributes: s = [] } = i;
    const d = s.findIndex(
      (p) => p.value && p.name === "type" && p.value === "text"
    );
    d >= 0 && (s = [
      ...s.slice(0, d),
      ...s.slice(d + 1)
    ]);
    const l = t({ ...i, attributes: s });
    return (p) => d >= 0 && p.type !== "text" ? !1 : p.matches(l);
  }
  c(o, "match");
  let a = [];
  for (const [i, s] of e.entries())
    a = [
      ...a,
      {
        match: o(i),
        roles: Array.from(s),
        specificity: r(i)
      }
    ];
  return a.sort(n);
}
c(_5, "buildElementRoleList");
function ph(e, t) {
  Xe(e, ph, this);
  const r = o5(e), n = arguments.length === 1;
  let o = !1;
  return n ? o = r !== "" : o = t instanceof RegExp ? t.test(r) : this.equals(r, t), {
    pass: o,
    message: /* @__PURE__ */ c(() => {
      const a = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${ph.name}`,
          "element",
          ""
        ),
        `Expected element ${a} have accessible name`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
c(ph, "toHaveAccessibleName");
function Mw(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
c(Mw, "printAttribute");
function E5(e, t, r) {
  return r === void 0 ? `element.hasAttribute(${e(t)})` : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
c(E5, "getAttributeComment");
function gS(e, t, r) {
  Xe(e, gS, this);
  const n = r !== void 0, o = e.hasAttribute(t), a = e.getAttribute(t);
  return {
    pass: n ? o && this.equals(a, r) : o,
    message: /* @__PURE__ */ c(() => {
      const i = this.isNot ? "not to" : "to", s = o ? Mw(this.utils.stringify, t, a) : null, d = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(t),
        {
          secondArgument: n ? this.utils.printExpected(r) : void 0,
          comment: E5(
            this.utils.stringify,
            t,
            r
          )
        }
      );
      return Dt(
        this,
        d,
        `Expected the element ${i} have attribute`,
        Mw(this.utils.stringify, t, r),
        "Received",
        s
      );
    }, "message")
  };
}
c(gS, "toHaveAttribute");
function x5(e) {
  const t = e.pop();
  let r, n;
  return typeof t == "object" && !(t instanceof RegExp) ? (r = e, n = t) : (r = e.concat(t), n = { exact: !1 }), { expectedClassNames: r, options: n };
}
c(x5, "getExpectedClassNamesAndOptions");
function Dw(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
c(Dw, "splitClassNames");
function qw(e, t) {
  return e.every(
    (r) => typeof r == "string" ? t.includes(r) : t.some((n) => r.test(n))
  );
}
c(qw, "isSubset$1");
function bS(e, ...t) {
  Xe(e, bS, this);
  const { expectedClassNames: r, options: n } = x5(t), o = Dw(e.getAttribute("class")), a = r.reduce(
    (s, d) => s.concat(
      typeof d == "string" || !d ? Dw(d) : d
    ),
    []
  ), i = a.some((s) => s instanceof RegExp);
  if (n.exact && i)
    throw new Error("Exact option does not support RegExp expected class names");
  return n.exact ? {
    pass: qw(a, o) && a.length === o.length,
    message: /* @__PURE__ */ c(() => {
      const s = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(a.join(" "))
        ),
        `Expected the element ${s} have EXACTLY defined classes`,
        a.join(" "),
        "Received",
        o.join(" ")
      );
    }, "message")
  } : a.length > 0 ? {
    pass: qw(a, o),
    message: /* @__PURE__ */ c(() => {
      const s = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(a.join(" "))
        ),
        `Expected the element ${s} have class`,
        a.join(" "),
        "Received",
        o.join(" ")
      );
    }, "message")
  } : {
    pass: this.isNot ? o.length > 0 : !1,
    message: /* @__PURE__ */ c(() => this.isNot ? Dt(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      o.join(" ")
    ) : [
      this.utils.matcherHint(".toHaveClass", "element"),
      "At least one expected class must be provided."
    ].join(`
`), "message")
  };
}
c(bS, "toHaveClass");
function S5(e, t) {
  const r = {}, n = e.createElement("div");
  return Object.keys(t).forEach((o) => {
    n.style[o] = t[o], r[o] = n.style[o];
  }), r;
}
c(S5, "getStyleDeclaration");
function T5(e, t) {
  return !!Object.keys(e).length && Object.entries(e).every(([r, n]) => {
    const o = r.startsWith("--"), a = [r];
    return o || a.push(r.toLowerCase()), a.some(
      (i) => t[i] === n || t.getPropertyValue(i) === n
    );
  });
}
c(T5, "isSubset");
function Lw(e) {
  return Object.keys(e).sort().map((t) => `${t}: ${e[t]};`).join(`
`);
}
c(Lw, "printoutStyles");
function A5(e, t, r) {
  const n = Array.from(r).filter((o) => t[o] !== void 0).reduce(
    (o, a) => Object.assign(o, { [a]: r.getPropertyValue(a) }),
    {}
  );
  return e(Lw(t), Lw(n)).replace(`${Dpe.default.red("+ Received")}
`, "");
}
c(A5, "expectedDiff");
function fh(e, t) {
  Xe(e, fh, this);
  const r = typeof t == "object" ? t : d5(t, fh, this), { getComputedStyle: n } = e.ownerDocument.defaultView, o = S5(e.ownerDocument, r), a = n(e);
  return {
    pass: T5(o, a),
    message: /* @__PURE__ */ c(() => {
      const i = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(i, "element", ""),
        A5(this.utils.diff, o, a)
      ].join(`

`);
    }, "message")
  };
}
c(fh, "toHaveStyle");
function vS(e) {
  return Xe(e, vS, this), {
    pass: e.ownerDocument.activeElement === e,
    message: /* @__PURE__ */ c(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveFocus`,
        "element",
        ""
      ),
      "",
      ...this.isNot ? [
        "Received element is focused:",
        `  ${this.utils.printReceived(e)}`
      ] : [
        "Expected element with focus:",
        `  ${this.utils.printExpected(e)}`,
        "Received element with focus:",
        `  ${this.utils.printReceived(
          e.ownerDocument.activeElement
        )}`
      ]
    ].join(`
`), "message")
  };
}
c(vS, "toHaveFocus");
function $5(e) {
  const t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  switch (t[0]) {
    case "radio": {
      const r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case "checkbox":
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
c($5, "getMultiElementValue");
function C5(e, t) {
  const r = [...e.querySelectorAll(`[name="${(0, qpe.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return uS(r[0]);
      default:
        return $5(r);
    }
}
c(C5, "getFormValue");
function k5(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
c(k5, "getPureName");
function P5(e) {
  return Array.from(e.elements).map((t) => t.name).reduce(
    (t, r) => ({
      ...t,
      [k5(r)]: C5(e, r)
    }),
    {}
  );
}
c(P5, "getAllFormValues");
function wS(e, t) {
  if (Xe(e, wS, this), !e.elements)
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  const r = P5(e);
  return {
    pass: Object.entries(t).every(
      ([n, o]) => qy(r[n], o)
    ),
    message: /* @__PURE__ */ c(() => {
      const n = this.isNot ? "not to" : "to", o = `${this.isNot ? ".not" : ""}.toHaveFormValues`, a = Object.keys(r).filter((i) => t.hasOwnProperty(i)).reduce((i, s) => ({ ...i, [s]: r[s] }), {});
      return [
        this.utils.matcherHint(o, "element", ""),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, a)
      ].join(`

`);
    }, "message")
  };
}
c(wS, "toHaveFormValues");
function O5(e) {
  const { getComputedStyle: t } = e.ownerDocument.defaultView, { display: r, visibility: n, opacity: o } = t(e);
  return r !== "none" && n !== "hidden" && n !== "collapse" && o !== "0" && o !== 0;
}
c(O5, "isStyleVisible");
function R5(e, t) {
  let r;
  return t ? r = e.nodeName === "DETAILS" && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0 : r = e.nodeName === "DETAILS" ? e.hasAttribute("open") : !0, !e.hasAttribute("hidden") && r;
}
c(R5, "isAttributeVisible");
function _S(e, t) {
  return O5(e) && R5(e, t) && (!e.parentElement || _S(e.parentElement, e));
}
c(_S, "isElementVisible");
function ES(e) {
  Xe(e, ES, this);
  const t = e.ownerDocument === e.getRootNode({ composed: !0 }), r = t && _S(e);
  return {
    pass: r,
    message: /* @__PURE__ */ c(() => {
      const n = r ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${n} visible${t ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(ES, "toBeVisible");
var Hpe = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function j5(e, t) {
  return ta(e) === "legend" && ta(t) === "fieldset" && e.isSameNode(
    Array.from(t.children).find((r) => ta(r) === "legend")
  );
}
c(j5, "isFirstLegendChildOfFieldset");
function I5(e, t) {
  return SS(t) && !j5(e, t);
}
c(I5, "isElementDisabledByParent");
function N5(e) {
  return e.includes("-");
}
c(N5, "isCustomElement");
function xS(e) {
  const t = ta(e);
  return Hpe.includes(t) || N5(t);
}
c(xS, "canElementBeDisabled");
function SS(e) {
  return xS(e) && e.hasAttribute("disabled");
}
c(SS, "isElementDisabled");
function TS(e) {
  const t = e.parentElement;
  return !!t && (I5(e, t) || TS(t));
}
c(TS, "isAncestorDisabled");
function AS(e) {
  return xS(e) && (SS(e) || TS(e));
}
c(AS, "isElementOrAncestorDisabled");
function $S(e) {
  Xe(e, $S, this);
  const t = AS(e);
  return {
    pass: t,
    message: /* @__PURE__ */ c(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c($S, "toBeDisabled");
function CS(e) {
  Xe(e, CS, this);
  const t = !AS(e);
  return {
    pass: t,
    message: /* @__PURE__ */ c(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(CS, "toBeEnabled");
var Vpe = ["select", "textarea"], zpe = ["input", "select", "textarea"], Jpe = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
], Wpe = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function M5(e) {
  return Vpe.includes(ta(e)) && e.hasAttribute("required");
}
c(M5, "isRequiredOnFormTagsExceptInput");
function D5(e) {
  return ta(e) === "input" && e.hasAttribute("required") && (e.hasAttribute("type") && !Jpe.includes(e.getAttribute("type")) || !e.hasAttribute("type"));
}
c(D5, "isRequiredOnSupportedInput");
function q5(e) {
  return e.hasAttribute("aria-required") && e.getAttribute("aria-required") === "true" && (zpe.includes(ta(e)) || e.hasAttribute("role") && Wpe.includes(e.getAttribute("role")));
}
c(q5, "isElementRequiredByARIA");
function kS(e) {
  Xe(e, kS, this);
  const t = M5(e) || D5(e) || q5(e);
  return {
    pass: t,
    message: /* @__PURE__ */ c(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(kS, "toBeRequired");
var Gpe = ["form", "input", "select", "textarea"];
function L5(e) {
  return e.hasAttribute("aria-invalid") && e.getAttribute("aria-invalid") !== "false";
}
c(L5, "isElementHavingAriaInvalid");
function F5(e) {
  return Gpe.includes(ta(e));
}
c(F5, "isSupportsValidityMethod");
function PS(e) {
  const t = L5(e);
  return F5(e) ? t || !e.checkValidity() : t;
}
c(PS, "isElementInvalid");
function OS(e) {
  Xe(e, OS, this);
  const t = PS(e);
  return {
    pass: t,
    message: /* @__PURE__ */ c(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(OS, "toBeInvalid");
function RS(e) {
  Xe(e, RS, this);
  const t = !PS(e);
  return {
    pass: t,
    message: /* @__PURE__ */ c(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(RS, "toBeValid");
function jS(e, t) {
  if (Xe(e, jS, this), e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type))
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  const r = uS(e), n = t !== void 0;
  let o = t, a = r;
  return t == r && t !== r && (o = `${t} (${typeof t})`, a = `${r} (${typeof r})`), {
    pass: n ? qy(r, t) : !!r,
    message: /* @__PURE__ */ c(() => {
      const i = this.isNot ? "not to" : "to", s = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        t
      );
      return Dt(
        this,
        s,
        `Expected the element ${i} have value`,
        n ? o : "(any)",
        "Received",
        a
      );
    }, "message")
  };
}
c(jS, "toHaveValue");
function IS(e, t) {
  Xe(e, IS, this);
  const r = e.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(r))
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  if (r === "input" && ["radio", "checkbox"].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`
    );
  const n = U5(r, e), o = B5(t), a = o.filter(
    (d) => n.some(
      (l) => d instanceof RegExp ? d.test(l) : this.equals(l, String(d))
    )
  ).length, i = a === n.length, s = a === o.length;
  return {
    pass: i && s,
    message: /* @__PURE__ */ c(() => Dt(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      t,
      "Received",
      n
    ), "message")
  };
}
c(IS, "toHaveDisplayValue");
function U5(e, t) {
  return e === "select" ? Array.from(t).filter((r) => r.selected).map((r) => r.textContent) : [t.value];
}
c(U5, "getValues");
function B5(e) {
  return e instanceof Array ? e : [e];
}
c(B5, "getExpectedValues");
function NS(e) {
  Xe(e, NS, this);
  const t = /* @__PURE__ */ c(() => e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type), "isValidInput"), r = /* @__PURE__ */ c(() => MS(e.getAttribute("role")) && ["true", "false"].includes(e.getAttribute("aria-checked")), "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: !1,
      message: /* @__PURE__ */ c(() => `only inputs with type="checkbox" or type="radio" or elements with ${H5()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`, "message")
    };
  const n = /* @__PURE__ */ c(() => t() ? e.checked : e.getAttribute("aria-checked") === "true", "isChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ c(() => {
      const o = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${o} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(NS, "toBeChecked");
function H5() {
  return y5(
    V5().map((e) => `role="${e}"`),
    { lastWordConnector: " or " }
  );
}
c(H5, "supportedRolesSentence");
function V5() {
  return lS.roles.keys().filter(MS);
}
c(V5, "supportedRoles");
function MS(e) {
  return lS.roles.get(e)?.props["aria-checked"] !== void 0;
}
c(MS, "roleSupportsChecked");
function DS(e) {
  Xe(e, DS, this);
  const t = /* @__PURE__ */ c(() => e.tagName.toLowerCase() === "input" && e.type === "checkbox", "isValidInput"), r = /* @__PURE__ */ c(() => e.getAttribute("role") === "checkbox", "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: !1,
      message: /* @__PURE__ */ c(() => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead', "message")
    };
  const n = /* @__PURE__ */ c(() => {
    const o = e.getAttribute("aria-checked") === "mixed";
    return t() && e.indeterminate || o;
  }, "isPartiallyChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ c(() => {
      const o = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${o} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
c(DS, "toBePartiallyChecked");
function qS(e, t) {
  pp(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  ), Xe(e, qS, this);
  const r = t !== void 0, n = (e.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean);
  let o = "";
  if (n.length > 0) {
    const a = e.ownerDocument, i = n.map((s) => a.getElementById(s)).filter(Boolean);
    o = fp(i.map((s) => s.textContent).join(" "));
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(o) : this.equals(o, t) : !!o,
    message: /* @__PURE__ */ c(() => {
      const a = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${a} have description`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(o)
      );
    }, "message")
  };
}
c(qS, "toHaveDescription");
function LS(e, t) {
  if (pp("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), Xe(e, LS, this), !e.hasAttribute("aria-invalid") || e.getAttribute("aria-invalid") === "false") {
    const a = this.isNot ? ".not" : "";
    return {
      pass: !1,
      message: /* @__PURE__ */ c(() => Dt(
        this,
        this.utils.matcherHint(`${a}.toHaveErrorMessage`, "element", ""),
        "Expected the element to have invalid state indicated by",
        'aria-invalid="true"',
        "Received",
        e.hasAttribute("aria-invalid") ? `aria-invalid="${e.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
      ), "message")
    };
  }
  const r = t !== void 0, n = (e.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean);
  let o = "";
  if (n.length > 0) {
    const a = e.ownerDocument, i = n.map((s) => a.getElementById(s)).filter(Boolean);
    o = fp(
      i.map((s) => s.textContent).join(" ")
    );
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(o) : this.equals(o, t) : !!o,
    message: /* @__PURE__ */ c(() => {
      const a = this.isNot ? "not to" : "to";
      return Dt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${a} have error message`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(o)
      );
    }, "message")
  };
}
c(LS, "toHaveErrorMessage");
function z5(e) {
  const t = e.ownerDocument.getSelection();
  if (["input", "textarea"].includes(e.tagName.toLowerCase()))
    return ["radio", "checkbox"].includes(e.type) ? "" : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null)
    return "";
  const r = t.getRangeAt(0), n = e.ownerDocument.createRange();
  if (t.containsNode(e, !1))
    n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n);
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    const a = e === r.startContainer || e.contains(r.startContainer), i = e === r.endContainer || e.contains(r.endContainer);
    t.removeAllRanges(), (a || i) && (n.selectNodeContents(e), a && n.setStart(
      r.startContainer,
      r.startOffset
    ), i && n.setEnd(
      r.endContainer,
      r.endOffset
    ), t.addRange(n));
  }
  const o = t.toString();
  return t.removeAllRanges(), t.addRange(r), o;
}
c(z5, "getSelection");
function FS(e, t) {
  Xe(e, FS, this);
  const r = t !== void 0;
  if (r && typeof t != "string")
    throw new Error("expected selection must be a string or undefined");
  const n = z5(e);
  return {
    pass: r ? qy(n, t) : !!n,
    message: /* @__PURE__ */ c(() => {
      const o = this.isNot ? "not to" : "to", a = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        t
      );
      return Dt(
        this,
        a,
        `Expected the element ${o} have selection`,
        r ? t : "(any)",
        "Received",
        n
      );
    }, "message")
  };
}
c(FS, "toHaveSelection");
function US(e) {
  Xe(e, US, this);
  const t = (e.getAttribute("role") || "").split(" ").map((o) => o.trim()), r = e.tagName.toLowerCase() === "button" || e.tagName.toLowerCase() === "input" && e.type === "button" || t.includes("button"), n = e.getAttribute("aria-pressed");
  return !r || !(n === "true" || n === "false") ? {
    pass: !1,
    message: /* @__PURE__ */ c(() => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()', "message")
  } : {
    pass: r && n === "true",
    message: /* @__PURE__ */ c(() => {
      const o = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePressed`,
        "element",
        ""
      );
      return Dt(
        this,
        o,
        "Expected element to have",
        `aria-pressed="${this.isNot ? "false" : "true"}"`,
        "Received",
        `aria-pressed="${n}"`
      );
    }, "message")
  };
}
c(US, "toBePressed");
function BS(e) {
  Xe(e, BS, this);
  const t = (e.getAttribute("role") || "").split(" ").map((o) => o.trim()), r = e.tagName.toLowerCase() === "button" || e.tagName.toLowerCase() === "input" && e.type === "button" || t.includes("button"), n = e.getAttribute("aria-pressed");
  return !r || !(n === "true" || n === "false" || n === "mixed") ? {
    pass: !1,
    message: /* @__PURE__ */ c(() => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()', "message")
  } : {
    pass: r && n === "mixed",
    message: /* @__PURE__ */ c(() => {
      const o = this.isNot ? "not to" : "to", a = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePartiallyPressed`,
        "element",
        ""
      );
      return Dt(
        this,
        a,
        `Expected element ${o} have`,
        'aria-pressed="mixed"',
        "Received",
        `aria-pressed="${n}"`
      );
    }, "message")
  };
}
c(BS, "toBePartiallyPressed");
or(uF(), 1);
or(hx(), 1);
or(vL(), 1);
or(dF(), 1);
var cv, wO;
function J5() {
  if (wO) return cv;
  wO = 1;
  var e, t, r, n, o, a, i, s, d, l, p, f, h, m, g, w, _, b, x;
  return h = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, f = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, e = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, p = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, w = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, x = /[\t\v\f\ufeff\p{Zs}]+/yu, s = /\r?\n|[\r\u2028\u2029]/y, d = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, m = /\/\/.*/y, r = /[<>.:={}]|\/(?![\/*])/y, t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, n = /(['"])(?:(?!\1)[^])*(\1)?/y, o = /[^<>{}]+/y, b = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, _ = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, a = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, i = /^(?:return|throw|yield)$/, l = RegExp(s.source), cv = /* @__PURE__ */ c(function* (P, { jsx: R = !1 } = {}) {
    var N, C, A, E, T, O, k, M, L, $, I, D, F, J;
    for ({ length: O } = P, E = 0, T = "", J = [
      { tag: "JS" }
    ], N = [], I = 0, D = !1; E < O; ) {
      switch (M = J[J.length - 1], M.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (P[E] === "/" && (b.test(T) || a.test(T)) && (h.lastIndex = E, k = h.exec(P))) {
            E = h.lastIndex, T = k[0], D = !0, yield {
              type: "RegularExpressionLiteral",
              value: k[0],
              closed: k[1] !== void 0 && k[1] !== "\\"
            };
            continue;
          }
          if (f.lastIndex = E, k = f.exec(P)) {
            switch (F = k[0], L = f.lastIndex, $ = F, F) {
              case "(":
                T === "?NonExpressionParenKeyword" && J.push({
                  tag: "JSNonExpressionParen",
                  nesting: I
                }), I++, D = !1;
                break;
              case ")":
                I--, D = !0, M.tag === "JSNonExpressionParen" && I === M.nesting && (J.pop(), $ = "?NonExpressionParenEnd", D = !1);
                break;
              case "{":
                f.lastIndex = 0, A = !_.test(T) && (b.test(T) || a.test(T)), N.push(A), D = !1;
                break;
              case "}":
                switch (M.tag) {
                  case "InterpolationInTemplate":
                    if (N.length === M.nesting) {
                      w.lastIndex = E, k = w.exec(P), E = w.lastIndex, T = k[0], k[1] === "${" ? (T = "?InterpolationInTemplate", D = !1, yield {
                        type: "TemplateMiddle",
                        value: k[0]
                      }) : (J.pop(), D = !0, yield {
                        type: "TemplateTail",
                        value: k[0],
                        closed: k[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (N.length === M.nesting) {
                      J.pop(), E += 1, T = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                D = N.pop(), $ = D ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                D = !0;
                break;
              case "++":
              case "--":
                $ = D ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (R && (b.test(T) || a.test(T))) {
                  J.push({ tag: "JSXTag" }), E += 1, T = "<", yield {
                    type: "JSXPunctuator",
                    value: F
                  };
                  continue;
                }
                D = !1;
                break;
              default:
                D = !1;
            }
            E = L, T = $, yield {
              type: "Punctuator",
              value: F
            };
            continue;
          }
          if (e.lastIndex = E, k = e.exec(P)) {
            switch (E = e.lastIndex, $ = k[0], k[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                T !== "." && T !== "?." && ($ = "?NonExpressionParenKeyword");
            }
            T = $, D = !a.test(k[0]), yield {
              type: k[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: k[0]
            };
            continue;
          }
          if (g.lastIndex = E, k = g.exec(P)) {
            E = g.lastIndex, T = k[0], D = !0, yield {
              type: "StringLiteral",
              value: k[0],
              closed: k[2] !== void 0
            };
            continue;
          }
          if (p.lastIndex = E, k = p.exec(P)) {
            E = p.lastIndex, T = k[0], D = !0, yield {
              type: "NumericLiteral",
              value: k[0]
            };
            continue;
          }
          if (w.lastIndex = E, k = w.exec(P)) {
            E = w.lastIndex, T = k[0], k[1] === "${" ? (T = "?InterpolationInTemplate", J.push({
              tag: "InterpolationInTemplate",
              nesting: N.length
            }), D = !1, yield {
              type: "TemplateHead",
              value: k[0]
            }) : (D = !0, yield {
              type: "NoSubstitutionTemplate",
              value: k[0],
              closed: k[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (r.lastIndex = E, k = r.exec(P)) {
            switch (E = r.lastIndex, $ = k[0], k[0]) {
              case "<":
                J.push({ tag: "JSXTag" });
                break;
              case ">":
                J.pop(), T === "/" || M.tag === "JSXTagEnd" ? ($ = "?JSX", D = !0) : J.push({ tag: "JSXChildren" });
                break;
              case "{":
                J.push({
                  tag: "InterpolationInJSX",
                  nesting: N.length
                }), $ = "?InterpolationInJSX", D = !1;
                break;
              case "/":
                T === "<" && (J.pop(), J[J.length - 1].tag === "JSXChildren" && J.pop(), J.push({ tag: "JSXTagEnd" }));
            }
            T = $, yield {
              type: "JSXPunctuator",
              value: k[0]
            };
            continue;
          }
          if (t.lastIndex = E, k = t.exec(P)) {
            E = t.lastIndex, T = k[0], yield {
              type: "JSXIdentifier",
              value: k[0]
            };
            continue;
          }
          if (n.lastIndex = E, k = n.exec(P)) {
            E = n.lastIndex, T = k[0], yield {
              type: "JSXString",
              value: k[0],
              closed: k[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (o.lastIndex = E, k = o.exec(P)) {
            E = o.lastIndex, T = k[0], yield {
              type: "JSXText",
              value: k[0]
            };
            continue;
          }
          switch (P[E]) {
            case "<":
              J.push({ tag: "JSXTag" }), E++, T = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              J.push({
                tag: "InterpolationInJSX",
                nesting: N.length
              }), E++, T = "?InterpolationInJSX", D = !1, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (x.lastIndex = E, k = x.exec(P)) {
        E = x.lastIndex, yield {
          type: "WhiteSpace",
          value: k[0]
        };
        continue;
      }
      if (s.lastIndex = E, k = s.exec(P)) {
        E = s.lastIndex, D = !1, i.test(T) && (T = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: k[0]
        };
        continue;
      }
      if (d.lastIndex = E, k = d.exec(P)) {
        E = d.lastIndex, l.test(k[0]) && (D = !1, i.test(T) && (T = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: k[0],
          closed: k[1] !== void 0
        };
        continue;
      }
      if (m.lastIndex = E, k = m.exec(P)) {
        E = m.lastIndex, D = !1, yield {
          type: "SingleLineComment",
          value: k[0]
        };
        continue;
      }
      C = String.fromCodePoint(P.codePointAt(E)), E += C.length, T = C, D = !1, yield {
        type: M.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: C
      };
    }
  }, "jsTokens_1"), cv;
}
c(J5, "requireJsTokens");
var Kpe = J5();
tx(Kpe);
var W5 = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(W5.keyword);
new Set(W5.strict);
function Mu(e, t) {
  if (!e)
    throw new Error(t);
}
c(Mu, "assert");
function qi(e, t) {
  return typeof t === e;
}
c(qi, "isType");
function G5(e) {
  return e instanceof Promise;
}
c(G5, "isPromise");
function Ll(e, t, r) {
  Object.defineProperty(e, t, r);
}
c(Ll, "define");
function Ki(e, t, r) {
  Ll(e, t, { value: r, configurable: !0, writable: !0 });
}
c(Ki, "defineValue");
var ja = Symbol.for("tinyspy:spy"), Ype = /* @__PURE__ */ new Set(), Xpe = /* @__PURE__ */ c((e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "reset"), Qpe = /* @__PURE__ */ c((e) => (Ll(e, ja, {
  value: { reset: /* @__PURE__ */ c(() => Xpe(e[ja]), "reset") }
}), e[ja]), "defineState"), Fw = /* @__PURE__ */ c((e) => e[ja] || Qpe(e), "getInternalState");
function K5(e) {
  Mu(
    qi("function", e) || qi("undefined", e),
    "cannot spy on a non-function value"
  );
  let t = /* @__PURE__ */ c(function(...n) {
    let o = Fw(t);
    o.called = !0, o.callCount++, o.calls.push(n);
    let a = o.next.shift();
    if (a) {
      o.results.push(a);
      let [p, f] = a;
      if (p === "ok")
        return f;
      throw f;
    }
    let i, s = "ok", d = o.results.length;
    if (o.impl)
      try {
        new.target ? i = Reflect.construct(o.impl, n, new.target) : i = o.impl.apply(this, n), s = "ok";
      } catch (p) {
        throw i = p, s = "error", o.results.push([s, p]), p;
      }
    let l = [s, i];
    return G5(i) && i.then(
      (p) => o.resolves[d] = ["ok", p],
      (p) => o.resolves[d] = ["error", p]
    ), o.results.push(l), i;
  }, "fn");
  Ki(t, "_isMockFunction", !0), Ki(t, "length", e ? e.length : 0), Ki(t, "name", e && e.name || "spy");
  let r = Fw(t);
  return r.reset(), r.impl = e, t;
}
c(K5, "createInternalSpy");
function Y5(e) {
  return !!e && e._isMockFunction === !0;
}
c(Y5, "isMockFunction");
var X5 = /* @__PURE__ */ c((e, t) => {
  let r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return [e, r];
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    let o = Object.getOwnPropertyDescriptor(n, t);
    if (o)
      return [n, o];
    n = Object.getPrototypeOf(n);
  }
}, "getDescriptor"), _O = /* @__PURE__ */ c((e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
}, "setPototype");
function HS(e, t, r) {
  Mu(
    !qi("undefined", e),
    "spyOn could not find an object to spy upon"
  ), Mu(
    qi("object", e) || qi("function", e),
    "cannot spyOn on a primitive value"
  );
  let [n, o] = (() => {
    if (!qi("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [a, i] = X5(e, n) || [];
  Mu(
    i || n in e,
    `${String(n)} does not exist`
  );
  let s = !1;
  o === "value" && i && !i.value && i.get && (o = "get", s = !0, r = i.get());
  let d;
  i ? d = i[o] : o !== "value" ? d = /* @__PURE__ */ c(() => e[n], "original") : d = e[n], d && eU(d) && (d = d[ja].getOriginal());
  let l = /* @__PURE__ */ c((m) => {
    let { value: g, ...w } = i || {
      configurable: !0,
      writable: !0
    };
    o !== "value" && delete w.writable, w[o] = m, Ll(e, n, w);
  }, "reassign"), p = /* @__PURE__ */ c(() => {
    a !== e ? Reflect.deleteProperty(e, n) : i && !d ? Ll(e, n, i) : l(d);
  }, "restore");
  r || (r = d);
  let f = Z5(K5(r), r);
  o === "value" && _O(f, d);
  let h = f[ja];
  return Ki(h, "restore", p), Ki(h, "getOriginal", () => s ? d() : d), Ki(h, "willCall", (m) => (h.impl = m, f)), l(
    s ? () => (_O(f, r), f) : f
  ), Ype.add(f), f;
}
c(HS, "internalSpyOn");
var Zpe = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function Q5(e) {
  let t = /* @__PURE__ */ new Set(), r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [
      ...Object.getOwnPropertyNames(e),
      ...Object.getOwnPropertySymbols(e)
    ];
    for (let o of n)
      r[o] || Zpe.has(o) || (t.add(o), r[o] = Object.getOwnPropertyDescriptor(e, o));
    e = Object.getPrototypeOf(e);
  }
  return {
    properties: t,
    descriptors: r
  };
}
c(Q5, "getAllProperties");
function Z5(e, t) {
  if (!t || // the original is already a spy, so it has all the properties
  ja in t)
    return e;
  let { properties: r, descriptors: n } = Q5(t);
  for (let o of r) {
    let a = n[o];
    X5(e, o) || Ll(e, o, a);
  }
  return e;
}
c(Z5, "wrap");
function eU(e) {
  return Y5(e) && "getOriginal" in e[ja];
}
c(eU, "isSpyFunction");
var Ly = /* @__PURE__ */ new Set();
function vl(e) {
  return typeof e == "function" && "_isMockFunction" in e && e._isMockFunction;
}
c(vl, "isMockFunction");
function efe(e, t, r) {
  const n = r ? { [{
    get: "getter",
    set: "setter"
  }[r]]: t } : t;
  let o;
  const a = tU(e, t), i = a && a[r || "value"];
  vl(i) && (o = i.mock._state());
  try {
    const s = HS(e, n), d = VS(s);
    return o && d.mock._state(o), d;
  } catch (s) {
    throw s instanceof TypeError && Symbol.toStringTag && e[Symbol.toStringTag] === "Module" && (s.message.includes("Cannot redefine property") || s.message.includes("Cannot replace module namespace") || s.message.includes("can't redefine non-configurable property")) ? new TypeError(`Cannot spy on export "${String(n)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: s }) : s;
  }
}
c(efe, "spyOn");
var tfe = 0;
function VS(e) {
  const t = e;
  let r, n = [], o = !1, a = [], i = [], s = [];
  const d = Fw(e), l = {
    get calls() {
      return d.calls;
    },
    get contexts() {
      return i;
    },
    get instances() {
      return a;
    },
    get invocationCallOrder() {
      return s;
    },
    get results() {
      return d.results.map(([m, g]) => ({
        type: m === "error" ? "throw" : "return",
        value: g
      }));
    },
    get settledResults() {
      return d.resolves.map(([m, g]) => ({
        type: m === "error" ? "rejected" : "fulfilled",
        value: g
      }));
    },
    get lastCall() {
      return d.calls[d.calls.length - 1];
    },
    _state(m) {
      return m && (r = m.implementation, n = m.onceImplementations, o = m.implementationChangedTemporarily), {
        implementation: r,
        onceImplementations: n,
        implementationChangedTemporarily: o
      };
    }
  };
  function p(...m) {
    return a.push(this), i.push(this), s.push(++tfe), (o ? r : n.shift() || r || d.getOriginal() || (() => {
    })).apply(this, m);
  }
  c(p, "mockCall");
  let f = t.name;
  t.getMockName = () => f || "vi.fn()", t.mockName = (m) => (f = m, t), t.mockClear = () => (d.reset(), a = [], i = [], s = [], t), t.mockReset = () => (t.mockClear(), r = void 0, n = [], t), t.mockRestore = () => (t.mockReset(), d.restore(), t), Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()), t.getMockImplementation = () => o ? r : n.at(0) || r, t.mockImplementation = (m) => (r = m, d.willCall(p), t), t.mockImplementationOnce = (m) => (n.push(m), t);
  function h(m, g) {
    const w = r;
    r = m, d.willCall(p), o = !0;
    const _ = /* @__PURE__ */ c(() => {
      r = w, o = !1;
    }, "reset"), b = g();
    return typeof b == "object" && b && typeof b.then == "function" ? b.then(() => (_(), t)) : (_(), t);
  }
  return c(h, "withImplementation"), t.withImplementation = h, t.mockReturnThis = () => t.mockImplementation(function() {
    return this;
  }), t.mockReturnValue = (m) => t.mockImplementation(() => m), t.mockReturnValueOnce = (m) => t.mockImplementationOnce(() => m), t.mockResolvedValue = (m) => t.mockImplementation(() => Promise.resolve(m)), t.mockResolvedValueOnce = (m) => t.mockImplementationOnce(() => Promise.resolve(m)), t.mockRejectedValue = (m) => t.mockImplementation(() => Promise.reject(m)), t.mockRejectedValueOnce = (m) => t.mockImplementationOnce(() => Promise.reject(m)), Object.defineProperty(t, "mock", { get: /* @__PURE__ */ c(() => l, "get") }), d.willCall(p), Ly.add(t), t;
}
c(VS, "enhanceSpy");
function Uw(e) {
  const t = VS(HS({ spy: e || function() {
  } }, "spy"));
  return e && t.mockImplementation(e), t;
}
c(Uw, "fn");
function tU(e, t) {
  const r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    const o = Object.getOwnPropertyDescriptor(n, t);
    if (o)
      return o;
    n = Object.getPrototypeOf(n);
  }
}
c(tU, "getDescriptor");
var gd = Symbol.for("matchers-object"), bd = Symbol.for("$$jest-matchers-object-storybook"), zS = Symbol.for("expect-global"), Bw = Symbol.for("asymmetric-matchers-object"), rfe = {
  toSatisfy(e, t, r) {
    const { printReceived: n, printExpected: o, matcherHint: a } = this.utils, i = t(e);
    return {
      pass: i,
      message: /* @__PURE__ */ c(() => i ? `${a(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${r || o(t)}
Received:
${n(e)}` : `${a(".toSatisfy", "received", "")}

Expected value to satisfy:
${r || o(t)}

Received:
${n(e)}`, "message")
    };
  },
  toBeOneOf(e, t) {
    const { equals: r, customTesters: n } = this, { printReceived: o, printExpected: a, matcherHint: i } = this.utils;
    if (!Array.isArray(t))
      throw new TypeError(`You must provide an array to ${i(".toBeOneOf")}, not '${typeof t}'.`);
    const s = t.length === 0 || t.some((d) => r(d, e, n));
    return {
      pass: s,
      message: /* @__PURE__ */ c(() => s ? `${i(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${a(t)}
Received:
${o(e)}` : `${i(".toBeOneOf", "received", "")}

Expected value to be one of:
${a(t)}

Received:
${o(e)}`, "message")
    };
  }
}, hh = Pt.green, JS = Pt.red, nfe = Pt.inverse, ofe = Pt.bold, ma = Pt.dim;
function rU(e, t = "received", r = "expected", n = {}) {
  const { comment: o = "", isDirectExpectCall: a = !1, isNot: i = !1, promise: s = "", secondArgument: d = "", expectedColor: l = hh, receivedColor: p = JS, secondArgumentColor: f = hh } = n;
  let h = "", m = "expect";
  return !a && t !== "" && (h += ma(`${m}(`) + p(t), m = ")"), s !== "" && (h += ma(`${m}.`) + s, m = ""), i && (h += `${ma(`${m}.`)}not`, m = ""), e.includes(".") ? m += e : (h += ma(`${m}.`) + e, m = ""), r === "" ? m += "()" : (h += ma(`${m}(`) + l(r), d && (h += ma(", ") + f(d)), m = ")"), o !== "" && (m += ` // ${o}`), m !== "" && (h += ma(m)), h;
}
c(rU, "matcherHint");
var afe = "Â·";
function WS(e) {
  return e.replace(/\s+$/gm, (t) => afe.repeat(t.length));
}
c(WS, "replaceTrailingSpaces");
function nU(e) {
  return JS(WS(Pr(e)));
}
c(nU, "printReceived");
function oU(e) {
  return hh(WS(Pr(e)));
}
c(oU, "printExpected");
function GS() {
  return {
    EXPECTED_COLOR: hh,
    RECEIVED_COLOR: JS,
    INVERTED_COLOR: nfe,
    BOLD_WEIGHT: ofe,
    DIM_COLOR: ma,
    diff: ks,
    matcherHint: rU,
    printReceived: nU,
    printExpected: oU,
    printDiffOrStringify: ux,
    printWithType: aU
  };
}
c(GS, "getMatcherUtils");
function aU(e, t, r) {
  const n = cd(t), o = n !== "null" && n !== "undefined" ? `${e} has type:  ${n}
` : "", a = `${e} has value: ${r(t)}`;
  return o + a;
}
c(aU, "printWithType");
function Fy() {
  return globalThis[bd].customEqualityTesters;
}
c(Fy, "getCustomEqualityTesters");
function Ze(e, t, r, n) {
  return r = r || [], wl(e, t, [], [], r, n ? KS : lU);
}
c(Ze, "equals");
function Hw(e) {
  return !!e && typeof e == "object" && "asymmetricMatch" in e && mn("Function", e.asymmetricMatch);
}
c(Hw, "isAsymmetric");
function iU(e, t) {
  const r = Hw(e), n = Hw(t);
  if (!(r && n)) {
    if (r)
      return e.asymmetricMatch(t);
    if (n)
      return t.asymmetricMatch(e);
  }
}
c(iU, "asymmetricMatch");
function wl(e, t, r, n, o, a) {
  let i = !0;
  const s = iU(e, t);
  if (s !== void 0)
    return s;
  const d = { equals: Ze };
  for (let g = 0; g < o.length; g++) {
    const w = o[g].call(d, e, t, o);
    if (w !== void 0)
      return w;
  }
  if (typeof URL == "function" && e instanceof URL && t instanceof URL)
    return e.href === t.href;
  if (Object.is(e, t))
    return !0;
  if (e === null || t === null)
    return e === t;
  const l = Object.prototype.toString.call(e);
  if (l !== Object.prototype.toString.call(t))
    return !1;
  switch (l) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof e != typeof t ? !1 : typeof e != "object" && typeof t != "object" ? Object.is(e, t) : Object.is(e.valueOf(), t.valueOf());
    case "[object Date]": {
      const g = +e, w = +t;
      return g === w || Number.isNaN(g) && Number.isNaN(w);
    }
    case "[object RegExp]":
      return e.source === t.source && e.flags === t.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return e.equals(t);
    case "[object Temporal.Duration]":
      return e.toString() === t.toString();
  }
  if (typeof e != "object" || typeof t != "object")
    return !1;
  if (zw(e) && zw(t))
    return e.isEqualNode(t);
  let p = r.length;
  for (; p--; ) {
    if (r[p] === e)
      return n[p] === t;
    if (n[p] === t)
      return !1;
  }
  if (r.push(e), n.push(t), l === "[object Array]" && e.length !== t.length)
    return !1;
  if (e instanceof Error && t instanceof Error)
    try {
      return sU(e, t, r, n, o, a);
    } finally {
      r.pop(), n.pop();
    }
  const f = Vw(e, a);
  let h, m = f.length;
  if (Vw(t, a).length !== m)
    return !1;
  for (; m--; )
    if (h = f[m], i = a(t, h) && wl(e[h], t[h], r, n, o, a), !i)
      return !1;
  return r.pop(), n.pop(), i;
}
c(wl, "eq");
function sU(e, t, r, n, o, a) {
  let i = Object.getPrototypeOf(e) === Object.getPrototypeOf(t) && e.name === t.name && e.message === t.message;
  return typeof t.cause < "u" && i && (i = wl(e.cause, t.cause, r, n, o, a)), e instanceof AggregateError && t instanceof AggregateError && i && (i = wl(e.errors, t.errors, r, n, o, a)), i && (i = wl({ ...e }, { ...t }, r, n, o, a)), i;
}
c(sU, "isErrorEqual");
function Vw(e, t) {
  const r = [];
  for (const n in e)
    t(e, n) && r.push(n);
  return r.concat(Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable));
}
c(Vw, "keys");
function lU(e, t) {
  return KS(e, t) && e[t] !== void 0;
}
c(lU, "hasDefinedKey");
function KS(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
c(KS, "hasKey");
function mn(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
c(mn, "isA");
function zw(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && typeof e.nodeType == "number" && "nodeName" in e && typeof e.nodeName == "string" && "isEqualNode" in e && typeof e.isEqualNode == "function";
}
c(zw, "isDomNode");
var cU = "@@__IMMUTABLE_KEYED__@@", uU = "@@__IMMUTABLE_SET__@@", ife = "@@__IMMUTABLE_LIST__@@", Uy = "@@__IMMUTABLE_ORDERED__@@", sfe = "@@__IMMUTABLE_RECORD__@@";
function dU(e) {
  return !!(e && e[cU] && !e[Uy]);
}
c(dU, "isImmutableUnorderedKeyed");
function pU(e) {
  return !!(e && e[uU] && !e[Uy]);
}
c(pU, "isImmutableUnorderedSet");
function hp(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
c(hp, "isObjectLiteral");
function fU(e) {
  return !!(e && hp(e) && e[ife]);
}
c(fU, "isImmutableList");
function hU(e) {
  return !!(e && hp(e) && e[cU] && e[Uy]);
}
c(hU, "isImmutableOrderedKeyed");
function mU(e) {
  return !!(e && hp(e) && e[uU] && e[Uy]);
}
c(mU, "isImmutableOrderedSet");
function yU(e) {
  return !!(e && hp(e) && e[sfe]);
}
c(yU, "isImmutableRecord");
var gU = Symbol.iterator;
function Jw(e) {
  return !!(e != null && e[gU]);
}
c(Jw, "hasIterator");
function Wr(e, t, r = [], n = [], o = []) {
  if (typeof e != "object" || typeof t != "object" || Array.isArray(e) || Array.isArray(t) || !Jw(e) || !Jw(t))
    return;
  if (e.constructor !== t.constructor)
    return !1;
  let a = n.length;
  for (; a--; )
    if (n[a] === e)
      return o[a] === t;
  n.push(e), o.push(t);
  const i = [...r.filter((l) => l !== Wr), s];
  function s(l, p) {
    return Wr(l, p, [...r], [...n], [...o]);
  }
  if (c(s, "iterableEqualityWithStack"), e.size !== void 0) {
    if (e.size !== t.size)
      return !1;
    if (mn("Set", e) || pU(e)) {
      let l = !0;
      for (const p of e)
        if (!t.has(p)) {
          let f = !1;
          for (const h of t)
            Ze(p, h, i) === !0 && (f = !0);
          if (f === !1) {
            l = !1;
            break;
          }
        }
      return n.pop(), o.pop(), l;
    } else if (mn("Map", e) || dU(e)) {
      let l = !0;
      for (const p of e)
        if (!t.has(p[0]) || !Ze(p[1], t.get(p[0]), i)) {
          let f = !1;
          for (const h of t) {
            const m = Ze(p[0], h[0], i);
            let g = !1;
            m === !0 && (g = Ze(p[1], h[1], i)), g === !0 && (f = !0);
          }
          if (f === !1) {
            l = !1;
            break;
          }
        }
      return n.pop(), o.pop(), l;
    }
  }
  const d = t[gU]();
  for (const l of e) {
    const p = d.next();
    if (p.done || !Ze(l, p.value, i))
      return !1;
  }
  if (!d.next().done)
    return !1;
  if (!fU(e) && !hU(e) && !mU(e) && !yU(e)) {
    const l = Object.entries(e), p = Object.entries(t);
    if (!Ze(l, p, i))
      return !1;
  }
  return n.pop(), o.pop(), !0;
}
c(Wr, "iterableEquality");
function By(e, t) {
  return !e || typeof e != "object" || e === Object.prototype ? !1 : Object.prototype.hasOwnProperty.call(e, t) || By(Object.getPrototypeOf(e), t);
}
c(By, "hasPropertyInObject");
function bU(e) {
  return Iu(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
c(bU, "isObjectWithKeys");
function $c(e, t, r = []) {
  const n = r.filter((a) => a !== $c), o = /* @__PURE__ */ c((a = /* @__PURE__ */ new WeakMap()) => (i, s) => {
    if (bU(s))
      return Object.keys(s).every((d) => {
        if (s[d] != null && typeof s[d] == "object") {
          if (a.has(s[d]))
            return Ze(i[d], s[d], n);
          a.set(s[d], !0);
        }
        const l = i != null && By(i, d) && Ze(i[d], s[d], [...n, o(a)]);
        return a.delete(s[d]), l;
      });
  }, "subsetEqualityWithContext");
  return o()(e, t);
}
c($c, "subsetEquality");
function Ww(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor))
    return !1;
}
c(Ww, "typeEquality");
function Gw(e, t) {
  let r = e, n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer))
      return;
    try {
      r = new DataView(e), n = new DataView(t);
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength)
    return !1;
  for (let o = 0; o < r.byteLength; o++)
    if (r.getUint8(o) !== n.getUint8(o))
      return !1;
  return !0;
}
c(Gw, "arrayBufferEquality");
function mh(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t))
    return;
  const n = Object.keys(e), o = Object.keys(t), a = r.filter((i) => i !== mh);
  return Ze(e, t, a, !0) && Ze(n, o);
}
c(mh, "sparseArrayEquality");
function vU(e, t = "#{this}", r = "#{exp}") {
  const n = `expected ${t} to be ${r} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(e) ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
` : n;
}
c(vU, "generateToBeMessage");
function wU(e, t) {
  return `${t} ${e}${t === 1 ? "" : "s"}`;
}
c(wU, "pluralize");
function af(e) {
  return [...Object.keys(e), ...Object.getOwnPropertySymbols(e).filter((t) => {
    var r;
    return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0 ? void 0 : r.enumerable;
  })];
}
c(af, "getObjectKeys");
function _U(e, t, r) {
  let n = 0;
  const o = /* @__PURE__ */ c((a = /* @__PURE__ */ new WeakMap()) => (i, s) => {
    if (Array.isArray(i)) {
      if (Array.isArray(s) && s.length === i.length)
        return s.map((d, l) => o(a)(i[l], d));
    } else {
      if (i instanceof Date)
        return i;
      if (Iu(i) && Iu(s)) {
        if (Ze(i, s, [
          ...r,
          Wr,
          $c
        ]))
          return s;
        const d = {};
        a.set(i, d), typeof i.constructor == "function" && typeof i.constructor.name == "string" && Object.defineProperty(d, "constructor", {
          enumerable: !1,
          value: i.constructor
        });
        for (const l of af(i))
          By(s, l) ? d[l] = a.has(i[l]) ? a.get(i[l]) : o(a)(i[l], s[l]) : a.has(i[l]) || (n += 1, Iu(i[l]) && (n += af(i[l]).length), o(a)(i[l], s[l]));
        if (af(d).length > 0)
          return d;
      }
    }
    return i;
  }, "getObjectSubsetWithContext");
  return {
    subset: o()(e, t),
    stripped: n
  };
}
c(_U, "getObjectSubset");
if (!Object.prototype.hasOwnProperty.call(globalThis, gd)) {
  const e = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, gd, { get: /* @__PURE__ */ c(() => e, "get") });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, bd)) {
  const e = /* @__PURE__ */ Object.create(null), t = [];
  Object.defineProperty(globalThis, bd, {
    configurable: !0,
    get: /* @__PURE__ */ c(() => ({
      state: globalThis[gd].get(globalThis[zS]),
      matchers: e,
      customEqualityTesters: t
    }), "get")
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Bw)) {
  const e = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, Bw, { get: /* @__PURE__ */ c(() => e, "get") });
}
function vd(e) {
  return globalThis[gd].get(e);
}
c(vd, "getState");
function sf(e, t) {
  const r = globalThis[gd], n = r.get(t) || {}, o = Object.defineProperties(n, {
    ...Object.getOwnPropertyDescriptors(n),
    ...Object.getOwnPropertyDescriptors(e)
  });
  r.set(t, o);
}
c(sf, "setState");
var EU = class {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(t, r = !1) {
    this.sample = t, this.inverse = r;
  }
  getMatcherContext(t) {
    return {
      ...vd(t || globalThis[zS]),
      equals: Ze,
      isNot: this.inverse,
      customTesters: Fy(),
      utils: {
        ...GS(),
        diff: ks,
        stringify: Pr,
        iterableEquality: Wr,
        subsetEquality: $c
      }
    };
  }
};
c(EU, "AsymmetricMatcher");
var la = EU;
la.prototype[Symbol.for("chai/inspect")] = function(e) {
  const t = Pr(this, e.depth, { min: !0 });
  return t.length <= e.truncate ? t : `${this.toString()}{â€¦}`;
};
var xU = class extends la {
  constructor(t, r = !1) {
    if (!mn("String", t))
      throw new Error("Expected is not a string");
    super(t, r);
  }
  asymmetricMatch(t) {
    const r = mn("String", t) && t.includes(this.sample);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
};
c(xU, "StringContaining");
var EO = xU, SU = class extends la {
  asymmetricMatch(t) {
    return t != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
};
c(SU, "Anything");
var lfe = SU, TU = class extends la {
  constructor(t, r = !1) {
    super(t, r);
  }
  getPrototype(t) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(t) : t.constructor.prototype === t ? null : t.constructor.prototype;
  }
  hasProperty(t, r) {
    return t ? Object.prototype.hasOwnProperty.call(t, r) ? !0 : this.hasProperty(this.getPrototype(t), r) : !1;
  }
  asymmetricMatch(t) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let r = !0;
    const n = this.getMatcherContext();
    for (const o in this.sample)
      if (!this.hasProperty(t, o) || !Ze(this.sample[o], t[o], n.customTesters)) {
        r = !1;
        break;
      }
    return this.inverse ? !r : r;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
};
c(TU, "ObjectContaining");
var xO = TU, AU = class extends la {
  constructor(t, r = !1) {
    super(t, r);
  }
  asymmetricMatch(t) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    const r = this.getMatcherContext(), n = this.sample.length === 0 || Array.isArray(t) && this.sample.every((o) => t.some((a) => Ze(o, a, r.customTesters)));
    return this.inverse ? !n : n;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
};
c(AU, "ArrayContaining");
var SO = AU, $U = class extends la {
  constructor(t) {
    if (typeof t > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(t);
  }
  fnNameFor(t) {
    if (t.name)
      return t.name;
    const r = Function.prototype.toString.call(t).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return r ? r[1] : "<anonymous>";
  }
  asymmetricMatch(t) {
    return this.sample === String ? typeof t == "string" || t instanceof String : this.sample === Number ? typeof t == "number" || t instanceof Number : this.sample === Function ? typeof t == "function" || typeof t == "function" : this.sample === Boolean ? typeof t == "boolean" || t instanceof Boolean : this.sample === BigInt ? typeof t == "bigint" || t instanceof BigInt : this.sample === Symbol ? typeof t == "symbol" || t instanceof Symbol : this.sample === Object ? typeof t == "object" : t instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
};
c($U, "Any");
var cfe = $U, CU = class extends la {
  constructor(t, r = !1) {
    if (!mn("String", t) && !mn("RegExp", t))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(t), r);
  }
  asymmetricMatch(t) {
    const r = mn("String", t) && this.sample.test(t);
    return this.inverse ? !r : r;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
};
c(CU, "StringMatching");
var TO = CU, kU = class extends la {
  precision;
  constructor(t, r = 2, n = !1) {
    if (!mn("Number", t))
      throw new Error("Expected is not a Number");
    if (!mn("Number", r))
      throw new Error("Precision is not a Number");
    super(t), this.inverse = n, this.precision = r;
  }
  asymmetricMatch(t) {
    if (!mn("Number", t))
      return !1;
    let r = !1;
    return t === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || t === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? r = !0 : r = Math.abs(this.sample - t) < 10 ** -this.precision / 2, this.inverse ? !r : r;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${wU("digit", this.precision)})`
    ].join(" ");
  }
};
c(kU, "CloseTo");
var AO = kU, ufe = /* @__PURE__ */ c((e, t) => {
  t.addMethod(e.expect, "anything", () => new lfe()), t.addMethod(e.expect, "any", (r) => new cfe(r)), t.addMethod(e.expect, "stringContaining", (r) => new EO(r)), t.addMethod(e.expect, "objectContaining", (r) => new xO(r)), t.addMethod(e.expect, "arrayContaining", (r) => new SO(r)), t.addMethod(e.expect, "stringMatching", (r) => new TO(r)), t.addMethod(e.expect, "closeTo", (r, n) => new AO(r, n)), e.expect.not = {
    stringContaining: /* @__PURE__ */ c((r) => new EO(r, !0), "stringContaining"),
    objectContaining: /* @__PURE__ */ c((r) => new xO(r, !0), "objectContaining"),
    arrayContaining: /* @__PURE__ */ c((r) => new SO(r, !0), "arrayContaining"),
    stringMatching: /* @__PURE__ */ c((r) => new TO(r, !0), "stringMatching"),
    closeTo: /* @__PURE__ */ c((r, n) => new AO(r, n, !0), "closeTo")
  };
}, "JestAsymmetricMatchers");
function Kw(e, t, r) {
  const n = e.flag(t, "negate") ? "not." : "", o = `${e.flag(t, "_name")}(${r ? "expected" : ""})`, a = e.flag(t, "promise");
  return `expect(actual)${a ? `.${a}` : ""}.${n}${o}`;
}
c(Kw, "createAssertionMessage");
function Yw(e, t, r, n) {
  const o = e;
  if (o && t instanceof Promise) {
    t = t.finally(() => {
      if (!o.promises)
        return;
      const i = o.promises.indexOf(t);
      i !== -1 && o.promises.splice(i, 1);
    }), o.promises || (o.promises = []), o.promises.push(t);
    let a = !1;
    return o.onFinished ?? (o.onFinished = []), o.onFinished.push(() => {
      if (!a) {
        var i;
        const s = (((i = globalThis.__vitest_worker__) === null || i === void 0 ? void 0 : i.onFilterStackTrace) || ((d) => d || ""))(n.stack);
        console.warn([
          `Promise returned by \`${r}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          s
        ].join(""));
      }
    }), {
      then(i, s) {
        return a = !0, t.then(i, s);
      },
      catch(i) {
        return t.catch(i);
      },
      finally(i) {
        return t.finally(i);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return t;
}
c(Yw, "recordAsyncExpect");
function Xw(e, t) {
  var r;
  e.result || (e.result = { state: "fail" }), e.result.state = "fail", (r = e.result).errors || (r.errors = []), e.result.errors.push(ty(t));
}
c(Xw, "handleTestError");
function YS(e, t, r) {
  return function(...n) {
    if (t !== "withTest" && e.flag(this, "_name", t), !e.flag(this, "soft"))
      return r.apply(this, n);
    const o = e.flag(this, "vitest-test");
    if (!o)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      const a = r.apply(this, n);
      return a && typeof a == "object" && typeof a.then == "function" ? a.then(C2, (i) => {
        Xw(o, i);
      }) : a;
    } catch (a) {
      Xw(o, a);
    }
  };
}
c(YS, "wrapAssertion");
var dfe = /* @__PURE__ */ c((e, t) => {
  const { AssertionError: r } = e, n = Fy();
  function o(l, p) {
    const f = /* @__PURE__ */ c((h) => {
      const m = YS(t, h, p);
      t.addMethod(e.Assertion.prototype, h, m), t.addMethod(globalThis[bd].matchers, h, m);
    }, "addMethod");
    Array.isArray(l) ? l.forEach((h) => f(h)) : f(l);
  }
  c(o, "def"), [
    "throw",
    "throws",
    "Throw"
  ].forEach((l) => {
    t.overwriteMethod(e.Assertion.prototype, l, (p) => function(...f) {
      const h = t.flag(this, "promise"), m = t.flag(this, "object"), g = t.flag(this, "negate");
      if (h === "rejects")
        t.flag(this, "object", () => {
          throw m;
        });
      else if (h === "resolves" && typeof m != "function") {
        if (g)
          return;
        {
          const w = t.flag(this, "message") || "expected promise to throw an error, but it didn't", _ = { showDiff: !1 };
          throw new r(w, _, t.flag(this, "ssfi"));
        }
      }
      p.apply(this, f);
    });
  }), o("withTest", function(l) {
    return t.flag(this, "vitest-test", l), this;
  }), o("toEqual", function(l) {
    const p = t.flag(this, "object"), f = Ze(p, l, [...n, Wr]);
    return this.assert(f, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", l, p);
  }), o("toStrictEqual", function(l) {
    const p = t.flag(this, "object"), f = Ze(p, l, [
      ...n,
      Wr,
      Ww,
      mh,
      Gw
    ], !0);
    return this.assert(f, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", l, p);
  }), o("toBe", function(l) {
    const p = this._obj, f = Object.is(p, l);
    let h = "";
    return f || (Ze(p, l, [
      ...n,
      Wr,
      Ww,
      mh,
      Gw
    ], !0) ? h = "toStrictEqual" : Ze(p, l, [...n, Wr]) && (h = "toEqual")), this.assert(f, vU(h), "expected #{this} not to be #{exp} // Object.is equality", l, p);
  }), o("toMatchObject", function(l) {
    const p = this._obj, f = Ze(p, l, [
      ...n,
      Wr,
      $c
    ]), h = t.flag(this, "negate"), { subset: m, stripped: g } = _U(p, l, n);
    if (f && h || !f && !h) {
      const w = t.getMessage(this, [
        f,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        l,
        m,
        !1
      ]), _ = g === 0 ? w : `${w}
(${g} matching ${g === 1 ? "property" : "properties"} omitted from actual)`;
      throw new r(_, {
        showDiff: !0,
        expected: l,
        actual: m
      });
    }
  }), o("toMatch", function(l) {
    const p = this._obj;
    if (typeof p != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
    return this.assert(typeof l == "string" ? p.includes(l) : p.match(l), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", l, p);
  }), o("toContain", function(l) {
    const p = this._obj;
    if (typeof Node < "u" && p instanceof Node) {
      if (!(l instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof l}`);
      return this.assert(p.contains(l), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", l, p);
    }
    if (typeof DOMTokenList < "u" && p instanceof DOMTokenList) {
      Yn(l, "class name", ["string"]);
      const f = t.flag(this, "negate") ? p.value.replace(l, "").trim() : `${p.value} ${l}`;
      return this.assert(p.contains(l), `expected "${p.value}" to contain "${l}"`, `expected "${p.value}" not to contain "${l}"`, f, p.value);
    }
    return typeof p == "string" && typeof l == "string" ? this.assert(p.includes(l), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", l, p) : (p != null && typeof p != "string" && t.flag(this, "object", Array.from(p)), this.contain(l));
  }), o("toContainEqual", function(l) {
    const p = t.flag(this, "object"), f = Array.from(p).findIndex((h) => Ze(h, l, n));
    this.assert(f !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", l);
  }), o("toBeTruthy", function() {
    const l = t.flag(this, "object");
    this.assert(!!l, "expected #{this} to be truthy", "expected #{this} to not be truthy", !0, l);
  }), o("toBeFalsy", function() {
    const l = t.flag(this, "object");
    this.assert(!l, "expected #{this} to be falsy", "expected #{this} to not be falsy", !1, l);
  }), o("toBeGreaterThan", function(l) {
    const p = this._obj;
    return Yn(p, "actual", ["number", "bigint"]), Yn(l, "expected", ["number", "bigint"]), this.assert(p > l, `expected ${p} to be greater than ${l}`, `expected ${p} to be not greater than ${l}`, l, p, !1);
  }), o("toBeGreaterThanOrEqual", function(l) {
    const p = this._obj;
    return Yn(p, "actual", ["number", "bigint"]), Yn(l, "expected", ["number", "bigint"]), this.assert(p >= l, `expected ${p} to be greater than or equal to ${l}`, `expected ${p} to be not greater than or equal to ${l}`, l, p, !1);
  }), o("toBeLessThan", function(l) {
    const p = this._obj;
    return Yn(p, "actual", ["number", "bigint"]), Yn(l, "expected", ["number", "bigint"]), this.assert(p < l, `expected ${p} to be less than ${l}`, `expected ${p} to be not less than ${l}`, l, p, !1);
  }), o("toBeLessThanOrEqual", function(l) {
    const p = this._obj;
    return Yn(p, "actual", ["number", "bigint"]), Yn(l, "expected", ["number", "bigint"]), this.assert(p <= l, `expected ${p} to be less than or equal to ${l}`, `expected ${p} to be not less than or equal to ${l}`, l, p, !1);
  }), o("toBeNaN", function() {
    const l = t.flag(this, "object");
    this.assert(Number.isNaN(l), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, l);
  }), o("toBeUndefined", function() {
    const l = t.flag(this, "object");
    this.assert(l === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, l);
  }), o("toBeNull", function() {
    const l = t.flag(this, "object");
    this.assert(l === null, "expected #{this} to be null", "expected #{this} not to be null", null, l);
  }), o("toBeDefined", function() {
    const l = t.flag(this, "object");
    this.assert(typeof l < "u", "expected #{this} to be defined", "expected #{this} to be undefined", l);
  }), o("toBeTypeOf", function(l) {
    const p = typeof this._obj, f = l === p;
    return this.assert(f, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", l, p);
  }), o("toBeInstanceOf", function(l) {
    return this.instanceOf(l);
  }), o("toHaveLength", function(l) {
    return this.have.length(l);
  }), o("toHaveProperty", function(...l) {
    Array.isArray(l[0]) && (l[0] = l[0].map((x) => String(x).replace(/([.[\]])/g, "\\$1")).join("."));
    const p = this._obj, [f, h] = l, m = /* @__PURE__ */ c(() => Object.prototype.hasOwnProperty.call(p, f) ? {
      value: p[f],
      exists: !0
    } : t.getPathInfo(p, f), "getValue"), { value: g, exists: w } = m(), _ = w && (l.length === 1 || Ze(h, g, n)), b = l.length === 1 ? "" : ` with value ${t.objDisplay(h)}`;
    return this.assert(_, `expected #{this} to have property "${f}"${b}`, `expected #{this} to not have property "${f}"${b}`, h, w ? g : void 0);
  }), o("toBeCloseTo", function(l, p = 2) {
    const f = this._obj;
    let h = !1, m = 0, g = 0;
    return l === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY || l === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY ? h = !0 : (m = 10 ** -p / 2, g = Math.abs(f - l), h = g < m), this.assert(h, `expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${m}`, `expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${m}`, l, f, !1);
  });
  function a(l) {
    if (!vl(l._obj))
      throw new TypeError(`${t.inspect(l._obj)} is not a spy or a call to a spy!`);
  }
  c(a, "assertIsMock");
  function i(l) {
    return a(l), l._obj;
  }
  c(i, "getSpy"), o(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls.length;
    return this.assert(h === l, `expected "${f}" to be called #{exp} times, but got ${h} times`, `expected "${f}" to not be called #{exp} times`, l, h, !1);
  }), o("toHaveBeenCalledOnce", function() {
    const l = i(this), p = l.getMockName(), f = l.mock.calls.length;
    return this.assert(f === 1, `expected "${p}" to be called once, but got ${f} times`, `expected "${p}" to not be called once`, 1, f, !1);
  }), o(["toHaveBeenCalled", "toBeCalled"], function() {
    const l = i(this), p = l.getMockName(), f = l.mock.calls.length, h = f > 0, m = t.flag(this, "negate");
    let g = t.getMessage(this, [
      h,
      `expected "${p}" to be called at least once`,
      `expected "${p}" to not be called at all, but actually been called ${f} times`,
      !0,
      h
    ]);
    if (h && m && (g = lf(l, g)), h && m || !h && !m)
      throw new r(g);
  });
  function s(l, p) {
    return l.length === p.length && l.every((f, h) => Ze(f, p[h], [...n, Wr]));
  }
  c(s, "equalsArgumentArray"), o(["toHaveBeenCalledWith", "toBeCalledWith"], function(...l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls.some((w) => s(w, l)), m = t.flag(this, "negate"), g = t.getMessage(this, [
      h,
      `expected "${f}" to be called with arguments: #{exp}`,
      `expected "${f}" to not be called with arguments: #{exp}`,
      l
    ]);
    if (h && m || !h && !m)
      throw new r(lf(p, g, l));
  }), o("toHaveBeenCalledExactlyOnceWith", function(...l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls.length, m = p.mock.calls.some((_) => s(_, l)) && h === 1, g = t.flag(this, "negate"), w = t.getMessage(this, [
      m,
      `expected "${f}" to be called once with arguments: #{exp}`,
      `expected "${f}" to not be called once with arguments: #{exp}`,
      l
    ]);
    if (m && g || !m && !g)
      throw new r(lf(p, w, l));
  }), o(["toHaveBeenNthCalledWith", "nthCalledWith"], function(l, ...p) {
    const f = i(this), h = f.getMockName(), m = f.mock.calls[l - 1], g = f.mock.calls.length, w = l <= g;
    this.assert(m && s(m, p), `expected ${_l(l)} "${h}" call to have been called with #{exp}${w ? "" : `, but called only ${g} times`}`, `expected ${_l(l)} "${h}" call to not have been called with #{exp}`, p, m, w);
  }), o(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls[p.mock.calls.length - 1];
    this.assert(h && s(h, l), `expected last "${f}" call to have been called with #{exp}`, `expected last "${f}" call to not have been called with #{exp}`, l, h);
  });
  function d(l, p, f) {
    const h = l.mock.invocationCallOrder, m = p.mock.invocationCallOrder;
    return h.length === 0 ? !f : m.length === 0 ? !1 : h[0] < m[0];
  }
  c(d, "isSpyCalledBeforeAnotherSpy"), o(["toHaveBeenCalledBefore"], function(l, p = !0) {
    const f = i(this);
    if (!vl(l))
      throw new TypeError(`${t.inspect(l)} is not a spy or a call to a spy`);
    this.assert(d(f, l, p), `expected "${f.getMockName()}" to have been called before "${l.getMockName()}"`, `expected "${f.getMockName()}" to not have been called before "${l.getMockName()}"`, l, f);
  }), o(["toHaveBeenCalledAfter"], function(l, p = !0) {
    const f = i(this);
    if (!vl(l))
      throw new TypeError(`${t.inspect(l)} is not a spy or a call to a spy`);
    this.assert(d(l, f, p), `expected "${f.getMockName()}" to have been called after "${l.getMockName()}"`, `expected "${f.getMockName()}" to not have been called after "${l.getMockName()}"`, l, f);
  }), o(["toThrow", "toThrowError"], function(l) {
    if (typeof l == "string" || typeof l > "u" || l instanceof RegExp)
      return this.throws(l === "" ? /^$/ : l);
    const p = this._obj, f = t.flag(this, "promise"), h = t.flag(this, "negate");
    let m = null;
    if (f === "rejects")
      m = p;
    else if (f === "resolves" && typeof p != "function") {
      if (h)
        return;
      {
        const g = t.flag(this, "message") || "expected promise to throw an error, but it didn't", w = { showDiff: !1 };
        throw new r(g, w, t.flag(this, "ssfi"));
      }
    } else {
      let g = !1;
      try {
        p();
      } catch (w) {
        g = !0, m = w;
      }
      if (!g && !h) {
        const w = t.flag(this, "message") || "expected function to throw an error, but it didn't", _ = { showDiff: !1 };
        throw new r(w, _, t.flag(this, "ssfi"));
      }
    }
    if (typeof l == "function") {
      const g = l.name || l.prototype.constructor.name;
      return this.assert(m && m instanceof l, `expected error to be instance of ${g}`, `expected error not to be instance of ${g}`, l, m);
    }
    if (l instanceof Error) {
      const g = Ze(m, l, [...n, Wr]);
      return this.assert(g, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", l, m);
    }
    if (typeof l == "object" && "asymmetricMatch" in l && typeof l.asymmetricMatch == "function") {
      const g = l;
      return this.assert(m && g.asymmetricMatch(m), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", g, m);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof l}"`);
  }), [{
    name: "toHaveResolved",
    condition: /* @__PURE__ */ c((l) => l.mock.settledResults.length > 0 && l.mock.settledResults.some(({ type: p }) => p === "fulfilled"), "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: /* @__PURE__ */ c((l) => l.mock.calls.length > 0 && l.mock.results.some(({ type: p }) => p !== "throw"), "condition"),
    action: "called"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function() {
      const h = i(this), m = h.getMockName(), g = p(h);
      this.assert(g, `expected "${m}" to be successfully ${f} at least once`, `expected "${m}" to not be successfully ${f}`, g, !g, !1);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: /* @__PURE__ */ c((l, p) => l.mock.settledResults.reduce((f, { type: h }) => h === "fulfilled" ? ++f : f, 0) === p, "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: /* @__PURE__ */ c((l, p) => l.mock.results.reduce((f, { type: h }) => h === "throw" ? f : ++f, 0) === p, "condition"),
    action: "called"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h) {
      const m = i(this), g = m.getMockName(), w = p(m, h);
      this.assert(w, `expected "${g}" to be successfully ${f} ${h} times`, `expected "${g}" to not be successfully ${f} ${h} times`, `expected resolved times: ${h}`, `received resolved times: ${w}`, !1);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: /* @__PURE__ */ c((l, p) => l.mock.settledResults.some(({ type: f, value: h }) => f === "fulfilled" && Ze(p, h)), "condition"),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: /* @__PURE__ */ c((l, p) => l.mock.results.some(({ type: f, value: h }) => f === "return" && Ze(p, h)), "condition"),
    action: "return"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h) {
      const m = i(this), g = p(m, h), w = t.flag(this, "negate");
      if (g && w || !g && !w) {
        const _ = m.getMockName(), b = t.getMessage(this, [
          g,
          `expected "${_}" to ${f} with: #{exp} at least once`,
          `expected "${_}" to not ${f} with: #{exp}`,
          h
        ]), x = f === "return" ? m.mock.results : m.mock.settledResults;
        throw new r(PU(m, x, b, h));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: /* @__PURE__ */ c((l, p) => {
      const f = l.mock.settledResults[l.mock.settledResults.length - 1];
      return f && f.type === "fulfilled" && Ze(f.value, p);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: /* @__PURE__ */ c((l, p) => {
      const f = l.mock.results[l.mock.results.length - 1];
      return f && f.type === "return" && Ze(f.value, p);
    }, "condition"),
    action: "return"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h) {
      const m = i(this), g = f === "return" ? m.mock.results : m.mock.settledResults, w = g[g.length - 1], _ = m.getMockName();
      this.assert(p(m, h), `expected last "${_}" call to ${f} #{exp}`, `expected last "${_}" call to not ${f} #{exp}`, h, w?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: /* @__PURE__ */ c((l, p, f) => {
      const h = l.mock.settledResults[p - 1];
      return h && h.type === "fulfilled" && Ze(h.value, f);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: /* @__PURE__ */ c((l, p, f) => {
      const h = l.mock.results[p - 1];
      return h && h.type === "return" && Ze(h.value, f);
    }, "condition"),
    action: "return"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h, m) {
      const g = i(this), w = g.getMockName(), _ = (f === "return" ? g.mock.results : g.mock.settledResults)[h - 1], b = `${_l(h)} call`;
      this.assert(p(g, h, m), `expected ${b} "${w}" call to ${f} #{exp}`, `expected ${b} "${w}" call to not ${f} #{exp}`, m, _?.value);
    });
  }), o("withContext", function(l) {
    for (const p in l)
      t.flag(this, p, l[p]);
    return this;
  }), t.addProperty(e.Assertion.prototype, "resolves", /* @__PURE__ */ c(function() {
    const l = new Error("resolves");
    t.flag(this, "promise", "resolves"), t.flag(this, "error", l);
    const p = t.flag(this, "vitest-test"), f = t.flag(this, "object");
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof f?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof f}'.`);
    const h = new Proxy(this, { get: /* @__PURE__ */ c((m, g, w) => {
      const _ = Reflect.get(m, g, w);
      return typeof _ != "function" ? _ instanceof e.Assertion ? h : _ : (...b) => {
        t.flag(this, "_name", g);
        const x = f.then((P) => (t.flag(this, "object", P), _.call(this, ...b)), (P) => {
          const R = new r(`promise rejected "${t.inspect(P)}" instead of resolving`, { showDiff: !1 });
          throw R.cause = P, R.stack = l.stack.replace(l.message, R.message), R;
        });
        return Yw(p, x, Kw(t, this, !!b.length), l);
      };
    }, "get") });
    return h;
  }, "__VITEST_RESOLVES__")), t.addProperty(e.Assertion.prototype, "rejects", /* @__PURE__ */ c(function() {
    const l = new Error("rejects");
    t.flag(this, "promise", "rejects"), t.flag(this, "error", l);
    const p = t.flag(this, "vitest-test"), f = t.flag(this, "object"), h = typeof f == "function" ? f() : f;
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof h?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof h}'.`);
    const m = new Proxy(this, { get: /* @__PURE__ */ c((g, w, _) => {
      const b = Reflect.get(g, w, _);
      return typeof b != "function" ? b instanceof e.Assertion ? m : b : (...x) => {
        t.flag(this, "_name", w);
        const P = h.then((R) => {
          const N = new r(`promise resolved "${t.inspect(R)}" instead of rejecting`, {
            showDiff: !0,
            expected: new Error("rejected promise"),
            actual: R
          });
          throw N.stack = l.stack.replace(l.message, N.message), N;
        }, (R) => (t.flag(this, "object", R), b.call(this, ...x)));
        return Yw(p, P, Kw(t, this, !!x.length), l);
      };
    }, "get") });
    return m;
  }, "__VITEST_REJECTS__"));
}, "JestChaiExpect");
function _l(e) {
  const t = e % 10, r = e % 100;
  return t === 1 && r !== 11 ? `${e}st` : t === 2 && r !== 12 ? `${e}nd` : t === 3 && r !== 13 ? `${e}rd` : `${e}th`;
}
c(_l, "ordinalOf");
function lf(e, t, r) {
  return e.mock.calls.length && (t += Pt.gray(`

Received: 

${e.mock.calls.map((n, o) => {
    let a = Pt.bold(`  ${_l(o + 1)} ${e.getMockName()} call:

`);
    return r ? a += ks(r, n, { omitAnnotationLines: !0 }) : a += Pr(n).split(`
`).map((i) => `    ${i}`).join(`
`), a += `
`, a;
  }).join(`
`)}`)), t += Pt.gray(`

Number of calls: ${Pt.bold(e.mock.calls.length)}
`), t;
}
c(lf, "formatCalls");
function PU(e, t, r, n) {
  return t.length && (r += Pt.gray(`

Received: 

${t.map((o, a) => {
    let i = Pt.bold(`  ${_l(a + 1)} ${e.getMockName()} call return:

`);
    return n ? i += ks(n, o.value, { omitAnnotationLines: !0 }) : i += Pr(o).split(`
`).map((s) => `    ${s}`).join(`
`), i += `
`, i;
  }).join(`
`)}`)), r += Pt.gray(`

Number of calls: ${Pt.bold(e.mock.calls.length)}
`), r;
}
c(PU, "formatReturns");
function OU(e, t) {
  const r = e._obj, n = to.flag(e, "negate"), o = to.flag(e, "promise") || "", a = {
    ...GS(),
    diff: ks,
    stringify: Pr,
    iterableEquality: Wr,
    subsetEquality: $c
  };
  return {
    state: {
      ...vd(t),
      customTesters: Fy(),
      isNot: n,
      utils: a,
      promise: o,
      equals: Ze,
      suppressedErrors: [],
      soft: to.flag(e, "soft"),
      poll: to.flag(e, "poll")
    },
    isNot: n,
    obj: r
  };
}
c(OU, "getMatcherState");
var RU = class extends Error {
  constructor(t, r, n) {
    super(t), this.actual = r, this.expected = n;
  }
};
c(RU, "JestExtendError");
var $O = RU;
function jU(e, t, r) {
  return (n, o) => {
    Object.entries(r).forEach(([a, i]) => {
      function s(...h) {
        const { state: m, isNot: g, obj: w } = OU(this, t), _ = i.call(m, w, ...h);
        if (_ && typeof _ == "object" && typeof _.then == "function")
          return _.then(({ pass: N, message: C, actual: A, expected: E }) => {
            if (N && g || !N && !g)
              throw new $O(C(), A, E);
          });
        const { pass: b, message: x, actual: P, expected: R } = _;
        if (b && g || !b && !g)
          throw new $O(x(), P, R);
      }
      c(s, "expectWrapper");
      const d = YS(o, a, s);
      o.addMethod(globalThis[bd].matchers, a, d), o.addMethod(e.Assertion.prototype, a, d);
      const l = class extends la {
        constructor(h = !1, ...m) {
          super(m, h);
        }
        asymmetricMatch(h) {
          const { pass: m } = i.call(this.getMatcherContext(t), h, ...this.sample);
          return this.inverse ? !m : m;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${a}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((h) => Pr(h)).join(", ")}>`;
        }
      };
      c(l, "CustomMatcher");
      let p = l;
      const f = /* @__PURE__ */ c((...h) => new p(!1, ...h), "customMatcher");
      Object.defineProperty(t, a, {
        configurable: !0,
        enumerable: !0,
        value: f,
        writable: !0
      }), Object.defineProperty(t.not, a, {
        configurable: !0,
        enumerable: !0,
        value: /* @__PURE__ */ c((...h) => new p(!0, ...h), "value"),
        writable: !0
      }), Object.defineProperty(globalThis[Bw], a, {
        configurable: !0,
        enumerable: !0,
        value: f,
        writable: !0
      });
    });
  };
}
c(jU, "JestExtendPlugin");
var pfe = /* @__PURE__ */ c((e, t) => {
  t.addMethod(e.expect, "extend", (r, n) => {
    Gi(jU(e, r, n));
  });
}, "JestExtend");
function IU() {
  Gi(pfe), Gi(dfe), Gi(ufe);
  const e = /* @__PURE__ */ c((n, o) => {
    const { assertionCalls: a } = vd(e);
    return sf({ assertionCalls: a + 1, soft: !1 }, e), Ra(n, o);
  }, "expect");
  Object.assign(e, Ra), e.getState = () => vd(e), e.setState = (n) => sf(n, e), e.extend = (n) => Ra.extend(e, n), e.soft = (...n) => {
    const o = e(...n);
    return e.setState({
      soft: !0
    }), o;
  }, e.extend(rfe), e.unreachable = (n) => {
    B.fail(`expected${n ? ` "${n}" ` : " "}not to be reached`);
  };
  function t(n) {
    const o = /* @__PURE__ */ c(() => new Error(
      `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`
    ), "errorGen");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(o(), t), e.setState({
      expectedAssertionsNumber: n,
      expectedAssertionsNumberErrorGen: o
    });
  }
  c(t, "assertions");
  function r() {
    const n = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, r), e.setState({
      isExpectingAssertions: !0,
      isExpectingAssertionsError: n
    });
  }
  return c(r, "hasAssertions"), sf(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: !1,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    e
  ), to.addMethod(e, "assertions", t), to.addMethod(e, "hasAssertions", r), e.extend(gF), e;
}
c(IU, "createExpect");
var NU = IU();
Object.defineProperty(globalThis, zS, {
  value: NU,
  writable: !0,
  configurable: !0
});
function MU(e, t, r) {
  Object.defineProperty(e, t, r);
}
c(MU, "f");
var cf = Symbol.for("tinyspy:spy"), ffe = /* @__PURE__ */ c((e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "P"), hfe = /* @__PURE__ */ c((e) => (MU(e, cf, { value: { reset: /* @__PURE__ */ c(() => ffe(e[cf]), "reset") } }), e[cf]), "K"), mfe = /* @__PURE__ */ c((e) => e[cf] || hfe(e), "T"), Qw = /* @__PURE__ */ new Set();
function DU(e) {
  return Qw.add(e), () => void Qw.delete(e);
}
c(DU, "onMockCall");
function qU(e) {
  const t = e ? Uw(e) : Uw();
  return LU(t);
}
c(qU, "fn");
function LU(e) {
  const t = Zw(e), r = t.mockImplementation.bind(null);
  return t.mockImplementation = (n) => Zw(r(n)), t;
}
c(LU, "reactiveMock");
function Zw(e) {
  const t = mfe(e), r = t.impl;
  return t.willCall(function(...n) {
    return Qw.forEach((o) => o(e, n)), r?.apply(this, n);
  }), e;
}
c(Zw, "listenWhenCalled");
function FU() {
  Ly.forEach((e) => e.mockClear());
}
c(FU, "clearAllMocks");
function UU() {
  Ly.forEach((e) => e.mockReset());
}
c(UU, "resetAllMocks");
function BU() {
  Ly.forEach((e) => e.mockRestore());
}
c(BU, "restoreAllMocks");
function yfe(e, t = {}) {
  return e;
}
c(yfe, "mocked");
var HU = {};
Qd(HU, {
  buildQueries: () => vo,
  configure: () => U3,
  createEvent: () => qu,
  findAllByAltText: () => NB,
  findAllByDisplayValue: () => kB,
  findAllByLabelText: () => lB,
  findAllByPlaceholderText: () => gB,
  findAllByRole: () => KB,
  findAllByTestId: () => tH,
  findAllByText: () => xB,
  findAllByTitle: () => UB,
  findByAltText: () => MB,
  findByDisplayValue: () => PB,
  findByLabelText: () => cB,
  findByPlaceholderText: () => bB,
  findByRole: () => YB,
  findByTestId: () => rH,
  findByText: () => SB,
  findByTitle: () => BB,
  fireEvent: () => Hl,
  getAllByAltText: () => jB,
  getAllByDisplayValue: () => $B,
  getAllByLabelText: () => uB,
  getAllByPlaceholderText: () => mB,
  getAllByRole: () => WB,
  getAllByTestId: () => ZB,
  getAllByText: () => _B,
  getAllByTitle: () => LB,
  getByAltText: () => IB,
  getByDisplayValue: () => CB,
  getByLabelText: () => dB,
  getByPlaceholderText: () => yB,
  getByRole: () => GB,
  getByTestId: () => eH,
  getByText: () => EB,
  getByTitle: () => FB,
  getConfig: () => He,
  getDefaultNormalizer: () => zy,
  getElementError: () => yp,
  getMultipleElementsFoundError: () => gp,
  getNodeText: () => Cc,
  getQueriesForElement: () => bh,
  getRoles: () => yT,
  getSuggestedQuery: () => _d,
  isInaccessible: () => mp,
  logDOM: () => i_,
  logRoles: () => Lfe,
  makeFindQuery: () => ss,
  makeGetAllQuery: () => Gy,
  makeSingleQuery: () => is,
  prettyDOM: () => Bl,
  prettyFormat: () => XS,
  queries: () => gh,
  queryAllByAltText: () => OB,
  queryAllByAttribute: () => oi,
  queryAllByDisplayValue: () => TB,
  queryAllByLabelText: () => pB,
  queryAllByPlaceholderText: () => fB,
  queryAllByRole: () => zB,
  queryAllByTestId: () => XB,
  queryAllByText: () => vB,
  queryAllByTitle: () => DB,
  queryByAltText: () => RB,
  queryByAttribute: () => bT,
  queryByDisplayValue: () => AB,
  queryByLabelText: () => iB,
  queryByPlaceholderText: () => hB,
  queryByRole: () => JB,
  queryByTestId: () => QB,
  queryByText: () => wB,
  queryByTitle: () => qB,
  queryHelpers: () => Ffe,
  screen: () => ihe,
  waitFor: () => Wy,
  waitForElementToBeRemoved: () => oH,
  within: () => bh,
  wrapAllByQueryWithSuggestion: () => Or,
  wrapSingleQueryWithSuggestion: () => Ia
});
var XS = or(ipe()), gfe = Object.prototype.toString;
function e_(e) {
  return typeof e == "function" || gfe.call(e) === "[object Function]";
}
c(e_, "isCallable");
function VU(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
c(VU, "toInteger");
var bfe = Math.pow(2, 53) - 1;
function zU(e) {
  var t = VU(e);
  return Math.min(Math.max(t, 0), bfe);
}
c(zU, "toLength");
function un(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !e_(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var o = zU(n.length), a = e_(r) ? Object(new r(o)) : new Array(o), i = 0, s; i < o; )
    s = n[i], t ? a[i] = t(s, i) : a[i] = s, i += 1;
  return a.length = o, a;
}
c(un, "arrayFrom");
function Fl(e) {
  "@babel/helpers - typeof";
  return Fl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fl(e);
}
c(Fl, "_typeof");
function JU(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
c(JU, "_classCallCheck");
function t_(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, QS(n.key), n);
  }
}
c(t_, "_defineProperties");
function WU(e, t, r) {
  return t && t_(e.prototype, t), r && t_(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
c(WU, "_createClass");
function GU(e, t, r) {
  return t = QS(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
c(GU, "_defineProperty");
function QS(e) {
  var t = KU(e, "string");
  return Fl(t) === "symbol" ? t : String(t);
}
c(QS, "_toPropertyKey");
function KU(e, t) {
  if (Fl(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (Fl(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
c(KU, "_toPrimitive");
var vfe = (function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    JU(this, e), GU(this, "items", void 0), this.items = t;
  }
  return c(e, "SetLike"), WU(e, [{
    key: "add",
    value: /* @__PURE__ */ c(function(t) {
      return this.has(t) === !1 && this.items.push(t), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ c(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ c(function(t) {
      var r = this.items.length;
      return this.items = this.items.filter(function(n) {
        return n !== t;
      }), r !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ c(function(t) {
      var r = this;
      this.items.forEach(function(n) {
        t(n, n, r);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ c(function(t) {
      return this.items.indexOf(t) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ c(function() {
      return this.items.length;
    }, "get")
  }]), e;
})(), wfe = typeof Set > "u" ? Set : vfe;
function pr(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
c(pr, "getLocalName");
var _fe = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, Efe = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function YU(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = Efe[t]) !== null && n !== void 0 && n.has(r));
  });
}
c(YU, "hasGlobalAriaAttributes");
function ZS(e, t) {
  return YU(e, t);
}
c(ZS, "ignorePresentationalRole");
function XU(e) {
  var t = ZU(e);
  if (t === null || t === "presentation") {
    var r = QU(e);
    if (t !== "presentation" || ZS(e, r || ""))
      return r;
  }
  return t;
}
c(XU, "getRole");
function QU(e) {
  var t = _fe[pr(e)];
  if (t !== void 0)
    return t;
  switch (pr(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !ZS(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
c(QU, "getImplicitRole");
function ZU(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
c(ZU, "getExplicitRole");
function yt(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
c(yt, "isElement");
function eT(e) {
  return yt(e) && pr(e) === "caption";
}
c(eT, "isHTMLTableCaptionElement");
function Du(e) {
  return yt(e) && pr(e) === "input";
}
c(Du, "isHTMLInputElement");
function e3(e) {
  return yt(e) && pr(e) === "optgroup";
}
c(e3, "isHTMLOptGroupElement");
function t3(e) {
  return yt(e) && pr(e) === "select";
}
c(t3, "isHTMLSelectElement");
function r3(e) {
  return yt(e) && pr(e) === "table";
}
c(r3, "isHTMLTableElement");
function n3(e) {
  return yt(e) && pr(e) === "textarea";
}
c(n3, "isHTMLTextAreaElement");
function o3(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
c(o3, "safeWindow");
function a3(e) {
  return yt(e) && pr(e) === "fieldset";
}
c(a3, "isHTMLFieldSetElement");
function i3(e) {
  return yt(e) && pr(e) === "legend";
}
c(i3, "isHTMLLegendElement");
function s3(e) {
  return yt(e) && pr(e) === "slot";
}
c(s3, "isHTMLSlotElement");
function l3(e) {
  return yt(e) && e.ownerSVGElement !== void 0;
}
c(l3, "isSVGElement");
function c3(e) {
  return yt(e) && pr(e) === "svg";
}
c(c3, "isSVGSVGElement");
function u3(e) {
  return l3(e) && pr(e) === "title";
}
c(u3, "isSVGTitleElement");
function wd(e, t) {
  if (yt(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(o) {
      return n.getElementById(o);
    }).filter(
      function(o) {
        return o !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
c(wd, "queryIdRefs");
function no(e, t) {
  return yt(e) ? t.indexOf(XU(e)) !== -1 : !1;
}
c(no, "hasAnyConcreteRoles");
function d3(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
c(d3, "asFlatString");
function p3(e, t) {
  if (!yt(e))
    return !1;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return !0;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
c(p3, "isHidden");
function f3(e) {
  return no(e, ["button", "combobox", "listbox", "textbox"]) || tT(e, "range");
}
c(f3, "isControl");
function tT(e, t) {
  if (!yt(e))
    return !1;
  switch (t) {
    case "range":
      return no(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
c(tT, "hasAbstractRole");
function r_(e, t) {
  var r = un(e.querySelectorAll(t));
  return wd(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, un(n.querySelectorAll(t)));
  }), r;
}
c(r_, "querySelectorAllSubtree");
function h3(e) {
  return t3(e) ? e.selectedOptions || r_(e, "[selected]") : r_(e, '[aria-selected="true"]');
}
c(h3, "querySelectedOptions");
function m3(e) {
  return no(e, ["none", "presentation"]);
}
c(m3, "isMarkedPresentational");
function y3(e) {
  return eT(e);
}
c(y3, "isNativeHostLanguageTextAlternativeElement");
function g3(e) {
  return no(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
c(g3, "allowsNameFromContent");
function b3(e) {
  return !1;
}
c(b3, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function v3(e) {
  return Du(e) || n3(e) ? e.value : e.textContent || "";
}
c(v3, "getValueOfTextbox");
function n_(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
c(n_, "getTextualContent");
function rT(e) {
  var t = pr(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
c(rT, "isLabelableElement");
function nT(e) {
  if (rT(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && yt(r)) {
      var n = nT(r);
      n !== null && (t = n);
    }
  }), t;
}
c(nT, "findLabelableElement");
function w3(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : nT(e);
}
c(w3, "getControlOfLabel");
function _3(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return un(t);
  if (!rT(e))
    return null;
  var r = e.ownerDocument;
  return un(r.querySelectorAll("label")).filter(function(n) {
    return w3(n) === e;
  });
}
c(_3, "getLabels");
function E3(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? un(e.childNodes) : t;
}
c(E3, "getSlotContents");
function oT(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new wfe(), n = o3(e), o = t.compute, a = o === void 0 ? "name" : o, i = t.computedStyleSupportsPseudoElements, s = i === void 0 ? t.getComputedStyle !== void 0 : i, d = t.getComputedStyle, l = d === void 0 ? n.getComputedStyle.bind(n) : d, p = t.hidden, f = p === void 0 ? !1 : p;
  function h(b, x) {
    var P = "";
    if (yt(b) && s) {
      var R = l(b, "::before"), N = n_(R);
      P = "".concat(N, " ").concat(P);
    }
    var C = s3(b) ? E3(b) : un(b.childNodes).concat(wd(b, "aria-owns"));
    if (C.forEach(function(T) {
      var O = _(T, {
        isEmbeddedInLabel: x.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), k = yt(T) ? l(T).getPropertyValue("display") : "inline", M = k !== "inline" ? " " : "";
      P += "".concat(M).concat(O).concat(M);
    }), yt(b) && s) {
      var A = l(b, "::after"), E = n_(A);
      P = "".concat(P, " ").concat(E);
    }
    return P.trim();
  }
  c(h, "computeMiscTextAlternative");
  function m(b, x) {
    var P = b.getAttributeNode(x);
    return P !== null && !r.has(P) && P.value.trim() !== "" ? (r.add(P), P.value) : null;
  }
  c(m, "useAttribute");
  function g(b) {
    return yt(b) ? m(b, "title") : null;
  }
  c(g, "computeTooltipAttributeValue");
  function w(b) {
    if (!yt(b))
      return null;
    if (a3(b)) {
      r.add(b);
      for (var x = un(b.childNodes), P = 0; P < x.length; P += 1) {
        var R = x[P];
        if (i3(R))
          return _(R, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (r3(b)) {
      r.add(b);
      for (var N = un(b.childNodes), C = 0; C < N.length; C += 1) {
        var A = N[C];
        if (eT(A))
          return _(A, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (c3(b)) {
      r.add(b);
      for (var E = un(b.childNodes), T = 0; T < E.length; T += 1) {
        var O = E[T];
        if (u3(O))
          return O.textContent;
      }
      return null;
    } else if (pr(b) === "img" || pr(b) === "area") {
      var k = m(b, "alt");
      if (k !== null)
        return k;
    } else if (e3(b)) {
      var M = m(b, "label");
      if (M !== null)
        return M;
    }
    if (Du(b) && (b.type === "button" || b.type === "submit" || b.type === "reset")) {
      var L = m(b, "value");
      if (L !== null)
        return L;
      if (b.type === "submit")
        return "Submit";
      if (b.type === "reset")
        return "Reset";
    }
    var $ = _3(b);
    if ($ !== null && $.length !== 0)
      return r.add(b), un($).map(function(J) {
        return _(J, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(J) {
        return J.length > 0;
      }).join(" ");
    if (Du(b) && b.type === "image") {
      var I = m(b, "alt");
      if (I !== null)
        return I;
      var D = m(b, "title");
      return D !== null ? D : "Submit Query";
    }
    if (no(b, ["button"])) {
      var F = h(b, {
        isEmbeddedInLabel: !1
      });
      if (F !== "")
        return F;
    }
    return null;
  }
  c(w, "computeElementTextAlternative");
  function _(b, x) {
    if (r.has(b))
      return "";
    if (!f && p3(b, l) && !x.isReferenced)
      return r.add(b), "";
    var P = yt(b) ? b.getAttributeNode("aria-labelledby") : null, R = P !== null && !r.has(P) ? wd(b, "aria-labelledby") : [];
    if (a === "name" && !x.isReferenced && R.length > 0)
      return r.add(P), R.map(function(k) {
        return _(k, {
          isEmbeddedInLabel: x.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var N = x.recursion && f3(b) && a === "name";
    if (!N) {
      var C = (yt(b) && b.getAttribute("aria-label") || "").trim();
      if (C !== "" && a === "name")
        return r.add(b), C;
      if (!m3(b)) {
        var A = w(b);
        if (A !== null)
          return r.add(b), A;
      }
    }
    if (no(b, ["menu"]))
      return r.add(b), "";
    if (N || x.isEmbeddedInLabel || x.isReferenced) {
      if (no(b, ["combobox", "listbox"])) {
        r.add(b);
        var E = h3(b);
        return E.length === 0 ? Du(b) ? b.value : "" : un(E).map(function(k) {
          return _(k, {
            isEmbeddedInLabel: x.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (tT(b, "range"))
        return r.add(b), b.hasAttribute("aria-valuetext") ? b.getAttribute("aria-valuetext") : b.hasAttribute("aria-valuenow") ? b.getAttribute("aria-valuenow") : b.getAttribute("value") || "";
      if (no(b, ["textbox"]))
        return r.add(b), v3(b);
    }
    if (g3(b) || yt(b) && x.isReferenced || y3(b) || b3()) {
      var T = h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
      if (T !== "")
        return r.add(b), T;
    }
    if (b.nodeType === b.TEXT_NODE)
      return r.add(b), b.textContent || "";
    if (x.recursion)
      return r.add(b), h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
    var O = g(b);
    return O !== null ? (r.add(b), O) : (r.add(b), "");
  }
  return c(_, "computeTextAlternative"), d3(_(e, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: a === "description",
    recursion: !1
  }));
}
c(oT, "computeTextAlternative");
function Ul(e) {
  "@babel/helpers - typeof";
  return Ul = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ul(e);
}
c(Ul, "_typeof");
function o_(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
c(o_, "ownKeys");
function a_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o_(Object(r), !0).forEach(function(n) {
      x3(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : o_(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
c(a_, "_objectSpread");
function x3(e, t, r) {
  return t = S3(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
c(x3, "_defineProperty");
function S3(e) {
  var t = T3(e, "string");
  return Ul(t) === "symbol" ? t : String(t);
}
c(S3, "_toPropertyKey");
function T3(e, t) {
  if (Ul(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (Ul(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
c(T3, "_toPrimitive");
function aT(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = wd(e, "aria-describedby").map(function(o) {
    return oT(o, a_(a_({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("title");
    r = n === null ? "" : n;
  }
  return r;
}
c(aT, "computeAccessibleDescription");
function A3(e) {
  return no(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
c(A3, "prohibitsNaming");
function Hy(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return A3(e) ? "" : oT(e, t);
}
c(Hy, "computeAccessibleName");
var on = or(hx()), xfe = or(spe());
function iT(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
c(iT, "escapeHTML");
var Sfe = /* @__PURE__ */ c((e, t, r, n, o, a, i) => {
  const s = n + r.indent, d = r.colors;
  return e.map((l) => {
    const p = t[l];
    let f = i(p, r, s, o, a);
    return typeof p != "string" && (f.indexOf(`
`) !== -1 && (f = r.spacingOuter + s + f + r.spacingOuter + n), f = "{" + f + "}"), r.spacingInner + n + d.prop.open + l + d.prop.close + "=" + d.value.open + f + d.value.close;
  }).join("");
}, "printProps"), Tfe = 3, Afe = /* @__PURE__ */ c((e, t, r, n, o, a) => e.map((i) => {
  const s = typeof i == "string" ? $3(i, t) : a(i, t, r, n, o);
  return s === "" && typeof i == "object" && i !== null && i.nodeType !== Tfe ? "" : t.spacingOuter + r + s;
}).join(""), "printChildren"), $3 = /* @__PURE__ */ c((e, t) => {
  const r = t.colors.content;
  return r.open + iT(e) + r.close;
}, "printText"), $fe = /* @__PURE__ */ c((e, t) => {
  const r = t.colors.comment;
  return r.open + "<!--" + iT(e) + "-->" + r.close;
}, "printComment"), Cfe = /* @__PURE__ */ c((e, t, r, n, o) => {
  const a = n.colors.tag;
  return a.open + "<" + e + (t && a.close + t + n.spacingOuter + o + a.open) + (r ? ">" + a.close + r + n.spacingOuter + o + a.open + "</" + e : (t && !n.min ? "" : " ") + "/") + ">" + a.close;
}, "printElement"), kfe = /* @__PURE__ */ c((e, t) => {
  const r = t.colors.tag;
  return r.open + "<" + e + r.close + " â€¦" + r.open + " />" + r.close;
}, "printElementAsLeaf"), Pfe = 1, C3 = 3, k3 = 8, P3 = 11, Ofe = /^((HTML|SVG)\w*)?Element$/, O3 = /* @__PURE__ */ c((e) => {
  const {
    tagName: t
  } = e;
  return !!(typeof t == "string" && t.includes("-") || typeof e.hasAttribute == "function" && e.hasAttribute("is"));
}, "isCustomElement"), Rfe = /* @__PURE__ */ c((e) => {
  const t = e.constructor.name, {
    nodeType: r
  } = e;
  return r === Pfe && (Ofe.test(t) || O3(e)) || r === C3 && t === "Text" || r === k3 && t === "Comment" || r === P3 && t === "DocumentFragment";
}, "testNode");
function R3(e) {
  return e.nodeType === C3;
}
c(R3, "nodeIsText");
function j3(e) {
  return e.nodeType === k3;
}
c(j3, "nodeIsComment");
function uf(e) {
  return e.nodeType === P3;
}
c(uf, "nodeIsFragment");
function I3(e) {
  return {
    test: /* @__PURE__ */ c((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || O3(t)) && Rfe(t);
    }, "test"),
    serialize: /* @__PURE__ */ c((t, r, n, o, a, i) => {
      if (R3(t))
        return $3(t.data, r);
      if (j3(t))
        return $fe(t.data, r);
      const s = uf(t) ? "DocumentFragment" : t.tagName.toLowerCase();
      return ++o > r.maxDepth ? kfe(s, r) : Cfe(s, Sfe(uf(t) ? [] : Array.from(t.attributes).map((d) => d.name).sort(), uf(t) ? {} : Array.from(t.attributes).reduce((d, l) => (d[l.name] = l.value, d), {}), r, n + r.indent, o, a, i), Afe(Array.prototype.slice.call(t.childNodes || t.children).filter(e), r, n + r.indent, o, a, i), r, n);
    }, "serialize")
  };
}
c(I3, "createDOMElementFilter");
var N3 = null, sT = null, lT = null;
try {
  const e = module && module.require;
  sT = e.call(module, "fs").readFileSync, lT = e.call(module, "@babel/code-frame").codeFrameColumns, N3 = e.call(module, "picocolors");
} catch {
}
function M3(e) {
  const t = e.indexOf("(") + 1, r = e.indexOf(")"), n = e.slice(t, r), o = n.split(":"), [a, i, s] = [o[0], parseInt(o[1], 10), parseInt(o[2], 10)];
  let d = "";
  try {
    d = sT(a, "utf-8");
  } catch {
    return "";
  }
  const l = lT(d, {
    start: {
      line: i,
      column: s
    }
  }, {
    highlightCode: !0,
    linesBelow: 0
  });
  return N3.dim(n) + `
` + l + `
`;
}
c(M3, "getCodeFrame");
function D3() {
  if (!sT || !lT)
    return "";
  const e = new Error().stack.split(`
`).slice(1).find((t) => !t.includes("node_modules/"));
  return M3(e);
}
c(D3, "getUserCodeFrame");
var q3 = 3;
function df() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === !0 || // modern timers
    // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : !1;
}
c(df, "jestFakeTimersAreEnabled");
function Vy() {
  if (typeof window > "u")
    throw new Error("Could not find default container");
  return window.document;
}
c(Vy, "getDocument");
function cT(e) {
  if (e.defaultView)
    return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView)
    return e.ownerDocument.defaultView;
  if (e.window)
    return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : e.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(e) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof e.debug == "function" && typeof e.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof e + ".");
}
c(cT, "getWindowFromNode");
function bo(e) {
  if (!e || typeof e.querySelector != "function" || typeof e.querySelectorAll != "function")
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + t(e) + ".");
  function t(r) {
    return typeof r == "object" ? r === null ? "null" : r.constructor.name : typeof r;
  }
  c(t, "getTypeName");
}
c(bo, "checkContainerType");
var jfe = /* @__PURE__ */ c(() => {
  if (typeof process > "u")
    return !1;
  let e;
  try {
    var t;
    const r = (t = Mf) == null ? void 0 : t.COLORS;
    r && (e = JSON.parse(r));
  } catch {
  }
  return typeof e == "boolean" ? e : process.versions !== void 0 && process.versions.node !== void 0;
}, "shouldHighlight"), {
  DOMCollection: Ife
} = XS.plugins, Nfe = 1, Mfe = 8;
function L3(e) {
  return e.nodeType !== Mfe && (e.nodeType !== Nfe || !e.matches(He().defaultIgnore));
}
c(L3, "filterCommentsAndDefaultIgnoreTagsTags");
function Bl(e, t, r) {
  if (r === void 0 && (r = {}), e || (e = Vy().body), typeof t != "number" && (t = typeof process < "u" && typeof Mf < "u" && Mf.DEBUG_PRINT_LIMIT || 7e3), t === 0)
    return "";
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if (n === "object" ? n = e.constructor.name : e = {}, !("outerHTML" in e))
    throw new TypeError("Expected an element or document but got " + n);
  const {
    filterNode: o = L3,
    ...a
  } = r, i = XS.format(e, {
    plugins: [I3(o), Ife],
    printFunctionName: !1,
    highlight: jfe(),
    ...a
  });
  return t !== void 0 && e.outerHTML.length > t ? i.slice(0, t) + "..." : i;
}
c(Bl, "prettyDOM");
var i_ = /* @__PURE__ */ c(function() {
  const e = D3();
  console.log(e ? Bl(...arguments) + `

` + e : Bl(...arguments));
}, "logDOM"), Yi = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: /* @__PURE__ */ c((e) => e(), "asyncWrapper"),
  unstable_advanceTimersWrapper: /* @__PURE__ */ c((e) => e(), "unstable_advanceTimersWrapper"),
  eventWrapper: /* @__PURE__ */ c((e) => e(), "eventWrapper"),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: !1,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: !1,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: !1,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(e, t) {
    const r = Bl(t), n = new Error([e, "Ignored nodes: comments, " + Yi.defaultIgnore + `
` + r].filter(Boolean).join(`

`));
    return n.name = "TestingLibraryElementError", n;
  },
  _disableExpensiveErrorDiagnostics: !1,
  computedStyleSupportsPseudoElements: !1
};
function F3(e) {
  try {
    return Yi._disableExpensiveErrorDiagnostics = !0, e();
  } finally {
    Yi._disableExpensiveErrorDiagnostics = !1;
  }
}
c(F3, "runWithExpensiveErrorDiagnosticsDisabled");
function U3(e) {
  typeof e == "function" && (e = e(Yi)), Yi = {
    ...Yi,
    ...e
  };
}
c(U3, "configure");
function He() {
  return Yi;
}
c(He, "getConfig");
var Dfe = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function uT(e) {
  return Dfe.includes(e.nodeName.toLowerCase()) ? "" : e.nodeType === q3 ? e.textContent : Array.from(e.childNodes).map((t) => uT(t)).join("");
}
c(uT, "getTextContent");
function yh(e) {
  let t;
  return e.tagName.toLowerCase() === "label" ? t = uT(e) : t = e.value || e.textContent, t;
}
c(yh, "getLabelContent");
function dT(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!B3(e)) return [];
  const r = e.ownerDocument.querySelectorAll("label");
  return Array.from(r).filter((n) => n.control === e);
}
c(dT, "getRealLabels");
function B3(e) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) || e.tagName === "INPUT" && e.getAttribute("type") !== "hidden";
}
c(B3, "isLabelable");
function pT(e, t, r) {
  let {
    selector: n = "*"
  } = r === void 0 ? {} : r;
  const o = t.getAttribute("aria-labelledby"), a = o ? o.split(" ") : [];
  return a.length ? a.map((i) => {
    const s = e.querySelector('[id="' + i + '"]');
    return s ? {
      content: yh(s),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(dT(t)).map((i) => {
    const s = yh(i), d = Array.from(i.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((l) => l.matches(n))[0];
    return {
      content: s,
      formControl: d
    };
  });
}
c(pT, "getLabels");
function fT(e) {
  if (e == null)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + e + " was passed instead of a matcher. Did you do something like getByText(" + e + ")?"
    );
}
c(fT, "assertNotNullOrUndefined");
function Os(e, t, r, n) {
  if (typeof e != "string")
    return !1;
  fT(r);
  const o = n(e);
  return typeof r == "string" || typeof r == "number" ? o.toLowerCase().includes(r.toString().toLowerCase()) : typeof r == "function" ? r(o, t) : hT(r, o);
}
c(Os, "fuzzyMatches");
function co(e, t, r, n) {
  if (typeof e != "string")
    return !1;
  fT(r);
  const o = n(e);
  return r instanceof Function ? r(o, t) : r instanceof RegExp ? hT(r, o) : o === String(r);
}
c(co, "matches");
function zy(e) {
  let {
    trim: t = !0,
    collapseWhitespace: r = !0
  } = e === void 0 ? {} : e;
  return (n) => {
    let o = n;
    return o = t ? o.trim() : o, o = r ? o.replace(/\s+/g, " ") : o, o;
  };
}
c(zy, "getDefaultNormalizer");
function ni(e) {
  let {
    trim: t,
    collapseWhitespace: r,
    normalizer: n
  } = e;
  if (!n)
    return zy({
      trim: t,
      collapseWhitespace: r
    });
  if (typeof t < "u" || typeof r < "u")
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return n;
}
c(ni, "makeNormalizer");
function hT(e, t) {
  const r = e.test(t);
  return e.global && e.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), e.lastIndex = 0), r;
}
c(hT, "matchRegExp");
function Cc(e) {
  return e.matches("input[type=submit], input[type=button], input[type=reset]") ? e.value : Array.from(e.childNodes).filter((t) => t.nodeType === q3 && !!t.textContent).map((t) => t.textContent).join("");
}
c(Cc, "getNodeText");
var qfe = H3(on.elementRoles);
function mT(e) {
  return e.hidden === !0 || e.getAttribute("aria-hidden") === "true" || e.ownerDocument.defaultView.getComputedStyle(e).display === "none";
}
c(mT, "isSubtreeInaccessible");
function mp(e, t) {
  t === void 0 && (t = {});
  const {
    isSubtreeInaccessible: r = mT
  } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === "hidden")
    return !0;
  let n = e;
  for (; n; ) {
    if (r(n))
      return !0;
    n = n.parentElement;
  }
  return !1;
}
c(mp, "isInaccessible");
function Jy(e) {
  for (const {
    match: t,
    roles: r
  } of qfe)
    if (t(e))
      return [...r];
  return [];
}
c(Jy, "getImplicitAriaRoles");
function H3(e) {
  function t(i) {
    let {
      name: s,
      attributes: d
    } = i;
    return "" + s + d.map((l) => {
      let {
        name: p,
        value: f,
        constraints: h = []
      } = l;
      const m = h.indexOf("undefined") !== -1, g = h.indexOf("set") !== -1;
      return typeof f < "u" ? "[" + p + '="' + f + '"]' : m ? ":not([" + p + "])" : g ? "[" + p + "]:not([" + p + '=""])' : "[" + p + "]";
    }).join("");
  }
  c(t, "makeElementSelector");
  function r(i) {
    let {
      attributes: s = []
    } = i;
    return s.length;
  }
  c(r, "getSelectorSpecificity");
  function n(i, s) {
    let {
      specificity: d
    } = i, {
      specificity: l
    } = s;
    return l - d;
  }
  c(n, "bySelectorSpecificity");
  function o(i) {
    let {
      attributes: s = []
    } = i;
    const d = s.findIndex((p) => p.value && p.name === "type" && p.value === "text");
    d >= 0 && (s = [...s.slice(0, d), ...s.slice(d + 1)]);
    const l = t({
      ...i,
      attributes: s
    });
    return (p) => d >= 0 && p.type !== "text" ? !1 : p.matches(l);
  }
  c(o, "match");
  let a = [];
  for (const [i, s] of e.entries())
    a = [...a, {
      match: o(i),
      roles: Array.from(s),
      specificity: r(i)
    }];
  return a.sort(n);
}
c(H3, "buildElementRoleList");
function yT(e, t) {
  let {
    hidden: r = !1
  } = t === void 0 ? {} : t;
  function n(o) {
    return [o, ...Array.from(o.children).reduce((a, i) => [...a, ...n(i)], [])];
  }
  return c(n, "flattenDOM"), n(e).filter((o) => r === !1 ? mp(o) === !1 : !0).reduce((o, a) => {
    let i = [];
    return a.hasAttribute("role") ? i = a.getAttribute("role").split(" ").slice(0, 1) : i = Jy(a), i.reduce((s, d) => Array.isArray(s[d]) ? {
      ...s,
      [d]: [...s[d], a]
    } : {
      ...s,
      [d]: [a]
    }, o);
  }, {});
}
c(yT, "getRoles");
function gT(e, t) {
  let {
    hidden: r,
    includeDescription: n
  } = t;
  const o = yT(e, {
    hidden: r
  });
  return Object.entries(o).filter((a) => {
    let [i] = a;
    return i !== "generic";
  }).map((a) => {
    let [i, s] = a;
    const d = "-".repeat(50), l = s.map((p) => {
      const f = 'Name "' + Hy(p, {
        computedStyleSupportsPseudoElements: He().computedStyleSupportsPseudoElements
      }) + `":
`, h = Bl(p.cloneNode(!1));
      if (n) {
        const m = 'Description "' + aT(p, {
          computedStyleSupportsPseudoElements: He().computedStyleSupportsPseudoElements
        }) + `":
`;
        return "" + f + m + h;
      }
      return "" + f + h;
    }).join(`

`);
    return i + `:

` + l + `

` + d;
  }).join(`
`);
}
c(gT, "prettyRoles");
var Lfe = /* @__PURE__ */ c(function(e, t) {
  let {
    hidden: r = !1
  } = t === void 0 ? {} : t;
  return console.log(gT(e, {
    hidden: r
  }));
}, "logRoles");
function V3(e) {
  return e.tagName === "OPTION" ? e.selected : kc(e, "aria-selected");
}
c(V3, "computeAriaSelected");
function z3(e) {
  return e.getAttribute("aria-busy") === "true";
}
c(z3, "computeAriaBusy");
function J3(e) {
  if (!("indeterminate" in e && e.indeterminate))
    return "checked" in e ? e.checked : kc(e, "aria-checked");
}
c(J3, "computeAriaChecked");
function W3(e) {
  return kc(e, "aria-pressed");
}
c(W3, "computeAriaPressed");
function G3(e) {
  var t, r;
  return (t = (r = kc(e, "aria-current")) != null ? r : e.getAttribute("aria-current")) != null ? t : !1;
}
c(G3, "computeAriaCurrent");
function K3(e) {
  return kc(e, "aria-expanded");
}
c(K3, "computeAriaExpanded");
function kc(e, t) {
  const r = e.getAttribute(t);
  if (r === "true")
    return !0;
  if (r === "false")
    return !1;
}
c(kc, "checkBooleanAttribute");
function Y3(e) {
  const t = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  return e.getAttribute("aria-level") && Number(e.getAttribute("aria-level")) || t[e.tagName];
}
c(Y3, "computeHeadingLevel");
function X3(e) {
  const t = e.getAttribute("aria-valuenow");
  return t === null ? void 0 : +t;
}
c(X3, "computeAriaValueNow");
function Q3(e) {
  const t = e.getAttribute("aria-valuemax");
  return t === null ? void 0 : +t;
}
c(Q3, "computeAriaValueMax");
function Z3(e) {
  const t = e.getAttribute("aria-valuemin");
  return t === null ? void 0 : +t;
}
c(Z3, "computeAriaValueMin");
function eB(e) {
  const t = e.getAttribute("aria-valuetext");
  return t === null ? void 0 : t;
}
c(eB, "computeAriaValueText");
var CO = zy();
function tB(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
c(tB, "escapeRegExp");
function s_(e) {
  return new RegExp(tB(e.toLowerCase()), "i");
}
c(s_, "getRegExpMatcher");
function Mo(e, t, r, n) {
  let {
    variant: o,
    name: a
  } = n, i = "";
  const s = {}, d = [["Role", "TestId"].includes(e) ? r : s_(r)];
  a && (s.name = s_(a)), e === "Role" && mp(t) && (s.hidden = !0, i = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(s).length > 0 && d.push(s);
  const l = o + "By" + e;
  return {
    queryName: e,
    queryMethod: l,
    queryArgs: d,
    variant: o,
    warning: i,
    toString() {
      i && console.warn(i);
      let [p, f] = d;
      return p = typeof p == "string" ? "'" + p + "'" : p, f = f ? ", { " + Object.entries(f).map((h) => {
        let [m, g] = h;
        return m + ": " + g;
      }).join(", ") + " }" : "", l + "(" + p + f + ")";
    }
  };
}
c(Mo, "makeSuggestion");
function Do(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
c(Do, "canSuggest");
function _d(e, t, r) {
  var n, o;
  if (t === void 0 && (t = "get"), e.matches(He().defaultIgnore))
    return;
  const a = (n = e.getAttribute("role")) != null ? n : (o = Jy(e)) == null ? void 0 : o[0];
  if (a !== "generic" && Do("Role", r, a))
    return Mo("Role", e, a, {
      variant: t,
      name: Hy(e, {
        computedStyleSupportsPseudoElements: He().computedStyleSupportsPseudoElements
      })
    });
  const i = pT(document, e).map((h) => h.content).join(" ");
  if (Do("LabelText", r, i))
    return Mo("LabelText", e, i, {
      variant: t
    });
  const s = e.getAttribute("placeholder");
  if (Do("PlaceholderText", r, s))
    return Mo("PlaceholderText", e, s, {
      variant: t
    });
  const d = CO(Cc(e));
  if (Do("Text", r, d))
    return Mo("Text", e, d, {
      variant: t
    });
  if (Do("DisplayValue", r, e.value))
    return Mo("DisplayValue", e, CO(e.value), {
      variant: t
    });
  const l = e.getAttribute("alt");
  if (Do("AltText", r, l))
    return Mo("AltText", e, l, {
      variant: t
    });
  const p = e.getAttribute("title");
  if (Do("Title", r, p))
    return Mo("Title", e, p, {
      variant: t
    });
  const f = e.getAttribute(He().testIdAttribute);
  if (Do("TestId", r, f))
    return Mo("TestId", e, f, {
      variant: t
    });
}
c(_d, "getSuggestedQuery");
function hu(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
c(hu, "copyStackTrace");
function rB(e, t) {
  let {
    container: r = Vy(),
    timeout: n = He().asyncUtilTimeout,
    showOriginalStackTrace: o = He().showOriginalStackTrace,
    stackTraceError: a,
    interval: i = 50,
    onTimeout: s = /* @__PURE__ */ c((l) => (Object.defineProperty(l, "message", {
      value: He().getElementError(l.message, r).message
    }), l), "onTimeout"),
    mutationObserverOptions: d = {
      subtree: !0,
      childList: !0,
      attributes: !0,
      characterData: !0
    }
  } = t;
  if (typeof e != "function")
    throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (l, p) => {
    let f, h, m, g = !1, w = "idle";
    const _ = setTimeout(N, n), b = df();
    if (b) {
      const {
        unstable_advanceTimersWrapper: C
      } = He();
      for (R(); !g; ) {
        if (!df()) {
          const A = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          o || hu(A, a), p(A);
          return;
        }
        if (await C(async () => {
          jest.advanceTimersByTime(i);
        }), g)
          break;
        R();
      }
    } else {
      try {
        bo(r);
      } catch (A) {
        p(A);
        return;
      }
      h = setInterval(P, i);
      const {
        MutationObserver: C
      } = cT(r);
      m = new C(P), m.observe(r, d), R();
    }
    function x(C, A) {
      g = !0, clearTimeout(_), b || (clearInterval(h), m.disconnect()), C ? p(C) : l(A);
    }
    c(x, "onDone");
    function P() {
      if (df()) {
        const C = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return o || hu(C, a), p(C);
      } else
        return R();
    }
    c(P, "checkRealTimersCallback");
    function R() {
      if (w !== "pending")
        try {
          const C = F3(e);
          typeof C?.then == "function" ? (w = "pending", C.then((A) => {
            w = "resolved", x(null, A);
          }, (A) => {
            w = "rejected", f = A;
          })) : x(null, C);
        } catch (C) {
          f = C;
        }
    }
    c(R, "checkCallback");
    function N() {
      let C;
      f ? (C = f, !o && C.name === "TestingLibraryElementError" && hu(C, a)) : (C = new Error("Timed out in waitFor."), o || hu(C, a)), x(s(C), null);
    }
    c(N, "handleTimeout");
  });
}
c(rB, "waitFor");
function Wy(e, t) {
  const r = new Error("STACK_TRACE_MESSAGE");
  return He().asyncWrapper(() => rB(e, {
    stackTraceError: r,
    ...t
  }));
}
c(Wy, "waitForWrapper");
function yp(e, t) {
  return He().getElementError(e, t);
}
c(yp, "getElementError");
function gp(e, t) {
  return yp(e + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", t);
}
c(gp, "getMultipleElementsFoundError");
function oi(e, t, r, n) {
  let {
    exact: o = !0,
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  } = n === void 0 ? {} : n;
  const d = o ? co : Os, l = ni({
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  });
  return Array.from(t.querySelectorAll("[" + e + "]")).filter((p) => d(p.getAttribute(e), p, r, l));
}
c(oi, "queryAllByAttribute");
function bT(e, t, r, n) {
  const o = oi(e, t, r, n);
  if (o.length > 1)
    throw gp("Found multiple elements by [" + e + "=" + r + "]", t);
  return o[0] || null;
}
c(bT, "queryByAttribute");
function is(e, t) {
  return function(r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
      o[a - 1] = arguments[a];
    const i = e(r, ...o);
    if (i.length > 1) {
      const s = i.map((d) => yp(null, d).message).join(`

`);
      throw gp(t(r, ...o) + `

Here are the matching elements:

` + s, r);
    }
    return i[0] || null;
  };
}
c(is, "makeSingleQuery");
function vT(e, t) {
  return He().getElementError(`A better query is available, try this:
` + e.toString() + `
`, t);
}
c(vT, "getSuggestionError");
function Gy(e, t) {
  return function(r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
      o[a - 1] = arguments[a];
    const i = e(r, ...o);
    if (!i.length)
      throw He().getElementError(t(r, ...o), r);
    return i;
  };
}
c(Gy, "makeGetAllQuery");
function ss(e) {
  return (t, r, n, o) => Wy(() => e(t, r, n), {
    container: t,
    ...o
  });
}
c(ss, "makeFindQuery");
var Ia = /* @__PURE__ */ c((e, t, r) => function(n) {
  for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
    a[i - 1] = arguments[i];
  const s = e(n, ...a), [{
    suggest: d = He().throwSuggestions
  } = {}] = a.slice(-1);
  if (s && d) {
    const l = _d(s, r);
    if (l && !t.endsWith(l.queryName))
      throw vT(l.toString(), n);
  }
  return s;
}, "wrapSingleQueryWithSuggestion"), Or = /* @__PURE__ */ c((e, t, r) => function(n) {
  for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
    a[i - 1] = arguments[i];
  const s = e(n, ...a), [{
    suggest: d = He().throwSuggestions
  } = {}] = a.slice(-1);
  if (s.length && d) {
    const l = [...new Set(s.map((p) => {
      var f;
      return (f = _d(p, r)) == null ? void 0 : f.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      l.length === 1 && !t.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        _d(s[0], r).queryName
      )
    )
      throw vT(l[0], n);
  }
  return s;
}, "wrapAllByQueryWithSuggestion");
function vo(e, t, r) {
  const n = Ia(is(e, t), e.name, "query"), o = Gy(e, r), a = is(o, t), i = Ia(a, e.name, "get"), s = Or(o, e.name.replace("query", "get"), "getAll"), d = ss(Or(o, e.name, "findAll")), l = ss(Ia(a, e.name, "find"));
  return [n, s, i, d, l];
}
c(vo, "buildQueries");
var Ffe = Object.freeze({
  __proto__: null,
  getElementError: yp,
  wrapAllByQueryWithSuggestion: Or,
  wrapSingleQueryWithSuggestion: Ia,
  getMultipleElementsFoundError: gp,
  queryAllByAttribute: oi,
  queryByAttribute: bT,
  makeSingleQuery: is,
  makeGetAllQuery: Gy,
  makeFindQuery: ss,
  buildQueries: vo
});
function nB(e) {
  return Array.from(e.querySelectorAll("label,input")).map((t) => ({
    node: t,
    textToMatch: yh(t)
  })).filter((t) => {
    let {
      textToMatch: r
    } = t;
    return r !== null;
  });
}
c(nB, "queryAllLabels");
var Ufe = /* @__PURE__ */ c(function(e, t, r) {
  let {
    exact: n = !0,
    trim: o,
    collapseWhitespace: a,
    normalizer: i
  } = r === void 0 ? {} : r;
  const s = n ? co : Os, d = ni({
    collapseWhitespace: a,
    trim: o,
    normalizer: i
  });
  return nB(e).filter((l) => {
    let {
      node: p,
      textToMatch: f
    } = l;
    return s(f, p, t, d);
  }).map((l) => {
    let {
      node: p
    } = l;
    return p;
  });
}, "queryAllLabelsByText"), Ed = /* @__PURE__ */ c(function(e, t, r) {
  let {
    selector: n = "*",
    exact: o = !0,
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  } = r === void 0 ? {} : r;
  bo(e);
  const d = o ? co : Os, l = ni({
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  }), p = Array.from(e.querySelectorAll("*")).filter((f) => dT(f).length || f.hasAttribute("aria-labelledby")).reduce((f, h) => {
    const m = pT(e, h, {
      selector: n
    });
    m.filter((w) => !!w.formControl).forEach((w) => {
      d(w.content, w.formControl, t, l) && w.formControl && f.push(w.formControl);
    });
    const g = m.filter((w) => !!w.content).map((w) => w.content);
    return d(g.join(" "), h, t, l) && f.push(h), g.length > 1 && g.forEach((w, _) => {
      d(w, h, t, l) && f.push(h);
      const b = [...g];
      b.splice(_, 1), b.length > 1 && d(b.join(" "), h, t, l) && f.push(h);
    }), f;
  }, []).concat(oi("aria-label", e, t, {
    exact: o,
    normalizer: l
  }));
  return Array.from(new Set(p)).filter((f) => f.matches(n));
}, "queryAllByLabelText"), ls = /* @__PURE__ */ c(function(e, t) {
  for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
    n[o - 2] = arguments[o];
  const a = Ed(e, t, ...n);
  if (!a.length) {
    const i = Ufe(e, t, ...n);
    if (i.length) {
      const s = i.map((d) => oB(e, d)).filter((d) => !!d);
      throw s.length ? He().getElementError(s.map((d) => "Found a label with the text of: " + t + ", however the element associated with this label (<" + d + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + d + " />, you can use aria-label or aria-labelledby instead.").join(`

`), e) : He().getElementError("Found a label with the text of: " + t + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, e);
    } else
      throw He().getElementError("Unable to find a label with the text of: " + t, e);
  }
  return a;
}, "getAllByLabelText");
function oB(e, t) {
  const r = t.getAttribute("for");
  if (!r)
    return null;
  const n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
c(oB, "getTagNameOfElementAssociatedWithLabelViaFor");
var aB = /* @__PURE__ */ c((e, t) => "Found multiple elements with the text of: " + t, "getMultipleError$7"), iB = Ia(is(Ed, aB), Ed.name, "query"), sB = is(ls, aB), lB = ss(Or(ls, ls.name, "findAll")), cB = ss(Ia(sB, ls.name, "find")), uB = Or(ls, ls.name, "getAll"), dB = Ia(sB, ls.name, "get"), pB = Or(Ed, Ed.name, "queryAll"), l_ = /* @__PURE__ */ c(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return bo(t[0]), oi("placeholder", ...t);
}, "queryAllByPlaceholderText"), Bfe = /* @__PURE__ */ c((e, t) => "Found multiple elements with the placeholder text of: " + t, "getMultipleError$6"), Hfe = /* @__PURE__ */ c((e, t) => "Unable to find an element with the placeholder text of: " + t, "getMissingError$6"), fB = Or(l_, l_.name, "queryAll"), [hB, mB, yB, gB, bB] = vo(l_, Bfe, Hfe), c_ = /* @__PURE__ */ c(function(e, t, r) {
  let {
    selector: n = "*",
    exact: o = !0,
    collapseWhitespace: a,
    trim: i,
    ignore: s = He().defaultIgnore,
    normalizer: d
  } = r === void 0 ? {} : r;
  bo(e);
  const l = o ? co : Os, p = ni({
    collapseWhitespace: a,
    trim: i,
    normalizer: d
  });
  let f = [];
  return typeof e.matches == "function" && e.matches(n) && (f = [e]), [...f, ...Array.from(e.querySelectorAll(n))].filter((h) => !s || !h.matches(s)).filter((h) => l(Cc(h), h, t, p));
}, "queryAllByText"), Vfe = /* @__PURE__ */ c((e, t) => "Found multiple elements with the text: " + t, "getMultipleError$5"), zfe = /* @__PURE__ */ c(function(e, t, r) {
  r === void 0 && (r = {});
  const {
    collapseWhitespace: n,
    trim: o,
    normalizer: a,
    selector: i
  } = r, s = ni({
    collapseWhitespace: n,
    trim: o,
    normalizer: a
  })(t.toString()), d = s !== t.toString(), l = (i ?? "*") !== "*";
  return "Unable to find an element with the text: " + (d ? s + " (normalized from '" + t + "')" : t) + (l ? ", which matches selector '" + i + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
}, "getMissingError$5"), vB = Or(c_, c_.name, "queryAll"), [wB, _B, EB, xB, SB] = vo(c_, Vfe, zfe), u_ = /* @__PURE__ */ c(function(e, t, r) {
  let {
    exact: n = !0,
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  } = r === void 0 ? {} : r;
  bo(e);
  const s = n ? co : Os, d = ni({
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  });
  return Array.from(e.querySelectorAll("input,textarea,select")).filter((l) => l.tagName === "SELECT" ? Array.from(l.options).filter((p) => p.selected).some((p) => s(Cc(p), p, t, d)) : s(l.value, l, t, d));
}, "queryAllByDisplayValue"), Jfe = /* @__PURE__ */ c((e, t) => "Found multiple elements with the display value: " + t + ".", "getMultipleError$4"), Wfe = /* @__PURE__ */ c((e, t) => "Unable to find an element with the display value: " + t + ".", "getMissingError$4"), TB = Or(u_, u_.name, "queryAll"), [AB, $B, CB, kB, PB] = vo(u_, Jfe, Wfe), Gfe = /^(img|input|area|.+-.+)$/i, d_ = /* @__PURE__ */ c(function(e, t, r) {
  return r === void 0 && (r = {}), bo(e), oi("alt", e, t, r).filter((n) => Gfe.test(n.tagName));
}, "queryAllByAltText"), Kfe = /* @__PURE__ */ c((e, t) => "Found multiple elements with the alt text: " + t, "getMultipleError$3"), Yfe = /* @__PURE__ */ c((e, t) => "Unable to find an element with the alt text: " + t, "getMissingError$3"), OB = Or(d_, d_.name, "queryAll"), [RB, jB, IB, NB, MB] = vo(d_, Kfe, Yfe), Xfe = /* @__PURE__ */ c((e) => {
  var t;
  return e.tagName.toLowerCase() === "title" && ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === "svg";
}, "isSvgTitle"), p_ = /* @__PURE__ */ c(function(e, t, r) {
  let {
    exact: n = !0,
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  } = r === void 0 ? {} : r;
  bo(e);
  const s = n ? co : Os, d = ni({
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  });
  return Array.from(e.querySelectorAll("[title], svg > title")).filter((l) => s(l.getAttribute("title"), l, t, d) || Xfe(l) && s(Cc(l), l, t, d));
}, "queryAllByTitle"), Qfe = /* @__PURE__ */ c((e, t) => "Found multiple elements with the title: " + t + ".", "getMultipleError$2"), Zfe = /* @__PURE__ */ c((e, t) => "Unable to find an element with the title: " + t + ".", "getMissingError$2"), DB = Or(p_, p_.name, "queryAll"), [qB, LB, FB, UB, BB] = vo(p_, Qfe, Zfe), f_ = /* @__PURE__ */ c(function(e, t, r) {
  let {
    hidden: n = He().defaultHidden,
    name: o,
    description: a,
    queryFallbacks: i = !1,
    selected: s,
    busy: d,
    checked: l,
    pressed: p,
    current: f,
    level: h,
    expanded: m,
    value: {
      now: g,
      min: w,
      max: _,
      text: b
    } = {}
  } = r === void 0 ? {} : r;
  if (bo(e), s !== void 0) {
    var x;
    if (((x = on.roles.get(t)) == null ? void 0 : x.props["aria-selected"]) === void 0)
      throw new Error('"aria-selected" is not supported on role "' + t + '".');
  }
  if (d !== void 0) {
    var P;
    if (((P = on.roles.get(t)) == null ? void 0 : P.props["aria-busy"]) === void 0)
      throw new Error('"aria-busy" is not supported on role "' + t + '".');
  }
  if (l !== void 0) {
    var R;
    if (((R = on.roles.get(t)) == null ? void 0 : R.props["aria-checked"]) === void 0)
      throw new Error('"aria-checked" is not supported on role "' + t + '".');
  }
  if (p !== void 0) {
    var N;
    if (((N = on.roles.get(t)) == null ? void 0 : N.props["aria-pressed"]) === void 0)
      throw new Error('"aria-pressed" is not supported on role "' + t + '".');
  }
  if (f !== void 0) {
    var C;
    if (((C = on.roles.get(t)) == null ? void 0 : C.props["aria-current"]) === void 0)
      throw new Error('"aria-current" is not supported on role "' + t + '".');
  }
  if (h !== void 0 && t !== "heading")
    throw new Error('Role "' + t + '" cannot have "level" property.');
  if (g !== void 0) {
    var A;
    if (((A = on.roles.get(t)) == null ? void 0 : A.props["aria-valuenow"]) === void 0)
      throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
  }
  if (_ !== void 0) {
    var E;
    if (((E = on.roles.get(t)) == null ? void 0 : E.props["aria-valuemax"]) === void 0)
      throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
  }
  if (w !== void 0) {
    var T;
    if (((T = on.roles.get(t)) == null ? void 0 : T.props["aria-valuemin"]) === void 0)
      throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
  }
  if (b !== void 0) {
    var O;
    if (((O = on.roles.get(t)) == null ? void 0 : O.props["aria-valuetext"]) === void 0)
      throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
  }
  if (m !== void 0) {
    var k;
    if (((k = on.roles.get(t)) == null ? void 0 : k.props["aria-expanded"]) === void 0)
      throw new Error('"aria-expanded" is not supported on role "' + t + '".');
  }
  const M = /* @__PURE__ */ new WeakMap();
  function L($) {
    return M.has($) || M.set($, mT($)), M.get($);
  }
  return c(L, "cachedIsSubtreeInaccessible"), Array.from(e.querySelectorAll(
    // Only query elements that can be matched by the following filters
    HB(t)
  )).filter(($) => {
    if ($.hasAttribute("role")) {
      const I = $.getAttribute("role");
      if (i)
        return I.split(" ").filter(Boolean).some((F) => F === t);
      const [D] = I.split(" ");
      return D === t;
    }
    return Jy($).some((I) => I === t);
  }).filter(($) => {
    if (s !== void 0)
      return s === V3($);
    if (d !== void 0)
      return d === z3($);
    if (l !== void 0)
      return l === J3($);
    if (p !== void 0)
      return p === W3($);
    if (f !== void 0)
      return f === G3($);
    if (m !== void 0)
      return m === K3($);
    if (h !== void 0)
      return h === Y3($);
    if (g !== void 0 || _ !== void 0 || w !== void 0 || b !== void 0) {
      let D = !0;
      if (g !== void 0 && D && (D = g === X3($)), _ !== void 0 && D && (D = _ === Q3($)), w !== void 0 && D && (D = w === Z3($)), b !== void 0) {
        var I;
        D && (D = co((I = eB($)) != null ? I : null, $, b, (F) => F));
      }
      return D;
    }
    return !0;
  }).filter(($) => o === void 0 ? !0 : co(Hy($, {
    computedStyleSupportsPseudoElements: He().computedStyleSupportsPseudoElements
  }), $, o, (I) => I)).filter(($) => a === void 0 ? !0 : co(aT($, {
    computedStyleSupportsPseudoElements: He().computedStyleSupportsPseudoElements
  }), $, a, (I) => I)).filter(($) => n === !1 ? mp($, {
    isSubtreeInaccessible: L
  }) === !1 : !0);
}, "queryAllByRole");
function HB(e) {
  var t;
  const r = '*[role~="' + e + '"]', n = (t = on.roleElements.get(e)) != null ? t : /* @__PURE__ */ new Set(), o = new Set(Array.from(n).map((a) => {
    let {
      name: i
    } = a;
    return i;
  }));
  return [r].concat(Array.from(o)).join(",");
}
c(HB, "makeRoleSelector");
var VB = /* @__PURE__ */ c((e) => {
  let t = "";
  return e === void 0 ? t = "" : typeof e == "string" ? t = ' and name "' + e + '"' : t = " and name `" + e + "`", t;
}, "getNameHint"), ehe = /* @__PURE__ */ c(function(e, t, r) {
  let {
    name: n
  } = r === void 0 ? {} : r;
  return 'Found multiple elements with the role "' + t + '"' + VB(n);
}, "getMultipleError$1"), the = /* @__PURE__ */ c(function(e, t, r) {
  let {
    hidden: n = He().defaultHidden,
    name: o,
    description: a
  } = r === void 0 ? {} : r;
  if (He()._disableExpensiveErrorDiagnostics)
    return 'Unable to find role="' + t + '"' + VB(o);
  let i = "";
  Array.from(e.children).forEach((p) => {
    i += gT(p, {
      hidden: n,
      includeDescription: a !== void 0
    });
  });
  let s;
  i.length === 0 ? n === !1 ? s = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : s = "There are no available roles." : s = (`
Here are the ` + (n === !1 ? "accessible" : "available") + ` roles:

  ` + i.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let d = "";
  o === void 0 ? d = "" : typeof o == "string" ? d = ' and name "' + o + '"' : d = " and name `" + o + "`";
  let l = "";
  return a === void 0 ? l = "" : typeof a == "string" ? l = ' and description "' + a + '"' : l = " and description `" + a + "`", (`
Unable to find an ` + (n === !1 ? "accessible " : "") + 'element with the role "' + t + '"' + d + l + `

` + s).trim();
}, "getMissingError$1"), zB = Or(f_, f_.name, "queryAll"), [JB, WB, GB, KB, YB] = vo(f_, ehe, the), wT = /* @__PURE__ */ c(() => He().testIdAttribute, "getTestIdAttribute"), h_ = /* @__PURE__ */ c(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return bo(t[0]), oi(wT(), ...t);
}, "queryAllByTestId"), rhe = /* @__PURE__ */ c((e, t) => "Found multiple elements by: [" + wT() + '="' + t + '"]', "getMultipleError"), nhe = /* @__PURE__ */ c((e, t) => "Unable to find an element by: [" + wT() + '="' + t + '"]', "getMissingError"), XB = Or(h_, h_.name, "queryAll"), [QB, ZB, eH, tH, rH] = vo(h_, rhe, nhe), gh = Object.freeze({
  __proto__: null,
  queryAllByLabelText: pB,
  queryByLabelText: iB,
  getAllByLabelText: uB,
  getByLabelText: dB,
  findAllByLabelText: lB,
  findByLabelText: cB,
  queryByPlaceholderText: hB,
  queryAllByPlaceholderText: fB,
  getByPlaceholderText: yB,
  getAllByPlaceholderText: mB,
  findAllByPlaceholderText: gB,
  findByPlaceholderText: bB,
  queryByText: wB,
  queryAllByText: vB,
  getByText: EB,
  getAllByText: _B,
  findAllByText: xB,
  findByText: SB,
  queryByDisplayValue: AB,
  queryAllByDisplayValue: TB,
  getByDisplayValue: CB,
  getAllByDisplayValue: $B,
  findAllByDisplayValue: kB,
  findByDisplayValue: PB,
  queryByAltText: RB,
  queryAllByAltText: OB,
  getByAltText: IB,
  getAllByAltText: jB,
  findAllByAltText: NB,
  findByAltText: MB,
  queryByTitle: qB,
  queryAllByTitle: DB,
  getByTitle: FB,
  getAllByTitle: LB,
  findAllByTitle: UB,
  findByTitle: BB,
  queryByRole: JB,
  queryAllByRole: zB,
  getAllByRole: WB,
  getByRole: GB,
  findAllByRole: KB,
  findByRole: YB,
  queryByTestId: QB,
  queryAllByTestId: XB,
  getByTestId: eH,
  getAllByTestId: ZB,
  findAllByTestId: tH,
  findByTestId: rH
});
function bh(e, t, r) {
  return t === void 0 && (t = gh), r === void 0 && (r = {}), Object.keys(t).reduce((n, o) => {
    const a = t[o];
    return n[o] = a.bind(null, e), n;
  }, r);
}
c(bh, "getQueriesForElement");
var nH = /* @__PURE__ */ c((e) => !e || Array.isArray(e) && !e.length, "isRemoved");
function m_(e) {
  if (nH(e))
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
c(m_, "initialCheck");
async function oH(e, t) {
  const r = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof e != "function") {
    m_(e);
    const n = (Array.isArray(e) ? e : [e]).map((o) => {
      let a = o.parentElement;
      if (a === null) return () => null;
      for (; a.parentElement; ) a = a.parentElement;
      return () => a.contains(o) ? o : null;
    });
    e = /* @__PURE__ */ c(() => n.map((o) => o()).filter(Boolean), "callback");
  }
  return m_(e()), Wy(() => {
    let n;
    try {
      n = e();
    } catch (o) {
      if (o.name === "TestingLibraryElementError")
        return;
      throw o;
    }
    if (!nH(n))
      throw r;
  }, t);
}
c(oH, "waitForElementToBeRemoved");
var kO = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !0
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      button: 0,
      composed: !0
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
}, PO = {
  doubleClick: "dblClick"
};
function Hl(e, t) {
  return He().eventWrapper(() => {
    if (!t)
      throw new Error("Unable to fire an event - please provide an event object.");
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
c(Hl, "fireEvent");
function qu(e, t, r, n) {
  let {
    EventType: o = "Event",
    defaultInit: a = {}
  } = n === void 0 ? {} : n;
  if (!t)
    throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  const i = {
    ...a,
    ...r
  }, {
    target: {
      value: s,
      files: d,
      ...l
    } = {}
  } = i;
  s !== void 0 && aH(t, s), d !== void 0 && Object.defineProperty(t, "files", {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    value: d
  }), Object.assign(t, l);
  const p = cT(t), f = p[o] || p.Event;
  let h;
  if (typeof f == "function")
    h = new f(e, i);
  else {
    h = p.document.createEvent(o);
    const {
      bubbles: m,
      cancelable: g,
      detail: w,
      ..._
    } = i;
    h.initEvent(e, m, g, w), Object.keys(_).forEach((b) => {
      h[b] = _[b];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((m) => {
    const g = i[m];
    typeof g == "object" && (typeof p.DataTransfer == "function" ? Object.defineProperty(h, m, {
      value: Object.getOwnPropertyNames(g).reduce((w, _) => (Object.defineProperty(w, _, {
        value: g[_]
      }), w), new p.DataTransfer())
    }) : Object.defineProperty(h, m, {
      value: g
    }));
  }), h;
}
c(qu, "createEvent");
Object.keys(kO).forEach((e) => {
  const {
    EventType: t,
    defaultInit: r
  } = kO[e], n = e.toLowerCase();
  qu[e] = (o, a) => qu(n, o, a, {
    EventType: t,
    defaultInit: r
  }), Hl[e] = (o, a) => Hl(o, qu[e](o, a));
});
function aH(e, t) {
  const {
    set: r
  } = Object.getOwnPropertyDescriptor(e, "value") || {}, n = Object.getPrototypeOf(e), {
    set: o
  } = Object.getOwnPropertyDescriptor(n, "value") || {};
  if (o && r !== o)
    o.call(e, t);
  else if (r)
    r.call(e, t);
  else
    throw new Error("The given element does not have a value setter");
}
c(aH, "setNativeValue");
Object.keys(PO).forEach((e) => {
  const t = PO[e];
  Hl[e] = function() {
    return Hl[t](...arguments);
  };
});
function iH(e) {
  return e.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
c(iH, "unindent");
function sH(e) {
  return xfe.default.compressToEncodedURIComponent(iH(e));
}
c(sH, "encode");
function lH(e) {
  return "https://testing-playground.com/#markup=" + sH(e);
}
c(lH, "getPlaygroundUrl");
var ohe = /* @__PURE__ */ c((e, t, r) => Array.isArray(e) ? e.forEach((n) => i_(n, t, r)) : i_(e, t, r), "debug"), ahe = /* @__PURE__ */ c(function(e) {
  if (e === void 0 && (e = Vy().body), !e || !("innerHTML" in e)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!e.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  const t = lH(e.innerHTML);
  return console.log(`Open this URL in your browser

` + t), t;
}, "logTestingPlaygroundURL"), OO = {
  debug: ohe,
  logTestingPlaygroundURL: ahe
}, ihe = typeof document < "u" && document.body ? bh(document.body, gh, OO) : Object.keys(gh).reduce((e, t) => (e[t] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, e), OO);
function Me(e, t, r) {
  return e.namespaceURI && e.namespaceURI !== "http://www.w3.org/1999/xhtml" || (t = Array.isArray(t) ? t : [
    t
  ], !t.includes(e.tagName.toLowerCase())) ? !1 : r ? Object.entries(r).every(([n, o]) => e[n] === o) : !0;
}
c(Me, "isElementType");
function Zr(e) {
  var t;
  if (cH(e) && e.defaultView)
    return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${uH(e)}`);
}
c(Zr, "getWindow");
function cH(e) {
  return e.nodeType === 9;
}
c(cH, "isDocument");
function uH(e) {
  return typeof e == "function" ? `function ${e.name}` : e === null ? "null" : String(e);
}
c(uH, "describe");
function _T(e, t) {
  return new Promise((r, n) => {
    const o = new t();
    o.onerror = n, o.onabort = n, o.onload = () => {
      r(String(o.result));
    }, o.readAsText(e);
  });
}
c(_T, "readBlobText");
function Ky(e, t) {
  const r = {
    ...t,
    length: t.length,
    item: /* @__PURE__ */ c((n) => r[n], "item"),
    [Symbol.iterator]: /* @__PURE__ */ c(function* () {
      for (let n = 0; n < r.length; n++)
        yield r[n];
    }, "nextFile")
  };
  return r.constructor = e.FileList, e.FileList && Object.setPrototypeOf(r, e.FileList.prototype), Object.freeze(r), r;
}
c(Ky, "createFileList");
function Go(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(Go, "_define_property");
var dH = class {
  getAsFile() {
    return this.file;
  }
  getAsString(t) {
    typeof this.data == "string" && t(this.data);
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(t, r) {
    Go(this, "kind", void 0), Go(this, "type", void 0), Go(this, "file", null), Go(this, "data", void 0), typeof t == "string" ? (this.kind = "string", this.type = String(r), this.data = t) : (this.kind = "file", this.type = t.type, this.file = t);
  }
};
c(dH, "DataTransferItemStub");
var pH = dH, fH = class extends Array {
  add(...t) {
    const r = new pH(t[0], t[1]);
    return this.push(r), r;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(t) {
    this.splice(t, 1);
  }
};
c(fH, "DataTransferItemListStub");
var she = fH;
function mu(e, t) {
  const [r, n] = e.split("/"), o = !n || n === "*";
  return (a) => t ? a.type === (o ? r : e) : o ? a.type.startsWith(`${r}/`) : a.type === r;
}
c(mu, "getTypeMatcher");
function hH(e) {
  var t;
  return new (t = class {
    getData(r) {
      var n;
      const o = (n = this.items.find(mu(r, !0))) !== null && n !== void 0 ? n : this.items.find(mu(r, !1));
      let a = "";
      return o?.getAsString((i) => {
        a = i;
      }), a;
    }
    setData(r, n) {
      const o = this.items.findIndex(mu(r, !0)), a = new pH(n, r);
      o >= 0 ? this.items.splice(o, 1, a) : this.items.push(a);
    }
    clearData(r) {
      if (r) {
        const n = this.items.findIndex(mu(r, !0));
        n >= 0 && this.items.remove(n);
      } else
        this.items.clear();
    }
    get types() {
      const r = [];
      return this.files.length && r.push("Files"), this.items.forEach((n) => r.push(n.type)), Object.freeze(r), r;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      Go(this, "dropEffect", "none"), Go(this, "effectAllowed", "uninitialized"), Go(this, "items", new she()), Go(this, "files", Ky(e, []));
    }
  }, c(t, "DataTransferStub"), t)();
}
c(hH, "createDataTransferStub");
function Yy(e, t = []) {
  const r = typeof e.DataTransfer > "u" ? hH(e) : (
    /* istanbul ignore next */
    new e.DataTransfer()
  );
  return Object.defineProperty(r, "files", {
    get: /* @__PURE__ */ c(() => Ky(e, t), "get")
  }), r;
}
c(Yy, "createDataTransfer");
async function mH(e, t) {
  return t.kind === "file" ? t.getAsFile() : new e.Blob([
    await new Promise((r) => t.getAsString(r))
  ], {
    type: t.type
  });
}
c(mH, "getBlobFromDataTransferItem");
function ET(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(ET, "_define_property");
function xT(e, ...t) {
  var r;
  const n = Object.fromEntries(t.map((o) => [
    typeof o == "string" ? "text/plain" : o.type,
    Promise.resolve(o)
  ]));
  return typeof e.ClipboardItem < "u" ? new e.ClipboardItem(n) : new (r = class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(o) {
      const a = await this.data[o];
      if (!a)
        throw new Error(`${o} is not one of the available MIME types on this item.`);
      return a instanceof e.Blob ? a : new e.Blob([
        a
      ], {
        type: o
      });
    }
    constructor(o) {
      ET(this, "data", void 0), this.data = o;
    }
  }, c(r, "ClipboardItem"), r)(n);
}
c(xT, "createClipboardItem");
var Vl = Symbol("Manage ClipboardSub");
function y_(e, t) {
  var r;
  return Object.assign(new (r = class extends e.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let n = "";
      for (const o of this.items) {
        const a = o.types.includes("text/plain") ? "text/plain" : o.types.find((i) => i.startsWith("text/"));
        a && (n += await o.getType(a).then((i) => _T(i, e.FileReader)));
      }
      return n;
    }
    async write(n) {
      this.items = n;
    }
    async writeText(n) {
      this.items = [
        xT(e, n)
      ];
    }
    constructor(...n) {
      super(...n), ET(this, "items", []);
    }
  }, c(r, "Clipboard"), r)(), {
    [Vl]: t
  });
}
c(y_, "createClipboardStub");
function Xy(e) {
  return !!e?.[Vl];
}
c(Xy, "isClipboardStub");
function yH(e) {
  if (Xy(e.navigator.clipboard))
    return e.navigator.clipboard[Vl];
  const t = Object.getOwnPropertyDescriptor(e.navigator, "clipboard");
  let r;
  const n = {
    resetClipboardStub: /* @__PURE__ */ c(() => {
      r = y_(e, n);
    }, "resetClipboardStub"),
    detachClipboardStub: /* @__PURE__ */ c(() => {
      t ? Object.defineProperty(e.navigator, "clipboard", t) : Object.defineProperty(e.navigator, "clipboard", {
        value: void 0,
        configurable: !0
      });
    }, "detachClipboardStub")
  };
  return r = y_(e, n), Object.defineProperty(e.navigator, "clipboard", {
    get: /* @__PURE__ */ c(() => r, "get"),
    configurable: !0
  }), r[Vl];
}
c(yH, "attachClipboardStubToView");
function gH(e) {
  Xy(e.navigator.clipboard) && e.navigator.clipboard[Vl].resetClipboardStub();
}
c(gH, "resetClipboardStubOnView");
function bH(e) {
  Xy(e.navigator.clipboard) && e.navigator.clipboard[Vl].detachClipboardStub();
}
c(bH, "detachClipboardStubFromView");
async function vH(e) {
  const t = e.defaultView, r = t?.navigator.clipboard, n = r && await r.read();
  if (!n)
    throw new Error("The Clipboard API is unavailable.");
  const o = Yy(t);
  for (const a of n)
    for (const i of a.types)
      o.setData(i, await a.getType(i).then((s) => _T(s, t.FileReader)));
  return o;
}
c(vH, "readDataTransferFromClipboard");
async function ST(e, t) {
  const r = Zr(e), n = r.navigator.clipboard, o = [];
  for (let a = 0; a < t.items.length; a++) {
    const i = t.items[a], s = await mH(r, i);
    o.push(xT(r, s));
  }
  if (!(n && await n.write(o).then(
    () => !0,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => !1
  )))
    throw new Error("The Clipboard API is unavailable.");
}
c(ST, "writeDataTransferToClipboard");
var vh = globalThis;
typeof vh.afterEach == "function" && vh.afterEach(() => {
  typeof globalThis.window < "u" && gH(globalThis.window);
});
typeof vh.afterAll == "function" && vh.afterAll(() => {
  typeof globalThis.window < "u" && bH(globalThis.window);
});
var wH = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");
function Qy(e) {
  return e.matches(wH);
}
c(Qy, "isFocusable");
function _H(e) {
  return new e.constructor(e.type, e);
}
c(_H, "cloneEvent");
function ho(e) {
  for (let r = e; r; r = r.parentElement)
    if (Me(r, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (r.hasAttribute("disabled"))
        return !0;
    } else if (Me(r, "fieldset")) {
      var t;
      if (r.hasAttribute("disabled") && !(!((t = r.querySelector(":scope > legend")) === null || t === void 0) && t.contains(e)))
        return !0;
    } else if (r.tagName.includes("-") && r.constructor.formAssociated && r.hasAttribute("disabled"))
      return !0;
  return !1;
}
c(ho, "isDisabled");
function Pc(e) {
  const t = e.activeElement;
  return t?.shadowRoot ? Pc(t.shadowRoot) : ho(t) ? e.ownerDocument ? (
    /* istanbul ignore next */
    e.ownerDocument.body
  ) : e.body : t;
}
c(Pc, "getActiveElement");
function pf(e) {
  var t;
  return (t = Pc(e)) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  );
}
c(pf, "getActiveElementOrBody");
function EH(e, t) {
  let r = e;
  do {
    if (t(r))
      return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
c(EH, "findClosest");
function Va(e) {
  return e.hasAttribute("contenteditable") && (e.getAttribute("contenteditable") == "true" || e.getAttribute("contenteditable") == "");
}
c(Va, "isContentEditable");
function zl(e) {
  const t = xH(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
c(zl, "getContentEditable");
function xH(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
c(xH, "getElement");
var SH = (function(e) {
  return e.button = "button", e.color = "color", e.file = "file", e.image = "image", e.reset = "reset", e.submit = "submit", e.checkbox = "checkbox", e.radio = "radio", e;
})(SH || {});
function TT(e) {
  return Me(e, "button") || Me(e, "input") && e.type in SH;
}
c(TT, "isClickableInput");
function cs(e) {
  return AT(e) && !e.readOnly || Va(e);
}
c(cs, "isEditable");
var TH = (function(e) {
  return e.text = "text", e.date = "date", e["datetime-local"] = "datetime-local", e.email = "email", e.month = "month", e.number = "number", e.password = "password", e.search = "search", e.tel = "tel", e.time = "time", e.url = "url", e.week = "week", e;
})(TH || {});
function AT(e) {
  return Me(e, "textarea") || Me(e, "input") && e.type in TH;
}
c(AT, "isEditableInputOrTextArea");
function Hn(e) {
  return $T(e) && AT(e);
}
c(Hn, "hasOwnSelection");
function AH(e) {
  return $T(e) && TT(e);
}
c(AH, "hasNoSelection");
function $T(e) {
  return e.nodeType === 1;
}
c($T, "isElement");
function $H(e) {
  const t = e.ownerDocument.getSelection();
  if (t?.focusNode && Hn(e)) {
    const n = zl(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        const o = ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3 ? n.firstChild : n;
        t.setBaseAndExtent(o, 0, o, 0);
      }
    } else
      t.setBaseAndExtent(e, 0, e, 0);
  }
}
c($H, "updateSelectionOnFocus");
function Jl(e, t) {
  return He().eventWrapper(e);
}
c(Jl, "wrapEvent");
function oa(e) {
  const t = EH(e, Qy), r = Pc(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r && (Jl(t ? () => t.focus() : () => r?.blur()), $H(t ?? e.ownerDocument.body));
}
c(oa, "focusElement");
function CH(e) {
  !Qy(e) || Pc(e.ownerDocument) !== e || Jl(() => e.blur());
}
c(CH, "blurElement");
var za = {};
za.click = (e, t, r) => {
  const n = t.closest("button,input,label,select,textarea"), o = n && Me(n, "label") && n.control;
  if (o && o !== t)
    return () => {
      Qy(o) && (oa(o), r.dispatchEvent(o, _H(e)));
    };
  if (Me(t, "input", {
    type: "file"
  }))
    return () => {
      CH(t), t.dispatchEvent(new (Zr(t)).Event("fileDialog")), oa(t);
    };
};
var Wl = Symbol("Displayed value in UI"), Ko = Symbol("Displayed selection in UI"), wh = Symbol("Initial value to compare on blur");
function kH(e) {
  return typeof e == "object" && Wl in e;
}
c(kH, "isUIValue");
function PH(e) {
  return !!e && typeof e == "object" && Ko in e;
}
c(PH, "isUISelectionStart");
function OH(e, t) {
  e[wh] === void 0 && (e[wh] = e.value), e[Wl] = t, e.value = Object.assign(new String(t), {
    [Wl]: !0
  });
}
c(OH, "setUIValue");
function Vn(e) {
  return e[Wl] === void 0 ? e.value : String(e[Wl]);
}
c(Vn, "getUIValue");
function Zy(e) {
  e[Wl] = void 0;
}
c(Zy, "setUIValueClean");
function CT(e) {
  e[wh] = void 0;
}
c(CT, "clearInitialValue");
function RH(e) {
  return e[wh];
}
c(RH, "getInitialValue");
function jH(e, t) {
  e[Ko] = t;
}
c(jH, "setUISelectionRaw");
function Rs(e, { focusOffset: t, anchorOffset: r = t }, n = "replace") {
  const o = Vn(e).length, a = /* @__PURE__ */ c((f) => Math.max(0, Math.min(o, f)), "sanitizeOffset"), i = n === "replace" || e[Ko] === void 0 ? a(r) : e[Ko].anchorOffset, s = a(t), d = Math.min(i, s), l = Math.max(i, s);
  if (e[Ko] = {
    anchorOffset: i,
    focusOffset: s
  }, e.selectionStart === d && e.selectionEnd === l)
    return;
  const p = Object.assign(new Number(d), {
    [Ko]: !0
  });
  try {
    e.setSelectionRange(p, l);
  } catch {
  }
}
c(Rs, "setUISelection");
function Gl(e) {
  var t, r, n;
  const o = (n = e[Ko]) !== null && n !== void 0 ? n : {
    anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
    focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0
  };
  return {
    ...o,
    startOffset: Math.min(o.anchorOffset, o.focusOffset),
    endOffset: Math.max(o.anchorOffset, o.focusOffset)
  };
}
c(Gl, "getUISelection");
function IH(e) {
  return !!e[Ko];
}
c(IH, "hasUISelection");
function Lu(e) {
  e[Ko] = void 0;
}
c(Lu, "setUISelectionClean");
var _h = globalThis.parseInt;
function NH(e) {
  const t = e.replace(/\D/g, "");
  if (t.length < 2)
    return e;
  const r = _h(t[0], 10), n = _h(t[1], 10);
  if (r >= 3 || r === 2 && n >= 4) {
    let o;
    return r >= 3 ? o = 1 : o = 2, g_(t, o);
  }
  return e.length === 2 ? e : g_(t, 2);
}
c(NH, "buildTimeValue");
function g_(e, t) {
  const r = e.slice(0, t), n = Math.min(_h(r, 10), 23), o = e.slice(t), a = _h(o, 10), i = Math.min(a, 59);
  return `${n.toString().padStart(2, "0")}:${i.toString().padStart(2, "0")}`;
}
c(g_, "build");
function kT(e, t) {
  const r = e.cloneNode();
  return r.value = t, r.value === t;
}
c(kT, "isValidDateOrTimeValue");
var MH = (function(e) {
  return e.email = "email", e.password = "password", e.search = "search", e.telephone = "telephone", e.text = "text", e.url = "url", e;
})(MH || {});
function DH(e) {
  var t;
  const r = (t = e.getAttribute("maxlength")) !== null && t !== void 0 ? t : "";
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
c(DH, "getMaxLength");
function qH(e) {
  return Me(e, "textarea") || Me(e, "input") && e.type in MH;
}
c(qH, "supportsMaxLength");
function PT(e, t, r, n) {
  if (Fu(e) && t + r >= 0 && t + r <= e.nodeValue.length)
    return {
      node: e,
      offset: t + r
    };
  const o = b_(e, t, r);
  if (o) {
    if (Fu(o))
      return {
        node: o,
        offset: r > 0 ? Math.min(1, o.nodeValue.length) : Math.max(o.nodeValue.length - 1, 0)
      };
    if (Me(o, "br")) {
      const a = b_(o, void 0, r);
      return a ? Fu(a) ? {
        node: a,
        offset: r > 0 ? 0 : a.nodeValue.length
      } : r < 0 && Me(a, "br") ? {
        node: o.parentNode,
        offset: yu(o)
      } : {
        node: a.parentNode,
        offset: yu(a) + (r > 0 ? 0 : 1)
      } : r < 0 && n === "deleteContentBackward" ? {
        node: o.parentNode,
        offset: yu(o)
      } : void 0;
    } else
      return {
        node: o.parentNode,
        offset: yu(o) + (r > 0 ? 1 : 0)
      };
  }
}
c(PT, "getNextCursorPosition");
function b_(e, t, r) {
  const n = Number(t) + (r < 0 ? -1 : 0);
  return t !== void 0 && eg(e) && n >= 0 && n < e.children.length && (e = e.children[n]), FH(e, r === 1 ? "next" : "previous", LH);
}
c(b_, "getNextCharacterContentNode");
function LH(e) {
  if (Fu(e))
    return !0;
  if (eg(e)) {
    if (Me(e, [
      "input",
      "textarea"
    ]))
      return e.type !== "hidden";
    if (Me(e, "br"))
      return !0;
  }
  return !1;
}
c(LH, "isTreatedAsCharacterContent");
function yu(e) {
  let t = 0;
  for (; e.previousSibling; )
    t++, e = e.previousSibling;
  return t;
}
c(yu, "getOffset");
function eg(e) {
  return e.nodeType === 1;
}
c(eg, "isElement");
function Fu(e) {
  return e.nodeType === 3;
}
c(Fu, "isTextNode");
function FH(e, t, r) {
  for (; ; ) {
    var n;
    const o = e[`${t}Sibling`];
    if (o) {
      if (e = UH(o, t === "next" ? "first" : "last"), r(e))
        return e;
    } else if (e.parentNode && (!eg(e.parentNode) || !Va(e.parentNode) && e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
      e = e.parentNode;
    else
      break;
  }
}
c(FH, "walkNodes");
function UH(e, t) {
  for (; e.hasChildNodes(); )
    e = e[`${t}Child`];
  return e;
}
c(UH, "getDescendant");
var xd = Symbol("Track programmatic changes for React workaround");
function BH(e) {
  return Object.getOwnPropertyNames(e).some((t) => t.startsWith("__react")) && Zr(e).REACT_VERSION === 17;
}
c(BH, "isReact17Element");
function HH(e) {
  BH(e) && (e[xd] = {
    previousValue: String(e.value),
    tracked: []
  });
}
c(HH, "startTrackValue");
function VH(e, t) {
  var r, n;
  (n = e[xd]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t), e[xd] || (Zy(e), Rs(e, {
    focusOffset: t.length
  }));
}
c(VH, "trackOrSetValue");
function zH(e, t) {
  var r;
  const n = e[xd];
  if (e[xd] = void 0, !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length))
    return;
  const o = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  o || Zy(e), IH(e) && Rs(e, {
    focusOffset: o ? t : e.value.length
  });
}
c(zH, "commitValueAfterInput");
function OT(e) {
  const t = JH(e);
  if (t && Hn(t))
    return {
      type: "input",
      selection: Gl(t)
    };
  const r = t?.ownerDocument.getSelection();
  return {
    type: zl(e) && r?.anchorNode && zl(r.anchorNode) ? "contenteditable" : "default",
    selection: r
  };
}
c(OT, "getTargetTypeAndSelection");
function JH(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
c(JH, "getElement");
function WH(e) {
  const t = OT(e);
  if (t.type === "input")
    return t.selection;
  if (t.type === "contenteditable") {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
c(WH, "getInputRange");
function Ja({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var o, a;
  if (OT(e).type === "input")
    return Rs(e, {
      anchorOffset: n,
      focusOffset: t
    });
  (a = r.ownerDocument) === null || a === void 0 || (o = a.getSelection()) === null || o === void 0 || o.setBaseAndExtent(r, n, e, t);
}
c(Ja, "setSelection");
function RT(e) {
  return Me(e, "input") && [
    "date",
    "time"
  ].includes(e.type);
}
c(RT, "isDateOrTime");
function us(e, t, r, n = "insertText") {
  const o = WH(t);
  o && (!RT(t) && !e.dispatchUIEvent(t, "beforeinput", {
    inputType: n,
    data: r
  }) || ("startContainer" in o ? GH(e, t, o, r, n) : KH(e, t, o, r, n)));
}
c(us, "input");
function GH(e, t, r, n, o) {
  let a = !1;
  if (!r.collapsed)
    a = !0, r.deleteContents();
  else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(o)) {
    const i = PT(r.startContainer, r.startOffset, o === "deleteContentBackward" ? -1 : 1, o);
    if (i) {
      a = !0;
      const s = r.cloneRange();
      s.comparePoint(i.node, i.offset) < 0 ? s.setStart(i.node, i.offset) : s.setEnd(i.node, i.offset), s.deleteContents();
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      const i = r.endOffset;
      r.endContainer.insertData(i, n), r.setStart(r.endContainer, i + n.length), r.setEnd(r.endContainer, i + n.length);
    } else {
      const i = t.ownerDocument.createTextNode(n);
      r.insertNode(i), r.setStart(i, n.length), r.setEnd(i, n.length);
    }
  (a || n) && e.dispatchUIEvent(t, "input", {
    inputType: o
  });
}
c(GH, "editContenteditable");
function KH(e, t, r, n, o) {
  let a = n;
  if (qH(t)) {
    const l = DH(t);
    if (l !== void 0 && n.length > 0) {
      const p = l - t.value.length;
      if (p > 0)
        a = n.substring(0, p);
      else
        return;
    }
  }
  const { newValue: i, newOffset: s, oldValue: d } = YH(a, t, r, o);
  i === d && s === r.startOffset && s === r.endOffset || Me(t, "input", {
    type: "number"
  }) && !XH(i) || (OH(t, i), Ja({
    focusNode: t,
    anchorOffset: s,
    focusOffset: s
  }), RT(t) ? kT(t, i) && (v_(e, t, s, {}), e.dispatchUIEvent(t, "change"), CT(t)) : v_(e, t, s, {
    data: n,
    inputType: o
  }));
}
c(KH, "editInputElement");
function YH(e, t, { startOffset: r, endOffset: n }, o) {
  const a = Vn(t), i = Math.max(0, r === n && o === "deleteContentBackward" ? r - 1 : r), s = a.substring(0, i), d = Math.min(a.length, r === n && o === "deleteContentForward" ? r + 1 : n), l = a.substring(d, a.length);
  let p = `${s}${e}${l}`, f = i + e.length;
  if (Me(t, "input", {
    type: "time"
  })) {
    const h = NH(p);
    h !== "" && kT(t, h) && (p = h, f = h.length);
  }
  return {
    oldValue: a,
    newValue: p,
    newOffset: f
  };
}
c(YH, "calculateNewValue");
function v_(e, t, r, n) {
  e.dispatchUIEvent(t, "input", n), zH(t, r);
}
c(v_, "commitInput");
function XH(e) {
  var t, r;
  const n = e.split("e", 2);
  return !(/[^\d.\-e]/.test(e) || Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 || Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 || n[1] && !/^-?\d*$/.test(n[1]));
}
c(XH, "isValidNumberInput");
za.cut = (e, t, r) => () => {
  cs(t) && us(r, t, "", "deleteByCut");
};
function QH(e) {
  return e ? Va(e) ? e.textContent : Vn(e) : null;
}
c(QH, "getValueOrTextContent");
function ZH(e) {
  const t = Zr(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    const { display: n, visibility: o } = t.getComputedStyle(r);
    if (n === "none" || o === "hidden")
      return !1;
  }
  return !0;
}
c(ZH, "isVisible");
function eV(e, t) {
  const r = e.ownerDocument, n = r.querySelectorAll(wH), o = Array.from(n).filter((d) => d === e || !(Number(d.getAttribute("tabindex")) < 0 || ho(d)));
  Number(e.getAttribute("tabindex")) >= 0 && o.sort((d, l) => {
    const p = Number(d.getAttribute("tabindex")), f = Number(l.getAttribute("tabindex"));
    return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
  });
  const a = {};
  let i = [
    r.body
  ];
  const s = Me(e, "input", {
    type: "radio"
  }) ? e.name : void 0;
  o.forEach((d) => {
    const l = d;
    if (Me(l, "input", {
      type: "radio"
    }) && l.name) {
      if (l === e) {
        i.push(l);
        return;
      } else if (l.name === s)
        return;
      if (l.checked) {
        i = i.filter((p) => !Me(p, "input", {
          type: "radio",
          name: l.name
        })), i.push(l), a[l.name] = l;
        return;
      }
      if (typeof a[l.name] < "u")
        return;
    }
    i.push(l);
  });
  for (let d = i.findIndex((l) => l === e); ; )
    if (d += t ? -1 : 1, d === i.length ? d = 0 : d === -1 && (d = i.length - 1), i[d] === e || i[d] === r.body || ZH(i[d]))
      return i[d];
}
c(eV, "getTabDestination");
function w_(e, t) {
  if (Hn(e)) {
    const r = Gl(e);
    Ja({
      focusNode: e,
      focusOffset: r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset
    });
  } else {
    const r = e.ownerDocument.getSelection();
    if (!r?.focusNode)
      return;
    if (r.isCollapsed) {
      const n = PT(r.focusNode, r.focusOffset, t);
      n && Ja({
        focusNode: n.node,
        focusOffset: n.offset
      });
    } else
      r[t < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}
c(w_, "moveSelection");
function jT(e) {
  if (Hn(e))
    return Ja({
      focusNode: e,
      anchorOffset: 0,
      focusOffset: Vn(e).length
    });
  var t;
  const r = (t = zl(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  Ja({
    focusNode: r,
    anchorOffset: 0,
    focusOffset: r.childNodes.length
  });
}
c(jT, "selectAll");
function tV(e) {
  if (Hn(e))
    return Gl(e).startOffset === 0 && Gl(e).endOffset === Vn(e).length;
  var t;
  const r = (t = zl(e)) !== null && t !== void 0 ? t : e.ownerDocument.body, n = e.ownerDocument.getSelection();
  return n?.anchorNode === r && n.focusNode === r && n.anchorOffset === 0 && n.focusOffset === r.childNodes.length;
}
c(tV, "isAllSelected");
function ll(e, t, r) {
  var n;
  if (Hn(e))
    return Ja({
      focusNode: e,
      anchorOffset: t,
      focusOffset: r
    });
  if (Va(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return Ja({
      focusNode: e.firstChild,
      anchorOffset: t,
      focusOffset: r
    });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
c(ll, "setSelectionRange");
function gu(e, t, r) {
  const n = Zr(t), o = Array.from(t.ownerDocument.querySelectorAll(t.name ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let a = o.findIndex((i) => i === t) + r; ; a += r) {
    if (o[a] || (a = r > 0 ? 0 : o.length - 1), o[a] === t)
      return;
    if (!ho(o[a])) {
      oa(o[a]), e.dispatchUIEvent(o[a], "click");
      return;
    }
  }
}
c(gu, "walkRadio");
za.keydown = (e, t, r) => {
  var n, o;
  return (o = (n = RO[e.key]) === null || n === void 0 ? void 0 : n.call(RO, e, t, r)) !== null && o !== void 0 ? o : lhe(e, t, r);
};
var RO = {
  ArrowDown: /* @__PURE__ */ c((e, t, r) => {
    if (Me(t, "input", {
      type: "radio"
    }))
      return () => gu(r, t, 1);
  }, "ArrowDown"),
  ArrowLeft: /* @__PURE__ */ c((e, t, r) => Me(t, "input", {
    type: "radio"
  }) ? () => gu(r, t, -1) : () => w_(t, -1), "ArrowLeft"),
  ArrowRight: /* @__PURE__ */ c((e, t, r) => Me(t, "input", {
    type: "radio"
  }) ? () => gu(r, t, 1) : () => w_(t, 1), "ArrowRight"),
  ArrowUp: /* @__PURE__ */ c((e, t, r) => {
    if (Me(t, "input", {
      type: "radio"
    }))
      return () => gu(r, t, -1);
  }, "ArrowUp"),
  Backspace: /* @__PURE__ */ c((e, t, r) => {
    if (cs(t))
      return () => {
        us(r, t, "", "deleteContentBackward");
      };
  }, "Backspace"),
  Delete: /* @__PURE__ */ c((e, t, r) => {
    if (cs(t))
      return () => {
        us(r, t, "", "deleteContentForward");
      };
  }, "Delete"),
  End: /* @__PURE__ */ c((e, t) => {
    if (Me(t, [
      "input",
      "textarea"
    ]) || Va(t))
      return () => {
        var r, n;
        const o = (n = (r = QH(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0 ? n : (
          /* istanbul ignore next */
          0
        );
        ll(t, o, o);
      };
  }, "End"),
  Home: /* @__PURE__ */ c((e, t) => {
    if (Me(t, [
      "input",
      "textarea"
    ]) || Va(t))
      return () => {
        ll(t, 0, 0);
      };
  }, "Home"),
  PageDown: /* @__PURE__ */ c((e, t) => {
    if (Me(t, [
      "input"
    ]))
      return () => {
        const r = Vn(t).length;
        ll(t, r, r);
      };
  }, "PageDown"),
  PageUp: /* @__PURE__ */ c((e, t) => {
    if (Me(t, [
      "input"
    ]))
      return () => {
        ll(t, 0, 0);
      };
  }, "PageUp"),
  Tab: /* @__PURE__ */ c((e, t, r) => () => {
    const n = eV(t, r.system.keyboard.modifiers.Shift);
    oa(n), Hn(n) && Rs(n, {
      anchorOffset: 0,
      focusOffset: n.value.length
    });
  }, "Tab")
}, lhe = /* @__PURE__ */ c((e, t, r) => {
  if (e.code === "KeyA" && r.system.keyboard.modifiers.Control)
    return () => jT(t);
}, "combinationBehavior");
za.keypress = (e, t, r) => {
  if (e.key === "Enter") {
    if (Me(t, "button") || Me(t, "input") && che.includes(t.type) || Me(t, "a") && t.href)
      return () => {
        r.dispatchUIEvent(t, "click");
      };
    if (Me(t, "input")) {
      const n = t.form, o = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return o ? () => r.dispatchUIEvent(o, "click") : n && uhe.includes(t.type) && n.querySelectorAll("input").length === 1 ? () => r.dispatchUIEvent(n, "submit") : void 0;
    }
  }
  if (cs(t)) {
    const n = e.key === "Enter" ? Va(t) && !r.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", o = e.key === "Enter" ? `
` : e.key;
    return () => us(r, t, o, n);
  }
};
var che = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
], uhe = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];
za.keyup = (e, t, r) => {
  var n;
  return (n = jO[e.key]) === null || n === void 0 ? void 0 : n.call(jO, e, t, r);
};
var jO = {
  " ": /* @__PURE__ */ c((e, t, r) => {
    if (TT(t))
      return () => r.dispatchUIEvent(t, "click");
  }, " ")
};
za.paste = (e, t, r) => {
  if (cs(t))
    return () => {
      var n;
      const o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData("text");
      o && us(r, t, o, "insertFromPaste");
    };
};
var rV = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
};
function IT(e) {
  return rV[e].EventType;
}
c(IT, "getEventClass");
var dhe = [
  "MouseEvent",
  "PointerEvent"
];
function nV(e) {
  return dhe.includes(IT(e));
}
c(nV, "isMouseEvent");
function oV(e) {
  return IT(e) === "KeyboardEvent";
}
c(oV, "isKeyboardEvent");
var phe = {
  ClipboardEvent: [
    iV
  ],
  Event: [],
  FocusEvent: [
    Ks,
    sV
  ],
  InputEvent: [
    Ks,
    lV
  ],
  MouseEvent: [
    Ks,
    ff,
    __
  ],
  PointerEvent: [
    Ks,
    ff,
    __,
    uV
  ],
  KeyboardEvent: [
    Ks,
    ff,
    cV
  ]
};
function NT(e, t, r) {
  const n = Zr(t), { EventType: o, defaultInit: a } = rV[e], i = new (aV(n))[o](e, a);
  return phe[o].forEach((s) => s(i, r ?? {})), i;
}
c(NT, "createEvent");
function aV(e) {
  var t, r, n, o, a, i, s, d, l, p, f, h, m, g, w, _;
  const b = (_ = e.Event) !== null && _ !== void 0 ? _ : (t = class {
  }, c(t, "Event"), t);
  var x;
  const P = (x = e.AnimationEvent) !== null && x !== void 0 ? x : (r = class extends b {
  }, c(r, "AnimationEvent"), r);
  var R;
  const N = (R = e.ClipboardEvent) !== null && R !== void 0 ? R : (n = class extends b {
  }, c(n, "ClipboardEvent"), n);
  var C;
  const A = (C = e.PopStateEvent) !== null && C !== void 0 ? C : (o = class extends b {
  }, c(o, "PopStateEvent"), o);
  var E;
  const T = (E = e.ProgressEvent) !== null && E !== void 0 ? E : (a = class extends b {
  }, c(a, "ProgressEvent"), a);
  var O;
  const k = (O = e.TransitionEvent) !== null && O !== void 0 ? O : (i = class extends b {
  }, c(i, "TransitionEvent"), i);
  var M;
  const L = (M = e.UIEvent) !== null && M !== void 0 ? M : (s = class extends b {
  }, c(s, "UIEvent"), s);
  var $;
  const I = ($ = e.CompositionEvent) !== null && $ !== void 0 ? $ : (d = class extends L {
  }, c(d, "CompositionEvent"), d);
  var D;
  const F = (D = e.FocusEvent) !== null && D !== void 0 ? D : (l = class extends L {
  }, c(l, "FocusEvent"), l);
  var J;
  const oe = (J = e.InputEvent) !== null && J !== void 0 ? J : (p = class extends L {
  }, c(p, "InputEvent"), p);
  var ce;
  const le = (ce = e.KeyboardEvent) !== null && ce !== void 0 ? ce : (f = class extends L {
  }, c(f, "KeyboardEvent"), f);
  var re;
  const we = (re = e.MouseEvent) !== null && re !== void 0 ? re : (h = class extends L {
  }, c(h, "MouseEvent"), h);
  var _e;
  const de = (_e = e.DragEvent) !== null && _e !== void 0 ? _e : (m = class extends we {
  }, c(m, "DragEvent"), m);
  var ne;
  const $e = (ne = e.PointerEvent) !== null && ne !== void 0 ? ne : (g = class extends we {
  }, c(g, "PointerEvent"), g);
  var Se;
  const nt = (Se = e.TouchEvent) !== null && Se !== void 0 ? Se : (w = class extends L {
  }, c(w, "TouchEvent"), w);
  return {
    Event: b,
    AnimationEvent: P,
    ClipboardEvent: N,
    PopStateEvent: A,
    ProgressEvent: T,
    TransitionEvent: k,
    UIEvent: L,
    CompositionEvent: I,
    FocusEvent: F,
    InputEvent: oe,
    KeyboardEvent: le,
    MouseEvent: we,
    DragEvent: de,
    PointerEvent: $e,
    TouchEvent: nt
  };
}
c(aV, "getEventConstructors");
function ca(e, t) {
  for (const [r, n] of Object.entries(t))
    Object.defineProperty(e, r, {
      get: /* @__PURE__ */ c(() => n ?? null, "get")
    });
}
c(ca, "assignProps");
function St(e) {
  return Number(e ?? 0);
}
c(St, "sanitizeNumber");
function iV(e, { clipboardData: t }) {
  ca(e, {
    clipboardData: t
  });
}
c(iV, "initClipboardEvent");
function sV(e, { relatedTarget: t }) {
  ca(e, {
    relatedTarget: t
  });
}
c(sV, "initFocusEvent");
function lV(e, { data: t, inputType: r, isComposing: n }) {
  ca(e, {
    data: t,
    isComposing: !!n,
    inputType: String(r)
  });
}
c(lV, "initInputEvent");
function Ks(e, { view: t, detail: r }) {
  ca(e, {
    view: t,
    detail: St(r ?? 0)
  });
}
c(Ks, "initUIEvent");
function ff(e, { altKey: t, ctrlKey: r, metaKey: n, shiftKey: o, modifierAltGraph: a, modifierCapsLock: i, modifierFn: s, modifierFnLock: d, modifierNumLock: l, modifierScrollLock: p, modifierSymbol: f, modifierSymbolLock: h }) {
  ca(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!o,
    getModifierState(m) {
      return !!{
        Alt: t,
        AltGraph: a,
        CapsLock: i,
        Control: r,
        Fn: s,
        FnLock: d,
        Meta: n,
        NumLock: l,
        ScrollLock: p,
        Shift: o,
        Symbol: f,
        SymbolLock: h
      }[m];
    }
  });
}
c(ff, "initUIEventModifiers");
function cV(e, { key: t, code: r, location: n, repeat: o, isComposing: a, charCode: i }) {
  ca(e, {
    key: String(t),
    code: String(r),
    location: St(n),
    repeat: !!o,
    isComposing: !!a,
    charCode: i
  });
}
c(cV, "initKeyboardEvent");
function __(e, { x: t, y: r, screenX: n, screenY: o, clientX: a = t, clientY: i = r, button: s, buttons: d, relatedTarget: l, offsetX: p, offsetY: f, pageX: h, pageY: m }) {
  ca(e, {
    screenX: St(n),
    screenY: St(o),
    clientX: St(a),
    x: St(a),
    clientY: St(i),
    y: St(i),
    button: St(s),
    buttons: St(d),
    relatedTarget: l,
    offsetX: St(p),
    offsetY: St(f),
    pageX: St(h),
    pageY: St(m)
  });
}
c(__, "initMouseEvent");
function uV(e, { pointerId: t, width: r, height: n, pressure: o, tangentialPressure: a, tiltX: i, tiltY: s, twist: d, pointerType: l, isPrimary: p }) {
  ca(e, {
    pointerId: St(t),
    width: St(r ?? 1),
    height: St(n ?? 1),
    pressure: St(o),
    tangentialPressure: St(a),
    tiltX: St(i),
    tiltY: St(s),
    twist: St(d),
    pointerType: String(l),
    isPrimary: !!p
  });
}
c(uV, "initPointerEvent");
function dV(e, t, r, n = !1) {
  (nV(t) || oV(t)) && (r = {
    ...r,
    ...this.system.getUIEventModifiers()
  });
  const o = NT(t, e, r);
  return MT.call(this, e, o, n);
}
c(dV, "dispatchUIEvent");
function MT(e, t, r = !1) {
  var n;
  const o = t.type, a = r ? () => {
  } : (n = za[o]) === null || n === void 0 ? void 0 : n.call(za, t, e, this);
  if (a) {
    t.preventDefault();
    let i = !1;
    return Object.defineProperty(t, "defaultPrevented", {
      get: /* @__PURE__ */ c(() => i, "get")
    }), Object.defineProperty(t, "preventDefault", {
      value: /* @__PURE__ */ c(() => {
        i = t.cancelable;
      }, "value")
    }), Jl(() => e.dispatchEvent(t)), i || a(), !i;
  }
  return Jl(() => e.dispatchEvent(t));
}
c(MT, "dispatchEvent");
function xa(e, t, r) {
  const n = NT(t, e, r);
  Jl(() => e.dispatchEvent(n));
}
c(xa, "dispatchDOMEvent");
var IO = Symbol("patched focus/blur methods");
function DT(e) {
  if (e.prototype[IO])
    return;
  const { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: {
      configurable: !0,
      get: /* @__PURE__ */ c(() => o, "get")
    },
    blur: {
      configurable: !0,
      get: /* @__PURE__ */ c(() => a, "get")
    },
    [IO]: {
      configurable: !0,
      get: /* @__PURE__ */ c(() => ({
        focus: t,
        blur: r
      }), "get")
    }
  });
  let n;
  function o(i) {
    if (this.ownerDocument.visibilityState !== "hidden")
      return t.call(this, i);
    const s = E_(this.ownerDocument);
    if (s === this)
      return;
    const d = Symbol("focus call");
    n = d, s && (r.call(s), xa(s, "blur", {
      relatedTarget: this
    }), xa(s, "focusout", {
      relatedTarget: n === d ? this : null
    })), n === d && (t.call(this, i), xa(this, "focus", {
      relatedTarget: s
    })), n === d && xa(this, "focusin", {
      relatedTarget: s
    });
  }
  c(o, "patchedFocus");
  function a() {
    if (this.ownerDocument.visibilityState !== "hidden")
      return r.call(this);
    const i = E_(this.ownerDocument);
    i === this && (n = Symbol("blur call"), r.call(this), xa(i, "blur", {
      relatedTarget: null
    }), xa(i, "focusout", {
      relatedTarget: null
    }));
  }
  c(a, "patchedBlur");
}
c(DT, "patchFocus");
function E_(e) {
  const t = Pc(e);
  return t?.tagName === "BODY" ? null : t;
}
c(E_, "getActiveTarget");
var uv = Symbol("Interceptor for programmatical calls");
function Li(e, t, r) {
  const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), o = Object.getOwnPropertyDescriptor(e, t), a = n?.set ? "set" : "value";
  if (typeof n?.[a] != "function" || n[a][uv])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function i(...s) {
    const { applyNative: d = !1, realArgs: l, then: p } = r.call(this, ...s), f = (!d && o || n)[a];
    a === "set" ? f.call(this, l) : f.call(this, ...l), p?.();
  }
  c(i, "intercept"), i[uv] = uv, Object.defineProperty(e, t, {
    ...o ?? n,
    [a]: i
  });
}
c(Li, "prepareInterceptor");
function pV(e) {
  Li(e, "value", /* @__PURE__ */ c(function(t) {
    const r = kH(t);
    return r && HH(this), {
      applyNative: !!r,
      realArgs: fV(this, t),
      then: r ? void 0 : () => VH(this, String(t))
    };
  }, "interceptorImpl"));
}
c(pV, "prepareValueInterceptor");
function fV(e, t) {
  return Me(e, "input", {
    type: "number"
  }) && String(t) !== "" && !Number.isNaN(Number(t)) ? String(Number(t)) : String(t);
}
c(fV, "sanitizeValue");
function hV(e) {
  Li(e, "setSelectionRange", /* @__PURE__ */ c(function(t, ...r) {
    const n = PH(t);
    return {
      applyNative: !!n,
      realArgs: [
        Number(t),
        ...r
      ],
      then: /* @__PURE__ */ c(() => n ? void 0 : Lu(e), "then")
    };
  }, "interceptorImpl")), Li(e, "selectionStart", /* @__PURE__ */ c(function(t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ c(() => Lu(e), "then")
    };
  }, "interceptorImpl")), Li(e, "selectionEnd", /* @__PURE__ */ c(function(t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ c(() => Lu(e), "then")
    };
  }, "interceptorImpl")), Li(e, "select", /* @__PURE__ */ c(function() {
    return {
      realArgs: [],
      then: /* @__PURE__ */ c(() => jH(e, {
        anchorOffset: 0,
        focusOffset: Vn(e).length
      }), "then")
    };
  }, "interceptorImpl"));
}
c(hV, "prepareSelectionInterceptor");
function mV(e) {
  Li(e, "setRangeText", /* @__PURE__ */ c(function(...t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ c(() => {
        Zy(e), Lu(e);
      }, "then")
    };
  }, "interceptorImpl"));
}
c(mV, "prepareRangeTextInterceptor");
var El = Symbol("Node prepared with document state workarounds");
function qT(e) {
  e[El] || (e.addEventListener("focus", (t) => {
    const r = t.target;
    x_(r);
  }, {
    capture: !0,
    passive: !0
  }), e.activeElement && x_(e.activeElement), e.addEventListener("blur", (t) => {
    const r = t.target, n = RH(r);
    n !== void 0 && (r.value !== n && xa(r, "change"), CT(r));
  }, {
    capture: !0,
    passive: !0
  }), e[El] = El);
}
c(qT, "prepareDocument");
function x_(e) {
  e[El] || (Me(e, [
    "input",
    "textarea"
  ]) && (pV(e), hV(e), mV(e)), e[El] = El);
}
c(x_, "prepareElement");
function yV(e) {
  return gV(e) ? e : e.ownerDocument;
}
c(yV, "getDocumentFromNode");
function gV(e) {
  return e.nodeType === 9;
}
c(gV, "isDocument");
var zr = (function(e) {
  return e[e.Trigger = 2] = "Trigger", e[e.Call = 1] = "Call", e;
})({});
function cl(e, t) {
  e.levelRefs[t] = {};
}
c(cl, "setLevelRef");
function bu(e, t) {
  return e.levelRefs[t];
}
c(bu, "getLevelRef");
function ds(e) {
  const t = e.delay;
  if (typeof t == "number")
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t)
    ]);
}
c(ds, "wait");
var hf = (function(e) {
  return e[e.EachTrigger = 4] = "EachTrigger", e[e.EachApiCall = 2] = "EachApiCall", e[e.EachTarget = 1] = "EachTarget", e[e.Never = 0] = "Never", e;
})({});
function ya(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(ya, "_define_property");
var Wn = (function(e) {
  return e[e.STANDARD = 0] = "STANDARD", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.NUMPAD = 3] = "NUMPAD", e;
})({}), fhe = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function S_(e) {
  return fhe.includes(e);
}
c(S_, "isModifierKey");
var hhe = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function T_(e) {
  return hhe.includes(e);
}
c(T_, "isModifierLock");
var bV = class {
  isKeyPressed(t) {
    return this.pressed.has(String(t.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((t) => t.keyDef);
  }
  /** Press a key */
  async keydown(t, r) {
    const n = String(r.key), o = String(r.code), a = pf(t.config.document);
    this.setKeydownTarget(a), this.pressed.add(o, r), S_(n) && (this.modifiers[n] = !0);
    const i = t.dispatchUIEvent(a, "keydown", {
      key: n,
      code: o
    });
    T_(n) && !this.modifiers[n] && (this.modifiers[n] = !0, this.modifierLockStart[n] = !0), i && this.pressed.setUnprevented(o), i && this.hasKeyPress(n) && t.dispatchUIEvent(pf(t.config.document), "keypress", {
      key: n,
      code: o,
      charCode: r.key === "Enter" ? 13 : String(r.key).charCodeAt(0)
    });
  }
  /** Release a key */
  async keyup(t, r) {
    const n = String(r.key), o = String(r.code), a = this.pressed.isUnprevented(o);
    this.pressed.delete(o), S_(n) && !this.pressed.values().find((i) => i.keyDef.key === n) && (this.modifiers[n] = !1), t.dispatchUIEvent(pf(t.config.document), "keyup", {
      key: n,
      code: o
    }, !a), T_(n) && this.modifiers[n] && (this.modifierLockStart[n] ? this.modifierLockStart[n] = !1 : this.modifiers[n] = !1);
  }
  setKeydownTarget(t) {
    t !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = t;
  }
  hasKeyPress(t) {
    return (t.length === 1 || t === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(t) {
    ya(this, "system", void 0), ya(this, "modifiers", {
      Alt: !1,
      AltGraph: !1,
      CapsLock: !1,
      Control: !1,
      Fn: !1,
      FnLock: !1,
      Meta: !1,
      NumLock: !1,
      ScrollLock: !1,
      Shift: !1,
      Symbol: !1,
      SymbolLock: !1
    }), ya(this, "pressed", new class {
      add(r, n) {
        var o, a, i;
        (i = (o = this.registry)[a = r]) !== null && i !== void 0 || (o[a] = {
          keyDef: n,
          unpreventedDefault: !1
        });
      }
      has(r) {
        return !!this.registry[r];
      }
      setUnprevented(r) {
        const n = this.registry[r];
        n && (n.unpreventedDefault = !0);
      }
      isUnprevented(r) {
        var n;
        return !!(!((n = this.registry[r]) === null || n === void 0) && n.unpreventedDefault);
      }
      delete(r) {
        delete this.registry[r];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        ya(this, "registry", {});
      }
    }()), ya(this, "carryChar", ""), ya(this, "lastKeydownTarget", void 0), ya(this, "modifierLockStart", {}), this.system = t;
  }
};
c(bV, "KeyboardHost");
var mhe = bV, yhe = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((e) => ({
    code: `Digit${e}`,
    key: e
  })),
  ...")!@#$%^&*(".split("").map((e, t) => ({
    code: `Digit${t}`,
    key: e,
    shiftKey: !0
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((e) => ({
    code: `Key${e.toUpperCase()}`,
    key: e
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((e) => ({
    code: `Key${e}`,
    key: e,
    shiftKey: !0
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: !0
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: !0
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: Wn.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: Wn.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: Wn.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: Wn.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: Wn.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: Wn.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: Wn.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: Wn.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: Wn.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: Wn.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
], ghe = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];
function vV(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(vV, "_define_property");
var wV = class {
  getButtons() {
    let t = 0;
    for (const r of Object.keys(this.pressed))
      t |= 2 ** Number(r);
    return t;
  }
  down(t) {
    const r = Eh(t.button);
    if (r in this.pressed) {
      this.pressed[r].push(t);
      return;
    }
    return this.pressed[r] = [
      t
    ], r;
  }
  up(t) {
    const r = Eh(t.button);
    if (r in this.pressed && (this.pressed[r] = this.pressed[r].filter((n) => n.name !== t.name), this.pressed[r].length === 0))
      return delete this.pressed[r], r;
  }
  constructor() {
    vV(this, "pressed", {});
  }
};
c(wV, "Buttons");
var _V = wV, NO = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function Eh(e = 0) {
  return e in NO ? NO[e] : Number(e);
}
c(Eh, "getMouseButtonId");
var MO = {
  1: 2,
  2: 1
};
function xh(e) {
  return e = Eh(e), e in MO ? MO[e] : e;
}
c(xh, "getMouseEventButton");
function EV(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(EV, "_define_property");
var xV = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(t) {
    return this.pressedKeys.has(t.name);
  }
  addPressed(t) {
    return this.pressedKeys.add(t.name);
  }
  removePressed(t) {
    return this.pressedKeys.delete(t.name);
  }
  constructor() {
    EV(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
c(xV, "Device");
var bhe = xV;
function xl(e, t) {
  const r = [];
  for (let a = e; a; a = a.parentElement)
    r.push(a);
  const n = [];
  for (let a = t; a; a = a.parentElement)
    n.push(a);
  let o = 0;
  for (; !(o >= r.length || o >= n.length || r[r.length - 1 - o] !== n[n.length - 1 - o]); o++)
    ;
  return [
    r.slice(0, r.length - o),
    n.slice(0, n.length - o),
    n.slice(n.length - o)
  ];
}
c(xl, "getTreeDiff");
function Sh({ target: e, node: t, offset: r }) {
  return Hn(e) ? {
    node: e,
    offset: r ?? Vn(e).length
  } : t ? {
    node: t,
    offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length)
  } : LT(e, r);
}
c(Sh, "resolveCaretPosition");
function LT(e, t, r = !0) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0;
  const o = t === void 0 ? -1 : 1;
  for (; t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length; ) {
    if (t && n === e.childNodes.length)
      throw new Error("The given offset is out of bounds.");
    const a = e.childNodes.item(n), i = String(a.textContent);
    if (i.length)
      if (t !== void 0 && i.length < t)
        t -= i.length;
      else {
        if (a.nodeType === 1)
          return LT(a, t, !1);
        if (a.nodeType === 3)
          return {
            node: a,
            offset: t ?? a.nodeValue.length
          };
      }
    n += o;
  }
  return {
    node: e,
    offset: e.childNodes.length
  };
}
c(LT, "findNodeAtTextOffset");
function SV({ document: e, target: t, clickCount: r, node: n, offset: o }) {
  if (AH(t))
    return;
  const a = Hn(t), i = String(a ? Vn(t) : t.textContent), [s, d] = n ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      o,
      o
    ]
  ) : TV(i, o, r);
  if (a)
    return Rs(t, {
      anchorOffset: s ?? i.length,
      focusOffset: d ?? i.length
    }), {
      node: t,
      start: s ?? 0,
      end: d ?? i.length
    };
  {
    const { node: l, offset: p } = Sh({
      target: t,
      node: n,
      offset: s
    }), { node: f, offset: h } = Sh({
      target: t,
      node: n,
      offset: d
    }), m = t.ownerDocument.createRange();
    try {
      m.setStart(l, p), m.setEnd(f, h);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    const g = e.getSelection();
    return g?.removeAllRanges(), g?.addRange(m.cloneRange()), m;
  }
}
c(SV, "setSelectionPerMouseDown");
function TV(e, t, r) {
  if (r % 3 === 1 || e.length === 0)
    return [
      t,
      t
    ];
  const n = t ?? e.length;
  return r % 3 === 2 ? [
    n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length
  ] : [
    n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length
  ];
}
c(TV, "getTextRange");
function AV(e, { document: t, target: r, node: n, offset: o }) {
  const a = Sh({
    target: r,
    node: n,
    offset: o
  });
  if ("node" in e) {
    if (a.node === e.node) {
      const i = a.offset < e.start ? e.end : e.start, s = a.offset > e.end || a.offset < e.start ? a.offset : e.end;
      Rs(e.node, {
        anchorOffset: i,
        focusOffset: s
      });
    }
  } else {
    const i = e.cloneRange(), s = i.comparePoint(a.node, a.offset);
    s < 0 ? i.setStart(a.node, a.offset) : s > 0 && i.setEnd(a.node, a.offset);
    const d = t.getSelection();
    d?.removeAllRanges(), d?.addRange(i.cloneRange());
  }
}
c(AV, "modifySelectionPerMouseMove");
function FT(e, t) {
  var r, n, o, a, i, s, d, l, p, f, h, m, g, w, _, b, x, P, R, N, C, A, E, T;
  return e.target !== t.target || ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !== ((n = t.coords) === null || n === void 0 ? void 0 : n.x) || ((o = e.coords) === null || o === void 0 ? void 0 : o.y) !== ((a = t.coords) === null || a === void 0 ? void 0 : a.y) || ((i = e.coords) === null || i === void 0 ? void 0 : i.clientX) !== ((s = t.coords) === null || s === void 0 ? void 0 : s.clientX) || ((d = e.coords) === null || d === void 0 ? void 0 : d.clientY) !== ((l = t.coords) === null || l === void 0 ? void 0 : l.clientY) || ((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !== ((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) || ((h = e.coords) === null || h === void 0 ? void 0 : h.offsetY) !== ((m = t.coords) === null || m === void 0 ? void 0 : m.offsetY) || ((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !== ((w = t.coords) === null || w === void 0 ? void 0 : w.pageX) || ((_ = e.coords) === null || _ === void 0 ? void 0 : _.pageY) !== ((b = t.coords) === null || b === void 0 ? void 0 : b.pageY) || ((x = e.coords) === null || x === void 0 ? void 0 : x.screenX) !== ((P = t.coords) === null || P === void 0 ? void 0 : P.screenX) || ((R = e.coords) === null || R === void 0 ? void 0 : R.screenY) !== ((N = t.coords) === null || N === void 0 ? void 0 : N.screenY) || ((C = e.caret) === null || C === void 0 ? void 0 : C.node) !== ((A = t.caret) === null || A === void 0 ? void 0 : A.node) || ((E = e.caret) === null || E === void 0 ? void 0 : E.offset) !== ((T = t.caret) === null || T === void 0 ? void 0 : T.offset);
}
c(FT, "isDifferentPointerPosition");
function ga(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(ga, "_define_property");
var $V = class {
  move(t, r, n) {
    const o = this.position, a = this.getTarget(t);
    if (this.position = r, !FT(o, r))
      return;
    const i = this.getTarget(t), s = this.getEventInit("mousemove"), [d, l] = xl(a, i);
    return {
      leave: /* @__PURE__ */ c(() => {
        a !== i && (t.dispatchUIEvent(a, "mouseout", s), d.forEach((p) => t.dispatchUIEvent(p, "mouseleave", s)));
      }, "leave"),
      enter: /* @__PURE__ */ c(() => {
        a !== i && (t.dispatchUIEvent(i, "mouseover", s), l.forEach((p) => t.dispatchUIEvent(p, "mouseenter", s)));
      }, "enter"),
      move: /* @__PURE__ */ c(() => {
        n || (t.dispatchUIEvent(i, "mousemove", s), this.modifySelecting(t));
      }, "move")
    };
  }
  down(t, r, n) {
    const o = this.buttons.down(r);
    if (o === void 0)
      return;
    const a = this.getTarget(t);
    this.buttonDownTarget[o] = a;
    const i = this.getEventInit("mousedown", r.button), s = ho(a);
    !n && (s || t.dispatchUIEvent(a, "mousedown", i)) && (this.startSelecting(t, i.detail), oa(a)), !s && xh(r.button) === 2 && t.dispatchUIEvent(a, "contextmenu", this.getEventInit("contextmenu", r.button));
  }
  up(t, r, n) {
    const o = this.buttons.up(r);
    if (o === void 0)
      return;
    const a = this.getTarget(t);
    if (!ho(a)) {
      if (!n) {
        const s = this.getEventInit("mouseup", r.button);
        t.dispatchUIEvent(a, "mouseup", s), this.endSelecting();
      }
      const i = xl(this.buttonDownTarget[o], a)[2][0];
      if (i) {
        const s = this.getEventInit("click", r.button);
        s.detail && (t.dispatchUIEvent(i, s.button === 0 ? "click" : "auxclick", s), s.button === 0 && s.detail === 2 && t.dispatchUIEvent(i, "dblclick", {
          ...this.getEventInit("dblclick", r.button),
          detail: s.detail
        }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(t, r) {
    const n = {
      ...this.position.coords
    };
    return n.button = xh(r), n.buttons = this.buttons.getButtons(), t === "mousedown" ? n.detail = this.clickCount.getOnDown(n.button) : t === "mouseup" ? n.detail = this.clickCount.getOnUp(n.button) : (t === "click" || t === "auxclick") && (n.detail = this.clickCount.incOnClick(n.button)), n;
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  startSelecting(t, r) {
    var n, o;
    this.selecting = SV({
      document: t.config.document,
      target: this.getTarget(t),
      node: (n = this.position.caret) === null || n === void 0 ? void 0 : n.node,
      offset: (o = this.position.caret) === null || o === void 0 ? void 0 : o.offset,
      clickCount: r
    });
  }
  modifySelecting(t) {
    var r, n;
    this.selecting && AV(this.selecting, {
      document: t.config.document,
      target: this.getTarget(t),
      node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    ga(this, "position", {}), ga(this, "buttons", new _V()), ga(this, "selecting", void 0), ga(this, "buttonDownTarget", {}), ga(this, "clickCount", new class {
      incOnClick(t) {
        const r = this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
        return this.count = this.count[t] === void 0 ? {} : {
          [t]: Number(this.count[t]) + 1
        }, r;
      }
      getOnDown(t) {
        var r;
        this.down = {
          [t]: (r = this.count[t]) !== null && r !== void 0 ? r : 0
        };
        var n;
        return this.count = {
          [t]: (n = this.count[t]) !== null && n !== void 0 ? n : 0
        }, Number(this.count[t]) + 1;
      }
      getOnUp(t) {
        return this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        ga(this, "down", {}), ga(this, "count", {});
      }
    }());
  }
};
c($V, "Mouse");
var vhe = $V;
function Sd(e, t) {
  var r;
  return ((r = UT(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== "none";
}
c(Sd, "hasPointerEvents");
function CV(e) {
  const t = Zr(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    const o = t.getComputedStyle(r).pointerEvents;
    if (o && ![
      "inherit",
      "unset"
    ].includes(o))
      return {
        pointerEvents: o,
        tree: n
      };
  }
}
c(CV, "closestPointerEventsDeclaration");
var DO = Symbol("Last check for pointer-events");
function UT(e, t) {
  const r = t[DO];
  if (!(e.config.pointerEventsCheck !== hf.Never && (!r || A_(e.config.pointerEventsCheck, hf.EachApiCall) && r[zr.Call] !== bu(e, zr.Call) || A_(e.config.pointerEventsCheck, hf.EachTrigger) && r[zr.Trigger] !== bu(e, zr.Trigger))))
    return r?.result;
  const n = CV(t);
  return t[DO] = {
    [zr.Call]: bu(e, zr.Call),
    [zr.Trigger]: bu(e, zr.Trigger),
    result: n
  }, n;
}
c(UT, "checkPointerEvents");
function ul(e, t) {
  const r = UT(e, t);
  if (r?.pointerEvents === "none")
    throw new Error([
      `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      kV(r.tree)
    ].join(`
`));
}
c(ul, "assertPointerEvents");
function kV(e) {
  return e.reverse().map((t, r) => [
    "".padEnd(r),
    t.tagName,
    t.id && `#${t.id}`,
    t.hasAttribute("data-testid") && `(testId=${t.getAttribute("data-testid")})`,
    PV(t),
    e.length > 1 && r === 0 && "  <-- This element declared `pointer-events: none`",
    e.length > 1 && r === e.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join(`
`);
}
c(kV, "printTree");
function PV(e) {
  var t;
  let r;
  if (e.hasAttribute("aria-label"))
    r = e.getAttribute("aria-label");
  else if (e.hasAttribute("aria-labelledby")) {
    var n, o;
    r = (o = e.ownerDocument.getElementById(e.getAttribute("aria-labelledby"))) === null || o === void 0 || (n = o.textContent) === null || n === void 0 ? void 0 : n.trim();
  } else if (Me(e, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && !((t = e.labels) === null || t === void 0) && t.length)
    r = Array.from(e.labels).map((i) => {
      var s;
      return (s = i.textContent) === null || s === void 0 ? void 0 : s.trim();
    }).join("|");
  else if (Me(e, "button")) {
    var a;
    r = (a = e.textContent) === null || a === void 0 ? void 0 : a.trim();
  }
  return r = r?.replace(/\n/g, "  "), Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}â€¦`), r ? `(label=${r})` : "";
}
c(PV, "getLabelDescr");
function A_(e, t) {
  return (e & t) > 0;
}
c(A_, "hasBitFlag");
function Xn(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(Xn, "_define_property");
var OV = class {
  init(t) {
    const r = this.getTarget(t), [, n] = xl(null, r), o = this.getEventInit();
    return ul(t, r), t.dispatchUIEvent(r, "pointerover", o), n.forEach((a) => t.dispatchUIEvent(a, "pointerenter", o)), this;
  }
  move(t, r) {
    const n = this.position, o = this.getTarget(t);
    if (this.position = r, !FT(n, r))
      return;
    const a = this.getTarget(t), i = this.getEventInit(-1), [s, d] = xl(o, a);
    return {
      leave: /* @__PURE__ */ c(() => {
        Sd(t, o) && o !== a && (t.dispatchUIEvent(o, "pointerout", i), s.forEach((l) => t.dispatchUIEvent(l, "pointerleave", i)));
      }, "leave"),
      enter: /* @__PURE__ */ c(() => {
        ul(t, a), o !== a && (t.dispatchUIEvent(a, "pointerover", i), d.forEach((l) => t.dispatchUIEvent(l, "pointerenter", i)));
      }, "enter"),
      move: /* @__PURE__ */ c(() => {
        t.dispatchUIEvent(a, "pointermove", i);
      }, "move")
    };
  }
  down(t, r = 0) {
    if (this.isDown)
      return;
    const n = this.getTarget(t);
    ul(t, n), this.isDown = !0, this.isPrevented = !t.dispatchUIEvent(n, "pointerdown", this.getEventInit(r));
  }
  up(t, r = 0) {
    if (!this.isDown)
      return;
    const n = this.getTarget(t);
    ul(t, n), this.isPrevented = !1, this.isDown = !1, t.dispatchUIEvent(n, "pointerup", this.getEventInit(r));
  }
  release(t) {
    const r = this.getTarget(t), [n] = xl(r, null), o = this.getEventInit();
    Sd(t, r) && (t.dispatchUIEvent(r, "pointerout", o), n.forEach((a) => t.dispatchUIEvent(a, "pointerleave", o))), this.isCancelled = !0;
  }
  getTarget(t) {
    var r;
    return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  getEventInit(t) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: xh(t),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId: t, pointerType: r, isPrimary: n }, o) {
    Xn(this, "pointerId", void 0), Xn(this, "pointerType", void 0), Xn(this, "isPrimary", void 0), Xn(this, "buttons", void 0), Xn(this, "isMultitouch", !1), Xn(this, "isCancelled", !1), Xn(this, "isDown", !1), Xn(this, "isPrevented", !1), Xn(this, "position", {}), this.pointerId = t, this.pointerType = r, this.isPrimary = n, this.isMultitouch = !n, this.buttons = o;
  }
};
c(OV, "Pointer");
var whe = OV;
function qo(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c(qo, "_define_property");
var RV = class {
  isKeyPressed(t) {
    return this.devices.get(t.pointerType).isPressed(t);
  }
  async press(t, r, n) {
    this.devices.get(r.pointerType).addPressed(r), this.buttons.down(r);
    const o = this.getPointerName(r), a = r.pointerType === "touch" ? this.pointers.new(o, r.pointerType, this.buttons) : this.pointers.get(o);
    a.position = n, a.pointerType !== "touch" && (this.mouse.position = n), a.pointerType === "touch" && a.init(t), a.down(t, r.button), a.pointerType !== "touch" && this.mouse.down(t, r, a.isPrevented);
  }
  async move(t, r, n) {
    const o = this.pointers.get(r), a = o.move(t, n), i = o.pointerType === "touch" ? void 0 : this.mouse.move(t, n, o.isPrevented);
    a?.leave(), i?.leave(), a?.enter(), i?.enter(), a?.move(), i?.move();
  }
  async release(t, r, n) {
    const o = this.devices.get(r.pointerType);
    o.removePressed(r), this.buttons.up(r);
    const a = this.pointers.get(this.getPointerName(r)), i = a.isPrevented;
    if (a.position = n, a.pointerType !== "touch" && (this.mouse.position = n), o.countPressed === 0 && a.up(t, r.button), a.pointerType === "touch" && a.release(t), a.pointerType === "touch" && !a.isMultitouch) {
      const s = this.mouse.move(t, n, i);
      s?.leave(), s?.enter(), s?.move(), this.mouse.down(t, r, i);
    }
    if (!a.isMultitouch) {
      const s = this.mouse.move(t, n, i);
      s?.leave(), s?.enter(), s?.move(), this.mouse.up(t, r, i);
    }
  }
  getPointerName(t) {
    return t.pointerType === "touch" ? t.name : t.pointerType;
  }
  getPreviousPosition(t) {
    return this.pointers.has(t) ? this.pointers.get(t).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(t) {
    var r;
    return (r = this.mouse.position.target) !== null && r !== void 0 ? r : t.config.document.body;
  }
  setMousePosition(t) {
    this.mouse.position = t, this.pointers.get("mouse").position = t;
  }
  constructor(t) {
    qo(this, "system", void 0), qo(this, "mouse", void 0), qo(this, "buttons", void 0), qo(this, "devices", new class {
      get(r) {
        var n, o, a;
        return (a = (n = this.registry)[o = r]) !== null && a !== void 0 ? a : n[o] = new bhe();
      }
      constructor() {
        qo(this, "registry", {});
      }
    }()), qo(this, "pointers", new class {
      new(r, n, o) {
        const a = n !== "touch" || !Object.values(this.registry).some((i) => i.pointerType === "touch" && !i.isCancelled);
        return a || Object.values(this.registry).forEach((i) => {
          i.pointerType === n && !i.isCancelled && (i.isMultitouch = !0);
        }), this.registry[r] = new whe({
          pointerId: this.nextId++,
          pointerType: n,
          isPrimary: a
        }, o), this.registry[r];
      }
      get(r) {
        if (!this.has(r))
          throw new Error(`Trying to access pointer "${r}" which does not exist.`);
        return this.registry[r];
      }
      has(r) {
        return r in this.registry;
      }
      constructor() {
        qo(this, "registry", {}), qo(this, "nextId", 1);
      }
    }()), this.system = t, this.buttons = new _V(), this.mouse = new vhe(), this.pointers.new("mouse", "mouse", this.buttons);
  }
};
c(RV, "PointerHost");
var _he = RV;
function $_(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
c($_, "_define_property");
var jV = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    $_(this, "keyboard", new mhe(this)), $_(this, "pointer", new _he(this));
  }
};
c(jV, "System");
var IV = jV;
async function NV(e) {
  const t = [];
  return this.config.skipHover || t.push({
    target: e
  }), t.push({
    keys: "[MouseLeft]",
    target: e
  }), this.pointer(t);
}
c(NV, "click");
async function MV(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
c(MV, "dblClick");
async function DV(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}
c(DV, "tripleClick");
async function qV(e) {
  return this.pointer({
    target: e
  });
}
c(qV, "hover");
async function LV(e) {
  return ul(this, this.system.pointer.getMouseTarget(this)), this.pointer({
    target: e.ownerDocument.body
  });
}
c(LV, "unhover");
async function FV({ shift: e } = {}) {
  return this.keyboard(e === !0 ? "{Shift>}{Tab}{/Shift}" : e === !1 ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
c(FV, "tab");
var BT = (function(e) {
  return e["{"] = "}", e["["] = "]", e;
})(BT || {});
function HT(e, t) {
  let r = 0;
  const n = e[r] in BT ? e[r] : "";
  r += n.length;
  const o = new RegExp(`^\\${n}{2}`).test(e) ? "" : n;
  return {
    type: o,
    ...o === "" ? UV(e, r, t) : BV(e, r, o, t)
  };
}
c(HT, "readNextDescriptor");
function UV(e, t, r) {
  const n = e[t];
  return VT(n, e, t, r), t += n.length, {
    consumedLength: t,
    descriptor: n,
    releasePrevious: !1,
    releaseSelf: !0,
    repeat: 1
  };
}
c(UV, "readPrintableChar");
function BV(e, t, r, n) {
  var o, a;
  const i = e[t] === "/" ? "/" : "";
  t += i.length;
  const s = r === "{" && e[t] === "\\";
  t += Number(s);
  const d = s ? e[t] : (o = e.slice(t).match(r === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || o === void 0 ? void 0 : o[0];
  VT(d, e, t, n), t += d.length;
  var l;
  const p = (l = (a = e.slice(t).match(/^>\d+/)) === null || a === void 0 ? void 0 : a[0]) !== null && l !== void 0 ? l : "";
  t += p.length;
  const f = e[t] === "/" || !p && e[t] === ">" ? e[t] : "";
  t += f.length;
  const h = BT[r], m = e[t] === h ? h : "";
  if (!m)
    throw new Error(zT([
      !p && "repeat modifier",
      !f && "release modifier",
      `"${h}"`
    ].filter(Boolean).join(" or "), e[t], e, n));
  return t += m.length, {
    consumedLength: t,
    descriptor: d,
    releasePrevious: !!i,
    repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
    releaseSelf: HV(f, p)
  };
}
c(BV, "readTag");
function VT(e, t, r, n) {
  if (!e)
    throw new Error(zT("key descriptor", t[r], t, n));
}
c(VT, "assertDescriptor");
function HV(e, t) {
  if (e)
    return e === "/";
  if (t)
    return !1;
}
c(HV, "hasReleaseSelf");
function zT(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ""}" in "${r}"
    See ${n === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}
c(zT, "getErrorMessage");
function VV(e, t) {
  const r = [];
  do {
    const { type: o, descriptor: a, consumedLength: i, releasePrevious: s, releaseSelf: d = !0, repeat: l } = HT(t, "keyboard");
    var n;
    const p = (n = e.find((f) => {
      if (o === "[") {
        var h;
        return ((h = f.code) === null || h === void 0 ? void 0 : h.toLowerCase()) === a.toLowerCase();
      } else if (o === "{") {
        var m;
        return ((m = f.key) === null || m === void 0 ? void 0 : m.toLowerCase()) === a.toLowerCase();
      }
      return f.key === a;
    })) !== null && n !== void 0 ? n : {
      key: "Unknown",
      code: "Unknown",
      [o === "[" ? "code" : "key"]: a
    };
    r.push({
      keyDef: p,
      releasePrevious: s,
      releaseSelf: d,
      repeat: l
    }), t = t.slice(i);
  } while (t);
  return r;
}
c(VV, "parseKeyDef");
async function zV(e) {
  const t = VV(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++)
    await ds(this.config), await JV(this, t[r]);
}
c(zV, "keyboard");
async function JV(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: o }) {
  const { system: a } = e;
  if (a.keyboard.isKeyPressed(t) && await a.keyboard.keyup(e, t), !r) {
    for (let i = 1; i <= o; i++)
      await a.keyboard.keydown(e, t), i < o && await ds(e.config);
    n && await a.keyboard.keyup(e, t);
  }
}
c(JV, "keyboardAction");
async function WV(e) {
  for (const t of e.system.keyboard.getPressedKeys())
    await e.system.keyboard.keyup(e, t);
}
c(WV, "releaseAllKeys");
function JT(e) {
  const t = Hn(e) ? {
    "text/plain": GV(e)
  } : {
    "text/plain": String(e.ownerDocument.getSelection())
  }, r = Yy(Zr(e));
  for (const n in t)
    t[n] && r.setData(n, t[n]);
  return r;
}
c(JT, "copySelection");
function GV(e) {
  const t = Gl(e);
  return Vn(e).substring(t.startOffset, t.endOffset);
}
c(GV, "readSelectedValueFromInput");
async function KV() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = JT(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "copy", {
      clipboardData: n
    }) && this.config.writeToClipboard && await ST(e, n), n;
}
c(KV, "copy");
async function YV() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = JT(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "cut", {
      clipboardData: n
    }) && this.config.writeToClipboard && await ST(r.ownerDocument, n), n;
}
c(YV, "cut");
async function XV(e) {
  const t = this.config.document;
  var r;
  const n = (r = t.activeElement) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    t.body
  );
  var o;
  const a = (o = typeof e == "string" ? QV(t, e) : e) !== null && o !== void 0 ? o : await vH(t).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(n, "paste", {
    clipboardData: a
  });
}
c(XV, "paste");
function QV(e, t) {
  const r = Yy(Zr(e));
  return r.setData("text", t), r;
}
c(QV, "getClipboardDataFromString");
function C_(e, t) {
  const r = [];
  do {
    const { descriptor: n, consumedLength: o, releasePrevious: a, releaseSelf: i = !0 } = HT(t, "pointer"), s = e.find((d) => d.name === n);
    s && r.push({
      keyDef: s,
      releasePrevious: a,
      releaseSelf: i
    }), t = t.slice(o);
  } while (t);
  return r;
}
c(C_, "parseKeyDef");
async function ZV(e) {
  const { pointerMap: t } = this.config, r = [];
  (Array.isArray(e) ? e : [
    e
  ]).forEach((n) => {
    typeof n == "string" ? r.push(...C_(t, n)) : "keys" in n ? r.push(...C_(t, n.keys).map((o) => ({
      ...n,
      ...o
    }))) : r.push(n);
  });
  for (let n = 0; n < r.length; n++)
    await ds(this.config), await e4(this, r[n]);
  this.system.pointer.resetClickCount();
}
c(ZV, "pointer");
async function e4(e, t) {
  var r, n;
  const o = "pointerName" in t && t.pointerName ? t.pointerName : "keyDef" in t ? e.system.pointer.getPointerName(t.keyDef) : "mouse", a = e.system.pointer.getPreviousPosition(o);
  var i, s, d, l;
  const p = {
    target: (i = t.target) !== null && i !== void 0 ? i : t4(e, a),
    coords: (s = t.coords) !== null && s !== void 0 ? s : a?.coords,
    caret: {
      node: (d = t.node) !== null && d !== void 0 ? d : k_(t) || a == null || (r = a.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (l = t.offset) !== null && l !== void 0 ? l : k_(t) || a == null || (n = a.caret) === null || n === void 0 ? void 0 : n.offset
    }
  };
  "keyDef" in t ? (e.system.pointer.isKeyPressed(t.keyDef) && (cl(e, zr.Trigger), await e.system.pointer.release(e, t.keyDef, p)), t.releasePrevious || (cl(e, zr.Trigger), await e.system.pointer.press(e, t.keyDef, p), t.releaseSelf && (cl(e, zr.Trigger), await e.system.pointer.release(e, t.keyDef, p)))) : (cl(e, zr.Trigger), await e.system.pointer.move(e, o, p));
}
c(e4, "pointerAction");
function k_(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0 ? r : e.offset !== void 0);
}
c(k_, "hasCaretPosition");
function t4(e, t) {
  if (!t)
    throw new Error("This pointer has no previous position. Provide a target property!");
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
c(t4, "getPrevTarget");
async function r4(e) {
  if (!cs(e) || ho(e))
    throw new Error("clear()` is only supported on editable elements.");
  if (oa(e), e.ownerDocument.activeElement !== e)
    throw new Error("The element to be cleared could not be focused.");
  if (jT(e), !tV(e))
    throw new Error("The element content to be cleared could not be selected.");
  us(this, e, "", "deleteContentBackward");
}
c(r4, "clear");
async function n4(e, t) {
  return WT.call(this, !0, e, t);
}
c(n4, "selectOptions");
async function o4(e, t) {
  return WT.call(this, !1, e, t);
}
c(o4, "deselectOptions");
async function WT(e, t, r) {
  if (!e && !t.multiple)
    throw He().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", t);
  const n = Array.isArray(r) ? r : [
    r
  ], o = Array.from(t.querySelectorAll('option, [role="option"]')), a = n.map((s) => {
    if (typeof s != "string" && o.includes(s))
      return s;
    {
      const d = o.find((l) => l.value === s || l.innerHTML === s);
      if (d)
        return d;
      throw He().getElementError(`Value "${String(s)}" not found in options`, t);
    }
  }).filter((s) => !ho(s));
  if (ho(t) || !a.length) return;
  const i = /* @__PURE__ */ c((s) => {
    s.selected = e, this.dispatchUIEvent(t, "input", {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }), this.dispatchUIEvent(t, "change");
  }, "selectOption");
  if (Me(t, "select"))
    if (t.multiple)
      for (const s of a) {
        const d = this.config.pointerEventsCheck === 0 ? !0 : Sd(this, s);
        d && (this.dispatchUIEvent(s, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(s, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(s, "pointermove"), this.dispatchUIEvent(s, "mousemove"), this.dispatchUIEvent(s, "pointerdown"), this.dispatchUIEvent(s, "mousedown")), oa(t), d && (this.dispatchUIEvent(s, "pointerup"), this.dispatchUIEvent(s, "mouseup")), i(s), d && this.dispatchUIEvent(s, "click"), await ds(this.config);
      }
    else if (a.length === 1) {
      const s = this.config.pointerEventsCheck === 0 ? !0 : Sd(this, t);
      s ? await this.click(t) : oa(t), i(a[0]), s && (this.dispatchUIEvent(t, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(t, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(t, "pointerup"), this.dispatchUIEvent(t, "mouseup"), this.dispatchUIEvent(t, "click")), await ds(this.config);
    } else
      throw He().getElementError("Cannot select multiple options on a non-multiple select", t);
  else if (t.getAttribute("role") === "listbox")
    for (const s of a)
      await this.click(s), await this.unhover(s);
  else
    throw He().getElementError("Cannot select options on elements that are neither select nor listbox elements", t);
}
c(WT, "selectOptionsBase");
async function a4(e, t, { skipClick: r = this.config.skipClick, skipAutoClose: n = this.config.skipAutoClose, initialSelectionStart: o, initialSelectionEnd: a } = {}) {
  e.disabled || (r || await this.click(e), o !== void 0 && ll(e, o, a ?? o), await this.keyboard(t), n || await WV(this));
}
c(a4, "type");
var qO = Symbol("files and value properties are mocked");
function mf(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
c(mf, "restoreProperty");
function i4(e, t) {
  var r;
  (r = e[qO]) === null || r === void 0 || r.restore();
  const n = Object.getOwnPropertyDescriptor(e, "type"), o = Object.getOwnPropertyDescriptor(e, "value"), a = Object.getOwnPropertyDescriptor(e, "files");
  function i() {
    mf(e, "type", n), mf(e, "value", o), mf(e, "files", a);
  }
  c(i, "restore"), e[qO] = {
    restore: i
  }, Object.defineProperties(e, {
    files: {
      configurable: !0,
      get: /* @__PURE__ */ c(() => t, "get")
    },
    value: {
      configurable: !0,
      get: /* @__PURE__ */ c(() => t.length ? `C:\\fakepath\\${t[0].name}` : "", "get"),
      set(s) {
        if (s === "")
          i();
        else {
          var d;
          o == null || (d = o.set) === null || d === void 0 || d.call(e, s);
        }
      }
    },
    type: {
      configurable: !0,
      get: /* @__PURE__ */ c(() => "file", "get"),
      set(s) {
        s !== "file" && (i(), e.type = s);
      }
    }
  });
}
c(i4, "setFiles");
async function s4(e, t) {
  const r = Me(e, "label") ? e.control : e;
  if (!r || !Me(r, "input", {
    type: "file"
  }))
    throw new TypeError(`The ${r === e ? "given" : "associated"} ${r?.tagName} element does not accept file uploads`);
  if (ho(e)) return;
  const n = (Array.isArray(t) ? t : [
    t
  ]).filter((a) => !this.config.applyAccept || l4(a, r.accept)).slice(0, r.multiple ? void 0 : 1), o = /* @__PURE__ */ c(() => {
    var a;
    n.length === ((a = r.files) === null || a === void 0 ? void 0 : a.length) && n.every((i, s) => {
      var d;
      return i === ((d = r.files) === null || d === void 0 ? void 0 : d.item(s));
    }) || (i4(r, Ky(Zr(e), n)), this.dispatchUIEvent(r, "input"), this.dispatchUIEvent(r, "change"));
  }, "fileDialog");
  r.addEventListener("fileDialog", o), await this.click(e), r.removeEventListener("fileDialog", o);
}
c(s4, "upload");
function vu(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
c(vu, "normalize");
function l4(e, t) {
  if (!t)
    return !0;
  const r = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return vu(t).trim().split(/\s*,\s*/).some((n) => n.startsWith(".") ? vu(e.name).endsWith(n) : r.includes(n) ? vu(e.type).startsWith(n.replace("*", "")) : vu(e.type) === n);
}
c(l4, "isAcceptableFile");
var LO = {
  click: NV,
  dblClick: MV,
  tripleClick: DV,
  hover: qV,
  unhover: LV,
  tab: FV,
  keyboard: zV,
  copy: KV,
  cut: YV,
  paste: XV,
  pointer: ZV,
  clear: r4,
  deselectOptions: o4,
  selectOptions: n4,
  type: a4,
  upload: s4
};
function c4(e) {
  return He().asyncWrapper(e);
}
c(c4, "wrapAsync");
var u4 = {
  applyAccept: !0,
  autoModify: !0,
  delay: 0,
  document: globalThis.document,
  keyboardMap: yhe,
  pointerMap: ghe,
  pointerEventsCheck: hf.EachApiCall,
  skipAutoClose: !1,
  skipClick: !1,
  skipHover: !1,
  writeToClipboard: !1,
  advanceTimers: /* @__PURE__ */ c(() => Promise.resolve(), "advanceTimers")
}, Ehe = {
  ...u4,
  writeToClipboard: !0
};
function GT(e = {}, t = Ehe, r) {
  const n = h4(e, r, t);
  return {
    ...t,
    ...e,
    document: n
  };
}
c(GT, "createConfig");
function d4(e = {}) {
  const t = GT(e);
  qT(t.document), DT(Zr(t.document).HTMLElement);
  var r;
  const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    globalThis.window
  );
  return yH(n), tg(t).api;
}
c(d4, "setupMain");
function yr({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  const o = GT(r, u4, n);
  qT(o.document), DT(Zr(o.document).HTMLElement);
  var a;
  const i = (a = t ?? e) !== null && a !== void 0 ? a : new IV();
  return {
    api: tg(o, i).api,
    system: i
  };
}
c(yr, "setupDirect");
function p4(e) {
  return tg({
    ...this.config,
    ...e
  }, this.system).api;
}
c(p4, "setupSub");
function f4(e, t) {
  function r(...n) {
    return cl(e, zr.Call), c4(() => t.apply(e, n).then(async (o) => (await ds(e.config), o)));
  }
  return c(r, "method"), Object.defineProperty(r, "name", {
    get: /* @__PURE__ */ c(() => t.name, "get")
  }), r;
}
c(f4, "wrapAndBindImpl");
function tg(e, t = new IV()) {
  const r = {};
  return Object.assign(r, {
    config: e,
    dispatchEvent: MT.bind(r),
    dispatchUIEvent: dV.bind(r),
    system: t,
    levelRefs: {},
    ...LO
  }), {
    instance: r,
    api: {
      ...Object.fromEntries(Object.entries(LO).map(([n, o]) => [
        n,
        f4(r, o)
      ])),
      setup: p4.bind(r)
    }
  };
}
c(tg, "createInstance");
function h4(e, t, r) {
  var n, o;
  return (o = (n = e.document) !== null && n !== void 0 ? n : t && yV(t)) !== null && o !== void 0 ? o : r.document;
}
c(h4, "getDocument");
var m4 = {};
Qd(m4, {
  clear: () => y4,
  click: () => g4,
  copy: () => b4,
  cut: () => v4,
  dblClick: () => w4,
  deselectOptions: () => _4,
  hover: () => E4,
  keyboard: () => x4,
  paste: () => T4,
  pointer: () => S4,
  selectOptions: () => A4,
  tab: () => O4,
  tripleClick: () => $4,
  type: () => C4,
  unhover: () => k4,
  upload: () => P4
});
function y4(e) {
  return yr().api.clear(e);
}
c(y4, "clear");
function g4(e, t = {}) {
  return yr(t, e).api.click(e);
}
c(g4, "click");
function b4(e = {}) {
  return yr(e).api.copy();
}
c(b4, "copy");
function v4(e = {}) {
  return yr(e).api.cut();
}
c(v4, "cut");
function w4(e, t = {}) {
  return yr(t).api.dblClick(e);
}
c(w4, "dblClick");
function _4(e, t, r = {}) {
  return yr(r).api.deselectOptions(e, t);
}
c(_4, "deselectOptions");
function E4(e, t = {}) {
  return yr(t).api.hover(e);
}
c(E4, "hover");
async function x4(e, t = {}) {
  const { api: r, system: n } = yr(t);
  return r.keyboard(e).then(() => n);
}
c(x4, "keyboard");
async function S4(e, t = {}) {
  const { api: r, system: n } = yr(t);
  return r.pointer(e).then(() => n);
}
c(S4, "pointer");
function T4(e, t) {
  return yr(t).api.paste(e);
}
c(T4, "paste");
function A4(e, t, r = {}) {
  return yr(r).api.selectOptions(e, t);
}
c(A4, "selectOptions");
function $4(e, t = {}) {
  return yr(t).api.tripleClick(e);
}
c($4, "tripleClick");
function C4(e, t, r = {}) {
  return yr(r, e).api.type(e, t, r);
}
c(C4, "type");
function k4(e, t = {}) {
  const { api: r, system: n } = yr(t);
  return n.pointer.setMousePosition({
    target: e
  }), r.unhover(e);
}
c(k4, "unhover");
function P4(e, t, r = {}) {
  return yr(r).api.upload(e, t);
}
c(P4, "upload");
function O4(e = {}) {
  return yr().api.tab(e);
}
c(O4, "tab");
var R4 = {
  ...m4,
  setup: d4
}, P_ = _c(
  { ...HU },
  {
    getKeys: /* @__PURE__ */ c((e) => Object.keys(e).filter((t) => t !== "eventWrapper"), "getKeys"),
    intercept: /* @__PURE__ */ c((e, t) => t[0] === "fireEvent" || e.startsWith("find") || e.startsWith("waitFor"), "intercept")
  }
);
P_.screen = new Proxy(P_.screen, {
  get(e, t, r) {
    return typeof window < "u" && globalThis.location?.href?.includes("viewMode=docs") && Mt.warn(Ue`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `), Reflect.get(e, t, r);
  }
});
var {
  buildQueries: lRe,
  configure: cRe,
  createEvent: uRe,
  fireEvent: dRe,
  findAllByAltText: pRe,
  findAllByDisplayValue: fRe,
  findAllByLabelText: hRe,
  findAllByPlaceholderText: mRe,
  findAllByRole: yRe,
  findAllByTestId: gRe,
  findAllByText: bRe,
  findAllByTitle: vRe,
  findByAltText: wRe,
  findByDisplayValue: _Re,
  findByLabelText: ERe,
  findByPlaceholderText: xRe,
  findByRole: SRe,
  findByTestId: TRe,
  findByText: ARe,
  findByTitle: $Re,
  getAllByAltText: CRe,
  getAllByDisplayValue: kRe,
  getAllByLabelText: PRe,
  getAllByPlaceholderText: ORe,
  getAllByRole: RRe,
  getAllByTestId: jRe,
  getAllByText: IRe,
  getAllByTitle: NRe,
  getByAltText: MRe,
  getByDisplayValue: DRe,
  getByLabelText: qRe,
  getByPlaceholderText: LRe,
  getByRole: FRe,
  getByTestId: URe,
  getByText: BRe,
  getByTitle: HRe,
  getConfig: VRe,
  getDefaultNormalizer: zRe,
  getElementError: JRe,
  getNodeText: WRe,
  getQueriesForElement: GRe,
  getRoles: KRe,
  getSuggestedQuery: YRe,
  isInaccessible: XRe,
  logDOM: QRe,
  logRoles: ZRe,
  prettyDOM: eje,
  queries: tje,
  queryAllByAltText: rje,
  queryAllByAttribute: nje,
  queryAllByDisplayValue: oje,
  queryAllByLabelText: aje,
  queryAllByPlaceholderText: ije,
  queryAllByRole: sje,
  queryAllByTestId: lje,
  queryAllByText: cje,
  queryAllByTitle: uje,
  queryByAltText: dje,
  queryByAttribute: pje,
  queryByDisplayValue: fje,
  queryByLabelText: hje,
  queryByPlaceholderText: mje,
  queryByRole: yje,
  queryByTestId: gje,
  queryByText: bje,
  queryByTitle: vje,
  queryHelpers: wje,
  screen: _je,
  waitFor: Eje,
  waitForElementToBeRemoved: xje,
  within: xhe,
  prettyFormat: Sje
} = P_, She = R4, { userEvent: Tje } = _c(
  { userEvent: R4 },
  { intercept: !0, getKeys: /* @__PURE__ */ c((e) => Object.keys(e).filter((t) => t !== "eventWrapper"), "getKeys") }
), { expect: Aje } = _c(
  { expect: NU },
  {
    getKeys: /* @__PURE__ */ c((e, t) => {
      if ("constructor" in e && e.constructor === V) {
        const r = ["assert", "__methods", "__flags", "_obj"], n = Object.keys(Object.getPrototypeOf(e)).filter(
          (o) => !r.includes(o)
        );
        return t > 2 ? n : [...n, "not"];
      }
      return "any" in e ? Object.keys(e).filter((r) => r !== "any") : Object.keys(e);
    }, "getKeys"),
    mutate: !0,
    intercept: /* @__PURE__ */ c((e) => e !== "expect", "intercept")
  }
), The = W({
  "../node_modules/@ngard/tiny-isequal/index.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.isEqual = /* @__PURE__ */ (function() {
      var t = Object.prototype.toString, r = Object.getPrototypeOf, n = Object.getOwnPropertySymbols ? function(o) {
        return Object.keys(o).concat(Object.getOwnPropertySymbols(o));
      } : Object.keys;
      return function(o, a) {
        return (/* @__PURE__ */ c(function i(s, d, l) {
          var p, f, h, m = t.call(s), g = t.call(d);
          if (s === d) return !0;
          if (s == null || d == null) return !1;
          if (l.indexOf(s) > -1 && l.indexOf(d) > -1) return !0;
          if (l.push(s, d), m != g || (p = n(s), f = n(d), p.length != f.length || p.some(function(w) {
            return !i(s[w], d[w], l);
          }))) return !1;
          switch (m.slice(8, -1)) {
            case "Symbol":
              return s.valueOf() == d.valueOf();
            case "Date":
            case "Number":
              return +s == +d || +s != +s && +d != +d;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + s == "" + d;
            case "Set":
            case "Map":
              p = s.entries(), f = d.entries();
              do
                if (!i((h = p.next()).value, f.next().value, l)) return !1;
              while (!h.done);
              return !0;
            case "ArrayBuffer":
              s = new Uint8Array(s), d = new Uint8Array(d);
            case "DataView":
              s = new Uint8Array(s.buffer), d = new Uint8Array(d.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (s.length != d.length) return !1;
              for (h = 0; h < s.length; h++) if ((h in s || h in d) && (h in s != h in d || !i(s[h], d[h], l))) return !1;
              return !0;
            case "Object":
              return i(r(s), r(d), l);
            default:
              return !1;
          }
        }, "n"))(o, a, []);
      };
    })();
  }
});
function j4(e) {
  return e.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, o) => `${r} ${n}${o}`).replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`).replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`).replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`).replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`).replace(/ +/g, " ").trim();
}
c(j4, "toStartCaseStr");
var FO = or(The(), 1), I4 = /* @__PURE__ */ c((e) => e.map((t) => typeof t < "u").filter(Boolean).length, "count"), Ahe = /* @__PURE__ */ c((e, t) => {
  const { exists: r, eq: n, neq: o, truthy: a } = e;
  if (I4([r, n, o, a]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: o })}`);
  if (typeof n < "u")
    return (0, FO.isEqual)(t, n);
  if (typeof o < "u")
    return !(0, FO.isEqual)(t, o);
  if (typeof r < "u") {
    const i = typeof t < "u";
    return r ? i : !i;
  }
  return typeof a > "u" || a ? !!t : !t;
}, "testValue"), $he = /* @__PURE__ */ c((e, t, r) => {
  if (!e.if)
    return !0;
  const { arg: n, global: o } = e.if;
  if (I4([n, o]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: o })}`);
  const a = n ? t[n] : r[o];
  return Ahe(e.if, a);
}, "includeConditionalArg"), N4 = {};
Qd(N4, {
  argsEnhancers: () => Phe
});
var M4 = /* @__PURE__ */ c((e, t) => typeof t[e] > "u" && !(e in t), "isInInitialArgs"), Che = /* @__PURE__ */ c((e) => {
  const {
    initialArgs: t,
    argTypes: r,
    id: n,
    parameters: { actions: o }
  } = e;
  if (!o || o.disable || !o.argTypesRegex || !r)
    return {};
  const a = new RegExp(o.argTypesRegex);
  return Object.entries(r).filter(
    ([i]) => !!a.test(i)
  ).reduce((i, [s, d]) => (M4(s, t) && (i[s] = zm(s, { implicit: !0, id: n })), i), {});
}, "inferActionsFromArgTypesRegex"), khe = /* @__PURE__ */ c((e) => {
  const {
    initialArgs: t,
    argTypes: r,
    parameters: { actions: n }
  } = e;
  return n?.disable || !r ? {} : Object.entries(r).filter(([o, a]) => !!a.action).reduce((o, [a, i]) => (M4(a, t) && (o[a] = zm(typeof i.action == "string" ? i.action : a)), o), {});
}, "addActionsFromArgTypes"), Phe = [
  khe,
  Che
], D4 = {};
Qd(D4, {
  loaders: () => Rhe
});
var UO = !1, Ohe = /* @__PURE__ */ c((e) => {
  const { parameters: t } = e;
  t?.actions?.disable || UO || (DU((r, n) => {
    const o = r.getMockName();
    o !== "spy" && o !== "vi.fn()" && (!/^next\/.*::/.test(o) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((a) => o.startsWith(a))) && zm(o)(n);
  }), UO = !0);
}, "logActionsWhenMockCalled"), Rhe = [Ohe], BO = /* @__PURE__ */ c(() => ({
  ...N4,
  ...D4
}), "default"), { document: Nn } = globalThis, jhe = /* @__PURE__ */ c(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, "isReduceMotionEnabled"), HO = /* @__PURE__ */ c((e) => {
  (Array.isArray(e) ? e : [e]).forEach(Ihe);
}, "clearStyles"), Ihe = /* @__PURE__ */ c((e) => {
  if (!Nn)
    return;
  const t = Nn.getElementById(e);
  t && t.parentElement && t.parentElement.removeChild(t);
}, "clearStyle"), Nhe = /* @__PURE__ */ c((e, t) => {
  if (!Nn)
    return;
  const r = Nn.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    const n = Nn.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, Nn.head.appendChild(n);
  }
}, "addGridStyle"), Mhe = /* @__PURE__ */ c((e, t, r) => {
  if (!Nn)
    return;
  const n = Nn.getElementById(e);
  if (n)
    n.innerHTML !== t && (n.innerHTML = t);
  else {
    const o = Nn.createElement("style");
    o.setAttribute("id", e), o.innerHTML = t;
    const a = `addon-backgrounds-grid${r ? `-docs-${r}` : ""}`, i = Nn.getElementById(a);
    i ? i.parentElement?.insertBefore(o, i) : Nn.head.appendChild(o);
  }
}, "addBackgroundStyle"), Dhe = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
}, VO = "addon-backgrounds", zO = "addon-backgrounds-grid", qhe = jhe() ? "" : "transition: background-color 0.3s;", Lhe = /* @__PURE__ */ c((e, t) => {
  const { globals: r = {}, parameters: n = {}, viewMode: o, id: a } = t, {
    options: i = gse,
    disable: s,
    grid: d = Dhe
  } = n[Uf] || {}, l = r[Uf] || {}, p = typeof l == "string" ? l : l?.value, f = p ? i[p] : void 0, h = typeof f == "string" ? f : f?.value || "transparent", m = typeof l == "string" ? !1 : l.grid || !1, g = !!f && !s, w = o === "docs" ? `#anchor--${a} .docs-story` : ".sb-show-main", _ = o === "docs" ? `#anchor--${a} .docs-story` : ".sb-show-main", b = n.layout === void 0 || n.layout === "padded", x = o === "docs" ? 20 : b ? 16 : 0, { cellAmount: P, cellSize: R, opacity: N, offsetX: C = x, offsetY: A = x } = d, E = o === "docs" ? `${VO}-docs-${a}` : `${VO}-color`, T = o === "docs" ? a : null;
  ps(() => {
    const k = `
    ${w} {
      background: ${h} !important;
      ${qhe}
      }`;
    if (!g) {
      HO(E);
      return;
    }
    Mhe(E, k, T);
  }, [w, E, T, g, h]);
  const O = o === "docs" ? `${zO}-docs-${a}` : `${zO}`;
  return ps(() => {
    if (!m) {
      HO(O);
      return;
    }
    const k = [
      `${R * P}px ${R * P}px`,
      `${R * P}px ${R * P}px`,
      `${R}px ${R}px`,
      `${R}px ${R}px`
    ].join(", "), M = `
        ${_} {
          background-size: ${k} !important;
          background-position: ${C}px ${A}px, ${C}px ${A}px, ${C}px ${A}px, ${C}px ${A}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${N}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${N}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${N / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${N / 2}) 1px, transparent 1px) !important;
        }
      `;
    Nhe(O, M);
  }, [P, R, _, O, m, C, A, N]), e();
}, "withBackgroundAndGrid"), Fhe = globalThis.FEATURES?.backgrounds ? [Lhe] : [], Uhe = {
  [Uf]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: !1
  }
}, Bhe = {
  [Uf]: { value: void 0, grid: !1 }
}, JO = /* @__PURE__ */ c(() => ({
  decorators: Fhe,
  parameters: Uhe,
  initialGlobals: Bhe
}), "default"), { step: Hhe } = _c(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: /* @__PURE__ */ c(async (e, t, r) => t(r), "step")
  },
  { intercept: !0 }
), WO = /* @__PURE__ */ c(() => ({
  parameters: {
    throwPlayFunctionExceptions: !1
  },
  runStep: Hhe
}), "default"), GO = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
}, Vhe = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), Gt = /* @__PURE__ */ c((e, t = {}, r) => {
  const n = Vhe.includes(e) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e);
  return Object.entries(t).forEach(([o, a]) => {
    /[A-Z]/.test(o) ? (o === "onClick" && (n.addEventListener("click", a), n.addEventListener("keydown", (i) => {
      (i.key === "Enter" || i.key === " ") && (i.preventDefault(), a());
    })), o === "onMouseEnter" && n.addEventListener("mouseenter", a), o === "onMouseLeave" && n.addEventListener("mouseleave", a)) : n.setAttribute(o, a);
  }), r?.forEach((o) => {
    if (!(o == null || o === !1))
      try {
        n.appendChild(o);
      } catch {
        n.appendChild(document.createTextNode(String(o)));
      }
  }), n;
}, "createElement"), Hp = /* @__PURE__ */ c((e) => GO[e] && Gt(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  GO[e].map(
    (t) => Gt("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: t
    })
  )
), "createIcon"), zhe = /* @__PURE__ */ c((e) => {
  if ("elements" in e) {
    const { elements: n, color: o, style: a } = e;
    return {
      id: void 0,
      priority: 0,
      selectors: n,
      styles: {
        outline: `2px ${a} ${o}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  const { menu: t, ...r } = e;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...r,
    menu: Array.isArray(t) ? t.every(Array.isArray) ? t : [t] : void 0
  };
}, "normalizeOptions"), Jhe = /* @__PURE__ */ c((e) => e instanceof Function, "isFunction"), nu = /* @__PURE__ */ new Map(), Ci = /* @__PURE__ */ new Map(), Vp = /* @__PURE__ */ new Map(), Ro = /* @__PURE__ */ c((e) => {
  const t = Symbol();
  return Ci.set(t, []), nu.set(t, e), { get: /* @__PURE__ */ c(() => nu.get(t), "get"), set: /* @__PURE__ */ c((r) => {
    const n = nu.get(t), o = Jhe(r) ? r(n) : r;
    o !== n && (nu.set(t, o), Ci.get(t)?.forEach((a) => {
      Vp.get(a)?.(), Vp.set(a, a(o));
    }));
  }, "set"), subscribe: /* @__PURE__ */ c((r) => (Ci.get(t)?.push(r), () => {
    const n = Ci.get(t);
    n && Ci.set(
      t,
      n.filter((o) => o !== r)
    );
  }), "subscribe"), teardown: /* @__PURE__ */ c(() => {
    Ci.get(t)?.forEach((r) => {
      Vp.get(r)?.(), Vp.delete(r);
    }), Ci.delete(t), nu.delete(t);
  }, "teardown") };
}, "useStore"), KO = /* @__PURE__ */ c((e) => {
  const t = document.getElementById("storybook-root"), r = /* @__PURE__ */ new Map();
  for (const n of e) {
    const { priority: o = 0 } = n;
    for (const a of n.selectors) {
      const i = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${a}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...t?.querySelectorAll(a) || []
      ];
      for (const s of i) {
        const d = r.get(s);
        (!d || d.priority <= o) && r.set(s, {
          ...n,
          priority: o,
          selectors: Array.from(new Set((d?.selectors || []).concat(a)))
        });
      }
    }
  }
  return r;
}, "mapElements"), Whe = /* @__PURE__ */ c((e) => Array.from(e.entries()).map(([t, { selectors: r, styles: n, hoverStyles: o, focusStyles: a, menu: i }]) => {
  const { top: s, left: d, width: l, height: p } = t.getBoundingClientRect(), { position: f } = getComputedStyle(t);
  return {
    element: t,
    selectors: r,
    styles: n,
    hoverStyles: o,
    focusStyles: a,
    menu: i,
    top: f === "fixed" ? s : s + window.scrollY,
    left: f === "fixed" ? d : d + window.scrollX,
    width: l,
    height: p
  };
}).sort((t, r) => r.width * r.height - t.width * t.height), "mapBoxes"), YO = /* @__PURE__ */ c((e, t) => {
  const r = e.getBoundingClientRect(), { x: n, y: o } = t;
  return r?.top && r?.left && n >= r.left && n <= r.left + r.width && o >= r.top && o <= r.top + r.height;
}, "isOverMenu"), XO = /* @__PURE__ */ c((e, t, r) => {
  if (!t || !r)
    return !1;
  let { left: n, top: o, width: a, height: i } = e;
  i < Ea && (o = o - Math.round((Ea - i) / 2), i = Ea), a < Ea && (n = n - Math.round((Ea - a) / 2), a = Ea), t.style.position === "fixed" && (n += window.scrollX, o += window.scrollY);
  const { x: s, y: d } = r;
  return s >= n && s <= n + a && d >= o && d <= o + i;
}, "isTargeted"), Ghe = /* @__PURE__ */ c((e, t, r = {}) => {
  const { x: n, y: o } = t, { margin: a = 5, topOffset: i = 0, centered: s = !1 } = r, { scrollX: d, scrollY: l, innerHeight: p, innerWidth: f } = window, h = Math.min(
    e.style.position === "fixed" ? o - l : o,
    p - e.clientHeight - a - i + l
  ), m = s ? e.clientWidth / 2 : 0, g = e.style.position === "fixed" ? Math.max(Math.min(n - d, f - m - a), m + a) : Math.max(
    Math.min(n, f - m - a + d),
    m + a + d
  );
  Object.assign(e.style, {
    ...g !== n && { left: `${g}px` },
    ...h !== o && { top: `${h}px` }
  });
}, "keepInViewport"), QO = /* @__PURE__ */ c((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.showPopover();
}, "showPopover"), Khe = /* @__PURE__ */ c((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.hidePopover();
}, "hidePopover"), Yhe = /* @__PURE__ */ c((e) => ({
  top: e.top,
  left: e.left,
  width: e.width,
  height: e.height,
  selectors: e.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(e.element.attributes).map((t) => [t.name, t.value])
    ),
    localName: e.element.localName,
    tagName: e.element.tagName,
    outerHTML: e.element.outerHTML
  }
}), "getEventDetails"), ft = "storybook-highlights-menu", ZO = "storybook-highlights-root", Xhe = "storybook-root", Qhe = /* @__PURE__ */ c((e) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
  const { document: t } = globalThis, r = Ro([]), n = Ro(/* @__PURE__ */ new Map()), o = Ro([]), a = Ro(), i = Ro(), s = Ro([]), d = Ro([]), l = Ro(), p = Ro();
  let f = t.getElementById(ZO);
  r.subscribe(() => {
    f || (f = Gt("div", { id: ZO }), t.body.appendChild(f));
  }), r.subscribe((A) => {
    const E = t.getElementById(Xhe);
    if (!E)
      return;
    n.set(KO(A));
    const T = new MutationObserver(() => n.set(KO(A)));
    return T.observe(E, { subtree: !0, childList: !0 }), () => {
      T.disconnect();
    };
  }), n.subscribe((A) => {
    const E = /* @__PURE__ */ c(() => requestAnimationFrame(() => o.set(Whe(A))), "updateBoxes"), T = new ResizeObserver(E);
    T.observe(t.body), Array.from(A.keys()).forEach((k) => T.observe(k));
    const O = Array.from(t.body.querySelectorAll("*")).filter((k) => {
      const { overflow: M, overflowX: L, overflowY: $ } = window.getComputedStyle(k);
      return ["auto", "scroll"].some((I) => [M, L, $].includes(I));
    });
    return O.forEach((k) => k.addEventListener("scroll", E)), () => {
      T.disconnect(), O.forEach((k) => k.removeEventListener("scroll", E));
    };
  }), n.subscribe((A) => {
    const E = Array.from(A.keys()).filter(({ style: O }) => O.position === "sticky"), T = /* @__PURE__ */ c(() => requestAnimationFrame(() => {
      o.set(
        (O) => O.map((k) => {
          if (E.includes(k.element)) {
            const { top: M, left: L } = k.element.getBoundingClientRect();
            return { ...k, top: M + window.scrollY, left: L + window.scrollX };
          }
          return k;
        })
      );
    }), "updateBoxes");
    return t.addEventListener("scroll", T), () => t.removeEventListener("scroll", T);
  }), n.subscribe((A) => {
    s.set((E) => E.filter(({ element: T }) => A.has(T)));
  }), s.subscribe((A) => {
    A.length ? (p.set((E) => A.some((T) => T.element === E?.element) ? E : void 0), l.set((E) => A.some((T) => T.element === E?.element) ? E : void 0)) : (p.set(void 0), l.set(void 0), a.set(void 0));
  });
  const h = new Map(/* @__PURE__ */ new Map());
  r.subscribe((A) => {
    A.forEach(({ keyframes: E }) => {
      if (E) {
        let T = h.get(E);
        T || (T = t.createElement("style"), T.setAttribute("data-highlight", "keyframes"), h.set(E, T), t.head.appendChild(T)), T.innerHTML = E;
      }
    }), h.forEach((E, T) => {
      A.some((O) => O.keyframes === T) || (E.remove(), h.delete(T));
    });
  });
  const m = new Map(/* @__PURE__ */ new Map());
  o.subscribe((A) => {
    A.forEach((E) => {
      let T = m.get(E.element);
      if (f && !T) {
        const O = {
          popover: "manual",
          "data-highlight-dimensions": `w${E.width.toFixed(0)}h${E.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${E.left.toFixed(0)}y${E.top.toFixed(0)}`
        };
        T = f.appendChild(
          Gt("div", O, [Gt("div")])
        ), m.set(E.element, T);
      }
    }), m.forEach((E, T) => {
      A.some(({ element: O }) => O === T) || (E.remove(), m.delete(T));
    });
  }), o.subscribe((A) => {
    const E = A.filter((O) => O.menu);
    if (!E.length)
      return;
    const T = /* @__PURE__ */ c((O) => {
      requestAnimationFrame(() => {
        const k = t.getElementById(ft), M = { x: O.pageX, y: O.pageY };
        if (k && !YO(k, M)) {
          const L = E.filter(($) => {
            const I = m.get($.element);
            return XO($, I, M);
          });
          a.set(L.length ? M : void 0), s.set(L);
        }
      });
    }, "onClick");
    return t.addEventListener("click", T), () => t.removeEventListener("click", T);
  });
  const g = /* @__PURE__ */ c(() => {
    const A = t.getElementById(ft), E = i.get();
    !E || A && YO(A, E) || d.set((T) => {
      const O = o.get().filter(($) => {
        const I = m.get($.element);
        return XO($, I, E);
      }), k = T.filter(($) => O.includes($)), M = O.filter(($) => !T.includes($)), L = T.length - k.length;
      return M.length || L ? [...k, ...M] : T;
    });
  }, "updateHovered");
  i.subscribe(g), o.subscribe(g);
  const w = /* @__PURE__ */ c(() => {
    const A = p.get(), E = A ? [A] : s.get(), T = E.length === 1 ? E[0] : l.get(), O = a.get() !== void 0;
    o.get().forEach((k) => {
      const M = m.get(k.element);
      if (M) {
        const L = T === k, $ = O ? T ? L : E.includes(k) : d.get()?.includes(k);
        Object.assign(M.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...k.styles,
          ...$ ? k.hoverStyles : {},
          ...L ? k.focusStyles : {},
          position: getComputedStyle(k.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: DP - 10,
          top: `${k.top}px`,
          left: `${k.left}px`,
          width: `${k.width}px`,
          height: `${k.height}px`,
          margin: 0,
          padding: 0,
          cursor: k.menu && $ ? "pointer" : "default",
          pointerEvents: k.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(M.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${Ea}px`,
          minWidth: `${Ea}px`,
          boxSizing: "content-box",
          padding: M.style.outlineWidth || "0px"
        }), QO(M);
      }
    });
  }, "updateBoxStyles");
  o.subscribe(w), s.subscribe(w), d.subscribe(w), l.subscribe(w), p.subscribe(w);
  const _ = /* @__PURE__ */ c(() => {
    if (!f)
      return;
    let A = t.getElementById(ft);
    if (A)
      A.innerHTML = "";
    else {
      const k = { id: ft, popover: "manual" };
      A = f.appendChild(Gt("div", k)), f.appendChild(
        Gt("style", {}, [
          `
            #${ft} {
              position: absolute;
              z-index: ${DP};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${ft} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${ft} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${ft} li {
              padding: 0 4px;
              margin: 0;
            }
            #${ft} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${ft} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${ft} button:focus-visible {
              outline-color: #029CFD;
            }
            #${ft} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${ft} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${ft} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${ft} li > button:hover svg, #${ft} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${ft} .element-list li svg {
              display: none;
            }
            #${ft} li.selectable svg, #${ft} li.selected svg {
              display: block;
            }
            #${ft} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${ft} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${ft} .menu-items, #${ft} .menu-items li {
              padding: 0;
            }
            #${ft} .menu-item {
              display: flex;
            }
            #${ft} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    const E = p.get(), T = E ? [E] : s.get();
    if (T.length && (A.style.position = getComputedStyle(T[0].element).position === "fixed" ? "fixed" : "absolute", A.appendChild(
      Gt(
        "ul",
        { class: "element-list" },
        T.map((k) => {
          const M = T.length > 1 && !!k.menu?.some(
            (I) => I.some(
              (D) => !D.selectors || D.selectors.some((F) => k.selectors.includes(F))
            )
          ), L = M ? {
            class: "selectable",
            onClick: /* @__PURE__ */ c(() => p.set(k), "onClick"),
            onMouseEnter: /* @__PURE__ */ c(() => l.set(k), "onMouseEnter"),
            onMouseLeave: /* @__PURE__ */ c(() => l.set(void 0), "onMouseLeave")
          } : E ? { class: "selected", onClick: /* @__PURE__ */ c(() => p.set(void 0), "onClick") } : {}, $ = M || E;
          return Gt("li", L, [
            Gt($ ? "button" : "div", $ ? { type: "button" } : {}, [
              E ? Hp("chevronLeft") : null,
              Gt("code", {}, [k.element.outerHTML]),
              M ? Hp("chevronRight") : null
            ])
          ]);
        })
      )
    )), p.get() || s.get().length === 1) {
      const k = p.get() || s.get()[0], M = k.menu?.filter(
        (L) => L.some(
          ($) => !$.selectors || $.selectors.some((I) => k.selectors.includes(I))
        )
      );
      M?.length && A.appendChild(
        Gt(
          "ul",
          { class: "menu-list" },
          M.map(
            (L) => Gt("li", {}, [
              Gt(
                "ul",
                { class: "menu-items" },
                L.map(
                  ({ id: $, title: I, description: D, iconLeft: F, iconRight: J, clickEvent: oe }) => {
                    const ce = oe && (() => e.emit(oe, $, Yhe(k)));
                    return Gt("li", {}, [
                      Gt(
                        ce ? "button" : "div",
                        ce ? { class: "menu-item", type: "button", onClick: ce } : { class: "menu-item" },
                        [
                          F ? Hp(F) : null,
                          Gt("div", { class: "menu-item-content" }, [
                            Gt(D ? "strong" : "span", {}, [I]),
                            D && Gt("span", {}, [D])
                          ]),
                          J ? Hp(J) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    const O = a.get();
    O ? (Object.assign(A.style, {
      display: "block",
      left: `${A.style.position === "fixed" ? O.x - window.scrollX : O.x}px`,
      top: `${A.style.position === "fixed" ? O.y - window.scrollY : O.y}px`
    }), QO(A), requestAnimationFrame(() => Ghe(A, O, { topOffset: 15, centered: !0 }))) : (Khe(A), Object.assign(A.style, { display: "none" }));
  }, "renderMenu");
  s.subscribe(_), p.subscribe(_);
  const b = /* @__PURE__ */ c((A) => {
    const E = zhe(A);
    r.set((T) => {
      const O = E.id ? T.filter((k) => k.id !== E.id) : T;
      return E.selectors?.length ? [...O, E] : O;
    });
  }, "addHighlight"), x = /* @__PURE__ */ c((A) => {
    A && r.set((E) => E.filter((T) => T.id !== A));
  }, "removeHighlight"), P = /* @__PURE__ */ c(() => {
    r.set([]), n.set(/* @__PURE__ */ new Map()), o.set([]), a.set(void 0), i.set(void 0), s.set([]), d.set([]), l.set(void 0), p.set(void 0);
  }, "resetState");
  let R;
  const N = /* @__PURE__ */ c((A, E) => {
    const T = "scrollIntoView-highlight";
    clearTimeout(R), x(T);
    const O = t.querySelector(A);
    if (!O) {
      console.warn(`Cannot scroll into view: ${A} not found`);
      return;
    }
    O.scrollIntoView({ behavior: "smooth", block: "center", ...E });
    const k = `kf-${Math.random().toString(36).substring(2, 15)}`;
    r.set((M) => [
      ...M,
      {
        id: T,
        priority: 1e3,
        selectors: [A],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${k} 3s linear forwards`
        },
        keyframes: `@keyframes ${k} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), R = setTimeout(() => x(T), 3500);
  }, "scrollIntoView"), C = /* @__PURE__ */ c((A) => {
    requestAnimationFrame(() => i.set({ x: A.pageX, y: A.pageY }));
  }, "onMouseMove");
  t.body.addEventListener("mousemove", C), e.on(bse, b), e.on(vse, x), e.on(wse, P), e.on(_se, N), e.on(os, ({ newPhase: A }) => {
    A === "loading" && P();
  });
}, "useHighlights");
globalThis?.FEATURES?.highlight && Fn?.ready && Fn.ready().then(Qhe);
var eR = /* @__PURE__ */ c(() => ({}), "default");
function KT() {
  const e = Ee.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
c(KT, "getDocumentWidthAndHeight");
function q4() {
  const e = Ee.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  const t = e.getContext("2d");
  lo(t != null);
  const { width: r, height: n } = KT();
  return Th(e, t, { width: r, height: n }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "2147483647", e.style.pointerEvents = "none", Ee.document.body.appendChild(e), { canvas: e, context: t, width: r, height: n };
}
c(q4, "createCanvas");
function Th(e, t, { width: r, height: n }) {
  e.style.width = `${r}px`, e.style.height = `${n}px`;
  const o = Ee.window.devicePixelRatio;
  e.width = Math.floor(r * o), e.height = Math.floor(n * o), t.scale(o, o);
}
c(Th, "setCanvasWidthAndHeight");
var Xt = {};
function L4() {
  Xt.canvas || (Xt = q4());
}
c(L4, "init");
function YT() {
  Xt.context && Xt.context.clearRect(0, 0, Xt.width ?? 0, Xt.height ?? 0);
}
c(YT, "clear");
function F4(e) {
  YT(), e(Xt.context);
}
c(F4, "draw");
function U4() {
  lo(Xt.canvas), lo(Xt.context), Th(Xt.canvas, Xt.context, { width: 0, height: 0 });
  const { width: e, height: t } = KT();
  Th(Xt.canvas, Xt.context, { width: e, height: t }), Xt.width = e, Xt.height = t;
}
c(U4, "rescale");
function B4() {
  Xt.canvas && (YT(), Xt.canvas.parentNode?.removeChild(Xt.canvas), Xt = {});
}
c(B4, "destroy");
var Hs = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, Yo = 6;
function O_(e, { x: t, y: r, w: n, h: o, r: a }) {
  t = t - n / 2, r = r - o / 2, n < 2 * a && (a = n / 2), o < 2 * a && (a = o / 2), e.beginPath(), e.moveTo(t + a, r), e.arcTo(t + n, r, t + n, r + o, a), e.arcTo(t + n, r + o, t, r + o, a), e.arcTo(t, r + o, t, r, a), e.arcTo(t, r, t + n, r, a), e.closePath();
}
c(O_, "roundedRect");
function H4(e, { padding: t, border: r, width: n, height: o, top: a, left: i }) {
  const s = n - r.left - r.right - t.left - t.right, d = o - t.top - t.bottom - r.top - r.bottom;
  let l = i + r.left + t.left, p = a + r.top + t.top;
  return e === "top" ? l += s / 2 : e === "right" ? (l += s, p += d / 2) : e === "bottom" ? (l += s / 2, p += d) : e === "left" ? p += d / 2 : e === "center" && (l += s / 2, p += d / 2), { x: l, y: p };
}
c(H4, "positionCoordinate");
function V4(e, t, { margin: r, border: n, padding: o }, a, i) {
  let s = /* @__PURE__ */ c((h) => 0, "shift"), d = 0, l = 0;
  const p = i ? 1 : 0.5, f = i ? a * 2 : 0;
  return e === "padding" ? s = /* @__PURE__ */ c((h) => o[h] * p + f, "shift") : e === "border" ? s = /* @__PURE__ */ c((h) => o[h] + n[h] * p + f, "shift") : e === "margin" && (s = /* @__PURE__ */ c((h) => o[h] + n[h] + r[h] * p + f, "shift")), t === "top" ? l = -s("top") : t === "right" ? d = s("right") : t === "bottom" ? l = s("bottom") : t === "left" && (d = -s("left")), { offsetX: d, offsetY: l };
}
c(V4, "offset");
function z4(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
c(z4, "collide");
function J4(e, t, r) {
  return e === "top" ? t.y = r.y - r.h - Yo : e === "right" ? t.x = r.x + r.w / 2 + Yo + t.w / 2 : e === "bottom" ? t.y = r.y + r.h + Yo : e === "left" && (t.x = r.x - r.w / 2 - Yo - t.w / 2), { x: t.x, y: t.y };
}
c(J4, "overlapAdjustment");
function XT(e, t, { x: r, y: n, w: o, h: a }, i) {
  return O_(e, { x: r, y: n, w: o, h: a, r: 3 }), e.fillStyle = `${Hs[t]}dd`, e.fill(), e.strokeStyle = Hs[t], e.stroke(), e.fillStyle = Hs.text, e.fillText(i, r, n), O_(e, { x: r, y: n, w: o, h: a, r: 3 }), e.fillStyle = `${Hs[t]}dd`, e.fill(), e.strokeStyle = Hs[t], e.stroke(), e.fillStyle = Hs.text, e.fillText(i, r, n), { x: r, y: n, w: o, h: a };
}
c(XT, "textWithRect");
function QT(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  const r = e.measureText(t), n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent, o = r.width + Yo * 2, a = n + Yo * 2;
  return { w: o, h: a };
}
c(QT, "configureText");
function W4(e, t, { type: r, position: n = "center", text: o }, a, i = !1) {
  let { x: s, y: d } = H4(n, t);
  const { offsetX: l, offsetY: p } = V4(r, n, t, Yo + 1, i);
  s += l, d += p;
  const { w: f, h } = QT(e, o);
  if (a && z4({ x: s, y: d, w: f, h }, a)) {
    const m = J4(n, { x: s, y: d, w: f }, a);
    s = m.x, d = m.y;
  }
  return XT(e, r, { x: s, y: d, w: f, h }, o);
}
c(W4, "drawLabel");
function G4(e, { w: t, h: r }) {
  const n = t * 0.5 + Yo, o = r * 0.5 + Yo;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * n,
    offsetY: (e.y === "top" ? -1 : 1) * o
  };
}
c(G4, "floatingOffset");
function K4(e, t, { type: r, text: n }) {
  const { floatingAlignment: o, extremities: a } = t;
  let i = a[o.x], s = a[o.y];
  const { w: d, h: l } = QT(e, n), { offsetX: p, offsetY: f } = G4(o, {
    w: d,
    h: l
  });
  return i += p, s += f, XT(e, r, { x: i, y: s, w: d, h: l }, n);
}
c(K4, "drawFloatingLabel");
function Ys(e, t, r, n) {
  const o = [];
  r.forEach((a, i) => {
    const s = n && a.position === "center" ? K4(e, t, a) : W4(e, t, a, o[i - 1], n);
    o[i] = s;
  });
}
c(Ys, "drawStack");
function Y4(e, t, r, n) {
  const o = r.reduce((a, i) => (Object.prototype.hasOwnProperty.call(a, i.position) || (a[i.position] = []), a[i.position]?.push(i), a), {});
  o.top && Ys(e, t, o.top, n), o.right && Ys(e, t, o.right, n), o.bottom && Ys(e, t, o.bottom, n), o.left && Ys(e, t, o.left, n), o.center && Ys(e, t, o.center, n);
}
c(Y4, "labelStacks");
var rg = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, tR = 30;
function Lr(e) {
  return parseInt(e.replace("px", ""), 10);
}
c(Lr, "pxToNumber");
function Fi(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
c(Fi, "round");
function ng(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
c(ng, "filterZeroValues");
function X4(e) {
  const t = {
    top: Ee.window.scrollY,
    bottom: Ee.window.scrollY + Ee.window.innerHeight,
    left: Ee.window.scrollX,
    right: Ee.window.scrollX + Ee.window.innerWidth
  }, r = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: r.left > r.right ? "left" : "right",
    y: r.top > r.bottom ? "top" : "bottom"
  };
}
c(X4, "floatingAlignment");
function Q4(e) {
  const t = Ee.getComputedStyle(e);
  let { top: r, left: n, right: o, bottom: a, width: i, height: s } = e.getBoundingClientRect();
  const {
    marginTop: d,
    marginBottom: l,
    marginLeft: p,
    marginRight: f,
    paddingTop: h,
    paddingBottom: m,
    paddingLeft: g,
    paddingRight: w,
    borderBottomWidth: _,
    borderTopWidth: b,
    borderLeftWidth: x,
    borderRightWidth: P
  } = t;
  r = r + Ee.window.scrollY, n = n + Ee.window.scrollX, a = a + Ee.window.scrollY, o = o + Ee.window.scrollX;
  const R = {
    top: Lr(d),
    bottom: Lr(l),
    left: Lr(p),
    right: Lr(f)
  }, N = {
    top: Lr(h),
    bottom: Lr(m),
    left: Lr(g),
    right: Lr(w)
  }, C = {
    top: Lr(b),
    bottom: Lr(_),
    left: Lr(x),
    right: Lr(P)
  }, A = {
    top: r - R.top,
    bottom: a + R.bottom,
    left: n - R.left,
    right: o + R.right
  };
  return {
    margin: R,
    padding: N,
    border: C,
    top: r,
    left: n,
    bottom: a,
    right: o,
    width: i,
    height: s,
    extremities: A,
    floatingAlignment: X4(A)
  };
}
c(Q4, "measureElement");
function Z4(e, { margin: t, width: r, height: n, top: o, left: a, bottom: i, right: s }) {
  const d = n + t.bottom + t.top;
  e.fillStyle = rg.margin, e.fillRect(a, o - t.top, r, t.top), e.fillRect(s, o - t.top, t.right, d), e.fillRect(a, i, r, t.bottom), e.fillRect(a - t.left, o - t.top, t.left, d);
  const l = [
    {
      type: "margin",
      text: Fi(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: Fi(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: Fi(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: Fi(t.left),
      position: "left"
    }
  ];
  return ng(l);
}
c(Z4, "drawMargin");
function ez(e, { padding: t, border: r, width: n, height: o, top: a, left: i, bottom: s, right: d }) {
  const l = n - r.left - r.right, p = o - t.top - t.bottom - r.top - r.bottom;
  e.fillStyle = rg.padding, e.fillRect(i + r.left, a + r.top, l, t.top), e.fillRect(
    d - t.right - r.right,
    a + t.top + r.top,
    t.right,
    p
  ), e.fillRect(
    i + r.left,
    s - t.bottom - r.bottom,
    l,
    t.bottom
  ), e.fillRect(i + r.left, a + t.top + r.top, t.left, p);
  const f = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return ng(f);
}
c(ez, "drawPadding");
function tz(e, { border: t, width: r, height: n, top: o, left: a, bottom: i, right: s }) {
  const d = n - t.top - t.bottom;
  e.fillStyle = rg.border, e.fillRect(a, o, r, t.top), e.fillRect(a, i - t.bottom, r, t.bottom), e.fillRect(a, o + t.top, t.left, d), e.fillRect(s - t.right, o + t.top, t.right, d);
  const l = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return ng(l);
}
c(tz, "drawBorder");
function rz(e, { padding: t, border: r, width: n, height: o, top: a, left: i }) {
  const s = n - r.left - r.right - t.left - t.right, d = o - t.top - t.bottom - r.top - r.bottom;
  return e.fillStyle = rg.content, e.fillRect(
    i + r.left + t.left,
    a + r.top + t.top,
    s,
    d
  ), [
    {
      type: "content",
      position: "center",
      text: `${Fi(s)} x ${Fi(d)}`
    }
  ];
}
c(rz, "drawContent");
function nz(e) {
  return (t) => {
    if (e && t) {
      const r = Q4(e), n = Z4(t, r), o = ez(t, r), a = tz(t, r), i = rz(t, r), s = r.width <= tR * 3 || r.height <= tR;
      Y4(
        t,
        r,
        [...i, ...o, ...a, ...n],
        s
      );
    }
  };
}
c(nz, "drawBoxModel");
function oz(e) {
  F4(nz(e));
}
c(oz, "drawSelectedElement");
var Zhe = /* @__PURE__ */ c((e, t) => {
  const r = Ee.document.elementFromPoint(e, t), n = /* @__PURE__ */ c((o) => {
    if (o && o.shadowRoot) {
      const a = o.shadowRoot.elementFromPoint(e, t);
      return o.isEqualNode(a) ? o : a.shadowRoot ? n(a) : a;
    }
    return o;
  }, "crawlShadows");
  return n(r) || r;
}, "deepElementFromPoint"), rR, zp = { x: 0, y: 0 };
function R_(e, t) {
  rR = Zhe(e, t), oz(rR);
}
c(R_, "findAndDrawElement");
var eme = /* @__PURE__ */ c((e, t) => {
  const { measureEnabled: r } = t.globals || {};
  return ps(() => {
    if (typeof globalThis.document > "u")
      return;
    const n = /* @__PURE__ */ c((o) => {
      window.requestAnimationFrame(() => {
        o.stopPropagation(), zp.x = o.clientX, zp.y = o.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", n), () => {
      globalThis.document.removeEventListener("pointermove", n);
    };
  }, []), ps(() => {
    const n = /* @__PURE__ */ c((a) => {
      window.requestAnimationFrame(() => {
        a.stopPropagation(), R_(a.clientX, a.clientY);
      });
    }, "onPointerOver"), o = /* @__PURE__ */ c(() => {
      window.requestAnimationFrame(() => {
        U4();
      });
    }, "onResize");
    return t.viewMode === "story" && r && (globalThis.document.addEventListener("pointerover", n), L4(), globalThis.window.addEventListener("resize", o), R_(zp.x, zp.y)), () => {
      globalThis.window.removeEventListener("resize", o), B4();
    };
  }, [r, t.viewMode]), e();
}, "withMeasure"), tme = globalThis.FEATURES?.measure ? [eme] : [], rme = {
  [yse]: !1
}, nR = /* @__PURE__ */ c(() => ({
  decorators: tme,
  initialGlobals: rme
}), "default"), oR = /* @__PURE__ */ c((e) => {
  (Array.isArray(e) ? e : [e]).forEach(nme);
}, "clearStyles"), nme = /* @__PURE__ */ c((e) => {
  const t = typeof e == "string" ? e : e.join(""), r = Ee.document.getElementById(t);
  r && r.parentElement && r.parentElement.removeChild(r);
}, "clearStyle"), ome = /* @__PURE__ */ c((e, t) => {
  const r = Ee.document.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    const n = Ee.document.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, Ee.document.head.appendChild(n);
  }
}, "addOutlineStyles");
function az(e) {
  return Ue`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
c(az, "outlineCSS");
var ame = /* @__PURE__ */ c((e, t) => {
  const r = t.globals || {}, n = [!0, "true"].includes(r[gL]), o = t.viewMode === "docs", a = gz(() => az(o ? '[data-story-block="true"]' : ".sb-show-main"), [t]);
  return ps(() => {
    const i = o ? `addon-outline-docs-${t.id}` : "addon-outline";
    return n ? ome(i, a) : oR(i), () => {
      oR(i);
    };
  }, [n, a, t]), e();
}, "withOutline"), ime = globalThis.FEATURES?.outline ? [ame] : [], sme = {
  [gL]: !1
}, aR = /* @__PURE__ */ c(() => ({ decorators: ime, initialGlobals: sme }), "default"), lme = /* @__PURE__ */ c(({ parameters: e }) => {
  e?.test?.mockReset === !0 ? UU() : e?.test?.clearMocks === !0 ? FU() : e?.test?.restoreMocks !== !1 && BU();
}, "resetAllMocksLoader"), j_ = /* @__PURE__ */ c((e, t = 0, r) => {
  if (t > 5 || e == null)
    return e;
  if (vl(e))
    return r && e.mockName(r), e;
  if (typeof e == "function" && "isAction" in e && e.isAction && !("implicit" in e && e.implicit)) {
    const n = qU(e);
    return r && n.mockName(r), n;
  }
  if (Array.isArray(e)) {
    t++;
    for (let n = 0; n < e.length; n++)
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = j_(e[n], t));
    return e;
  }
  if (typeof e == "object" && e.constructor === Object) {
    t++;
    for (const [n, o] of Object.entries(e))
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = j_(o, t, n));
    return e;
  }
  return e;
}, "traverseArgs"), cme = /* @__PURE__ */ c(({ initialArgs: e }) => {
  j_(e);
}, "nameSpiesAndWrapActionsInSpies"), iR = !1, ume = /* @__PURE__ */ c(async (e) => {
  globalThis.HTMLElement && e.canvasElement instanceof globalThis.HTMLElement && (e.canvas = xhe(e.canvasElement));
  const t = globalThis.window?.navigator?.clipboard;
  if (t && (e.userEvent = _c(
    { userEvent: She.setup() },
    {
      intercept: !0,
      getKeys: /* @__PURE__ */ c((r) => Object.keys(r).filter((n) => n !== "eventWrapper"), "getKeys")
    }
  ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
    get: /* @__PURE__ */ c(() => t, "get"),
    configurable: !0
  }), !iR)) {
    const r = HTMLElement.prototype.focus;
    let n = HTMLElement.prototype.focus;
    const o = /* @__PURE__ */ new Set();
    Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: !0,
        set: /* @__PURE__ */ c((a) => {
          n = a;
        }, "set"),
        get() {
          return o.has(this) ? r : (o.add(this), setTimeout(() => o.delete(this), 0), n);
        }
      }
    }), iR = !0;
  }
}, "enhanceContext"), sR = /* @__PURE__ */ c(() => ({
  loaders: [lme, cme, ume]
}), "default"), dme = {
  [$se]: { value: void 0, isRotated: !1 }
}, lR = /* @__PURE__ */ c(() => ({
  initialGlobals: dme
}), "default");
function og() {
  return [
    // @ts-expect-error CJS fallback
    (nR.default ?? nR)(),
    // @ts-expect-error CJS fallback
    (JO.default ?? JO)(),
    // @ts-expect-error CJS fallback
    (eR.default ?? eR)(),
    // @ts-expect-error CJS fallback
    (aR.default ?? aR)(),
    // @ts-expect-error CJS fallback
    (lR.default ?? lR)(),
    // @ts-expect-error CJS fallback
    (BO.default ?? BO)(),
    // @ts-expect-error CJS fallback
    (WO.default ?? WO)(),
    // @ts-expect-error CJS fallback
    (sR.default ?? sR)()
  ];
}
c(og, "getCoreAnnotations");
function pme(e) {
  let t;
  const r = {
    _tag: "Preview",
    input: e,
    get composed() {
      if (t)
        return t;
      const { addons: n, ...o } = e;
      return t = Ad(
        fs([...og(), ...n ?? [], o])
      ), t;
    },
    meta(n) {
      return sz(n, this);
    }
  };
  return globalThis.globalProjectAnnotations = r.composed, r;
}
c(pme, "definePreview");
function fme(e) {
  return e;
}
c(fme, "definePreviewAddon");
function hme(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Preview";
}
c(hme, "isPreview");
function iz(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Meta";
}
c(iz, "isMeta");
function sz(e, t) {
  return {
    _tag: "Meta",
    input: e,
    preview: t,
    // @ts-expect-error hard
    story(r = {}) {
      return ZT(typeof r == "function" ? { render: r } : r, this);
    }
  };
}
c(sz, "defineMeta");
function ag(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Story";
}
c(ag, "isStory");
function ZT(e, t) {
  let r;
  const n = /* @__PURE__ */ c(() => (r || (r = sA(
    e,
    t.input,
    void 0,
    t.preview.composed
  )), r), "compose"), o = [];
  return {
    _tag: "Story",
    input: e,
    meta: t,
    // @ts-expect-error this is a private property used only once in renderers/react/src/preview
    __compose: n,
    __children: o,
    get composed() {
      const a = n(), { args: i, argTypes: s, parameters: d, id: l, tags: p, globals: f, storyName: h } = a;
      return { args: i, argTypes: s, parameters: d, id: l, tags: p, name: h, globals: f };
    },
    get play() {
      return e.play ?? t.input?.play ?? (async () => {
      });
    },
    async run(a) {
      await n().run(a);
    },
    test(a, i, s) {
      const d = typeof i != "function" ? i : {}, l = typeof i != "function" ? s : i, p = Ph(this.play) || Ph(l) ? async ({ context: h }) => {
        await this.play?.(h), await l(h);
      } : async (h) => {
        await this.play?.(h), await l(h);
      }, f = this.extend({
        ...d,
        name: a,
        tags: ["test-fn", "!autodocs", ...d.tags ?? []],
        play: p
      });
      return o.push(f), f;
    },
    extend(a) {
      return ZT(
        {
          ...this.input,
          ...a,
          args: { ...this.input.args || {}, ...a.args },
          argTypes: Ba(this.input.argTypes, a.argTypes),
          afterEach: [
            ...Ke(this.input?.afterEach ?? []),
            ...Ke(a.afterEach ?? [])
          ],
          beforeEach: [
            ...Ke(this.input?.beforeEach ?? []),
            ...Ke(a.beforeEach ?? [])
          ],
          decorators: [
            ...Ke(this.input?.decorators ?? []),
            ...Ke(a.decorators ?? [])
          ],
          globals: { ...this.input.globals, ...a.globals },
          loaders: [
            ...Ke(this.input?.loaders ?? []),
            ...Ke(a.loaders ?? [])
          ],
          parameters: Ba(this.input.parameters, a.parameters),
          tags: uz(...this.input.tags ?? [], ...a.tags ?? [])
        },
        this.meta
      );
    }
  };
}
c(ZT, "defineStory");
function lz(e) {
  return "__children" in e ? e.__children : [];
}
c(lz, "getStoryChildren");
var cz = /* @__PURE__ */ c((e) => e.toLowerCase().replace(/[ â€™â€“â€”â€•â€²Â¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), "sanitize"), I_ = /* @__PURE__ */ c((e, t) => {
  const r = cz(e);
  if (r === "")
    throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
  return r;
}, "sanitizeSafe"), mme = /* @__PURE__ */ c((e, t) => `${I_(e, "kind")}${t ? `--${I_(t, "name")}` : ""}`, "toId"), yme = /* @__PURE__ */ c((e, t) => `${e}:${I_(t, "test")}`, "toTestId"), gme = /* @__PURE__ */ c((e) => j4(e), "storyNameFromExport");
function N_(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
c(N_, "matches");
function Ah(e, { includeStories: t, excludeStories: r }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    e !== "__esModule" && (!t || N_(e, t)) && (!r || !N_(e, r))
  );
}
c(Ah, "isExportStory");
var uz = /* @__PURE__ */ c((...e) => {
  const t = e.reduce((r, n) => (n.startsWith("!") ? r.delete(n.slice(1)) : r.add(n), r), /* @__PURE__ */ new Set());
  return Array.from(t);
}, "combineTags");
function dz() {
  const e = {
    setHandler: /* @__PURE__ */ c(() => {
    }, "setHandler"),
    send: /* @__PURE__ */ c(() => {
    }, "send")
  };
  return new hL({ transport: e });
}
c(dz, "mockChannel");
var pz = class {
  constructor() {
    this.getChannel = /* @__PURE__ */ c(() => {
      if (!this.channel) {
        const t = dz();
        return this.setChannel(t), t;
      }
      return this.channel;
    }, "getChannel"), this.ready = /* @__PURE__ */ c(() => this.promise, "ready"), this.hasChannel = /* @__PURE__ */ c(() => !!this.channel, "hasChannel"), this.setChannel = /* @__PURE__ */ c((t) => {
      this.channel = t, this.resolve();
    }, "setChannel"), this.promise = new Promise((t) => {
      this.resolve = () => t(this.getChannel());
    });
  }
};
c(pz, "AddonStore");
var bme = pz, dv = "__STORYBOOK_ADDONS_PREVIEW";
function fz() {
  return Ee[dv] || (Ee[dv] = new bme()), Ee[dv];
}
c(fz, "getAddonsStore");
var Fn = fz(), hz = class {
  constructor() {
    this.hookListsMap = void 0, this.mountedDecorators = void 0, this.prevMountedDecorators = void 0, this.currentHooks = void 0, this.nextHookIndex = void 0, this.currentPhase = void 0, this.currentEffects = void 0, this.prevEffects = void 0, this.currentDecoratorName = void 0, this.hasUpdates = void 0, this.currentContext = void 0, this.renderListener = /* @__PURE__ */ c((t) => {
      t === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener"), this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((t) => {
      t.destroy && t.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    const t = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, t;
  }
  triggerEffects() {
    this.prevEffects.forEach((t) => {
      !this.currentEffects.includes(t) && t.destroy && t.destroy();
    }), this.currentEffects.forEach((t) => {
      this.prevEffects.includes(t) || (t.destroy = t.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), Fn.getChannel().on(Ff, this.renderListener);
  }
  removeRenderListeners() {
    Fn.getChannel().removeListener(Ff, this.renderListener);
  }
};
c(hz, "HooksContext");
var mz = hz;
function M_(e) {
  const t = /* @__PURE__ */ c((...r) => {
    const { hooks: n } = typeof r[0] == "function" ? r[1] : r[0], o = n.currentPhase, a = n.currentHooks, i = n.nextHookIndex, s = n.currentDecoratorName;
    n.currentDecoratorName = e.name, n.prevMountedDecorators.has(e) ? (n.currentPhase = "UPDATE", n.currentHooks = n.hookListsMap.get(e) || []) : (n.currentPhase = "MOUNT", n.currentHooks = [], n.hookListsMap.set(e, n.currentHooks), n.prevMountedDecorators.add(e)), n.nextHookIndex = 0;
    const d = Ee.STORYBOOK_HOOKS_CONTEXT;
    Ee.STORYBOOK_HOOKS_CONTEXT = n;
    const l = e(...r);
    if (Ee.STORYBOOK_HOOKS_CONTEXT = d, n.currentPhase === "UPDATE" && n.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return n.currentPhase = o, n.currentHooks = a, n.nextHookIndex = i, n.currentDecoratorName = s, l;
  }, "hookified");
  return t.originalFn = e, t;
}
c(M_, "hookify");
var pv = 0, vme = 25, wme = /* @__PURE__ */ c((e) => (t, r) => {
  const n = e(
    M_(t),
    r.map((o) => M_(o))
  );
  return (o) => {
    const { hooks: a } = o;
    a.prevMountedDecorators ??= /* @__PURE__ */ new Set(), a.mountedDecorators = /* @__PURE__ */ new Set([t, ...r]), a.currentContext = o, a.hasUpdates = !1;
    let i = n(o);
    for (pv = 1; a.hasUpdates; )
      if (a.hasUpdates = !1, a.currentEffects = [], i = n(o), pv += 1, pv > vme)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return a.addRenderListeners(), i;
  };
}, "applyHooks"), _me = /* @__PURE__ */ c((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), "areDepsEqual"), eA = /* @__PURE__ */ c(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
function tA() {
  return Ee.STORYBOOK_HOOKS_CONTEXT || null;
}
c(tA, "getHooksContextOrNull");
function ig() {
  const e = tA();
  if (e == null)
    throw eA();
  return e;
}
c(ig, "getHooksContextOrThrow");
function yz(e, t, r) {
  const n = ig();
  if (n.currentPhase === "MOUNT") {
    r != null && !Array.isArray(r) && vt.warn(
      `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`
    );
    const o = { name: e, deps: r };
    return n.currentHooks.push(o), t(o), o;
  }
  if (n.currentPhase === "UPDATE") {
    const o = n.getNextHook();
    if (o == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return o.name !== e && vt.warn(
      `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), r != null && o.deps == null && vt.warn(
      `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), r != null && o.deps != null && r.length !== o.deps.length && vt.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`), (r == null || o.deps == null || !_me(r, o.deps)) && (t(o), o.deps = r), o;
  }
  throw eA();
}
c(yz, "useHook");
function bp(e, t, r) {
  const { memoizedState: n } = yz(
    e,
    (o) => {
      o.memoizedState = t();
    },
    r
  );
  return n;
}
c(bp, "useMemoLike");
function gz(e, t) {
  return bp("useMemo", e, t);
}
c(gz, "useMemo");
function Td(e, t) {
  return bp("useCallback", () => e, t);
}
c(Td, "useCallback");
function rA(e, t) {
  return bp(e, () => ({ current: t }), []);
}
c(rA, "useRefLike");
function Eme(e) {
  return rA("useRef", e);
}
c(Eme, "useRef");
function bz() {
  const e = tA();
  if (e != null && e.currentPhase !== "NONE")
    e.hasUpdates = !0;
  else
    try {
      Fn.getChannel().emit(NE);
    } catch {
      vt.warn("State updates of Storybook preview hooks work only in browser");
    }
}
c(bz, "triggerUpdate");
function nA(e, t) {
  const r = rA(
    e,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof t == "function" ? t() : t
  ), n = /* @__PURE__ */ c((o) => {
    r.current = typeof o == "function" ? o(r.current) : o, bz();
  }, "setState");
  return [r.current, n];
}
c(nA, "useStateLike");
function xme(e) {
  return nA("useState", e);
}
c(xme, "useState");
function Sme(e, t, r) {
  const n = r != null ? () => r(t) : t, [o, a] = nA("useReducer", n);
  return [o, /* @__PURE__ */ c((i) => a((s) => e(s, i)), "dispatch")];
}
c(Sme, "useReducer");
function ps(e, t) {
  const r = ig(), n = bp("useEffect", () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
c(ps, "useEffect");
function Tme(e, t = []) {
  const r = Fn.getChannel();
  return ps(() => (Object.entries(e).forEach(([n, o]) => r.on(n, o)), () => {
    Object.entries(e).forEach(
      ([n, o]) => r.removeListener(n, o)
    );
  }), [...Object.keys(e), ...t]), Td(r.emit.bind(r), [r]);
}
c(Tme, "useChannel");
function sg() {
  const { currentContext: e } = ig();
  if (e == null)
    throw eA();
  return e;
}
c(sg, "useStoryContext");
function Ame(e, t) {
  const { parameters: r } = sg();
  if (e)
    return r[e] ?? t;
}
c(Ame, "useParameter");
function $me() {
  const e = Fn.getChannel(), { id: t, args: r } = sg(), n = Td(
    (a) => e.emit(LE, { storyId: t, updatedArgs: a }),
    [e, t]
  ), o = Td(
    (a) => e.emit(ME, { storyId: t, argNames: a }),
    [e, t]
  );
  return [r, n, o];
}
c($me, "useArgs");
function Cme() {
  const e = Fn.getChannel(), { globals: t } = sg(), r = Td(
    (n) => e.emit(qE, { globals: n }),
    [e]
  );
  return [t, r];
}
c(Cme, "useGlobals");
var kme = /* @__PURE__ */ c(({
  name: e,
  parameterName: t,
  wrapper: r,
  skipIfNoParametersOrOptions: n = !1
}) => {
  const o = /* @__PURE__ */ c((a) => (i, s) => {
    const d = s.parameters && s.parameters[t];
    return d && d.disable || n && !a && !d ? i(s) : r(i, s, {
      options: a,
      parameters: d
    });
  }, "decorator");
  return (...a) => typeof a[0] == "function" ? o()(...a) : (...i) => {
    if (i.length > 1)
      return a.length > 1 ? o(a)(...i) : o(...a)(...i);
    throw new Error(
      `Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`
    );
  };
}, "makeDecorator"), fv = or(LD(), 1), Ri = Symbol("incompatible"), D_ = /* @__PURE__ */ c((e, t) => {
  const r = t.type;
  if (e == null || !r || t.mapping)
    return e;
  switch (r.name) {
    case "string":
      return String(e);
    case "enum":
      return e;
    case "number":
      return Number(e);
    case "boolean":
      return String(e) === "true";
    case "array":
      return !r.value || !Array.isArray(e) ? Ri : e.reduce((n, o, a) => {
        const i = D_(o, { type: r.value });
        return i !== Ri && (n[a] = i), n;
      }, new Array(e.length));
    case "object":
      return typeof e == "string" || typeof e == "number" ? e : !r.value || typeof e != "object" ? Ri : Object.entries(e).reduce((n, [o, a]) => {
        const i = D_(a, { type: r.value[o] });
        return i === Ri ? n : Object.assign(n, { [o]: i });
      }, {});
    case "other": {
      const n = typeof e == "string" || typeof e == "number" || typeof e == "boolean";
      return r.value === "ReactNode" && n ? e : Ri;
    }
    default:
      return Ri;
  }
}, "map"), Pme = /* @__PURE__ */ c((e, t) => Object.entries(e).reduce((r, [n, o]) => {
  if (!t[n])
    return r;
  const a = D_(o, t[n]);
  return a === Ri ? r : Object.assign(r, { [n]: a });
}, {}), "mapArgsToTypes"), q_ = /* @__PURE__ */ c((e, t) => Array.isArray(e) && Array.isArray(t) ? t.reduce(
  (r, n, o) => (r[o] = q_(e[o], t[o]), r),
  [...e]
).filter((r) => r !== void 0) : !Kr(e) || !Kr(t) ? t : Object.keys({ ...e, ...t }).reduce((r, n) => {
  if (n in t) {
    const o = q_(e[n], t[n]);
    o !== void 0 && (r[n] = o);
  } else
    r[n] = e[n];
  return r;
}, {}), "combineArgs"), Ome = /* @__PURE__ */ c((e, t) => Object.entries(t).reduce((r, [n, { options: o }]) => {
  function a() {
    return n in e && (r[n] = e[n]), r;
  }
  if (c(a, "allowArg"), !o)
    return a();
  if (!Array.isArray(o))
    return Mt.error(Ue`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), a();
  if (o.some((f) => f && ["object", "function"].includes(typeof f)))
    return Mt.error(Ue`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), a();
  const i = Array.isArray(e[n]), s = i && e[n].findIndex((f) => !o.includes(f)), d = i && s === -1;
  if (e[n] === void 0 || o.includes(e[n]) || d)
    return a();
  const l = i ? `${n}[${s}]` : n, p = o.map((f) => typeof f == "string" ? `'${f}'` : String(f)).join(", ");
  return Mt.warn(`Received illegal value for '${l}'. Supported options: ${p}`), r;
}, {}), "validateOptions"), Uu = Symbol("Deeply equal"), $h = /* @__PURE__ */ c((e, t) => {
  if (typeof e != typeof t)
    return t;
  if (MD(e, t))
    return Uu;
  if (Array.isArray(e) && Array.isArray(t)) {
    const r = t.reduce((n, o, a) => {
      const i = $h(e[a], o);
      return i !== Uu && (n[a] = i), n;
    }, new Array(t.length));
    return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
  }
  return Kr(e) && Kr(t) ? Object.keys({ ...e, ...t }).reduce((r, n) => {
    const o = $h(e?.[n], t?.[n]);
    return o === Uu ? r : Object.assign(r, { [n]: o });
  }, {}) : t;
}, "deepDiff"), vz = "UNTARGETED";
function wz({
  args: e,
  argTypes: t
}) {
  const r = {};
  return Object.entries(e).forEach(([n, o]) => {
    const { target: a = vz } = t[n] || {};
    r[a] = r[a] || {}, r[a][n] = o;
  }), r;
}
c(wz, "groupArgsByTarget");
function _z(e) {
  return Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e;
}
c(_z, "deleteUndefined");
var Ez = class {
  constructor() {
    this.initialArgsByStoryId = {}, this.argsByStoryId = {};
  }
  get(t) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    return this.argsByStoryId[t];
  }
  setInitial(t) {
    if (!this.initialArgsByStoryId[t.id])
      this.initialArgsByStoryId[t.id] = t.initialArgs, this.argsByStoryId[t.id] = t.initialArgs;
    else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
      const r = $h(this.initialArgsByStoryId[t.id], this.argsByStoryId[t.id]);
      this.initialArgsByStoryId[t.id] = t.initialArgs, this.argsByStoryId[t.id] = t.initialArgs, r !== Uu && this.updateFromDelta(t, r);
    }
  }
  updateFromDelta(t, r) {
    const n = Ome(r, t.argTypes);
    this.argsByStoryId[t.id] = q_(this.argsByStoryId[t.id], n);
  }
  updateFromPersisted(t, r) {
    const n = Pme(r, t.argTypes);
    return this.updateFromDelta(t, n);
  }
  update(t, r) {
    if (!(t in this.argsByStoryId))
      throw new Error(`No args known for ${t} -- has it been rendered yet?`);
    this.argsByStoryId[t] = _z({
      ...this.argsByStoryId[t],
      ...r
    });
  }
};
c(Ez, "ArgsStore");
var Rme = Ez, xz = /* @__PURE__ */ c((e = {}) => Object.entries(e).reduce((t, [r, { defaultValue: n }]) => (typeof n < "u" && (t[r] = n), t), {}), "getValuesFromArgTypes"), Sz = class {
  constructor({
    globals: t = {},
    globalTypes: r = {}
  }) {
    this.set({ globals: t, globalTypes: r });
  }
  set({ globals: t = {}, globalTypes: r = {} }) {
    const n = this.initialGlobals && $h(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(t), ...Object.keys(r)]);
    const o = xz(r);
    this.initialGlobals = { ...o, ...t }, this.globals = this.initialGlobals, n && n !== Uu && this.updateFromPersisted(n);
  }
  filterAllowedGlobals(t) {
    return Object.entries(t).reduce((r, [n, o]) => (this.allowedGlobalNames.has(n) ? r[n] = o : vt.warn(
      `Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`
    ), r), {});
  }
  updateFromPersisted(t) {
    const r = this.filterAllowedGlobals(t);
    this.globals = { ...this.globals, ...r };
  }
  get() {
    return this.globals;
  }
  update(t) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) };
    for (const r in t)
      t[r] === void 0 && (this.globals[r] = this.initialGlobals[r]);
  }
};
c(Sz, "GlobalsStore");
var jme = Sz, Ime = or(LD(), 1), Nme = (0, Ime.default)(1)(
  (e) => Object.values(e).reduce(
    (t, r) => (t[r.importPath] = t[r.importPath] || r, t),
    {}
  )
), Tz = class {
  constructor({ entries: t } = { v: 5, entries: {} }) {
    this.entries = t;
  }
  entryFromSpecifier(t) {
    const r = Object.values(this.entries);
    if (t === "*")
      return r[0];
    if (typeof t == "string")
      return this.entries[t] ? this.entries[t] : r.find((a) => a.id.startsWith(t));
    const { name: n, title: o } = t;
    return r.find((a) => a.name === n && a.title === o);
  }
  storyIdToEntry(t) {
    const r = this.entries[t];
    if (!r)
      throw new bne({ storyId: t });
    return r;
  }
  importPathToEntry(t) {
    return Nme(this.entries)[t];
  }
};
c(Tz, "StoryIndexStore");
var Mme = Tz, Dme = /* @__PURE__ */ c((e) => typeof e == "string" ? { name: e } : e, "normalizeType"), qme = /* @__PURE__ */ c((e) => typeof e == "string" ? { type: e } : e, "normalizeControl"), Lme = /* @__PURE__ */ c((e, t) => {
  const { type: r, control: n, ...o } = e, a = {
    name: t,
    ...o
  };
  return r && (a.type = Dme(r)), n ? a.control = qme(n) : n === !1 && (a.control = { disable: !0 }), a;
}, "normalizeInputType"), Ch = /* @__PURE__ */ c((e) => Ol(e, Lme), "normalizeInputTypes"), Ke = /* @__PURE__ */ c((e) => Array.isArray(e) ? e : e ? [e] : [], "normalizeArrays"), Fme = Ue`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function Bu(e, t, r) {
  const n = t, o = typeof t == "function" ? t : null, { story: a } = n;
  a && (vt.debug("deprecated story", a), Jq(Fme));
  const i = gme(e), s = typeof n != "function" && n.name || n.storyName || a?.name || i, d = [
    ...Ke(n.decorators),
    ...Ke(a?.decorators)
  ], l = { ...a?.parameters, ...n.parameters }, p = { ...a?.args, ...n.args }, f = { ...a?.argTypes, ...n.argTypes }, h = [...Ke(n.loaders), ...Ke(a?.loaders)], m = [
    ...Ke(n.beforeEach),
    ...Ke(a?.beforeEach)
  ], g = [
    ...Ke(n.afterEach),
    ...Ke(a?.afterEach)
  ], { render: w, play: _, tags: b = [], globals: x = {} } = n, P = l.__id || mme(r.id, i);
  return {
    moduleExport: t,
    id: P,
    name: s,
    tags: b,
    decorators: d,
    parameters: l,
    args: p,
    argTypes: Ch(f),
    loaders: h,
    beforeEach: m,
    afterEach: g,
    globals: x,
    ...w && { render: w },
    ...o && { userStoryFn: o },
    ..._ && { play: _ }
  };
}
c(Bu, "normalizeStory");
function kh(e, t = e.title, r) {
  const { id: n, argTypes: o } = e;
  return {
    id: cz(n || t),
    ...e,
    title: t,
    ...o && { argTypes: Ch(o) },
    parameters: {
      fileName: r,
      ...e.parameters
    }
  };
}
c(kh, "normalizeComponentAnnotations");
var Ume = /* @__PURE__ */ c((e) => {
  const { globals: t, globalTypes: r } = e;
  (t || r) && vt.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: t,
      globalTypes: r
    })
  );
}, "checkGlobals"), Bme = /* @__PURE__ */ c((e) => {
  const { options: t } = e;
  t?.storySort && vt.error("The storySort option parameter can only be set globally");
}, "checkStorySort"), Jp = /* @__PURE__ */ c((e) => {
  e && (Ume(e), Bme(e));
}, "checkDisallowedParameters");
function Az(e, t, r) {
  const { default: n, __namedExportsOrder: o, ...a } = e, i = Object.values(a)[0];
  if (ag(i)) {
    const l = kh(i.meta.input, r, t);
    Jp(l.parameters);
    const p = { meta: l, stories: {}, moduleExports: e };
    return Object.keys(a).forEach((f) => {
      if (Ah(f, l)) {
        const h = a[f], m = Bu(f, h.input, l);
        Jp(m.parameters), p.stories[m.id] = m, lz(h).forEach((g) => {
          const w = g.input.name, _ = yme(m.id, w);
          g.input.parameters ??= {}, g.input.parameters.__id = _, p.stories[_] = Bu(w, g.input, l);
        });
      }
    }), p.projectAnnotations = i.meta.preview.composed, p;
  }
  const s = kh(
    n,
    r,
    t
  );
  Jp(s.parameters);
  const d = { meta: s, stories: {}, moduleExports: e };
  return Object.keys(a).forEach((l) => {
    if (Ah(l, s)) {
      const p = Bu(l, a[l], s);
      Jp(p.parameters), d.stories[p.id] = p;
    }
  }), d;
}
c(Az, "processCSFFile");
function Ph(e) {
  return e != null && $z(e).includes("mount");
}
c(Ph, "mountDestructured");
function $z(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t)
    return [];
  const r = L_(t[1]);
  if (!r.length)
    return [];
  const n = r[0];
  return n.startsWith("{") && n.endsWith("}") ? L_(n.slice(1, -1).replace(/\s/g, "")).map((o) => o.replace(/:.*|=.*/g, "")) : [];
}
c($z, "getUsedProps");
function L_(e) {
  const t = [], r = [];
  let n = 0;
  for (let a = 0; a < e.length; a++)
    if (e[a] === "{" || e[a] === "[")
      r.push(e[a] === "{" ? "}" : "]");
    else if (e[a] === r[r.length - 1])
      r.pop();
    else if (!r.length && e[a] === ",") {
      const i = e.substring(n, a).trim();
      i && t.push(i), n = a + 1;
    }
  const o = e.substring(n).trim();
  return o && t.push(o), t;
}
c(L_, "splitByComma");
function Cz(e, t, r) {
  const n = r(e);
  return (o) => t(n, o);
}
c(Cz, "decorateStory");
function kz({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: o,
  story: a,
  parameters: i,
  initialArgs: s,
  argTypes: d,
  ...l
} = {}) {
  return l;
}
c(kz, "sanitizeStoryContextUpdate");
function Pz(e, t) {
  const r = {}, n = /* @__PURE__ */ c((a) => (i) => {
    if (!r.value)
      throw new Error("Decorated function called without init");
    return r.value = {
      ...r.value,
      ...kz(i)
    }, a(r.value);
  }, "bindWithContext"), o = t.reduce(
    (a, i) => Cz(a, i, n),
    e
  );
  return (a) => (r.value = a, o(a));
}
c(Pz, "defaultDecorateStory");
function oA(e, t, r) {
  const { moduleExport: n, id: o, name: a } = e || {}, i = aA(
    e,
    t,
    r
  ), s = /* @__PURE__ */ c(async (C) => {
    const A = {};
    for (const E of [
      Ke(r.loaders),
      Ke(t.loaders),
      Ke(e.loaders)
    ]) {
      if (C.abortSignal.aborted)
        return A;
      const T = await Promise.all(E.map((O) => O(C)));
      Object.assign(A, ...T);
    }
    return A;
  }, "applyLoaders"), d = /* @__PURE__ */ c(async (C) => {
    const A = new Array();
    for (const E of [
      ...Ke(r.beforeEach),
      ...Ke(t.beforeEach),
      ...Ke(e.beforeEach)
    ]) {
      if (C.abortSignal.aborted)
        return A;
      const T = await E(C);
      T && A.push(T);
    }
    return A;
  }, "applyBeforeEach"), l = /* @__PURE__ */ c(async (C) => {
    const A = [
      ...Ke(r.afterEach),
      ...Ke(t.afterEach),
      ...Ke(e.afterEach)
    ].reverse();
    for (const E of A) {
      if (C.abortSignal.aborted)
        return;
      await E(C);
    }
  }, "applyAfterEach"), p = /* @__PURE__ */ c((C) => C.originalStoryFn(C.args, C), "undecoratedStoryFn"), { applyDecorators: f = Pz, runStep: h } = r, m = [
    ...Ke(e?.decorators),
    ...Ke(t?.decorators),
    ...Ke(r?.decorators)
  ], g = e?.userStoryFn || e?.render || t.render || r.render, w = wme(f)(p, m), _ = /* @__PURE__ */ c((C) => w(C), "unboundStoryFn"), b = e?.play ?? t?.play, x = Ph(b);
  if (!g && !x)
    throw new Cne({ id: o });
  const P = /* @__PURE__ */ c((C) => async () => (await C.renderToCanvas(), C.canvas), "defaultMount"), R = e.mount ?? t.mount ?? r.mount ?? P, N = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...i,
    moduleExport: n,
    id: o,
    name: a,
    story: a,
    originalStoryFn: g,
    undecoratedStoryFn: p,
    unboundStoryFn: _,
    applyLoaders: s,
    applyBeforeEach: d,
    applyAfterEach: l,
    playFunction: b,
    runStep: h,
    mount: R,
    testingLibraryRender: N,
    renderToCanvas: r.renderToCanvas,
    usesMount: x
  };
}
c(oA, "prepareStory");
function Oz(e, t, r) {
  return {
    ...aA(void 0, e, t),
    moduleExport: r
  };
}
c(Oz, "prepareMeta");
function aA(e, t, r) {
  const n = ["dev", "test"], o = Ee.DOCS_OPTIONS?.autodocs === !0 ? ["autodocs"] : [], a = e?.tags?.includes("test-fn") ? ["!autodocs"] : [], i = uz(
    ...n,
    ...o,
    ...r.tags ?? [],
    ...t.tags ?? [],
    ...a,
    ...e?.tags ?? []
  ), s = Ba(
    r.parameters,
    t.parameters,
    e?.parameters
  ), { argTypesEnhancers: d = [], argsEnhancers: l = [] } = r, p = Ba(
    r.argTypes,
    t.argTypes,
    e?.argTypes
  );
  if (e) {
    const x = e?.userStoryFn || e?.render || t.render || r.render;
    s.__isArgsStory = x && x.length > 0;
  }
  const f = {
    ...r.args,
    ...t.args,
    ...e?.args
  }, h = {
    ...t.globals,
    ...e?.globals
  }, m = {
    componentId: t.id,
    title: t.title,
    kind: t.title,
    // Back compat
    id: e?.id || t.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: e?.name || "__meta",
    story: e?.name || "__meta",
    // Back compat
    component: t.component,
    subcomponents: t.subcomponents,
    tags: i,
    parameters: s,
    initialArgs: f,
    argTypes: p,
    storyGlobals: h
  };
  m.argTypes = d.reduce(
    (x, P) => P({ ...m, argTypes: x }),
    m.argTypes
  );
  const g = { ...f };
  m.initialArgs = [...l].reduce(
    (x, P) => ({
      ...x,
      ...P({
        ...m,
        initialArgs: x
      })
    }),
    g
  );
  const { name: w, story: _, ...b } = m;
  return b;
}
c(aA, "preparePartialAnnotations");
function iA(e) {
  const { args: t } = e;
  let r = {
    ...e,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (Ee.FEATURES?.argTypeTargetsV7) {
    const a = wz(e);
    r = {
      ...e,
      allArgs: e.args,
      argsByTarget: a,
      args: a[vz] || {}
    };
  }
  const n = Object.entries(r.args).reduce((a, [i, s]) => {
    if (!r.argTypes[i]?.mapping)
      return a[i] = s, a;
    const d = /* @__PURE__ */ c((l) => {
      const p = r.argTypes[i].mapping;
      return p && l in p ? p[l] : l;
    }, "mappingFn");
    return a[i] = Array.isArray(s) ? s.map(d) : d(s), a;
  }, {}), o = Object.entries(n).reduce((a, [i, s]) => {
    const d = r.argTypes[i] || {};
    return $he(d, n, r.globals) && (a[i] = s), a;
  }, {});
  return { ...r, unmappedArgs: t, args: o };
}
c(iA, "prepareContext");
var F_ = /* @__PURE__ */ c((e, t, r) => {
  const n = typeof e;
  switch (n) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: n };
  }
  return e ? r.has(e) ? (vt.warn(Ue`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (r.add(e), Array.isArray(e) ? { name: "array", value: e.length > 0 ? F_(e[0], t, new Set(r)) : { name: "other", value: "unknown" } } : { name: "object", value: Ol(e, (o) => F_(o, t, new Set(r))) }) : { name: "object", value: {} };
}, "inferType"), Rz = /* @__PURE__ */ c((e) => {
  const { id: t, argTypes: r = {}, initialArgs: n = {} } = e, o = Ol(n, (i, s) => ({
    name: s,
    type: F_(i, `${t}.${s}`, /* @__PURE__ */ new Set())
  })), a = Ol(r, (i, s) => ({
    name: s
  }));
  return Ba(o, a, r);
}, "inferArgTypes");
Rz.secondPass = !0;
var cR = /* @__PURE__ */ c((e, t) => Array.isArray(t) ? t.includes(e) : e.match(t), "matches"), Hme = /* @__PURE__ */ c((e, t, r) => !t && !r ? e : e && $M(e, (n, o) => {
  const a = n.name || o.toString();
  return !!(!t || cR(a, t)) && (!r || !cR(a, r));
}), "filterArgTypes"), Vme = /* @__PURE__ */ c((e, t, r) => {
  const { type: n, options: o } = e;
  if (n) {
    if (r.color && r.color.test(t)) {
      const a = n.name;
      if (a === "string")
        return { control: { type: "color" } };
      a !== "enum" && vt.warn(
        `Addon controls: Control of type color only supports string, received "${a}" instead`
      );
    }
    if (r.date && r.date.test(t))
      return { control: { type: "date" } };
    switch (n.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        const { value: a } = n;
        return { control: { type: a?.length <= 5 ? "radio" : "select" }, options: a };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: o ? "select" : "object" } };
    }
  }
}, "inferControl"), jz = /* @__PURE__ */ c((e) => {
  const {
    argTypes: t,
    parameters: { __isArgsStory: r, controls: { include: n = null, exclude: o = null, matchers: a = {} } = {} }
  } = e;
  if (!r)
    return t;
  const i = Hme(t, n, o), s = Ol(i, (d, l) => d?.type && Vme(d, l.toString(), a));
  return Ba(s, i);
}, "inferControls");
jz.secondPass = !0;
function Ad({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: o,
  beforeEach: a,
  afterEach: i,
  initialGlobals: s,
  ...d
}) {
  return {
    ...e && { argTypes: Ch(e) },
    ...t && { globalTypes: Ch(t) },
    decorators: Ke(n),
    loaders: Ke(o),
    beforeEach: Ke(a),
    afterEach: Ke(i),
    argTypesEnhancers: [
      ...r || [],
      Rz,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      jz
    ],
    initialGlobals: s,
    ...d
  };
}
c(Ad, "normalizeProjectAnnotations");
var zme = /* @__PURE__ */ c((e) => async () => {
  const t = [];
  for (const r of e) {
    const n = await r();
    n && t.unshift(n);
  }
  return async () => {
    for (const r of t)
      await r();
  };
}, "composeBeforeAllHooks");
function Iz(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (o, a) => async () => a(t, o, n),
      async () => r(n)
    )();
  };
}
c(Iz, "composeStepRunners");
function Kl(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
c(Kl, "getField");
function Lo(e, t, r = {}) {
  return Kl(e, t).reduce((n, o) => {
    const a = Ke(o);
    return r.reverseFileOrder ? [...a, ...n] : [...n, ...a];
  }, []);
}
c(Lo, "getArrayField");
function wu(e, t) {
  return Object.assign({}, ...Kl(e, t));
}
c(wu, "getObjectField");
function Xs(e, t) {
  return Kl(e, t).pop();
}
c(Xs, "getSingletonField");
function fs(e) {
  const t = Lo(e, "argTypesEnhancers"), r = Kl(e, "runStep"), n = Lo(e, "beforeAll");
  return {
    parameters: Ba(...Kl(e, "parameters")),
    decorators: Lo(e, "decorators", {
      reverseFileOrder: !(Ee.FEATURES?.legacyDecoratorFileOrder ?? !1)
    }),
    args: wu(e, "args"),
    argsEnhancers: Lo(e, "argsEnhancers"),
    argTypes: wu(e, "argTypes"),
    argTypesEnhancers: [
      ...t.filter((o) => !o.secondPass),
      ...t.filter((o) => o.secondPass)
    ],
    initialGlobals: wu(e, "initialGlobals"),
    globalTypes: wu(e, "globalTypes"),
    loaders: Lo(e, "loaders"),
    beforeAll: zme(n),
    beforeEach: Lo(e, "beforeEach"),
    afterEach: Lo(e, "afterEach"),
    render: Xs(e, "render"),
    renderToCanvas: Xs(e, "renderToCanvas"),
    applyDecorators: Xs(e, "applyDecorators"),
    runStep: Iz(r),
    tags: Lo(e, "tags"),
    mount: Xs(e, "mount"),
    testingLibraryRender: Xs(e, "testingLibraryRender")
  };
}
c(fs, "composeConfigs");
var Nz = class {
  constructor() {
    this.reports = [];
  }
  async addReport(t) {
    this.reports.push(t);
  }
};
c(Nz, "ReporterAPI");
var Mz = Nz;
function Dz(e, t, r) {
  return ag(e) ? {
    story: e.input,
    meta: e.meta.input,
    preview: e.meta.preview.composed
  } : { story: e, meta: iz(t) ? t.input : t, preview: r };
}
c(Dz, "getCsfFactoryAnnotations");
function Jme(e) {
  globalThis.defaultProjectAnnotations = e;
}
c(Jme, "setDefaultProjectAnnotations");
var Wme = "ComposedStory", Gme = "Unnamed Story";
function qz(e) {
  return e ? fs([e]) : {};
}
c(qz, "extractAnnotation");
function Kme(e) {
  const t = Array.isArray(e) ? e : [e];
  return globalThis.globalProjectAnnotations = fs([
    ...og(),
    globalThis.defaultProjectAnnotations ?? {},
    fs(t.map(qz))
  ]), globalThis.globalProjectAnnotations ?? {};
}
c(Kme, "setProjectAnnotations");
var Ca = [];
function sA(e, t, r, n, o) {
  if (e === void 0)
    throw new Error("Expected a story but received undefined.");
  t.title = t.title ?? Wme;
  const a = kh(t), i = o || e.storyName || e.story?.name || e.name || Gme, s = Bu(
    i,
    e,
    a
  ), d = Ad(
    fs([
      n ?? globalThis.globalProjectAnnotations ?? {},
      r ?? {}
    ])
  ), l = oA(
    s,
    a,
    d
  ), p = {
    ...xz(d.globalTypes),
    ...d.initialGlobals,
    ...l.storyGlobals
  }, f = new Mz(), h = /* @__PURE__ */ c(() => {
    const b = iA({
      hooks: new mz(),
      globals: p,
      args: { ...l.initialArgs },
      viewMode: "story",
      reporting: f,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: /* @__PURE__ */ c((x, P) => l.runStep(x, P, b), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: d.globalTypes,
      ...l,
      context: null,
      mount: null
    });
    return b.parameters.__isPortableStory = !0, b.context = b, l.renderToCanvas && (b.renderToCanvas = async () => {
      const x = await l.renderToCanvas?.(
        {
          componentId: l.componentId,
          title: l.title,
          id: l.id,
          name: l.name,
          tags: l.tags,
          showMain: /* @__PURE__ */ c(() => {
          }, "showMain"),
          showError: /* @__PURE__ */ c((P) => {
            throw new Error(`${P.title}
${P.description}`);
          }, "showError"),
          showException: /* @__PURE__ */ c((P) => {
            throw P;
          }, "showException"),
          forceRemount: !0,
          storyContext: b,
          storyFn: /* @__PURE__ */ c(() => l.unboundStoryFn(b), "storyFn"),
          unboundStoryFn: l.unboundStoryFn
        },
        b.canvasElement
      );
      x && Ca.push(x);
    }), b.mount = l.mount(b), b;
  }, "initializeContext");
  let m;
  const g = /* @__PURE__ */ c(async (b) => {
    const x = h();
    return x.canvasElement ??= globalThis?.document?.body, m && (x.loaded = m.loaded), Object.assign(x, b), l.playFunction(x);
  }, "play"), w = /* @__PURE__ */ c((b) => {
    const x = h();
    return Object.assign(x, b), Lz(l, x);
  }, "run"), _ = l.playFunction ? g : void 0;
  return Object.assign(
    /* @__PURE__ */ c(function(b) {
      const x = h();
      return m && (x.loaded = m.loaded), x.args = {
        ...x.initialArgs,
        ...b
      }, l.unboundStoryFn(x);
    }, "storyFn"),
    {
      id: l.id,
      storyName: i,
      load: /* @__PURE__ */ c(async () => {
        for (const x of [...Ca].reverse())
          await x();
        Ca.length = 0;
        const b = h();
        b.loaded = await l.applyLoaders(b), Ca.push(...(await l.applyBeforeEach(b)).filter(Boolean)), m = b;
      }, "load"),
      globals: p,
      args: l.initialArgs,
      parameters: l.parameters,
      argTypes: l.argTypes,
      play: _,
      run: w,
      reporting: f,
      tags: l.tags
    }
  );
}
c(sA, "composeStory");
var Yme = /* @__PURE__ */ c((e, t, r, n) => sA(e, t, r, {}, n), "defaultComposeStory");
function Xme(e, t, r = Yme) {
  const { default: n, __esModule: o, __namedExportsOrder: a, ...i } = e;
  let s = n;
  return Object.entries(i).reduce(
    (d, [l, p]) => {
      const { story: f, meta: h } = Dz(p);
      return !s && h && (s = h), Ah(l, s) ? Object.assign(d, {
        [l]: r(f, s, t, l)
      }) : d;
    },
    {}
  );
}
c(Xme, "composeStories");
function Qme(e) {
  return e.extend({
    mount: /* @__PURE__ */ c(async ({ mount: t, page: r }, n) => {
      await n(async (o, ...a) => {
        if (!("__pw_type" in o) || "__pw_type" in o && o.__pw_type !== "jsx")
          throw new Error(Ue`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        const { props: i, ...s } = o;
        await r.evaluate(async (l) => {
          const p = await globalThis.__pwUnwrapObject?.(l);
          return ("__pw_type" in p ? p.type : p)?.load?.();
        }, s);
        const d = await t(o, ...a);
        return await r.evaluate(async (l) => {
          const p = await globalThis.__pwUnwrapObject?.(l), f = "__pw_type" in p ? p.type : p, h = document.querySelector("#root");
          return f?.play?.({ canvasElement: h });
        }, s), d;
      });
    }, "mount")
  });
}
c(Qme, "createPlaywrightTest");
async function Lz(e, t) {
  for (const a of [...Ca].reverse())
    await a();
  if (Ca.length = 0, !t.canvasElement) {
    const a = document.createElement("div");
    globalThis?.document?.body?.appendChild(a), t.canvasElement = a, Ca.push(() => {
      globalThis?.document?.body?.contains(a) && globalThis?.document?.body?.removeChild(a);
    });
  }
  if (t.loaded = await e.applyLoaders(t), t.abortSignal.aborted)
    return;
  Ca.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  const r = e.playFunction, n = e.usesMount;
  if (n || await t.mount(), t.abortSignal.aborted)
    return;
  r && (n || (t.mount = async () => {
    throw new VM({ playFunction: r.toString() });
  }), await r(t));
  let o;
  aE() ? o = iE() : await sE(t.abortSignal), await e.applyAfterEach(t), await o?.();
}
c(Lz, "runStory");
var uR = 1e3, Zme = 1e4, Fz = class {
  constructor(t, r, n) {
    this.importFn = r, this.storyIndex = new Mme(t), this.projectAnnotations = Ad(
      fs([...og(), n])
    );
    const { initialGlobals: o, globalTypes: a } = this.projectAnnotations;
    this.args = new Rme(), this.userGlobals = new jme({ globals: o, globalTypes: a }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, fv.default)(uR)(Az), this.prepareMetaWithCache = (0, fv.default)(uR)(Oz), this.prepareStoryWithCache = (0, fv.default)(Zme)(oA);
  }
  setProjectAnnotations(t) {
    this.projectAnnotations = Ad(t);
    const { initialGlobals: r, globalTypes: n } = t;
    this.userGlobals.set({ globals: r, globalTypes: n });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: t,
    storyIndex: r
  }) {
    t && (this.importFn = t), r && (this.storyIndex.entries = r.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(t) {
    return this.storyIndex.storyIdToEntry(t);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(t) {
    const { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t), o = await this.importFn(r);
    return this.processCSFFileWithCache(o, r, n);
  }
  async loadAllCSFFiles() {
    const t = {};
    return Object.entries(this.storyIndex.entries).forEach(([r, { importPath: n }]) => {
      t[n] = r;
    }), (await Promise.all(
      Object.entries(t).map(async ([r, n]) => ({
        importPath: r,
        csfFile: await this.loadCSFFileByStoryId(n)
      }))
    )).reduce(
      (r, { importPath: n, csfFile: o }) => (r[n] = o, r),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: t }) {
    const r = t.meta;
    return this.prepareMetaWithCache(
      r,
      this.projectAnnotations,
      t.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: t }) {
    const r = await this.loadCSFFileByStoryId(t);
    return this.storyFromCSFFile({ storyId: t, csfFile: r });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: t,
    csfFile: r
  }) {
    const n = r.stories[t];
    if (!n)
      throw new Ane({ storyId: t });
    const o = r.meta, a = this.prepareStoryWithCache(
      n,
      o,
      r.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(a), this.hooks[a.id] = this.hooks[a.id] || new mz(), a;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: t
  }) {
    return Object.keys(this.storyIndex.entries).filter((r) => !!t.stories[r]).map((r) => this.storyFromCSFFile({ storyId: r, csfFile: t }));
  }
  async loadEntry(t) {
    const r = await this.storyIdToEntry(t), n = r.type === "docs" ? r.storiesImports : [], [o, ...a] = await Promise.all([
      this.importFn(r.importPath),
      ...n.map((i) => {
        const s = this.storyIndex.importPathToEntry(i);
        return this.loadCSFFileByStoryId(s.id);
      })
    ]);
    return { entryExports: o, csfFiles: a };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
    const n = this.userGlobals.get(), { initialGlobals: o } = this.userGlobals, a = new Mz();
    return iA({
      ...t,
      args: r ? t.initialArgs : this.args.get(t.id),
      initialGlobals: o,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: n,
      reporting: a,
      globals: {
        ...n,
        ...t.storyGlobals
      },
      hooks: this.hooks[t.id]
    });
  }
  addCleanupCallbacks(t, ...r) {
    this.cleanupCallbacks[t.id] = (this.cleanupCallbacks[t.id] || []).concat(r);
  }
  async cleanupStory(t) {
    this.hooks[t.id].clean();
    const r = this.cleanupCallbacks[t.id];
    if (r)
      for (const n of [...r].reverse())
        await n();
    delete this.cleanupCallbacks[t.id];
  }
  extract(t = { includeDocsOnly: !1 }) {
    const { cachedCSFFiles: r } = this;
    if (console.log("extract: extracting stories", r), !r)
      throw new wne();
    const n = Object.entries(this.storyIndex.entries).reduce(
      (o, [a, i]) => {
        if (i.type === "docs")
          return o;
        const s = r[i.importPath], d = this.storyFromCSFFile({ storyId: a, csfFile: s });
        return !t.includeDocsOnly && d.parameters.docsOnly || (o[a] = Object.entries(d).reduce(
          (l, [p, f]) => p === "story" && i.subtype === "test" ? { ...l, story: i.parentName } : p === "moduleExport" || typeof f == "function" ? l : Array.isArray(f) ? Object.assign(l, { [p]: f.slice().sort() }) : Object.assign(l, { [p]: f }),
          {
            args: d.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...d.storyGlobals
            },
            storyId: i.parent ? i.parent : a
          }
        )), o;
      },
      {}
    );
    return console.log("extract: stories", n), n;
  }
};
c(Fz, "StoryStore");
var eye = Fz;
function tye(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
c(tye, "slash");
function rye(e) {
  return e.flatMap((t) => t.split("/")).filter(Boolean).join("/");
}
c(rye, "pathJoin");
var lg = new Error("prepareAborted"), { AbortController: dR } = globalThis;
function U_(e) {
  try {
    const { name: t = "Error", message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: "Error", message: String(e) };
  }
}
c(U_, "serializeError");
var Uz = class {
  constructor(t, r, n, o, a, i, s = { autoplay: !0, forceInitialArgs: !1 }, d) {
    this.channel = t, this.store = r, this.renderToScreen = n, this.callbacks = o, this.id = a, this.viewMode = i, this.renderOptions = s, this.type = "story", this.notYetRendered = !0, this.rerenderEnqueued = !1, this.disableKeyListeners = !1, this.teardownRender = /* @__PURE__ */ c(() => {
    }, "teardownRender"), this.torndown = !1, this.abortController = new dR(), this.renderId = Date.now(), d && (this.story = d, this.phase = "preparing");
  }
  async runPhase(t, r, n) {
    this.phase = r, this.channel.emit(os, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), n && (await n(), this.checkIfAborted(t));
  }
  checkIfAborted(t) {
    return t.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(os, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    })), t.aborted;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), lg;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(t) {
    return this.canvasElement = t, this.render({ initial: !0, forceRemount: !0 });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    const { forceInitialArgs: t } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: t });
  }
  async render({
    initial: t = !1,
    forceRemount: r = !1
  } = {}) {
    const { canvasElement: n } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    const o = this.story;
    if (!n)
      throw new Error("cannot render when canvasElement is unset");
    const {
      id: a,
      componentId: i,
      title: s,
      name: d,
      tags: l,
      applyLoaders: p,
      applyBeforeEach: f,
      applyAfterEach: h,
      unboundStoryFn: m,
      playFunction: g,
      runStep: w
    } = o;
    r && !t && (this.cancelRender(), this.abortController = new dR());
    const _ = this.abortController.signal;
    let b = !1;
    const x = o.usesMount;
    try {
      const P = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: _,
        canvasElement: n,
        loaded: {},
        step: /* @__PURE__ */ c((L, $) => w(L, $, P), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: /* @__PURE__ */ c(async () => {
          const L = await this.renderToScreen(R, n);
          this.teardownRender = L || (() => {
          }), b = !0;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: /* @__PURE__ */ c(async (...L) => {
          this.callbacks.showStoryDuringRender?.();
          let $ = null;
          return await this.runPhase(_, "rendering", async () => {
            $ = await o.mount(P)(...L);
          }), x && await this.runPhase(_, "playing"), $;
        }, "mount")
      };
      P.context = P;
      const R = {
        componentId: i,
        title: s,
        kind: s,
        id: a,
        name: d,
        story: d,
        tags: l,
        ...this.callbacks,
        showError: /* @__PURE__ */ c((L) => (this.phase = "errored", this.callbacks.showError(L)), "showError"),
        showException: /* @__PURE__ */ c((L) => (this.phase = "errored", this.callbacks.showException(L)), "showException"),
        forceRemount: r || this.notYetRendered,
        storyContext: P,
        storyFn: /* @__PURE__ */ c(() => m(P), "storyFn"),
        unboundStoryFn: m
      };
      if (await this.runPhase(_, "loading", async () => {
        P.loaded = await p(P);
      }), _.aborted)
        return;
      const N = await f(P);
      if (this.store.addCleanupCallbacks(o, ...N), this.checkIfAborted(_) || (!b && !x && await P.mount(), this.notYetRendered = !1, _.aborted))
        return;
      const C = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, A = /* @__PURE__ */ new Set(), E = /* @__PURE__ */ c((L) => {
        L.error && A.add(L.error);
      }, "onError"), T = /* @__PURE__ */ c((L) => {
        L.reason && A.add(L.reason);
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && r && g && this.phase !== "errored") {
        window?.addEventListener?.("error", E), window?.addEventListener?.("unhandledrejection", T), this.disableKeyListeners = !0;
        try {
          if (x ? await g(P) : (P.mount = async () => {
            throw new VM({ playFunction: g.toString() });
          }, await this.runPhase(_, "playing", async () => g(P))), !b)
            throw new kne();
          this.checkIfAborted(_), !C && A.size > 0 ? await this.runPhase(_, "errored") : await this.runPhase(_, "played");
        } catch (L) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(_, "errored", async () => {
            this.channel.emit(Yq, U_(L));
          }), this.story.parameters.throwPlayFunctionExceptions !== !1)
            throw L;
          console.error(L);
        }
        if (!C && A.size > 0 && this.channel.emit(
          Xq,
          Array.from(A).map(U_)
        ), this.disableKeyListeners = !1, window?.removeEventListener?.("unhandledrejection", T), window?.removeEventListener?.("error", E), _.aborted)
          return;
      }
      await this.runPhase(_, "completing", async () => {
        aE() ? this.store.addCleanupCallbacks(o, iE()) : await sE(_);
      }), await this.runPhase(_, "completed", async () => {
        this.channel.emit(Ff, a);
      }), this.phase !== "errored" && await this.runPhase(_, "afterEach", async () => {
        await h(P);
      });
      const O = !C && A.size > 0, k = P.reporting.reports.some(
        (L) => L.status === "failed"
      ), M = O || k;
      await this.runPhase(
        _,
        "finished",
        async () => this.channel.emit(tw, {
          storyId: a,
          status: M ? "error" : "success",
          reporters: P.reporting.reports
        })
      );
    } catch (P) {
      this.phase = "errored", this.callbacks.showException(P), await this.runPhase(
        _,
        "finished",
        async () => this.channel.emit(tw, {
          storyId: a,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = !0;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: !0 });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let t = 0; t < 3; t += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((r) => setTimeout(r, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
c(Uz, "StoryRender");
var B_ = Uz, { fetch: nye } = Ee, oye = "./index.json", Bz = class {
  constructor(t, r, n = Fn.getChannel(), o = !0) {
    this.importFn = t, this.getProjectAnnotations = r, this.channel = n, this.storyRenders = [], this.storeInitializationPromise = new Promise((a, i) => {
      this.resolveStoreInitializationPromise = a, this.rejectStoreInitializationPromise = i;
    }), o && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: /* @__PURE__ */ c((t, r) => {
          if (this.storyStoreValue)
            return Jq("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[r];
          throw new $ne();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      const t = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(t), await this.initializeWithProjectAnnotations(t);
      const r = globalThis?.navigator?.userAgent;
      await this.channel.emit(Zq, { userAgent: r });
    } catch (t) {
      this.rejectStoreInitializationPromise(t);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(aL, this.onStoryIndexChanged.bind(this)), this.channel.on(qE, this.onUpdateGlobals.bind(this)), this.channel.on(LE, this.onUpdateArgs.bind(this)), this.channel.on(pL, this.onRequestArgTypesInfo.bind(this)), this.channel.on(ME, this.onResetArgs.bind(this)), this.channel.on(NE, this.onForceReRender.bind(this)), this.channel.on(Lf, this.onForceRemount.bind(this)), this.channel.on(uL, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      const t = await this.getProjectAnnotations();
      if (this.renderToCanvas = t.renderToCanvas, !this.renderToCanvas)
        throw new _ne();
      return t;
    } catch (t) {
      throw this.renderPreviewEntryError("Error reading preview.js:", t), t;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(t) {
    this.projectAnnotationsBeforeInitialization = t;
    try {
      const r = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(r);
    } catch (r) {
      throw this.renderPreviewEntryError("Error loading story index:", r), r;
    }
  }
  async runBeforeAllHook(t) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await t.beforeAll?.();
    } catch (r) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", r), r;
    }
  }
  async getStoryIndexFromServer() {
    const t = await nye(oye);
    if (t.status === 200)
      return t.json();
    throw new Ene({ text: await t.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(t) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new eye(
      t,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "emitGlobals" });
    const t = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(tL, t);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: t
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = t;
    const r = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(r), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(r);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        const t = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(t);
          return;
        }
        await this.onStoriesChanged({ storyIndex: t });
      } catch (t) {
        throw this.renderPreviewEntryError("Error loading story index:", t), t;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: t,
    storyIndex: r
  }) {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: t, storyIndex: r });
  }
  async onUpdateGlobals({
    globals: t,
    currentStory: r
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new sn({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(t), r) {
      const { initialGlobals: n, storyGlobals: o, userGlobals: a, globals: i } = this.storyStoreValue.getStoryContext(r);
      this.channel.emit(id, {
        initialGlobals: n,
        userGlobals: a,
        storyGlobals: o,
        globals: i
      });
    } else {
      const { initialGlobals: n, globals: o } = this.storyStoreValue.userGlobals;
      this.channel.emit(id, {
        initialGlobals: n,
        userGlobals: o,
        storyGlobals: {},
        globals: o
      });
    }
    await Promise.all(this.storyRenders.map((n) => n.rerender()));
  }
  async onUpdateArgs({ storyId: t, updatedArgs: r }) {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(t, r), await Promise.all(
      this.storyRenders.filter((n) => n.id === t && !n.renderOptions.forceInitialArgs).map(
        (n) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          n.story && n.story.usesMount ? n.remount() : n.rerender()
        )
      )
    ), this.channel.emit(rL, {
      storyId: t,
      args: this.storyStoreValue.args.get(t)
    });
  }
  async onRequestArgTypesInfo({ id: t, payload: r }) {
    try {
      await this.storeInitializationPromise;
      const n = await this.storyStoreValue?.loadStory(r);
      this.channel.emit(rw, {
        id: t,
        success: !0,
        payload: { argTypes: n?.argTypes || {} },
        error: null
      });
    } catch (n) {
      this.channel.emit(rw, {
        id: t,
        success: !1,
        error: n?.message
      });
    }
  }
  async onResetArgs({ storyId: t, argNames: r }) {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "onResetArgs" });
    const n = this.storyRenders.find((a) => a.id === t)?.story || await this.storyStoreValue.loadStory({ storyId: t }), o = (r || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(n.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(t))
      ])
    ]).reduce((a, i) => (a[i] = n.initialArgs[i], a), {});
    await this.onUpdateArgs({ storyId: t, updatedArgs: o });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((t) => t.rerender()));
  }
  async onForceRemount({ storyId: t }) {
    await Promise.all(this.storyRenders.filter((r) => r.id === t).map((r) => r.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((t) => t.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(t, r, n, o) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new sn({
        methodName: "renderStoryToElement"
      });
    const a = new B_(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      n,
      t.id,
      "docs",
      o,
      t
    );
    return a.renderToElement(r), this.storyRenders.push(a), async () => {
      await this.teardownRender(a);
    };
  }
  async teardownRender(t, { viewModeChanged: r } = {}) {
    this.storyRenders = this.storyRenders.filter((n) => n !== t), await t?.teardown?.({ viewModeChanged: r });
  }
  // API
  async loadStory({ storyId: t }) {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: t });
  }
  getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r });
  }
  async extract(t) {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(t);
  }
  // UTILITIES
  renderPreviewEntryError(t, r) {
    this.previewEntryError = r, vt.error(t), vt.error(r), this.channel.emit(Gq, r);
  }
};
c(Bz, "Preview");
var aye = Bz, Hz = class {
  constructor(t, r, n, o) {
    this.channel = t, this.store = r, this.renderStoryToElement = n, this.storyIdByName = /* @__PURE__ */ c((a) => {
      const i = this.nameToStoryId.get(a);
      if (i)
        return i;
      throw new Error(`No story found with that name: ${a}`);
    }, "storyIdByName"), this.componentStories = /* @__PURE__ */ c(() => this.componentStoriesValue, "componentStories"), this.componentStoriesFromCSFFile = /* @__PURE__ */ c((a) => this.store.componentStoriesFromCSFFile({ csfFile: a }), "componentStoriesFromCSFFile"), this.storyById = /* @__PURE__ */ c((a) => {
      if (!a) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      const i = this.storyIdToCSFFile.get(a);
      if (!i)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${a}`);
      return this.store.storyFromCSFFile({ storyId: a, csfFile: i });
    }, "storyById"), this.getStoryContext = /* @__PURE__ */ c((a) => ({
      ...this.store.getStoryContext(a),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext"), this.loadStory = /* @__PURE__ */ c((a) => this.store.loadStory({ storyId: a }), "loadStory"), this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), o.forEach((a, i) => {
      this.referenceCSFFile(a);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(t) {
    this.exportsToCSFFile.set(t.moduleExports, t), this.exportsToCSFFile.set(t.moduleExports.default, t), this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((r) => {
      const n = t.stories[r.id];
      this.storyIdToCSFFile.set(n.id, t), this.exportToStory.set(n.moduleExport, r);
    });
  }
  attachCSFFile(t) {
    if (!this.exportsToCSFFile.has(t.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    this.attachedCSFFiles.has(t) || (this.attachedCSFFiles.add(t), this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((r) => {
      this.nameToStoryId.set(r.name, r.id), this.componentStoriesValue.push(r), this.primaryStory || (this.primaryStory = r);
    }));
  }
  referenceMeta(t, r) {
    const n = this.resolveModuleExport(t);
    if (n.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    r && this.attachCSFFile(n.csfFile);
  }
  get projectAnnotations() {
    const { projectAnnotations: t } = this.store;
    if (!t)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return t;
  }
  resolveAttachedModuleExportType(t) {
    if (t === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    const r = Array.from(this.attachedCSFFiles)[0];
    if (t === "meta")
      return { type: "meta", csfFile: r };
    const { component: n } = r.meta;
    if (!n)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: n };
  }
  resolveModuleExport(t) {
    const r = this.exportsToCSFFile.get(t);
    if (r)
      return { type: "meta", csfFile: r };
    const n = this.exportToStory.get(
      ag(t) ? t.input : t
    );
    return n ? { type: "story", story: n } : { type: "component", component: t };
  }
  resolveOf(t, r = []) {
    let n;
    if (["component", "meta", "story"].includes(t)) {
      const o = t;
      n = this.resolveAttachedModuleExportType(o);
    } else
      n = this.resolveModuleExport(t);
    if (r.length && !r.includes(n.type)) {
      const o = n.type === "component" ? "component or unknown" : n.type;
      throw new Error(Ue`Invalid value passed to the 'of' prop. The value was resolved to a '${o}' type but the only types for this block are: ${r.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (n.type) {
      case "component":
        return {
          ...n,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...n,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: n.csfFile })
        };
      case "story":
      default:
        return n;
    }
  }
};
c(Hz, "DocsContext");
var Vz = Hz, zz = class {
  constructor(t, r, n, o) {
    this.channel = t, this.store = r, this.entry = n, this.callbacks = o, this.type = "docs", this.subtype = "csf", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = n.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw lg;
    const { importPath: n, title: o } = this.entry, a = this.store.processCSFFileWithCache(
      t,
      n,
      o
    ), i = Object.keys(a.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: i, csfFile: a }), this.csfFiles = [a, ...r], this.preparing = !1;
  }
  isEqual(t) {
    return !!(this.id === t.id && this.story && this.story === t.story);
  }
  docsContext(t) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    const r = new Vz(
      this.channel,
      this.store,
      t,
      this.csfFiles
    );
    return this.csfFiles.forEach((n) => r.attachCSFFile(n)), r;
  }
  async renderToElement(t, r) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    const n = this.docsContext(r), { docs: o } = this.story.parameters || {};
    if (!o)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    const a = await o.renderer(), { render: i } = a, s = /* @__PURE__ */ c(async () => {
      try {
        await i(n, o, t), this.channel.emit(IE, this.id);
      } catch (d) {
        this.callbacks.showException(d);
      }
    }, "renderDocs");
    return this.rerender = async () => s(), this.teardownRender = async ({ viewModeChanged: d }) => {
      !d || !t || a.unmount(t);
    }, s();
  }
  async teardown({ viewModeChanged: t } = {}) {
    this.teardownRender?.({ viewModeChanged: t }), this.torndown = !0;
  }
};
c(zz, "CsfDocsRender");
var pR = zz, Jz = class {
  constructor(t, r, n, o) {
    this.channel = t, this.store = r, this.entry = n, this.callbacks = o, this.type = "docs", this.subtype = "mdx", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = n.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw lg;
    this.csfFiles = r, this.exports = t, this.preparing = !1;
  }
  isEqual(t) {
    return !!(this.id === t.id && this.exports && this.exports === t.exports);
  }
  docsContext(t) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new Vz(
      this.channel,
      this.store,
      t,
      this.csfFiles
    );
  }
  async renderToElement(t, r) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    const n = this.docsContext(r), { docs: o } = this.store.projectAnnotations.parameters ?? {};
    if (!o)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    const a = { ...o, page: this.exports.default }, i = await o.renderer(), { render: s } = i, d = /* @__PURE__ */ c(async () => {
      try {
        await s(n, a, t), this.channel.emit(IE, this.id);
      } catch (l) {
        this.callbacks.showException(l);
      }
    }, "renderDocs");
    return this.rerender = async () => d(), this.teardownRender = async ({ viewModeChanged: l } = {}) => {
      !l || !t || (i.unmount(t), this.torndown = !0);
    }, d();
  }
  async teardown({ viewModeChanged: t } = {}) {
    this.teardownRender?.({ viewModeChanged: t }), this.torndown = !0;
  }
};
c(Jz, "MdxDocsRender");
var fR = Jz, iye = globalThis;
function Wz(e) {
  const t = e.composedPath && e.composedPath()[0] || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute("contenteditable") !== null;
}
c(Wz, "focusInInput");
var Gz = "attached-mdx", sye = "unattached-mdx";
function Kz({ tags: e }) {
  return e?.includes(sye) || e?.includes(Gz);
}
c(Kz, "isMdxEntry");
function yf(e) {
  return e.type === "story";
}
c(yf, "isStoryRender");
function Yz(e) {
  return e.type === "docs";
}
c(Yz, "isDocsRender");
function Xz(e) {
  return Yz(e) && e.subtype === "csf";
}
c(Xz, "isCsfDocsRender");
var Qz = class extends aye {
  constructor(t, r, n, o) {
    super(t, r, void 0, !1), this.importFn = t, this.getProjectAnnotations = r, this.selectionStore = n, this.view = o, this.initialize();
  }
  setupListeners() {
    super.setupListeners(), iye.onkeydown = this.onKeydown.bind(this), this.channel.on(DE, this.onSetCurrentStory.bind(this)), this.channel.on(dL, this.onUpdateQueryParams.bind(this)), this.channel.on(Qq, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new sn({ methodName: "setInitialGlobals" });
    const { globals: t } = this.selectionStore.selectionSpecifier || {};
    t && this.storyStoreValue.userGlobals.updateFromPersisted(t), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(t) {
    return await super.initializeWithStoryIndex(t), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new sn({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier: t, args: r } = this.selectionStore.selectionSpecifier, n = this.storyStoreValue.storyIndex.entryFromSpecifier(t);
    if (!n) {
      t === "*" ? this.renderStoryLoadingException(t, new Sne()) : this.renderStoryLoadingException(
        t,
        new Tne({ storySpecifier: t.toString() })
      );
      return;
    }
    const { id: o, type: a } = n;
    this.selectionStore.setSelection({ storyId: o, viewMode: a }), this.channel.emit(sL, this.selectionStore.selection), this.channel.emit(Zv, this.selectionStore.selection), await this.renderSelection({ persistedArgs: r });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: t
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: t,
    storyIndex: r
  }) {
    await super.onStoriesChanged({ importFn: t, storyIndex: r }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(t) {
    if (!this.storyRenders.find((r) => r.disableKeyListeners) && !Wz(t)) {
      const { altKey: r, ctrlKey: n, metaKey: o, shiftKey: a, key: i, code: s, keyCode: d } = t;
      this.channel.emit(eL, {
        event: { altKey: r, ctrlKey: n, metaKey: o, shiftKey: a, key: i, code: s, keyCode: d }
      });
    }
  }
  async onSetCurrentStory(t) {
    this.selectionStore.setSelection({ viewMode: "story", ...t }), await this.storeInitializationPromise, this.channel.emit(Zv, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(t) {
    this.selectionStore.setQueryParams(t);
  }
  async onUpdateGlobals({ globals: t }) {
    const r = this.currentRender instanceof B_ && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: t, currentStory: r }), (this.currentRender instanceof fR || this.currentRender instanceof pR) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId: t, updatedArgs: r }) {
    super.onUpdateArgs({ storyId: t, updatedArgs: r });
  }
  async onPreloadStories({ ids: t }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(t.map((r) => this.storyStoreValue?.loadEntry(r)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: t } = {}) {
    const { renderToCanvas: r } = this;
    if (!this.storyStoreValue || !r)
      throw new sn({ methodName: "renderSelection" });
    const { selection: n } = this.selectionStore;
    if (!n)
      throw new Error("Cannot call renderSelection as no selection was made");
    const { storyId: o } = n;
    let a;
    try {
      a = await this.storyStoreValue.storyIdToEntry(o);
    } catch (h) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(o, h);
      return;
    }
    const i = this.currentSelection?.storyId !== o, s = this.currentRender?.type !== a.type;
    a.type === "story" ? this.view.showPreparingStory({ immediate: s }) : this.view.showPreparingDocs({ immediate: s }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let d;
    a.type === "story" ? d = new B_(
      this.channel,
      this.storyStoreValue,
      r,
      this.mainStoryCallbacks(o),
      o,
      "story"
    ) : Kz(a) ? d = new fR(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(o)
    ) : d = new pR(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(o)
    );
    const l = this.currentSelection;
    this.currentSelection = n;
    const p = this.currentRender;
    this.currentRender = d;
    try {
      await d.prepare();
    } catch (h) {
      p && await this.teardownRender(p), h !== lg && this.renderStoryLoadingException(o, h);
      return;
    }
    const f = !i && p && !d.isEqual(p);
    if (t && yf(d) && (lo(!!d.story), this.storyStoreValue.args.updateFromPersisted(d.story, t)), p && !p.torndown && !i && !f && !s) {
      this.currentRender = p, this.channel.emit(cL, o), this.view.showMain();
      return;
    }
    if (p && await this.teardownRender(p, { viewModeChanged: s }), l && (i || s) && this.channel.emit(nL, o), yf(d)) {
      lo(!!d.story);
      const {
        parameters: h,
        initialArgs: m,
        argTypes: g,
        unmappedArgs: w,
        initialGlobals: _,
        userGlobals: b,
        storyGlobals: x,
        globals: P
      } = this.storyStoreValue.getStoryContext(d.story);
      this.channel.emit(iL, {
        id: o,
        parameters: h,
        initialArgs: m,
        argTypes: g,
        args: w
      }), this.channel.emit(id, { userGlobals: b, storyGlobals: x, globals: P, initialGlobals: _ });
    } else {
      let { parameters: h } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: m, globals: g } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(id, {
        globals: g,
        initialGlobals: m,
        storyGlobals: {},
        userGlobals: g
      }), Xz(d) || d.entry.tags?.includes(Gz)) {
        if (!d.csfFiles)
          throw new xne({ storyId: o });
        ({ parameters: h } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: d.csfFiles[0]
        }));
      }
      this.channel.emit(Kq, {
        id: o,
        parameters: h
      });
    }
    yf(d) ? (lo(!!d.story), this.storyRenders.push(d), this.currentRender.renderToElement(
      this.view.prepareForStory(d.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(t, { viewModeChanged: r = !1 } = {}) {
    this.storyRenders = this.storyRenders.filter((n) => n !== t), await t?.teardown?.({ viewModeChanged: r });
  }
  // UTILITIES
  mainStoryCallbacks(t) {
    return {
      showStoryDuringRender: /* @__PURE__ */ c(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: /* @__PURE__ */ c(() => this.view.showMain(), "showMain"),
      showError: /* @__PURE__ */ c((r) => this.renderError(t, r), "showError"),
      showException: /* @__PURE__ */ c((r) => this.renderException(t, r), "showException")
    };
  }
  renderPreviewEntryError(t, r) {
    super.renderPreviewEntryError(t, r), this.view.showErrorDisplay(r);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(ew);
  }
  renderStoryLoadingException(t, r) {
    vt.error(r), this.view.showErrorDisplay(r), this.channel.emit(ew, t);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(t, r) {
    const { name: n = "Error", message: o = String(r), stack: a } = r, i = this.currentRender?.renderId;
    this.channel.emit(lL, { name: n, message: o, stack: a }), this.channel.emit(os, { newPhase: "errored", renderId: i, storyId: t }), this.view.showErrorDisplay(r), vt.error(`Error rendering story '${t}':`), vt.error(r);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(t, { title: r, description: n }) {
    const o = this.currentRender?.renderId;
    this.channel.emit(oL, { title: r, description: n }), this.channel.emit(os, { newPhase: "errored", renderId: o, storyId: t }), this.view.showErrorDisplay({ message: r, stack: n }), vt.error(`Error rendering story ${r}: ${n}`);
  }
};
c(Qz, "PreviewWithSelection");
var lye = Qz, H_ = or(uE(), 1), cye = or(uE(), 1), hR = /^[a-zA-Z0-9 _-]*$/, Zz = /^-?[0-9]+(\.[0-9]+)?$/, uye = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, eJ = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, V_ = /* @__PURE__ */ c((e = "", t) => e === null || e === "" || !hR.test(e) ? !1 : t == null || t instanceof Date || typeof t == "number" || typeof t == "boolean" ? !0 : typeof t == "string" ? hR.test(t) || Zz.test(t) || uye.test(t) || eJ.test(t) : Array.isArray(t) ? t.every((r) => V_(e, r)) : Kr(t) ? Object.entries(t).every(([r, n]) => V_(r, n)) : !1, "validateArgs"), dye = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: !0,
  arrayRepeat: !0,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(e) {
    if (e.startsWith("!")) {
      if (e === "!undefined")
        return;
      if (e === "!null")
        return null;
      if (e === "!true")
        return !0;
      if (e === "!false")
        return !1;
      if (e.startsWith("!date(") && e.endsWith(")"))
        return new Date(e.replaceAll(" ", "+").slice(6, -1));
      if (e.startsWith("!hex(") && e.endsWith(")"))
        return `#${e.slice(5, -1)}`;
      const t = e.slice(1).match(eJ);
      if (t)
        return e.startsWith("!rgba") || e.startsWith("!RGBA") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})` : e.startsWith("!hsla") || e.startsWith("!HSLA") ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})` : e.startsWith("!rgb") || e.startsWith("!RGB") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})` : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
    }
    return Zz.test(e) ? Number(e) : e;
  }
}, mR = /* @__PURE__ */ c((e) => {
  const t = e.split(";").map((r) => r.replace("=", "~").replace(":", "="));
  return Object.entries((0, cye.parse)(t.join(";"), dye)).reduce((r, [n, o]) => V_(n, o) ? Object.assign(r, { [n]: o }) : (Mt.warn(Ue`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), r), {});
}, "parseArgsParam"), { history: tJ, document: Na } = Ee;
function rJ(e) {
  const t = (e || "").match(/^\/story\/(.+)/);
  if (!t)
    throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
c(rJ, "pathToId");
var nJ = /* @__PURE__ */ c(({
  selection: e,
  extraParams: t
}) => {
  const r = Na?.location.search.slice(1), { path: n, selectedKind: o, selectedStory: a, ...i } = (0, H_.parse)(r);
  return `?${(0, H_.stringify)({
    ...i,
    ...t,
    ...e && { id: e.storyId, viewMode: e.viewMode }
  })}`;
}, "getQueryString"), pye = /* @__PURE__ */ c((e) => {
  if (!e)
    return;
  const t = nJ({ selection: e }), { hash: r = "" } = Na.location;
  Na.title = e.storyId, tJ.replaceState({}, "", `${Na.location.pathname}${t}${r}`);
}, "setPath"), fye = /* @__PURE__ */ c((e) => e != null && typeof e == "object" && Array.isArray(e) === !1, "isObject"), Hu = /* @__PURE__ */ c((e) => {
  if (e !== void 0) {
    if (typeof e == "string")
      return e;
    if (Array.isArray(e))
      return Hu(e[0]);
    if (fye(e))
      return Hu(
        Object.values(e).filter(Boolean)
      );
  }
}, "getFirstString"), hye = /* @__PURE__ */ c(() => {
  if (typeof Na < "u") {
    const e = Na.location.search.slice(1), t = (0, H_.parse)(e), r = typeof t.args == "string" ? mR(t.args) : void 0, n = typeof t.globals == "string" ? mR(t.globals) : void 0;
    let o = Hu(t.viewMode);
    (typeof o != "string" || !o.match(/docs|story/)) && (o = "story");
    const a = Hu(t.path), i = a ? rJ(a) : Hu(t.id);
    if (i)
      return { storySpecifier: i, args: r, globals: n, viewMode: o };
  }
  return null;
}, "getSelectionSpecifierFromPath"), oJ = class {
  constructor() {
    this.selectionSpecifier = hye();
  }
  setSelection(t) {
    this.selection = t, pye(this.selection);
  }
  setQueryParams(t) {
    const r = nJ({ extraParams: t }), { hash: n = "" } = Na.location;
    tJ.replaceState({}, "", `${Na.location.pathname}${r}${n}`);
  }
};
c(oJ, "UrlStore");
var mye = oJ, yye = or(foe(), 1), gye = or(uE(), 1), { document: vr } = Ee, yR = 100, aJ = /* @__PURE__ */ ((e) => (e.MAIN = "MAIN", e.NOPREVIEW = "NOPREVIEW", e.PREPARING_STORY = "PREPARING_STORY", e.PREPARING_DOCS = "PREPARING_DOCS", e.ERROR = "ERROR", e))(aJ || {}), hv = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
}, mv = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
}, gR = new yye.default({
  escapeXML: !0
}), iJ = class {
  constructor() {
    if (this.testing = !1, typeof vr < "u") {
      const { __SPECIAL_TEST_PARAMETER__: t } = (0, gye.parse)(vr.location.search.slice(1));
      switch (t) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = !0;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = !0;
          break;
        }
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(t) {
    return this.showStory(), this.applyLayout(t.parameters.layout), vr.documentElement.scrollTop = 0, vr.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return vr.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), vr.documentElement.scrollTop = 0, vr.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return vr.getElementById("storybook-docs");
  }
  applyLayout(t = "padded") {
    if (t === "none") {
      vr.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(t);
    const r = mv[t];
    vr.body.classList.remove(this.currentLayoutClass), vr.body.classList.add(r), this.currentLayoutClass = r;
  }
  checkIfLayoutExists(t) {
    mv[t] || vt.warn(
      Ue`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(mv).join(", ")}, none.
        `
    );
  }
  showMode(t) {
    clearTimeout(this.preparingTimeout), Object.keys(aJ).forEach((r) => {
      r === t ? vr.body.classList.add(hv[r]) : vr.body.classList.remove(hv[r]);
    });
  }
  showErrorDisplay({ message: t = "", stack: r = "" }) {
    let n = t, o = r;
    const a = t.split(`
`);
    a.length > 1 && ([n] = a, o = a.slice(1).join(`
`).replace(/^\n/, "")), vr.getElementById("error-message").innerHTML = gR.toHtml(n), vr.getElementById("error-stack").innerHTML = gR.toHtml(o), this.showMode(
      "ERROR"
      /* ERROR */
    );
  }
  showNoPreview() {
    this.testing || (this.showMode(
      "NOPREVIEW"
      /* NOPREVIEW */
    ), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: t = !1 } = {}) {
    clearTimeout(this.preparingTimeout), t ? this.showMode(
      "PREPARING_STORY"
      /* PREPARING_STORY */
    ) : this.preparingTimeout = setTimeout(
      () => this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      ),
      yR
    );
  }
  showPreparingDocs({ immediate: t = !1 } = {}) {
    clearTimeout(this.preparingTimeout), t ? this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ) : this.preparingTimeout = setTimeout(() => this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ), yR);
  }
  showMain() {
    this.showMode(
      "MAIN"
      /* MAIN */
    );
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    vr.body.classList.add(hv.MAIN);
  }
};
c(iJ, "WebView");
var bye = iJ, vye = class extends lye {
  constructor(e, t) {
    super(e, t, new mye(), new bye()), this.importFn = e, this.getProjectAnnotations = t, Ee.__STORYBOOK_PREVIEW__ = this;
  }
};
c(vye, "PreviewWeb");
var { document: Xi } = Ee, wye = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
], _ye = "script", bR = "scripts-root";
function z_() {
  const e = Xi.createEvent("Event");
  e.initEvent("DOMContentLoaded", !0, !0), Xi.dispatchEvent(e);
}
c(z_, "simulateDOMContentLoaded");
function sJ(e, t, r) {
  const n = Xi.createElement("script");
  n.type = e.type === "module" ? "module" : "text/javascript", e.src ? (n.onload = t, n.onerror = t, n.src = e.src) : n.textContent = e.innerText, r ? r.appendChild(n) : Xi.head.appendChild(n), e.parentNode.removeChild(e), e.src || t();
}
c(sJ, "insertScript");
function lA(e, t, r = 0) {
  e[r](() => {
    r++, r === e.length ? t() : lA(e, t, r);
  });
}
c(lA, "insertScriptsSequentially");
function Eye(e) {
  let t = Xi.getElementById(bR);
  t ? t.innerHTML = "" : (t = Xi.createElement("div"), t.id = bR, Xi.body.appendChild(t));
  const r = Array.from(e.querySelectorAll(_ye));
  if (r.length) {
    const n = [];
    r.forEach((o) => {
      const a = o.getAttribute("type");
      (!a || wye.includes(a)) && n.push((i) => sJ(o, i, t));
    }), n.length && lA(n, z_, void 0);
  } else
    z_();
}
c(Eye, "simulatePageLoad");
async function xye(e, t) {
  const r = t.parameters?.docs?.source?.transform, { id: n, unmappedArgs: o } = t, a = r && e ? r?.(e, t) : e, i = a ? await a : void 0;
  Fn.getChannel().emit(soe, {
    id: n,
    source: i,
    args: o
  });
}
c(xye, "emitTransformCode");
const yv = {
  xs: {
    name: "xs: 375px",
    styles: { width: "375px", height: "667px" }
  },
  mobile: {
    name: "mobile: 719px",
    styles: { width: "719px", height: "1024px" }
  },
  sm: {
    name: "sm: 720px",
    styles: { width: "720px", height: "1024px" }
  },
  md: {
    name: "md: 960px",
    styles: { width: "960px", height: "768px" }
  },
  lg: {
    name: "lg: 1280px",
    styles: { width: "1280px", height: "720px" }
  },
  xl: {
    name: "xl: 1440px",
    styles: { width: "1440px", height: "810px" }
  },
  xxl: {
    name: "xxl: 1920px",
    styles: { width: "1920px", height: "1080px" }
  }
};
Object.keys(yv).reduce(
  (e, t) => ({
    ...e,
    [t]: `${parseInt(yv[t].styles.width, 10)}x${parseInt(yv[t].styles.height, 10)}`
  }),
  {}
);
kme({
  name: "withScreenshot",
  parameterName: "screenshot",
  skipIfNoParametersOrOptions: !1,
  wrapper: (e, t, { parameters: r, options: n }) => {
    if (typeof process < "u" && (process == null ? void 0 : Mf.JEST_WORKER_ID) !== void 0)
      return e(t);
    const o = r || n;
    return rne.triggerScreenshot(o, t), e(t);
  }
});
const vR = (e, t) => {
  customElements.get(e) || customElements.define(e, t);
}, cg = (e) => (t, r) => {
  r !== void 0 ? r.addInitializer(() => {
    vR(e, t);
  }) : vR(e, t);
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const gf = globalThis, cA = gf.ShadowRoot && (gf.ShadyCSS === void 0 || gf.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, uA = Symbol(), wR = /* @__PURE__ */ new WeakMap();
let lJ = class {
  constructor(t, r, n) {
    if (this._$cssResult$ = !0, n !== uA) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = r;
  }
  get styleSheet() {
    let t = this.o;
    const r = this.t;
    if (cA && t === void 0) {
      const n = r !== void 0 && r.length === 1;
      n && (t = wR.get(r)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && wR.set(r, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Nt = (e) => new lJ(typeof e == "string" ? e : e + "", void 0, uA), Ut = (e, ...t) => {
  const r = e.length === 1 ? e[0] : t.reduce(((n, o, a) => n + ((i) => {
    if (i._$cssResult$ === !0) return i.cssText;
    if (typeof i == "number") return i;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + i + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(o) + e[a + 1]), e[0]);
  return new lJ(r, e, uA);
}, Sye = (e, t) => {
  if (cA) e.adoptedStyleSheets = t.map(((r) => r instanceof CSSStyleSheet ? r : r.styleSheet));
  else for (const r of t) {
    const n = document.createElement("style"), o = gf.litNonce;
    o !== void 0 && n.setAttribute("nonce", o), n.textContent = r.cssText, e.appendChild(n);
  }
}, _R = cA ? (e) => e : (e) => e instanceof CSSStyleSheet ? ((t) => {
  let r = "";
  for (const n of t.cssRules) r += n.cssText;
  return Nt(r);
})(e) : e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Tye, defineProperty: Aye, getOwnPropertyDescriptor: $ye, getOwnPropertyNames: Cye, getOwnPropertySymbols: kye, getPrototypeOf: Pye } = Object, ug = globalThis, ER = ug.trustedTypes, Oye = ER ? ER.emptyScript : "", Rye = ug.reactiveElementPolyfillSupport, Vu = (e, t) => e, Oh = { toAttribute(e, t) {
  switch (t) {
    case Boolean:
      e = e ? Oye : null;
      break;
    case Object:
    case Array:
      e = e == null ? e : JSON.stringify(e);
  }
  return e;
}, fromAttribute(e, t) {
  let r = e;
  switch (t) {
    case Boolean:
      r = e !== null;
      break;
    case Number:
      r = e === null ? null : Number(e);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(e);
      } catch {
        r = null;
      }
  }
  return r;
} }, dA = (e, t) => !Tye(e, t), xR = { attribute: !0, type: String, converter: Oh, reflect: !1, hasChanged: dA };
Symbol.metadata ??= Symbol("metadata"), ug.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
let Qs = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, r = xR) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.elementProperties.set(t, r), !r.noAccessor) {
      const n = Symbol(), o = this.getPropertyDescriptor(t, n, r);
      o !== void 0 && Aye(this.prototype, t, o);
    }
  }
  static getPropertyDescriptor(t, r, n) {
    const { get: o, set: a } = $ye(this.prototype, t) ?? { get() {
      return this[r];
    }, set(i) {
      this[r] = i;
    } };
    return { get() {
      return o?.call(this);
    }, set(i) {
      const s = o?.call(this);
      a.call(this, i), this.requestUpdate(t, s, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? xR;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Vu("elementProperties"))) return;
    const t = Pye(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Vu("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Vu("properties"))) {
      const r = this.properties, n = [...Cye(r), ...kye(r)];
      for (const o of n) this.createProperty(o, r[o]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const r = litPropertyMetadata.get(t);
      if (r !== void 0) for (const [n, o] of r) this.elementProperties.set(n, o);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const o = this._$Eu(r, n);
      o !== void 0 && this._$Eh.set(o, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const r = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const o of n) r.unshift(_R(o));
    } else t !== void 0 && r.push(_R(t));
    return r;
  }
  static _$Eu(t, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t) => t(this)));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Sye(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((t) => t.hostConnected?.()));
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t) => t.hostDisconnected?.()));
  }
  attributeChangedCallback(t, r, n) {
    this._$AK(t, n);
  }
  _$EC(t, r) {
    const n = this.constructor.elementProperties.get(t), o = this.constructor._$Eu(t, n);
    if (o !== void 0 && n.reflect === !0) {
      const a = (n.converter?.toAttribute !== void 0 ? n.converter : Oh).toAttribute(r, n.type);
      this._$Em = t, a == null ? this.removeAttribute(o) : this.setAttribute(o, a), this._$Em = null;
    }
  }
  _$AK(t, r) {
    const n = this.constructor, o = n._$Eh.get(t);
    if (o !== void 0 && this._$Em !== o) {
      const a = n.getPropertyOptions(o), i = typeof a.converter == "function" ? { fromAttribute: a.converter } : a.converter?.fromAttribute !== void 0 ? a.converter : Oh;
      this._$Em = o, this[o] = i.fromAttribute(r, a.type), this._$Em = null;
    }
  }
  requestUpdate(t, r, n) {
    if (t !== void 0) {
      if (n ??= this.constructor.getPropertyOptions(t), !(n.hasChanged ?? dA)(this[t], r)) return;
      this.P(t, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, r, n) {
    this._$AL.has(t) || this._$AL.set(t, r), n.reflect === !0 && this._$Em !== t && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [o, a] of this._$Ep) this[o] = a;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0) for (const [o, a] of n) a.wrapped !== !0 || this._$AL.has(o) || this[o] === void 0 || this.P(o, this[o], a);
    }
    let t = !1;
    const r = this._$AL;
    try {
      t = this.shouldUpdate(r), t ? (this.willUpdate(r), this._$EO?.forEach(((n) => n.hostUpdate?.())), this.update(r)) : this._$EU();
    } catch (n) {
      throw t = !1, this._$EU(), n;
    }
    t && this._$AE(r);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach(((r) => r.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej &&= this._$Ej.forEach(((r) => this._$EC(r, this[r]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Qs.elementStyles = [], Qs.shadowRootOptions = { mode: "open" }, Qs[Vu("elementProperties")] = /* @__PURE__ */ new Map(), Qs[Vu("finalized")] = /* @__PURE__ */ new Map(), Rye?.({ ReactiveElement: Qs }), (ug.reactiveElementVersions ??= []).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const pA = globalThis, Rh = pA.trustedTypes, SR = Rh ? Rh.createPolicy("lit-html", { createHTML: (e) => e }) : void 0, cJ = "$lit$", $a = `lit$${Math.random().toFixed(9).slice(2)}$`, uJ = "?" + $a, jye = `<${uJ}>`, hs = document, $d = () => hs.createComment(""), Cd = (e) => e === null || typeof e != "object" && typeof e != "function", fA = Array.isArray, Iye = (e) => fA(e) || typeof e?.[Symbol.iterator] == "function", gv = `[ 	
\f\r]`, ou = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, TR = /-->/g, AR = />/g, ki = RegExp(`>|${gv}(?:([^\\s"'>=/]+)(${gv}*=${gv}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), $R = /'/g, CR = /"/g, dJ = /^(?:script|style|textarea|title)$/i, pJ = (e) => (t, ...r) => ({ _$litType$: e, strings: t, values: r }), be = pJ(1), Nye = pJ(2), Wa = Symbol.for("lit-noChange"), It = Symbol.for("lit-nothing"), kR = /* @__PURE__ */ new WeakMap(), Ui = hs.createTreeWalker(hs, 129);
function fJ(e, t) {
  if (!fA(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return SR !== void 0 ? SR.createHTML(t) : t;
}
const Mye = (e, t) => {
  const r = e.length - 1, n = [];
  let o, a = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", i = ou;
  for (let s = 0; s < r; s++) {
    const d = e[s];
    let l, p, f = -1, h = 0;
    for (; h < d.length && (i.lastIndex = h, p = i.exec(d), p !== null); ) h = i.lastIndex, i === ou ? p[1] === "!--" ? i = TR : p[1] !== void 0 ? i = AR : p[2] !== void 0 ? (dJ.test(p[2]) && (o = RegExp("</" + p[2], "g")), i = ki) : p[3] !== void 0 && (i = ki) : i === ki ? p[0] === ">" ? (i = o ?? ou, f = -1) : p[1] === void 0 ? f = -2 : (f = i.lastIndex - p[2].length, l = p[1], i = p[3] === void 0 ? ki : p[3] === '"' ? CR : $R) : i === CR || i === $R ? i = ki : i === TR || i === AR ? i = ou : (i = ki, o = void 0);
    const m = i === ki && e[s + 1].startsWith("/>") ? " " : "";
    a += i === ou ? d + jye : f >= 0 ? (n.push(l), d.slice(0, f) + cJ + d.slice(f) + $a + m) : d + $a + (f === -2 ? s : m);
  }
  return [fJ(e, a + (e[r] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
let J_ = class hJ {
  constructor({ strings: t, _$litType$: r }, n) {
    let o;
    this.parts = [];
    let a = 0, i = 0;
    const s = t.length - 1, d = this.parts, [l, p] = Mye(t, r);
    if (this.el = hJ.createElement(l, n), Ui.currentNode = this.el.content, r === 2 || r === 3) {
      const f = this.el.content.firstChild;
      f.replaceWith(...f.childNodes);
    }
    for (; (o = Ui.nextNode()) !== null && d.length < s; ) {
      if (o.nodeType === 1) {
        if (o.hasAttributes()) for (const f of o.getAttributeNames()) if (f.endsWith(cJ)) {
          const h = p[i++], m = o.getAttribute(f).split($a), g = /([.?@])?(.*)/.exec(h);
          d.push({ type: 1, index: a, name: g[2], strings: m, ctor: g[1] === "." ? qye : g[1] === "?" ? Lye : g[1] === "@" ? Fye : dg }), o.removeAttribute(f);
        } else f.startsWith($a) && (d.push({ type: 6, index: a }), o.removeAttribute(f));
        if (dJ.test(o.tagName)) {
          const f = o.textContent.split($a), h = f.length - 1;
          if (h > 0) {
            o.textContent = Rh ? Rh.emptyScript : "";
            for (let m = 0; m < h; m++) o.append(f[m], $d()), Ui.nextNode(), d.push({ type: 2, index: ++a });
            o.append(f[h], $d());
          }
        }
      } else if (o.nodeType === 8) if (o.data === uJ) d.push({ type: 2, index: a });
      else {
        let f = -1;
        for (; (f = o.data.indexOf($a, f + 1)) !== -1; ) d.push({ type: 7, index: a }), f += $a.length - 1;
      }
      a++;
    }
  }
  static createElement(t, r) {
    const n = hs.createElement("template");
    return n.innerHTML = t, n;
  }
};
function Yl(e, t, r = e, n) {
  if (t === Wa) return t;
  let o = n !== void 0 ? r._$Co?.[n] : r._$Cl;
  const a = Cd(t) ? void 0 : t._$litDirective$;
  return o?.constructor !== a && (o?._$AO?.(!1), a === void 0 ? o = void 0 : (o = new a(e), o._$AT(e, r, n)), n !== void 0 ? (r._$Co ??= [])[n] = o : r._$Cl = o), o !== void 0 && (t = Yl(e, o._$AS(e, t.values), o, n)), t;
}
class Dye {
  constructor(t, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: r }, parts: n } = this._$AD, o = (t?.creationScope ?? hs).importNode(r, !0);
    Ui.currentNode = o;
    let a = Ui.nextNode(), i = 0, s = 0, d = n[0];
    for (; d !== void 0; ) {
      if (i === d.index) {
        let l;
        d.type === 2 ? l = new hA(a, a.nextSibling, this, t) : d.type === 1 ? l = new d.ctor(a, d.name, d.strings, this, t) : d.type === 6 && (l = new Uye(a, this, t)), this._$AV.push(l), d = n[++s];
      }
      i !== d?.index && (a = Ui.nextNode(), i++);
    }
    return Ui.currentNode = hs, o;
  }
  p(t) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, r), r += n.strings.length - 2) : n._$AI(t[r])), r++;
  }
}
let hA = class mJ {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, r, n, o) {
    this.type = 2, this._$AH = It, this._$AN = void 0, this._$AA = t, this._$AB = r, this._$AM = n, this.options = o, this._$Cv = o?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && t?.nodeType === 11 && (t = r.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, r = this) {
    t = Yl(this, t, r), Cd(t) ? t === It || t == null || t === "" ? (this._$AH !== It && this._$AR(), this._$AH = It) : t !== this._$AH && t !== Wa && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Iye(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== It && Cd(this._$AH) ? this._$AA.nextSibling.data = t : this.T(hs.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: r, _$litType$: n } = t, o = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = J_.createElement(fJ(n.h, n.h[0]), this.options)), n);
    if (this._$AH?._$AD === o) this._$AH.p(r);
    else {
      const a = new Dye(o, this), i = a.u(this.options);
      a.p(r), this.T(i), this._$AH = a;
    }
  }
  _$AC(t) {
    let r = kR.get(t.strings);
    return r === void 0 && kR.set(t.strings, r = new J_(t)), r;
  }
  k(t) {
    fA(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, o = 0;
    for (const a of t) o === r.length ? r.push(n = new mJ(this.O($d()), this.O($d()), this, this.options)) : n = r[o], n._$AI(a), o++;
    o < r.length && (this._$AR(n && n._$AB.nextSibling, o), r.length = o);
  }
  _$AR(t = this._$AA.nextSibling, r) {
    for (this._$AP?.(!1, !0, r); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
}, dg = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, r, n, o, a) {
    this.type = 1, this._$AH = It, this._$AN = void 0, this.element = t, this.name = r, this._$AM = o, this.options = a, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = It;
  }
  _$AI(t, r = this, n, o) {
    const a = this.strings;
    let i = !1;
    if (a === void 0) t = Yl(this, t, r, 0), i = !Cd(t) || t !== this._$AH && t !== Wa, i && (this._$AH = t);
    else {
      const s = t;
      let d, l;
      for (t = a[0], d = 0; d < a.length - 1; d++) l = Yl(this, s[n + d], r, d), l === Wa && (l = this._$AH[d]), i ||= !Cd(l) || l !== this._$AH[d], l === It ? t = It : t !== It && (t += (l ?? "") + a[d + 1]), this._$AH[d] = l;
    }
    i && !o && this.j(t);
  }
  j(t) {
    t === It ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
class qye extends dg {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === It ? void 0 : t;
  }
}
class Lye extends dg {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== It);
  }
}
class Fye extends dg {
  constructor(t, r, n, o, a) {
    super(t, r, n, o, a), this.type = 5;
  }
  _$AI(t, r = this) {
    if ((t = Yl(this, t, r, 0) ?? It) === Wa) return;
    const n = this._$AH, o = t === It && n !== It || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, a = t !== It && (n === It || o);
    o && this.element.removeEventListener(this.name, this, n), a && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class Uye {
  constructor(t, r, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Yl(this, t);
  }
}
const Bye = pA.litHtmlPolyfillSupport;
Bye?.(J_, hA), (pA.litHtmlVersions ??= []).push("3.2.1");
const Hye = (e, t, r) => {
  const n = r?.renderBefore ?? t;
  let o = n._$litPart$;
  if (o === void 0) {
    const a = r?.renderBefore ?? null;
    n._$litPart$ = o = new hA(t.insertBefore($d(), a), a, void 0, r ?? {});
  }
  return o._$AI(e), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Rt = class extends Qs {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const r = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Hye(r, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return Wa;
  }
};
Rt._$litElement$ = !0, Rt.finalized = !0, globalThis.litElementHydrateSupport?.({ LitElement: Rt });
const Vye = globalThis.litElementPolyfillSupport;
Vye?.({ LitElement: Rt });
(globalThis.litElementVersions ??= []).push("4.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const zye = { attribute: !0, type: String, converter: Oh, reflect: !1, hasChanged: dA }, Jye = (e = zye, t, r) => {
  const { kind: n, metadata: o } = r;
  let a = globalThis.litPropertyMetadata.get(o);
  if (a === void 0 && globalThis.litPropertyMetadata.set(o, a = /* @__PURE__ */ new Map()), a.set(r.name, e), n === "accessor") {
    const { name: i } = r;
    return { set(s) {
      const d = t.get.call(this);
      t.set.call(this, s), this.requestUpdate(i, d, e);
    }, init(s) {
      return s !== void 0 && this.P(i, void 0, e), s;
    } };
  }
  if (n === "setter") {
    const { name: i } = r;
    return function(s) {
      const d = this[i];
      t.call(this, s), this.requestUpdate(i, d, e);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function ge(e) {
  return (t, r) => typeof r == "object" ? Jye(e, t, r) : ((n, o, a) => {
    const i = o.hasOwnProperty(a);
    return o.constructor.createProperty(a, i ? { ...n, wrapped: !0 } : n), i ? Object.getOwnPropertyDescriptor(o, a) : void 0;
  })(e, t, r);
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ar = (e) => e ?? It;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const yJ = { ATTRIBUTE: 1, CHILD: 2 }, gJ = (e) => (...t) => ({ _$litDirective$: e, values: t });
class bJ {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, r, n) {
    this._$Ct = t, this._$AM = r, this._$Ci = n;
  }
  _$AS(t, r) {
    return this.update(t, r);
  }
  update(t, r) {
    return this.render(...r);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let W_ = class extends bJ {
  constructor(t) {
    if (super(t), this.it = It, t.type !== yJ.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === It || t == null) return this._t = void 0, this.it = t;
    if (t === Wa) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const r = [t];
    return r.raw = r, this._t = { _$litType$: this.constructor.resultType, strings: r, values: [] };
  }
};
W_.directiveName = "unsafeHTML", W_.resultType = 1;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let G_ = class extends W_ {
};
G_.directiveName = "unsafeSVG", G_.resultType = 2;
const oo = gJ(G_);
var vJ = /* @__PURE__ */ ((e) => (e.NAV_FLYOUT_TOGGLE = "epic-wf-nav-flyout-toggle", e.NAV_MAIN_LINK_KEY_DOWN = "epic-wf-nav-main-link-key-down", e.DRAWER_TOGGLE = "toggle", e))(vJ || {});
const Wye = ":host{display:flex;fill:var(--color-text-primary, #ffffff)}:host svg,:host path{fill:inherit;transition:inherit}", Gye = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="none" viewBox="0 0 32 32">
  <path fill="#fff" d="M26.439 1.25c1.712 0 2.336.623 2.336 2.31v20.56c0 .265-.047.74-.133.944-.087.205-.167.371-.327.52-.164.153-.45.312-.587.375l-11.067 4.657a1.686 1.686 0 0 1-1.322 0L4.273 25.961a2.624 2.624 0 0 1-.586-.376c-.16-.149-.24-.315-.327-.519-.086-.203-.133-.68-.133-.944V3.56c0-1.687.624-2.31 2.336-2.31h20.875ZM11.845 26.07a.097.097 0 0 0-.029.019.096.096 0 0 0-.02.028.103.103 0 0 0-.007.035.09.09 0 0 0 .007.037.098.098 0 0 0 .049.046l4.007 1.7a.358.358 0 0 0 .28 0l4.038-1.7a.08.08 0 0 0 .028-.018.093.093 0 0 0 .02-.028.106.106 0 0 0 .007-.037.087.087 0 0 0-.027-.063.083.083 0 0 0-.063-.026H11.88a.089.089 0 0 0-.035.006ZM8.7 18.901c-.267 0-.516.046-.745.137-.23.092-.427.218-.593.38a1.79 1.79 0 0 0-.388.565c-.095.215-.141.45-.141.7v.011c0 .258.047.496.143.712.095.217.228.404.396.56.17.158.368.28.598.368.23.088.48.132.75.132.318 0 .602-.051.853-.152a2.54 2.54 0 0 0 .654-.378v-1.543H8.632v.698h.683v.416a.998.998 0 0 1-.554.141.992.992 0 0 1-.38-.07.874.874 0 0 1-.492-.498 1.03 1.03 0 0 1-.07-.382v-.01a.973.973 0 0 1 .257-.666.837.837 0 0 1 .629-.274c.172 0 .324.027.454.083.13.055.259.135.384.24l.565-.67a2.195 2.195 0 0 0-.612-.368 2.178 2.178 0 0 0-.796-.132Zm14.96.007a1.83 1.83 0 0 0-.561.081 1.281 1.281 0 0 0-.423.229.978.978 0 0 0-.268.347 1.054 1.054 0 0 0-.092.44v.012c0 .175.034.324.102.443.068.119.16.219.278.299.118.08.256.145.414.196.158.05.33.096.515.139.12.026.215.051.29.076.073.024.133.05.178.076a.254.254 0 0 1 .092.08c.016.027.025.06.025.096v.01a.193.193 0 0 1-.103.173.574.574 0 0 1-.293.062c-.404 0-.779-.138-1.125-.412l-.536.633c.215.189.463.33.742.425.278.095.573.142.883.142.212 0 .404-.024.576-.075.172-.051.319-.125.44-.22.123-.097.218-.214.286-.351.068-.137.102-.295.102-.471v-.01a.89.89 0 0 0-.09-.414.826.826 0 0 0-.257-.297 1.658 1.658 0 0 0-.41-.208 4.235 4.235 0 0 0-.537-.15 3.63 3.63 0 0 1-.294-.075 1.016 1.016 0 0 1-.184-.074.25.25 0 0 1-.095-.08.19.19 0 0 1-.027-.102v-.011c0-.062.03-.114.087-.156a.441.441 0 0 1 .26-.065c.155 0 .316.03.483.087.167.058.33.14.488.252l.48-.67a2.007 2.007 0 0 0-.63-.342 2.524 2.524 0 0 0-.797-.115Zm-13.127 3.486h1.012l.248-.614h1.338l.253.614h1.031l-1.477-3.455h-.927l-1.478 3.454Zm4.219 0h.941v-1.96l.883 1.332h.02l.887-1.342v1.97h.956v-3.43h-1.015l-.83 1.328-.826-1.327h-1.016v3.428Zm4.33 0h2.814v-.808h-1.863v-.544h1.665v-.75h-1.665v-.519h1.84v-.808h-2.791v3.428Zm-6.23-1.353h-.778l.39-.975.388.975Zm9.275-16.19c-1.42 0-2.123.695-2.123 2.101v7.305c0 1.406.703 2.1 2.124 2.1h.865c1.42 0 2.123-.695 2.123-2.1v-2.635h-1.715v2.554c0 .452-.212.662-.653.662h-.326c-.457 0-.67-.21-.67-.662V7.034c0-.453.212-.663.67-.663h.294c.44 0 .652.21.652.663v2.213h1.715v-2.31c0-1.406-.686-2.085-2.106-2.085h-.85Zm-15.21 11.41h3.919v-1.568H8.664v-3.409h2.058V9.717H8.664v-3.2h2.139V4.95H6.917v11.312Zm4.763 0h1.747v-4.105h.996c1.42 0 2.123-.694 2.123-2.1V7.05c0-1.407-.702-2.1-2.123-2.1H11.68v11.31ZM17.334 4.95v11.312h1.747V4.95h-1.747Zm-3.19 1.519c.441 0 .654.21.654.662v2.845c0 .452-.212.663-.653.663h-.718v-4.17h.718Z"/>
</svg>
`;
var Kye = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let K_ = class extends Rt {
  render() {
    return be` ${oo(Gye)} `;
  }
};
K_.styles = Ut`
		${Nt(Wye)}
	`;
K_ = Kye([
  cg("epic-wf-shield")
], K_);
const jo = {
  en: "en-US"
}, bv = { en: "en-US", "zh-TW": "zh-Hant" }, PR = {
  ar: "ar-ar",
  de: "de-de",
  en: "en-us",
  "en-US": "en-us",
  "es-ES": "es-es",
  "es-MX": "es-mx",
  fr: "fr-fr",
  it: "it-it",
  ja: "ja-jp",
  ko: "ko-kr",
  pl: "pl-pl",
  "pt-BR": "pt-br",
  ru: "ru-ru",
  tr: "tr-tr",
  "zh-CN": "zh-cn"
}, vv = {
  ue: jo,
  fn: jo,
  fg: jo,
  rl: {},
  egs: bv,
  sketch: {},
  artstation: {},
  fab: jo,
  createfn: {},
  tm: jo,
  realityscan: jo,
  realitycapture: {},
  eos: jo,
  devportal: bv,
  superawesome: jo,
  sac: jo,
  ssp: bv,
  edc: PR,
  communities: PR
}, kr = {
  ue: ["en", "de", "es-ES", "fr", "ja", "ko", "pt-BR", "zh-CN"],
  // 8
  eos: ["en", "ja", "ko", "zh-CN"],
  // 4
  fn: ["en", "ar", "de", "es-ES", "es-MX", "fr", "it", "ja", "ko", "pl", "pt-BR", "ru", "tr"],
  // 13
  eg: ["en", "ar", "de", "es-ES", "es-MX", "fr", "it", "ja", "ko", "pl", "pt-BR", "ru", "th", "tr", "zh-CN", "zh-TW"],
  // 16
  egs: [
    "en",
    "ar",
    "bg",
    "cs",
    "da",
    "de",
    "es-ES",
    "es-MX",
    "fi",
    "fil",
    "fr",
    "hi",
    "hu",
    "id",
    "it",
    "ja",
    "ko",
    "ms",
    "nl",
    "no",
    "pl",
    "pt",
    "pt-BR",
    "ro",
    "ru",
    "sv",
    "th",
    "tr",
    "uk",
    "vi",
    "zh-CN",
    "zh-TW"
  ],
  // 32
  ssp: [
    "en",
    "ar",
    "ca",
    "da",
    "de",
    "es-ES",
    "es-MX",
    "fr",
    "it",
    "ja",
    "ko",
    "nl",
    "pl",
    "pt-BR",
    "ro",
    "ru",
    "sv",
    "th",
    "tr",
    "uk",
    "zh-CN",
    "zh-TW"
  ],
  // 22
  sac: ["en", "ar", "es-ES", "es-MX", "de", "fr", "it", "ja", "ko", "pl", "pt-BR", "ru", "tr"],
  // 13
  edc: ["en", "de", "es-ES", "es-MX", "fr", "it", "ja", "ko", "pl", "pt-BR", "ru", "tr", "zh-CN"]
}, wv = ["en"], Yye = {
  ue: kr.ue,
  fn: kr.fn,
  fg: ["en", "de", "es-ES", "es-MX", "fr", "it", "ja", "ko", "pl", "pt-BR", "ru", "zh-CN"],
  rl: ["en", "de", "fr", "pt-BR", "it", "es-MX", "es-ES"],
  egs: kr.egs,
  sketch: wv,
  artstation: wv,
  fab: kr.ue,
  createfn: kr.fn,
  tm: kr.ue,
  realityscan: kr.ue,
  realitycapture: wv,
  eos: kr.eos,
  devportal: kr.eg,
  superawesome: kr.ue,
  sac: kr.sac,
  ssp: kr.ssp,
  edc: kr.edc,
  communities: kr.edc
}, Xye = '.visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}svg{fill:currentColor}svg[viewBox="0 0 24 24"]{inline-size:1.5rem;block-size:1.5rem}svg[viewBox="0 0 20 20"]{inline-size:1.25rem;block-size:1.25rem}svg{color:var(--color-icon-primary, #ffffff)}:host{z-index:1000;position:relative}@media (max-width: 719.9px){:host{position:static}}.nav-flyout-toggle{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none;position:relative;z-index:2;align-items:center;display:flex;gap:.125rem}.nav-flyout-toggle>*{pointer-events:none}.nav-flyout-toggle:not([disabled]){cursor:pointer}.nav-flyout-toggle:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}.nav-flyout-toggle epic-wf-shield{height:2rem;width:2rem;color:var(--color-text-primary, #ffffff);transition:transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.nav-flyout-toggle.active .icon,.nav-flyout-toggle:active .icon{transform:rotate(180deg)}.nav-flyout-toggle:focus-within{outline-offset:.125rem}@media (min-width: 720px){.nav-flyout-toggle{padding-inline-end:.25rem}.nav-flyout-toggle:hover svg,.nav-flyout-toggle:hover epic-wf-shield,.nav-flyout-toggle.active svg,.nav-flyout-toggle.active epic-wf-shield,.nav-flyout-toggle:active svg,.nav-flyout-toggle:active epic-wf-shield{color:var(--color-text-secondary, rgba(255, 255, 255, .65));fill:var(--color-text-secondary, rgba(255, 255, 255, .65))}}.nav-flyout-toggle .icon{transition:transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));display:flex;align-items:center;width:.75rem;height:.75rem}.nav-flyout-toggle .icon svg{width:.75rem;height:.75rem}@media (max-width: 719.9px){.nav-flyout-toggle~.nav-flyout-header,.nav-flyout-toggle~.nav-flyout-menu{--nav-flyout-mobile-offset: -2.5rem;display:inline-flex;transition:visibility var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.nav-flyout-toggle~.nav-flyout-menu{transform:translate(0) translateY(calc(var(--nav-flyout-mobile-offset) - var(--drawer-padding-block-start)))}.nav-flyout-toggle~.nav-flyout-menu,.nav-flyout-toggle~.nav-flyout-menu li{transition:opacity var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),visibility var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.nav-flyout-toggle~.nav-flyout-menu li{visibility:hidden}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(1){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 1))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(2){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 2))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(3){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 3))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(4){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 4))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(5){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 5))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(6){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 6))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(7){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 7))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(8){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 8))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(9){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 9))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(10){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 10))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(11){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 11))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(12){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 12))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(13){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 13))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(14){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 14))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(15){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 15))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(16){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 16))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(17){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 17))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(18){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 18))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(19){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 19))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(20){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 20))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(21){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 21))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(22){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 22))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(23){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 23))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(24){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 24))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(25){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 25))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(26){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 26))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(27){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 27))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(28){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 28))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(29){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 29))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(30){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 30))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(31){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 31))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(32){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 32))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(33){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 33))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(34){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 34))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(35){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 35))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(36){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 36))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(37){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 37))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(38){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 38))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(39){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 39))}.nav-flyout-toggle~.nav-flyout-menu li:nth-child(40){opacity:0;transform:translate(0) translateY(calc(var(--main-nav-mobile-offset) * 40))}.nav-flyout-toggle:not(.active)~.nav-flyout-header,.nav-flyout-toggle:not(.active)~.nav-flyout-menu{opacity:0;pointer-events:none;visibility:hidden}.nav-flyout-toggle.active~.nav-flyout-header,.nav-flyout-toggle.active~.nav-flyout-menu{z-index:1;opacity:1;visibility:visible;transform:translate(0) translateY(0)}.nav-flyout-toggle.active~.nav-flyout-header li,.nav-flyout-toggle.active~.nav-flyout-menu li{opacity:1;visibility:visible;transform:translate(0) translateY(0)}}.nav-flyout-header{display:none;background:var(--color-background-default, #101014);position:absolute;inset-block-start:0rem;inset-inline:0;width:100vw;max-width:100%;height:var(--header-height, 4.5rem);z-index:1;box-sizing:border-box;padding-inline:var(--header-padding-inline, 1rem);justify-content:end;align-items:center}.nav-flyout-menu{list-style:none;margin:0;padding:0;z-index:-1;box-sizing:border-box;align-items:flex-start;color:var(--color-text-primary, #ffffff);flex-direction:column;flex-wrap:nowrap;inset-block-start:2.5625rem;inset-inline-start:-1rem;--drawer-padding-inline: 0rem;--drawer-padding-block-end: 0rem;--drawer-padding-block-start: 0rem;padding-inline:var(--drawer-padding-inline);padding-block-end:var(--drawer-padding-block-end);padding-block-start:var(--drawer-padding-block-start);position:absolute;display:inline-flex;max-height:calc(100dvh - var(--header-height, 4.5rem));overscroll-behavior:contain;overflow-y:scroll;overflow-x:hidden;scrollbar-width:none;-ms-overflow-style:none}@media (max-width: 719.9px){.nav-flyout-menu{gap:2.5rem;--drawer-padding-inline: 4rem;--drawer-padding-block-end: 4rem;--drawer-padding-block-start: 4rem;inset-block-start:var(--header-height, 4.5rem);inset-inline:0;height:100vh;background:var(--color-background-default, #101014)}}@media (max-width: 719.9px){.nav-flyout-menu{--drawer-padding-inline: 1rem;--drawer-padding-block-end: 1rem;--drawer-padding-block-start: 1rem}}.nav-flyout-menu::-webkit-scrollbar{display:none}@media (min-width: 720px){.nav-flyout-menu{background:var(--color-background-transparent-menu, rgba(48, 48, 52, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));border-radius:var(--size-border-radius-16, 16px);border:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1));box-shadow:0 32px 16px #0000001a,0 16px 8px #0000001a,0 8px 4px #0000001a,0 4px 2px #0000001a,0 2px 1px #0000001a;flex-wrap:wrap;max-height:37.5rem;width:38.75rem}.nav-flyout-menu:not(.active){display:none;pointer-events:none}.nav-flyout-menu:active{display:inline-flex}}.nav-flyout-menu__section{max-width:100%;width:100%}@media (min-width: 720px){.nav-flyout-menu__section{width:13.75rem;max-width:17.5rem;padding:2rem}.nav-flyout-menu__section[data-flyout-section="0"]{border-bottom:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1))}.nav-flyout-menu__section[data-flyout-section="2"]{flex:1;border-left:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1));width:17.5rem}}.nav-flyout-menu__headline{font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:120%;letter-spacing:-.005rem;font-size:1.25rem;letter-spacing:-.01875rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--color-text-primary, #ffffff);display:flex;margin-block-start:0;margin-block-end:.625rem;padding-inline-start:.375rem}.nav-flyout-menu__list{list-style:none;margin:0;padding:0}.nav-flyout-menu__list-item a{transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;gap:.75rem;height:2.5rem;margin-inline:-.25rem;padding-block:.25rem;padding-inline:.625rem;text-decoration:none;-webkit-user-select:none;user-select:none;width:calc(100% + .5rem)}.nav-flyout-menu__list-item a:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}.nav-flyout-menu__list-item a:hover{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.nav-flyout-menu__list-item a .logo{background-color:var(--color-text-primary, #ffffff);background-position:center;flex-shrink:0;height:1.25rem;width:1.25rem;mask-position:center;mask-repeat:no-repeat;mask-size:cover;-webkit-mask-position:center;-webkit-mask-repeat:no-repeat;-webkit-mask-size:cover}.nav-flyout-menu__list-item a .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media (max-width: 719.9px){.nav-flyout-menu__list-item a{height:3rem;padding-block:.75rem;padding-inline:.5rem;margin-inline:0}.nav-flyout-menu__list-item a .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}.nav-flyout-menu__list-item a .logo{height:1.5rem;width:1.5rem}}.nav-flyout-menu .menu-heading{font-family:Inter,sans-serif;font-style:normal;font-size:2rem;font-weight:900;line-height:100%;letter-spacing:-.07rem;color:var(--color-text-primary, #ffffff);align-self:start;padding-inline:.5rem}.nav-flyout-menu .menu-heading h2{margin:0;font-weight:inherit;font-size:inherit}@media (min-width: 720px){.nav-flyout-menu .menu-heading{display:none}}', Qye = (e) => {
  if (!e) return "";
  const t = new URL(e);
  return t.searchParams.delete("locale"), t.searchParams.delete("lang"), t.toString();
}, Zye = (e, t) => {
  if (!e || !t || typeof t != "string")
    return !1;
  const r = t.replace(/_/g, "-").toLowerCase();
  return r ? (Yye[e] || []).map((n) => n.replace(/_/g, "-").toLowerCase()).includes(r) : !1;
};
var ege = Object.defineProperty, tge = Object.getOwnPropertyDescriptor, Oc = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? tge(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && ege(t, r, o), o;
};
let Ga = class extends Rt {
  constructor() {
    super(...arguments), this.active = !1, this.buttonLabel = "Epic Games", this.mobileFlyoutMenuHeading = "Epic Games", this.disabled = !1, this.sections = new Array();
  }
  _click(t) {
    this.dispatchEvent(new CustomEvent(vJ.NAV_FLYOUT_TOGGLE));
  }
  _getMappedHygraphLocale(t, r) {
    if (vv && t && vv[t]) {
      const n = vv[t];
      if (n && typeof n[r] < "u")
        return n[r];
    }
    return r;
  }
  render() {
    const t = this.buttonLabel || "Epic Ecosystem Dropdown";
    return be`
			<button
				@click=${this._click}
				?disabled=${this.disabled}
				aria-controls="nav-flyout-menu"
				aria-expanded=${this.active}
				aria-haspopup="true"
				aria-label=${t}
				class="nav-flyout-toggle ${this.active ? "active" : ""}"
				id="nav-flyout-toggle"
			>
				<epic-wf-shield aria-hidden="true"></epic-wf-shield>
				${this.disabled ? null : be`<span aria-hidden="true" class="icon">${oo(QN)}</span>`}
			</button>
			<slot></slot>
			<div class="nav-flyout-header">
				<button
					aria-controls="nav-flyout-menu"
					aria-expanded=${this.active}
					aria-label=${t}
					class="nav-flyout-toggle nav-flyout-close"
					id="nav-flyout-close"
					@click=${this._click}
				>
					${oo(ZN)}
				</button>
			</div>
			<ul
				aria-labelledby="nav-flyout-toggle"
				class="nav-flyout-menu ${this.active ? "active" : ""}"
				id="nav-flyout-menu"
				role="menu"
			>
				<li class="menu-heading"><h2>${this.mobileFlyoutMenuHeading || "Epic Games"}</h2></li>
				${this.sections.map((r, n) => {
      const o = r?.items || [];
      return be`
						<li class="nav-flyout-menu__section" data-flyout-section=${n} role="none">
							<h3 id="${Ar(r.headline)}" class="nav-flyout-menu__headline">
								${Ar(r.headline)}
							</h3>
							<ul aria-labelledby="${Ar(r.headline)}" class="nav-flyout-menu__list" role="menu">
								${o.map((a) => {
        const i = a.logo?.url, s = `
										mask-image: url(${i});
										-webkit-mask-image: url(${i});
									`, d = fo({
          hrefTemplate: a?.hrefTemplate,
          locale: this._getMappedHygraphLocale(a.key, a.locale)
        });
        let l = d;
        return Zye(a.key, a.locale) || (l = Qye(d)), be`
										<li class="nav-flyout-menu__list-item" role="none">
											<a href=${l} role="menuitem">
												<div class="logo" style="${s}"></div>
												<span class="label">${Ar(a.label)}</span>
											</a>
										</li>
									`;
      })}
							</ul>
						</li>
					`;
    })}
			</ul>
		`;
  }
};
Ga.styles = Ut`
		${Nt(Xye)}
	`;
Oc([
  ge({ type: Boolean, converter: Cr, reflect: !0 })
], Ga.prototype, "active", 2);
Oc([
  ge()
], Ga.prototype, "buttonLabel", 2);
Oc([
  ge()
], Ga.prototype, "mobileFlyoutMenuHeading", 2);
Oc([
  ge({ type: Boolean, converter: Cr })
], Ga.prototype, "disabled", 2);
Oc([
  ge({ type: Array })
], Ga.prototype, "sections", 2);
Ga = Oc([
  cg("epic-wf-nav-flyout-menu")
], Ga);
const OR = (e, t) => {
  customElements.get(e) || customElements.define(e, t);
}, rge = (e) => (t, r) => {
  r !== void 0 ? r.addInitializer(() => {
    OR(e, t);
  }) : OR(e, t);
}, nge = ":host{fill:var(--color-icon-primary, #ffffff);display:flex;box-sizing:border-box}:host svg{height:100%;width:100%}:host([textcolor=primary]){fill:var(--color-svg-primary, #ffffff)}:host([textcolor=secondary]){fill:var(--color-svg-secondary, rgba(255, 255, 255, .65))}:host([textcolor=disabled]){fill:var(--color-svg-disabled, rgba(255, 255, 255, .65))}:host([textcolor=link]){fill:var(--color-svg-link, #26bbff)}:host([textcolor=select]){fill:var(--color-svg-select, #26bbff)}:host([textcolor=success]){fill:var(--color-svg-success, #45c761)}:host([textcolor=warning]){fill:var(--color-svg-warning, #ffc229)}:host([textcolor=critical]){fill:var(--color-svg-critical, #ff6173)}:host([textcolor=onAccent]){fill:var(--color-svg-onAccent, #000000)}:host([textcolor=contrast]){fill:var(--color-svg-contrast, #ffffff)}:host([accentcolor=blue]){fill:var(--color-svg-blue, #26bbff)}:host([accentcolor=lime]){fill:var(--color-svg-lime, #a9d34f)}:host([accentcolor=yellow]){fill:var(--color-svg-yellow, #ffc229)}:host([accentcolor=red]){fill:var(--color-svg-red, #ff3f56)}:host([accentcolor=pink]){fill:var(--color-svg-pink, #fe54ba)}:host([accentcolor=purple]){fill:var(--color-svg-purple, #be3dff)}:host([accentcolor=indigo]){fill:var(--color-svg-indigo, #7371ff)}:host([accentcolor=cyan]){fill:var(--color-svg-cyan, #43dac2)}:host([accentcolor=green]){fill:var(--color-svg-green, #45c761)}:host([accentcolor=amber]){fill:var(--color-svg-amber, #ff8e1f)}:host([accentcolor=orange]){fill:var(--color-svg-orange, #fd6535)}:host([accentcolor=brown]){fill:var(--color-svg-brown, #b2715d)}:host([accentcolor=epicgames]){fill:var(--color-svg-epicgames, #26bbff)}:host([accentcolor=fallguys]){fill:var(--color-svg-fallguys, #60e9ff)}:host([accentcolor=fortnite]){fill:var(--color-svg-fortnite, #f7ff1a)}:host([accentcolor=rocketleague]){fill:var(--color-svg-rocketleague, #faa41a)}:host([accentcolor=twinmotion]){fill:var(--color-svg-twinmotion, #f43c9c)}", oge = async (e) => {
  if (!e)
    return null;
  let t;
  switch (e) {
    case "a_slash_b":
      return t = await import("./a-slash-b.W_Cnlyu--W_Cnlyu-.mjs"), v(t.default);
    case "accessibility_filled":
      return t = await import("./accessibility-filled.BpUfcCi1-CmHLb0e0.mjs"), v(t.default);
    case "accessibility":
      return t = await import("./accessibility.CiYAgPVJ-CiYAgPVJ.mjs"), v(t.default);
    case "adobe_illustrator":
      return t = await import("./adobe-illustrator.IidBePh6-IidBePh6.mjs"), v(t.default);
    case "adobe_photoshop":
      return t = await import("./adobe-photoshop.2iG9QE1z-2iG9QE1z.mjs"), v(t.default);
    case "adobe_substance_3d_modeler":
      return t = await import("./adobe-substance-3d-modeler.VcrLkuc0-VcrLkuc0.mjs"), v(t.default);
    case "adobe_substance_3d_painter":
      return t = await import("./adobe-substance-3d-painter.BZzn4qo6-BZzn4qo6.mjs"), v(t.default);
    case "ai_filled":
      return t = await import("./ai-filled.BErCIJiF-BErCIJiF.mjs"), v(t.default);
    case "ai":
      return t = await import("./ai.Bgv4etct-Bgv4etct.mjs"), v(t.default);
    case "alarm_clock_filled":
      return t = await import("./alarm-clock-filled.DR1Kg3eo-DR1Kg3eo.mjs"), v(t.default);
    case "alarm_clock":
      return t = await import("./alarm-clock.C8lJX-dg-C8lJX-dg.mjs"), v(t.default);
    case "alternating_diagonal_lines_square_filled":
      return t = await import("./alternating-diagonal-lines-square-filled.Cg-V8g2l-Cg-V8g2l.mjs"), v(t.default);
    case "alternating_diagonal_lines_square":
      return t = await import("./alternating-diagonal-lines-square.N0bjlMyx-N0bjlMyx.mjs"), v(t.default);
    case "anchor":
      return t = await import("./anchor.CQwbs9ND-CQwbs9ND.mjs"), v(t.default);
    case "android":
      return t = await import("./android.BF0zUxsY-BF0zUxsY.mjs"), v(t.default);
    case "ao":
      return t = await import("./ao.DcOfCo0b-DcOfCo0b.mjs"), v(t.default);
    case "apple":
      return t = await import("./apple.JcvTJZ_p-JcvTJZ_p.mjs"), v(t.default);
    case "archive_filled":
      return t = await import("./archive-filled.Dmouv6ix-Dmouv6ix.mjs"), v(t.default);
    case "archive":
      return t = await import("./archive.CsTr22ap-CsTr22ap.mjs"), v(t.default);
    case "arrow_down_circle_filled":
      return t = await import("./arrow-down-circle-filled.iBUoeEcn-iBUoeEcn.mjs"), v(t.default);
    case "arrow_down_circle":
      return t = await import("./arrow-down-circle.D55Wd9fb-D55Wd9fb.mjs"), v(t.default);
    case "arrow_down_list_wide_to_narrow":
      return t = await import("./arrow-down-list-wide-to-narrow.BByDbFwp-BByDbFwp.mjs"), v(t.default);
    case "arrow_down_right_arrow_up_left":
      return t = await import("./arrow-down-right-arrow-up-left.k3VYiLki-k3VYiLki.mjs"), v(t.default);
    case "arrow_down_right_to_square":
      return t = await import("./arrow-down-right-to-square.DdVyLgE4-DdVyLgE4.mjs"), v(t.default);
    case "arrow_down_semi_dashed_circle":
      return t = await import("./arrow-down-semi-dashed-circle.BCcx44bL-BCcx44bL.mjs"), v(t.default);
    case "arrow_down_to_bracket":
      return t = await import("./arrow-down-to-bracket.B5mg--Yb-B5mg--Yb.mjs"), v(t.default);
    case "arrow_down_turn_left":
      return t = await import("./arrow-down-turn-left.Ddk87uoM-Ddk87uoM.mjs"), v(t.default);
    case "arrow_down":
      return t = await import("./arrow-down.KA1xwH1X-KA1xwH1X.mjs"), v(t.default);
    case "arrow_left_circle_filled":
      return t = await import("./arrow-left-circle-filled.PBQQSG3Q-PBQQSG3Q.mjs"), v(t.default);
    case "arrow_left_circle":
      return t = await import("./arrow-left-circle.D9bO9iXO-D9bO9iXO.mjs"), v(t.default);
    case "arrow_left_to_line":
      return t = await import("./arrow-left-to-line.N4itJJSd-N4itJJSd.mjs"), v(t.default);
    case "arrow_left":
      return t = await import("./arrow-left.D2hFgUwm-D2hFgUwm.mjs"), v(t.default);
    case "arrow_right_arrow_left_horizontal":
      return t = await import("./arrow-right-arrow-left-horizontal.CiXaBSfc-CiXaBSfc.mjs"), v(t.default);
    case "arrow_right_circle_filled":
      return t = await import("./arrow-right-circle-filled.DeLhrQhH-DeLhrQhH.mjs"), v(t.default);
    case "arrow_right_circle":
      return t = await import("./arrow-right-circle.xLPiXX6q-xLPiXX6q.mjs"), v(t.default);
    case "arrow_right_from_bracket":
      return t = await import("./arrow-right-from-bracket.89Xns2lq-89Xns2lq.mjs"), v(t.default);
    case "arrow_right_to_bracket":
      return t = await import("./arrow-right-to-bracket.BrcL_Uz1-BrcL_Uz1.mjs"), v(t.default);
    case "arrow_right_to_line":
      return t = await import("./arrow-right-to-line.CrAxAyeL-CrAxAyeL.mjs"), v(t.default);
    case "arrow_right":
      return t = await import("./arrow-right.CwdQF_U9-CwdQF_U9.mjs"), v(t.default);
    case "arrow_rotate_left":
      return t = await import("./arrow-rotate-left.DBs5FzM5-Cqov6seQ.mjs"), v(t.default);
    case "arrow_rotate_right":
      return t = await import("./arrow-rotate-right.DRrVEOfC-DRrVEOfC.mjs"), v(t.default);
    case "arrow_rotate_x":
      return t = await import("./arrow-rotate-x.ShPpqgyR-ShPpqgyR.mjs"), v(t.default);
    case "arrow_rotate_y":
      return t = await import("./arrow-rotate-y.DfHDjFAr-DfHDjFAr.mjs"), v(t.default);
    case "arrow_turn_left_down":
      return t = await import("./arrow-turn-left-down.0sj1hMG9-0sj1hMG9.mjs"), v(t.default);
    case "arrow_turn_up_left":
      return t = await import("./arrow-turn-up-left.0VecCQWV-0VecCQWV.mjs"), v(t.default);
    case "arrow_turn_up_right":
      return t = await import("./arrow-turn-up-right.yQllv3Lc-yQllv3Lc.mjs"), v(t.default);
    case "arrow_up_arrow_down_vertical":
      return t = await import("./arrow-up-arrow-down-vertical.CXSYPXjI-CXSYPXjI.mjs"), v(t.default);
    case "arrow_up_circle_filled":
      return t = await import("./arrow-up-circle-filled.Ay28qzNC-Ay28qzNC.mjs"), v(t.default);
    case "arrow_up_circle":
      return t = await import("./arrow-up-circle.BRIQvQUg-BRIQvQUg.mjs"), v(t.default);
    case "arrow_up_from_bracket":
      return t = await import("./arrow-up-from-bracket.C1pqCqJm-C1pqCqJm.mjs"), v(t.default);
    case "arrow_up_left_arrow_down_right_collide":
      return t = await import("./arrow-up-left-arrow-down-right-collide.Cg4CTWiI-Cg4CTWiI.mjs"), v(t.default);
    case "arrow_up_left_arrow_down_right":
      return t = await import("./arrow-up-left-arrow-down-right.x27TVYEH-x27TVYEH.mjs"), v(t.default);
    case "arrow_up_list_narrow_to_wide":
      return t = await import("./arrow-up-list-narrow-to-wide.pnfViF-s-pnfViF-s.mjs"), v(t.default);
    case "arrow_up_right_from_square":
      return t = await import("./arrow-up-right-from-square.lZ8eLwV3-lZ8eLwV3.mjs"), v(t.default);
    case "arrow_up":
      return t = await import("./arrow-up.DS7I-4EO-DS7I-4EO.mjs"), v(t.default);
    case "arrows_crossed":
      return t = await import("./arrows-crossed.CH83KMsj-CH83KMsj.mjs"), v(t.default);
    case "arrows_horizontal_from_center":
      return t = await import("./arrows-horizontal-from-center.D9FJCM0E-D9FJCM0E.mjs"), v(t.default);
    case "arrows_horizontal_to_lines":
      return t = await import("./arrows-horizontal-to-lines.DORZKFMr-DORZKFMr.mjs"), v(t.default);
    case "arrows_rotate_right":
      return t = await import("./arrows-rotate-right.B0kETBm5-B0kETBm5.mjs"), v(t.default);
    case "arrows_vertical_from_center":
      return t = await import("./arrows-vertical-from-center.BijwcrYb-BijwcrYb.mjs"), v(t.default);
    case "arrows_vertical_to_lines":
      return t = await import("./arrows-vertical-to-lines.BM5rdeNm-BM5rdeNm.mjs"), v(t.default);
    case "artstation":
      return t = await import("./artstation.BtRre1Zb-BtRre1Zb.mjs"), v(t.default);
    case "at":
      return t = await import("./at.C9iJiGd1-C9iJiGd1.mjs"), v(t.default);
    case "autodesk":
      return t = await import("./autodesk.JmWHMU8X-JmWHMU8X.mjs"), v(t.default);
    case "axe_filled":
      return t = await import("./axe-filled.DekOl2ED-DekOl2ED.mjs"), v(t.default);
    case "axe":
      return t = await import("./axe.Edu3KlXT-Edu3KlXT.mjs"), v(t.default);
    case "backpack_filled":
      return t = await import("./backpack-filled.m23D-0_Z-m23D-0_Z.mjs"), v(t.default);
    case "backpack":
      return t = await import("./backpack.co3WQu8I-co3WQu8I.mjs"), v(t.default);
    case "backward_end_filled":
      return t = await import("./backward-end-filled.CIyQTgj9-CIyQTgj9.mjs"), v(t.default);
    case "backward_end":
      return t = await import("./backward-end.D-C5lXMK-D-C5lXMK.mjs"), v(t.default);
    case "backward_filled":
      return t = await import("./backward-filled.CvJF7-aK-CvJF7-aK.mjs"), v(t.default);
    case "backward":
      return t = await import("./backward.D2uKJWHk-D2uKJWHk.mjs"), v(t.default);
    case "badge_filled":
      return t = await import("./badge-filled.DFgw1TFk-DFgw1TFk.mjs"), v(t.default);
    case "badge":
      return t = await import("./badge.D8LRp-wh-D8LRp-wh.mjs"), v(t.default);
    case "ball_filled":
      return t = await import("./ball-filled.C0Z6BKxH-C0Z6BKxH.mjs"), v(t.default);
    case "ball":
      return t = await import("./ball.CTR-PEGf-CTR-PEGf.mjs"), v(t.default);
    case "bass_filled":
      return t = await import("./bass-filled.DCCYduRd-DCCYduRd.mjs"), v(t.default);
    case "bass":
      return t = await import("./bass.BoCSoE0i-BoCSoE0i.mjs"), v(t.default);
    case "behance":
      return t = await import("./behance.D5qdWydP-D5qdWydP.mjs"), v(t.default);
    case "bell_badge_filled":
      return t = await import("./bell-badge-filled.8YwwWwQa-8YwwWwQa.mjs"), v(t.default);
    case "bell_badge":
      return t = await import("./bell-badge.CsVtz85v-CsVtz85v.mjs"), v(t.default);
    case "bell_filled":
      return t = await import("./bell-filled.r05thf5_-3PMA2Pwc.mjs"), v(t.default);
    case "bell_slash_filled":
      return t = await import("./bell-slash-filled.CtpOeLSq-CJhWVfhH.mjs"), v(t.default);
    case "bell_slash":
      return t = await import("./bell-slash.BsLVwhcH-BsLVwhcH.mjs"), v(t.default);
    case "bell":
      return t = await import("./bell.CT0CAQ9W-CT0CAQ9W.mjs"), v(t.default);
    case "blender":
      return t = await import("./blender.U70Zq8aK-U70Zq8aK.mjs"), v(t.default);
    case "block_quote":
      return t = await import("./block-quote.XB0ZXL37-XB0ZXL37.mjs"), v(t.default);
    case "bluetooth":
      return t = await import("./bluetooth.CDYF9WFP-CDYF9WFP.mjs"), v(t.default);
    case "bold":
      return t = await import("./bold.DOBDO4jx-DOBDO4jx.mjs"), v(t.default);
    case "bolt_filled":
      return t = await import("./bolt-filled.Dn4V2WkP-Dn4V2WkP.mjs"), v(t.default);
    case "bolt_slash_filled":
      return t = await import("./bolt-slash-filled.CEc_ulWI-CEc_ulWI.mjs"), v(t.default);
    case "bolt_slash":
      return t = await import("./bolt-slash.BpGNj9Mx-BpGNj9Mx.mjs"), v(t.default);
    case "bolt":
      return t = await import("./bolt.BqeoqpLv-BqeoqpLv.mjs"), v(t.default);
    case "bookmark_filled":
      return t = await import("./bookmark-filled.BdzY-4zN-BdzY-4zN.mjs"), v(t.default);
    case "bookmark":
      return t = await import("./bookmark.CVHnBKhi-CVHnBKhi.mjs"), v(t.default);
    case "bowl_filled":
      return t = await import("./bowl-filled.CUDld_BC-CUDld_BC.mjs"), v(t.default);
    case "bowl":
      return t = await import("./bowl.LDxRGKrH-LDxRGKrH.mjs"), v(t.default);
    case "box_check_filled":
      return t = await import("./box-check-filled.BojtgDkF-BojtgDkF.mjs"), v(t.default);
    case "box_check":
      return t = await import("./box-check.Dfj0zgpR-Dfj0zgpR.mjs"), v(t.default);
    case "box_cogwheel_filled":
      return t = await import("./box-cogwheel-filled.Bt0YEYeW-Bt0YEYeW.mjs"), v(t.default);
    case "box_cogwheel":
      return t = await import("./box-cogwheel.BqJBqlcE-BqJBqlcE.mjs"), v(t.default);
    case "box_filled":
      return t = await import("./box-filled.Dki0YotG-Dki0YotG.mjs"), v(t.default);
    case "box_minus_filled":
      return t = await import("./box-minus-filled.D9l5P-rE-CMK-SkHh.mjs"), v(t.default);
    case "box_minus":
      return t = await import("./box-minus.DhjB_RRC-DhjB_RRC.mjs"), v(t.default);
    case "box_pen_filled":
      return t = await import("./box-pen-filled.Z1MCHLDv-Z1MCHLDv.mjs"), v(t.default);
    case "box_pen":
      return t = await import("./box-pen.DmCxIpDK-DmCxIpDK.mjs"), v(t.default);
    case "box_plus_filled":
      return t = await import("./box-plus-filled.BqWANJa_-BqWANJa_.mjs"), v(t.default);
    case "box_plus":
      return t = await import("./box-plus.BdkYbVPi-BdkYbVPi.mjs"), v(t.default);
    case "box_x_mark_filled":
      return t = await import("./box-x-mark-filled.jarkrTaB-jarkrTaB.mjs"), v(t.default);
    case "box_x_mark":
      return t = await import("./box-x-mark.DhU8I_aQ-DhU8I_aQ.mjs"), v(t.default);
    case "box":
      return t = await import("./box.DpEioDDc-DpEioDDc.mjs"), v(t.default);
    case "branch":
      return t = await import("./branch.B8ZP-Bvj-B8ZP-Bvj.mjs"), v(t.default);
    case "brick_wall_filled":
      return t = await import("./brick-wall-filled.DJIDRMK3-DJIDRMK3.mjs"), v(t.default);
    case "brick_wall":
      return t = await import("./brick-wall.B6vftHRv-B6vftHRv.mjs"), v(t.default);
    case "briefcase_filled":
      return t = await import("./briefcase-filled.DA4vuL2z-DA4vuL2z.mjs"), v(t.default);
    case "briefcase":
      return t = await import("./briefcase.Dufew702-Dufew702.mjs"), v(t.default);
    case "browser_window_cogwheel_filled":
      return t = await import("./browser-window-cogwheel-filled.y8yZ136s-y8yZ136s.mjs"), v(t.default);
    case "browser_window_cogwheel":
      return t = await import("./browser-window-cogwheel.Dp2_pkRY-Dp2_pkRY.mjs"), v(t.default);
    case "browser_window_filled":
      return t = await import("./browser-window-filled.BqwXDhqv-BqwXDhqv.mjs"), v(t.default);
    case "browser_window":
      return t = await import("./browser-window.COGBPZ-A-COGBPZ-A.mjs"), v(t.default);
    case "brush_filled":
      return t = await import("./brush-filled.xwe1olmf-xwe1olmf.mjs"), v(t.default);
    case "brush":
      return t = await import("./brush.Dsim9FJv-Dsim9FJv.mjs"), v(t.default);
    case "bug_filled":
      return t = await import("./bug-filled.CG_do4WH-CG_do4WH.mjs"), v(t.default);
    case "bug":
      return t = await import("./bug.RZClSblS-RZClSblS.mjs"), v(t.default);
    case "building_filled":
      return t = await import("./building-filled.CbqVhG6w-CbqVhG6w.mjs"), v(t.default);
    case "building":
      return t = await import("./building.DW5L1m41-DW5L1m41.mjs"), v(t.default);
    case "bullet_list":
      return t = await import("./bullet-list.Bb5kp_Pk-Bb5kp_Pk.mjs"), v(t.default);
    case "bullhorn_filled":
      return t = await import("./bullhorn-filled.DcidvXHF-CORBZNq7.mjs"), v(t.default);
    case "bullhorn":
      return t = await import("./bullhorn.DTZgVcSB-DTZgVcSB.mjs"), v(t.default);
    case "bump_arrow_up":
      return t = await import("./bump-arrow-up.CyAqOjOO-CyAqOjOO.mjs"), v(t.default);
    case "burger_filled":
      return t = await import("./burger-filled.CAQIvwqf-CAQIvwqf.mjs"), v(t.default);
    case "burger":
      return t = await import("./burger.CO3RtZ1C-CO3RtZ1C.mjs"), v(t.default);
    case "calendar_arrows_filled":
      return t = await import("./calendar-arrows-filled.BxEPeJn2-BxEPeJn2.mjs"), v(t.default);
    case "calendar_arrows":
      return t = await import("./calendar-arrows.BJVDM7wp-BJVDM7wp.mjs"), v(t.default);
    case "calendar_check_filled":
      return t = await import("./calendar-check-filled.sgHwtXrS-sgHwtXrS.mjs"), v(t.default);
    case "calendar_check":
      return t = await import("./calendar-check.D0UloNi--D0UloNi-.mjs"), v(t.default);
    case "calendar_cogwheel_filled":
      return t = await import("./calendar-cogwheel-filled.BkQPrnsc-BkQPrnsc.mjs"), v(t.default);
    case "calendar_cogwheel":
      return t = await import("./calendar-cogwheel.OXeMavU9-OXeMavU9.mjs"), v(t.default);
    case "calendar_filled":
      return t = await import("./calendar-filled.B7A81Ge1-B7A81Ge1.mjs"), v(t.default);
    case "calendar_minus_filled":
      return t = await import("./calendar-minus-filled.BfhqXZbO-BfhqXZbO.mjs"), v(t.default);
    case "calendar_minus":
      return t = await import("./calendar-minus.BT-xCvyA-BT-xCvyA.mjs"), v(t.default);
    case "calendar_pen_filled":
      return t = await import("./calendar-pen-filled.COEeW2Tp-COEeW2Tp.mjs"), v(t.default);
    case "calendar_pen":
      return t = await import("./calendar-pen.D3xb2nbB-D3xb2nbB.mjs"), v(t.default);
    case "calendar_plus_filled":
      return t = await import("./calendar-plus-filled.D59QsHIe-D59QsHIe.mjs"), v(t.default);
    case "calendar_plus":
      return t = await import("./calendar-plus.DNsyw26P-DNsyw26P.mjs"), v(t.default);
    case "calendar_x_mark_filled":
      return t = await import("./calendar-x-mark-filled.CqEzVUw8-CqEzVUw8.mjs"), v(t.default);
    case "calendar_x_mark":
      return t = await import("./calendar-x-mark.BnUH3XiR-BnUH3XiR.mjs"), v(t.default);
    case "calendar":
      return t = await import("./calendar.B2eVGUCn-B2eVGUCn.mjs"), v(t.default);
    case "camera_filled":
      return t = await import("./camera-filled.Dgnbk97Z-Dgnbk97Z.mjs"), v(t.default);
    case "camera_slash_filled":
      return t = await import("./camera-slash-filled.BKIR2jeV-BKIR2jeV.mjs"), v(t.default);
    case "camera_slash":
      return t = await import("./camera-slash.BXmxw2k1-BXmxw2k1.mjs"), v(t.default);
    case "camera":
      return t = await import("./camera.D08G_CbW-D08G_CbW.mjs"), v(t.default);
    case "car_filled":
      return t = await import("./car-filled.CRR-VAWI-CRR-VAWI.mjs"), v(t.default);
    case "car":
      return t = await import("./car.Dlcl-NqY-Dlcl-NqY.mjs"), v(t.default);
    case "card_holder_filled":
      return t = await import("./card-holder-filled.CvMRbILX-CvMRbILX.mjs"), v(t.default);
    case "card_holder":
      return t = await import("./card-holder.Il6N-0X0-Il6N-0X0.mjs"), v(t.default);
    case "chart_bar_x_axis_filled":
      return t = await import("./chart-bar-x-axis-filled.CDUS65L5-CDUS65L5.mjs"), v(t.default);
    case "chart_bar_x_axis":
      return t = await import("./chart-bar-x-axis.DseHFaRf-DseHFaRf.mjs"), v(t.default);
    case "chart_line_down_trend_xy_axis":
      return t = await import("./chart-line-down-trend-xy-axis.BrbrQ8rF-BrbrQ8rF.mjs"), v(t.default);
    case "chart_line_up_trend_xy_axis":
      return t = await import("./chart-line-up-trend-xy-axis.z8Dx_F6Y-z8Dx_F6Y.mjs"), v(t.default);
    case "chart_pie_filled":
      return t = await import("./chart-pie-filled.D6fnVo5U-D6fnVo5U.mjs"), v(t.default);
    case "chart_pie":
      return t = await import("./chart-pie.CQyQVGk_-CQyQVGk_.mjs"), v(t.default);
    case "check_circle_filled":
      return t = await import("./check-circle-filled.DZvJw0pj-CpuWKgNW.mjs"), v(t.default);
    case "check_circle":
      return t = await import("./check-circle.DDzL8GQS-DDzL8GQS.mjs"), v(t.default);
    case "check_double":
      return t = await import("./check-double.EZepoGaw-EZepoGaw.mjs"), v(t.default);
    case "check_square_filled":
      return t = await import("./check-square-filled.2P1SyjPY-2P1SyjPY.mjs"), v(t.default);
    case "check_square":
      return t = await import("./check-square.CDrSwmSy-CDrSwmSy.mjs"), v(t.default);
    case "check":
      return t = await import("./check.B535HyRi-B535HyRi.mjs"), v(t.default);
    case "checkerboard_2x2":
      return t = await import("./checkerboard-2x2.xFi0_dAA-xFi0_dAA.mjs"), v(t.default);
    case "checkerboard_4x4":
      return t = await import("./checkerboard-4x4.DIGgwdKy-DIGgwdKy.mjs"), v(t.default);
    case "checklist":
      return t = await import("./checklist.DqepExmU-DqepExmU.mjs"), v(t.default);
    case "checkmark_seal_filled":
      return t = await import("./checkmark-seal-filled.qvMWvtq9-qvMWvtq9.mjs"), v(t.default);
    case "checkmark_seal":
      return t = await import("./checkmark-seal.Bllg2v52-Bllg2v52.mjs"), v(t.default);
    case "chefs_hat_filled":
      return t = await import("./chefs-hat-filled.BBzAz9e4-BBzAz9e4.mjs"), v(t.default);
    case "chefs_hat":
      return t = await import("./chefs-hat.Bpy-xcqK-Bpy-xcqK.mjs"), v(t.default);
    case "chevron_down_double":
      return t = await import("./chevron-down-double.B4ifpdGf-B4ifpdGf.mjs"), v(t.default);
    case "chevron_down":
      return t = await import("./chevron-down.ByqXecK1-Bm922ghA.mjs"), v(t.default);
    case "chevron_left_double":
      return t = await import("./chevron-left-double.B0A2LdPb-B0A2LdPb.mjs"), v(t.default);
    case "chevron_left_to_line":
      return t = await import("./chevron-left-to-line.DpDJwwJL-DpDJwwJL.mjs"), v(t.default);
    case "chevron_left_to_vertical_line_filled":
      return t = await import("./chevron-left-to-vertical-line-filled.D69xH4lB-D69xH4lB.mjs"), v(t.default);
    case "chevron_left_to_vertical_line":
      return t = await import("./chevron-left-to-vertical-line.pAmiDFuo-pAmiDFuo.mjs"), v(t.default);
    case "chevron_left":
      return t = await import("./chevron-left.5NxKEhgw-5NxKEhgw.mjs"), v(t.default);
    case "chevron_right_double":
      return t = await import("./chevron-right-double.pfo6aV7Q-pfo6aV7Q.mjs"), v(t.default);
    case "chevron_right_from_vertical_line_filled":
      return t = await import("./chevron-right-from-vertical-line-filled.CSa_9MPA-CSa_9MPA.mjs"), v(t.default);
    case "chevron_right_from_vertical_line":
      return t = await import("./chevron-right-from-vertical-line.G3DByH8q-G3DByH8q.mjs"), v(t.default);
    case "chevron_right_to_line":
      return t = await import("./chevron-right-to-line.CGtkNvqp-CGtkNvqp.mjs"), v(t.default);
    case "chevron_right":
      return t = await import("./chevron-right.CVg59ZJK-CVg59ZJK.mjs"), v(t.default);
    case "chevron_up_double":
      return t = await import("./chevron-up-double.JIT8RUaP-JIT8RUaP.mjs"), v(t.default);
    case "chevron_up":
      return t = await import("./chevron-up.Cl4ZaywG-DV2Izvms.mjs"), v(t.default);
    case "cinema_4d":
      return t = await import("./cinema-4d.C_WNLgor-C_WNLgor.mjs"), v(t.default);
    case "circle_filled":
      return t = await import("./circle-filled.D2_-GSFv-D2_-GSFv.mjs"), v(t.default);
    case "circle_invert":
      return t = await import("./circle-invert.AwTLGW_T-AwTLGW_T.mjs"), v(t.default);
    case "circle_line_right_down_circle_line_to_left_up_filled":
      return t = await import("./circle-line-right-down-circle-line-to-left-up-filled.CAaz2Yrq-CAaz2Yrq.mjs"), v(t.default);
    case "circle_line_right_down_circle_line_to_left_up":
      return t = await import("./circle-line-right-down-circle-line-to-left-up.Dte0TmIq-Dte0TmIq.mjs"), v(t.default);
    case "circle_radial_streaks":
      return t = await import("./circle-radial-streaks.BVSYPWci-BVSYPWci.mjs"), v(t.default);
    case "circle":
      return t = await import("./circle.BpV3efRT-BpV3efRT.mjs"), v(t.default);
    case "circles_bottom_left_top_right_filled":
      return t = await import("./circles-bottom-left-top-right-filled.CcjbQp0Z-CcjbQp0Z.mjs"), v(t.default);
    case "circles_bottom_left_top_right":
      return t = await import("./circles-bottom-left-top-right.wdw7LFeg-wdw7LFeg.mjs"), v(t.default);
    case "circles_filled":
      return t = await import("./circles-filled.D2fOOZwj-D2fOOZwj.mjs"), v(t.default);
    case "circles":
      return t = await import("./circles.Cxpxk4N6-Cxpxk4N6.mjs"), v(t.default);
    case "clapper_filled":
      return t = await import("./clapper-filled.C7sbs3B6-C7sbs3B6.mjs"), v(t.default);
    case "clapper":
      return t = await import("./clapper.CIgnVioi-CIgnVioi.mjs"), v(t.default);
    case "clipboard_filled":
      return t = await import("./clipboard-filled.CrSa3wPS-CrSa3wPS.mjs"), v(t.default);
    case "clipboard_lines_filled":
      return t = await import("./clipboard-lines-filled.BwS7Q4nB-BwS7Q4nB.mjs"), v(t.default);
    case "clipboard_lines":
      return t = await import("./clipboard-lines.k281yqMx-k281yqMx.mjs"), v(t.default);
    case "clipboard":
      return t = await import("./clipboard.Bql4JnEl-Bql4JnEl.mjs"), v(t.default);
    case "clock_arrow_rotate_left":
      return t = await import("./clock-arrow-rotate-left.CLY2C7vu-CLY2C7vu.mjs"), v(t.default);
    case "clock_arrow_rotate_right":
      return t = await import("./clock-arrow-rotate-right.CXZdnnVA-CXZdnnVA.mjs"), v(t.default);
    case "clock_filled":
      return t = await import("./clock-filled.CQiPTkpu-BXIw60fr.mjs"), v(t.default);
    case "clock":
      return t = await import("./clock.aUn0W--U-aUn0W--U.mjs"), v(t.default);
    case "cloud_arrow_down_filled":
      return t = await import("./cloud-arrow-down-filled.CIDFDksO-CIDFDksO.mjs"), v(t.default);
    case "cloud_arrow_down":
      return t = await import("./cloud-arrow-down.BWQaI74F-BWQaI74F.mjs"), v(t.default);
    case "cloud_arrow_up_filled":
      return t = await import("./cloud-arrow-up-filled.D0b6eTPt-D0b6eTPt.mjs"), v(t.default);
    case "cloud_arrow_up":
      return t = await import("./cloud-arrow-up.Ck2wfJME-Ck2wfJME.mjs"), v(t.default);
    case "cloud_filled":
      return t = await import("./cloud-filled.CQ0akqYU-CQ0akqYU.mjs"), v(t.default);
    case "cloud":
      return t = await import("./cloud.Be15t1fl-Be15t1fl.mjs"), v(t.default);
    case "code_block":
      return t = await import("./code-block.C9Lggf4d-C9Lggf4d.mjs"), v(t.default);
    case "code":
      return t = await import("./code.4BzMZ2cJ-4BzMZ2cJ.mjs"), v(t.default);
    case "cog_filled":
      return t = await import("./cog-filled.BoG3AouY-BoG3AouY.mjs"), v(t.default);
    case "cog":
      return t = await import("./cog.C8DrtQXy-C8DrtQXy.mjs"), v(t.default);
    case "combined_geometric_shapes":
      return t = await import("./combined-geometric-shapes.B1g9WH95-B1g9WH95.mjs"), v(t.default);
    case "comet_filled":
      return t = await import("./comet-filled.QRhoadYQ-QRhoadYQ.mjs"), v(t.default);
    case "comet":
      return t = await import("./comet.KwIEkDt1-KwIEkDt1.mjs"), v(t.default);
    case "commit":
      return t = await import("./commit.CMfHib7M-CMfHib7M.mjs"), v(t.default);
    case "compass_filled":
      return t = await import("./compass-filled.BgBtjF3b-BgBtjF3b.mjs"), v(t.default);
    case "compass":
      return t = await import("./compass.B6vM2WGS-B6vM2WGS.mjs"), v(t.default);
    case "compile_filled":
      return t = await import("./compile-filled.C7ffh5BS-C7ffh5BS.mjs"), v(t.default);
    case "compile":
      return t = await import("./compile.B66HSS8e-B66HSS8e.mjs"), v(t.default);
    case "compress":
      return t = await import("./compress.q2KOPw4K-q2KOPw4K.mjs"), v(t.default);
    case "computer_chip_filled":
      return t = await import("./computer-chip-filled.VmGsfSMk-VmGsfSMk.mjs"), v(t.default);
    case "computer_chip":
      return t = await import("./computer-chip.D5ejky9t-D5ejky9t.mjs"), v(t.default);
    case "computer_mouse_filled":
      return t = await import("./computer-mouse-filled.Bsgmbtqo-Bsgmbtqo.mjs"), v(t.default);
    case "computer_mouse_left_click_filled":
      return t = await import("./computer-mouse-left-click-filled.CtIqJq_s-CtIqJq_s.mjs"), v(t.default);
    case "computer_mouse_left_click":
      return t = await import("./computer-mouse-left-click.DDPZAX0w-DDPZAX0w.mjs"), v(t.default);
    case "computer_mouse_right_click_filled":
      return t = await import("./computer-mouse-right-click-filled.BvQoEp9J-BvQoEp9J.mjs"), v(t.default);
    case "computer_mouse_right_click":
      return t = await import("./computer-mouse-right-click.CO4oDUrP-CO4oDUrP.mjs"), v(t.default);
    case "computer_mouse":
      return t = await import("./computer-mouse.B0A4Kz2y-B0A4Kz2y.mjs"), v(t.default);
    case "computer_network_filled":
      return t = await import("./computer-network-filled.Bsv7sJja-Bsv7sJja.mjs"), v(t.default);
    case "computer_network":
      return t = await import("./computer-network.DugYvjV6-DugYvjV6.mjs"), v(t.default);
    case "cookie_filled":
      return t = await import("./cookie-filled.BzakUHPM-BzakUHPM.mjs"), v(t.default);
    case "cookie_slash_filled":
      return t = await import("./cookie-slash-filled.DVGHQd6--DVGHQd6-.mjs"), v(t.default);
    case "cookie_slash":
      return t = await import("./cookie-slash.WL3_iZvi-WL3_iZvi.mjs"), v(t.default);
    case "cookie":
      return t = await import("./cookie.Cdk37uIL-Cdk37uIL.mjs"), v(t.default);
    case "coupon_filled":
      return t = await import("./coupon-filled.DFg8rJq3-DFg8rJq3.mjs"), v(t.default);
    case "coupon":
      return t = await import("./coupon.CMltiw3F-CMltiw3F.mjs"), v(t.default);
    case "credit_card_check_filled":
      return t = await import("./credit-card-check-filled.B9-9PsBh-B9-9PsBh.mjs"), v(t.default);
    case "credit_card_check":
      return t = await import("./credit-card-check.C03edTie-C03edTie.mjs"), v(t.default);
    case "credit_card_cogwheel_filled":
      return t = await import("./credit-card-cogwheel-filled.CILJcKLl-CILJcKLl.mjs"), v(t.default);
    case "credit_card_cogwheel":
      return t = await import("./credit-card-cogwheel.BINg_vxQ-BINg_vxQ.mjs"), v(t.default);
    case "credit_card_filled":
      return t = await import("./credit-card-filled.CgJefeFr-CgJefeFr.mjs"), v(t.default);
    case "credit_card_minus_filled":
      return t = await import("./credit-card-minus-filled.C2HwQb7g-C2HwQb7g.mjs"), v(t.default);
    case "credit_card_minus":
      return t = await import("./credit-card-minus.DkDbVLyR-DkDbVLyR.mjs"), v(t.default);
    case "credit_card_pen_filled":
      return t = await import("./credit-card-pen-filled.DRZ2gaHS-DRZ2gaHS.mjs"), v(t.default);
    case "credit_card_pen":
      return t = await import("./credit-card-pen.CuXTrVw--CuXTrVw-.mjs"), v(t.default);
    case "credit_card_plus_filled":
      return t = await import("./credit-card-plus-filled.DryUDOQO-DryUDOQO.mjs"), v(t.default);
    case "credit_card_plus":
      return t = await import("./credit-card-plus.K8P5C_Cu-K8P5C_Cu.mjs"), v(t.default);
    case "credit_card_x_mark_filled":
      return t = await import("./credit-card-x-mark-filled.Bxbw0zjT-Bxbw0zjT.mjs"), v(t.default);
    case "credit_card_x_mark":
      return t = await import("./credit-card-x-mark.BADR-Ufj-BADR-Ufj.mjs"), v(t.default);
    case "credit_card":
      return t = await import("./credit-card.DS9-hH3Y-DS9-hH3Y.mjs"), v(t.default);
    case "crop":
      return t = await import("./crop.D9tbBow2-D9tbBow2.mjs"), v(t.default);
    case "crosshair":
      return t = await import("./crosshair.Bxdu5NBb-Bxdu5NBb.mjs"), v(t.default);
    case "crown_filled":
      return t = await import("./crown-filled.DavTc61R-DavTc61R.mjs"), v(t.default);
    case "crown":
      return t = await import("./crown.NozS8Xsh-NozS8Xsh.mjs"), v(t.default);
    case "cube_filled":
      return t = await import("./cube-filled.B2ENbPNx-B2ENbPNx.mjs"), v(t.default);
    case "cube_magnifier_filled":
      return t = await import("./cube-magnifier-filled.Cp7oaxiB-Cp7oaxiB.mjs"), v(t.default);
    case "cube_magnifier":
      return t = await import("./cube-magnifier.DDenHdQF-DDenHdQF.mjs"), v(t.default);
    case "cube_sparkle_filled":
      return t = await import("./cube-sparkle-filled.DfFyleeO-DfFyleeO.mjs"), v(t.default);
    case "cube_sparkle":
      return t = await import("./cube-sparkle.B60V4lvq-B60V4lvq.mjs"), v(t.default);
    case "cube":
      return t = await import("./cube.Brz9km6M-Brz9km6M.mjs"), v(t.default);
    case "curly_braces":
      return t = await import("./curly-braces.CnV-XSal-CnV-XSal.mjs"), v(t.default);
    case "database_filled":
      return t = await import("./database-filled.CcqLWnN0-rqIAvwnk.mjs"), v(t.default);
    case "database":
      return t = await import("./database.l4EyPH0O-l4EyPH0O.mjs"), v(t.default);
    case "deviantart":
      return t = await import("./deviantart.C2cCZP-8-C2cCZP-8.mjs"), v(t.default);
    case "diagonal_lines_square_filled":
      return t = await import("./diagonal-lines-square-filled.CV201hUK-CV201hUK.mjs"), v(t.default);
    case "diagonal_lines_square":
      return t = await import("./diagonal-lines-square.DZDTBQzO-DZDTBQzO.mjs"), v(t.default);
    case "dictionary_filled":
      return t = await import("./dictionary-filled.D1APxzmO-D1APxzmO.mjs"), v(t.default);
    case "dictionary":
      return t = await import("./dictionary.BmpZugvr-BmpZugvr.mjs"), v(t.default);
    case "directional_pad_filled":
      return t = await import("./directional-pad-filled.CuSvQr---CuSvQr--.mjs"), v(t.default);
    case "directional_pad":
      return t = await import("./directional-pad.D-6g9Dzy-D-6g9Dzy.mjs"), v(t.default);
    case "discord":
      return t = await import("./discord.B2WdWsf0-B2WdWsf0.mjs"), v(t.default);
    case "display_filled":
      return t = await import("./display-filled.BcV79d06-BcV79d06.mjs"), v(t.default);
    case "display_x_mark_filled":
      return t = await import("./display-x-mark-filled.Cx4VG6J--Cx4VG6J-.mjs"), v(t.default);
    case "display_x_mark":
      return t = await import("./display-x-mark.CFsdkgfU-CFsdkgfU.mjs"), v(t.default);
    case "display":
      return t = await import("./display.C-8ye7uF-C-8ye7uF.mjs"), v(t.default);
    case "dollar_sign_circle_filled":
      return t = await import("./dollar-sign-circle-filled.BRy5LSgC-BRy5LSgC.mjs"), v(t.default);
    case "dollar_sign_circle":
      return t = await import("./dollar-sign-circle.TbibnKkz-TbibnKkz.mjs"), v(t.default);
    case "dot_square_filled":
      return t = await import("./dot-square-filled.Ds26I_g2-Ds26I_g2.mjs"), v(t.default);
    case "dot_square":
      return t = await import("./dot-square.A5NIskX--A5NIskX-.mjs"), v(t.default);
    case "drag_handle_horizontal":
      return t = await import("./drag-handle-horizontal.CkdadBXU-CkdadBXU.mjs"), v(t.default);
    case "drag_handle_vertical":
      return t = await import("./drag-handle-vertical.BvzXTSgY-BvzXTSgY.mjs"), v(t.default);
    case "drop_cap":
      return t = await import("./drop-cap.C9zxjf-U-C9zxjf-U.mjs"), v(t.default);
    case "drop_dashed_circle":
      return t = await import("./drop-dashed-circle.DefCwMVo-DefCwMVo.mjs"), v(t.default);
    case "drop_filled":
      return t = await import("./drop-filled.CEUTVvVA-CEUTVvVA.mjs"), v(t.default);
    case "drop":
      return t = await import("./drop.D-3GMUVI-D-3GMUVI.mjs"), v(t.default);
    case "dropbox":
      return t = await import("./dropbox.WBW2mzd7-WBW2mzd7.mjs"), v(t.default);
    case "drum_filled":
      return t = await import("./drum-filled.BlGiKHDO-BlGiKHDO.mjs"), v(t.default);
    case "drum":
      return t = await import("./drum.BZXfitMD-BZXfitMD.mjs"), v(t.default);
    case "dual_display_filled":
      return t = await import("./dual-display-filled.soY-SY7x-soY-SY7x.mjs"), v(t.default);
    case "dual_display":
      return t = await import("./dual-display.CBW5EAw_-CBW5EAw_.mjs"), v(t.default);
    case "earth_filled":
      return t = await import("./earth-filled.DfOovZJa-DfOovZJa.mjs"), v(t.default);
    case "earth_location_filled":
      return t = await import("./earth-location-filled.Z_ukiaHu-Z_ukiaHu.mjs"), v(t.default);
    case "earth_location":
      return t = await import("./earth-location.BSnuHx8n-BSnuHx8n.mjs"), v(t.default);
    case "earth":
      return t = await import("./earth.BRLLXJJZ-BRLLXJJZ.mjs"), v(t.default);
    case "ellipsis_horizontal_circle_filled":
      return t = await import("./ellipsis-horizontal-circle-filled.CRCSrley-CRCSrley.mjs"), v(t.default);
    case "ellipsis_horizontal_circle":
      return t = await import("./ellipsis-horizontal-circle.DZ6DZuzn-DZ6DZuzn.mjs"), v(t.default);
    case "ellipsis_horizontal":
      return t = await import("./ellipsis-horizontal.DOEH26Ht-DOEH26Ht.mjs"), v(t.default);
    case "ellipsis_vertical_circle_filled":
      return t = await import("./ellipsis-vertical-circle-filled.B_R8UVOs-B_R8UVOs.mjs"), v(t.default);
    case "ellipsis_vertical_circle":
      return t = await import("./ellipsis-vertical-circle.DZTcjqtW-DZTcjqtW.mjs"), v(t.default);
    case "ellipsis_vertical":
      return t = await import("./ellipsis-vertical.DHNn5ooc-DHNn5ooc.mjs"), v(t.default);
    case "emoji_child_filled":
      return t = await import("./emoji-child-filled.CqVXu7dF-CqVXu7dF.mjs"), v(t.default);
    case "emoji_child":
      return t = await import("./emoji-child.4PLkOhGU-4PLkOhGU.mjs"), v(t.default);
    case "emoji_happy_filled":
      return t = await import("./emoji-happy-filled.CNe1cHC9-CNe1cHC9.mjs"), v(t.default);
    case "emoji_happy":
      return t = await import("./emoji-happy.B0V2KPJK-B0V2KPJK.mjs"), v(t.default);
    case "emoji_neutral_filled":
      return t = await import("./emoji-neutral-filled.BIszb6vh-BIszb6vh.mjs"), v(t.default);
    case "emoji_neutral":
      return t = await import("./emoji-neutral.B0ETdtSC-B0ETdtSC.mjs"), v(t.default);
    case "emoji_plus_filled":
      return t = await import("./emoji-plus-filled.CKwIBnik-CKwIBnik.mjs"), v(t.default);
    case "emoji_plus":
      return t = await import("./emoji-plus.a_HGZiN--a_HGZiN-.mjs"), v(t.default);
    case "emoji_sad_filled":
      return t = await import("./emoji-sad-filled.BMn8QgXy-BMn8QgXy.mjs"), v(t.default);
    case "emoji_sad":
      return t = await import("./emoji-sad.BVseo9WM-BVseo9WM.mjs"), v(t.default);
    case "emoji_smile_filled":
      return t = await import("./emoji-smile-filled.CWARXIby-CWARXIby.mjs"), v(t.default);
    case "emoji_smile":
      return t = await import("./emoji-smile.qIei2cvx-qIei2cvx.mjs"), v(t.default);
    case "envelope_arrows_filled":
      return t = await import("./envelope-arrows-filled.CeU5eHtI-CeU5eHtI.mjs"), v(t.default);
    case "envelope_arrows":
      return t = await import("./envelope-arrows.Cr8noEA0-Cr8noEA0.mjs"), v(t.default);
    case "envelope_cogwheel_filled":
      return t = await import("./envelope-cogwheel-filled.DJQ5uMRw-DJQ5uMRw.mjs"), v(t.default);
    case "envelope_cogwheel":
      return t = await import("./envelope-cogwheel.FIIGFLrV-FIIGFLrV.mjs"), v(t.default);
    case "envelope_filled":
      return t = await import("./envelope-filled.ChTf0boF-ChTf0boF.mjs"), v(t.default);
    case "envelope_open_filled":
      return t = await import("./envelope-open-filled.DID_Dgz2-B7Ctm1t3.mjs"), v(t.default);
    case "envelope_open":
      return t = await import("./envelope-open.CBl47bSD-CBl47bSD.mjs"), v(t.default);
    case "envelope_pen_filled":
      return t = await import("./envelope-pen-filled.De5VlQay-smGwtfoF.mjs"), v(t.default);
    case "envelope_pen":
      return t = await import("./envelope-pen.CR73weLy-CR73weLy.mjs"), v(t.default);
    case "envelope_question_filled":
      return t = await import("./envelope-question-filled.CQd_x1kU-CQd_x1kU.mjs"), v(t.default);
    case "envelope_question":
      return t = await import("./envelope-question.C7HhYbrO-C7HhYbrO.mjs"), v(t.default);
    case "envelope_x_mark_filled":
      return t = await import("./envelope-x-mark-filled.By-Pg6ZU-By-Pg6ZU.mjs"), v(t.default);
    case "envelope_x_mark":
      return t = await import("./envelope-x-mark.CJ6LFw-2-CJ6LFw-2.mjs"), v(t.default);
    case "envelope":
      return t = await import("./envelope.DlV9aFhN-DlV9aFhN.mjs"), v(t.default);
    case "epic_games":
      return t = await import("./epic-games.CmGk1B-o-CmGk1B-o.mjs"), v(t.default);
    case "epic_rewards_filled":
      return t = await import("./epic-rewards-filled.B-GPKbMr-B-GPKbMr.mjs"), v(t.default);
    case "epic_rewards":
      return t = await import("./epic-rewards.CwnhiUZT-CwnhiUZT.mjs"), v(t.default);
    case "epic":
      return t = await import("./epic.1KTH7Myg-1KTH7Myg.mjs"), v(t.default);
    case "eraser_filled":
      return t = await import("./eraser-filled.Bp_rvpb3-Bp_rvpb3.mjs"), v(t.default);
    case "eraser":
      return t = await import("./eraser.CwS6rV9c-CwS6rV9c.mjs"), v(t.default);
    case "euro_sign_circle_filled":
      return t = await import("./euro-sign-circle-filled.LOAEoz7k-LOAEoz7k.mjs"), v(t.default);
    case "euro_sign_circle":
      return t = await import("./euro-sign-circle.8f4aJvVu-8f4aJvVu.mjs"), v(t.default);
    case "exclamation_circle_filled":
      return t = await import("./exclamation-circle-filled.BaM-ex0w-KColAWuM.mjs"), v(t.default);
    case "exclamation_circle":
      return t = await import("./exclamation-circle.DpBL6A1g-DpBL6A1g.mjs"), v(t.default);
    case "exclamation_triangle_filled":
      return t = await import("./exclamation-triangle-filled.MohopSTx-MohopSTx.mjs"), v(t.default);
    case "exclamation_triangle":
      return t = await import("./exclamation-triangle.DPbnpARE-DPbnpARE.mjs"), v(t.default);
    case "expand":
      return t = await import("./expand.CM1yEZX4-CM1yEZX4.mjs"), v(t.default);
    case "external_drive_filled":
      return t = await import("./external-drive-filled.DVIWi29Q-DVIWi29Q.mjs"), v(t.default);
    case "external_drive":
      return t = await import("./external-drive.jKRDTOMZ-jKRDTOMZ.mjs"), v(t.default);
    case "eye_dropper_filled":
      return t = await import("./eye-dropper-filled.CplU4fFP-CDFEkRCR.mjs"), v(t.default);
    case "eye_dropper":
      return t = await import("./eye-dropper.s3fBiUq1-s3fBiUq1.mjs"), v(t.default);
    case "eye_filled":
      return t = await import("./eye-filled.BzHX-xGD-BzHX-xGD.mjs"), v(t.default);
    case "eye_slash_filled":
      return t = await import("./eye-slash-filled.DGYuXb8T-DGYuXb8T.mjs"), v(t.default);
    case "eye_slash":
      return t = await import("./eye-slash.BTmqWULm-BTmqWULm.mjs"), v(t.default);
    case "eye":
      return t = await import("./eye.Ca8hiHtY-Ca8hiHtY.mjs"), v(t.default);
    case "fab":
      return t = await import("./fab.Bz3ii5GN-Bz3ii5GN.mjs"), v(t.default);
    case "facebook":
      return t = await import("./facebook.CWLejaHJ-CWLejaHJ.mjs"), v(t.default);
    case "fall_guys":
      return t = await import("./fall-guys.DtJN9g2N-DtJN9g2N.mjs"), v(t.default);
    case "figma":
      return t = await import("./figma.CNJs0QxO-CNJs0QxO.mjs"), v(t.default);
    case "figure_rigged":
      return t = await import("./figure-rigged.DZ6FuJOB-DZ6FuJOB.mjs"), v(t.default);
    case "file_check_filled":
      return t = await import("./file-check-filled._XbeSzlI-_XbeSzlI.mjs"), v(t.default);
    case "file_check":
      return t = await import("./file-check.P1ft5sZ7-P1ft5sZ7.mjs"), v(t.default);
    case "file_code_filled":
      return t = await import("./file-code-filled.DmVggtrI-DmVggtrI.mjs"), v(t.default);
    case "file_code":
      return t = await import("./file-code.mxAEZh5u-mxAEZh5u.mjs"), v(t.default);
    case "file_cogwheel_filled":
      return t = await import("./file-cogwheel-filled.dOmSaaQm-dOmSaaQm.mjs"), v(t.default);
    case "file_cogwheel":
      return t = await import("./file-cogwheel.BmMdd5_J-BmMdd5_J.mjs"), v(t.default);
    case "file_filled":
      return t = await import("./file-filled.tILKDx7o-tILKDx7o.mjs"), v(t.default);
    case "file_lines_filled":
      return t = await import("./file-lines-filled.BXRaTIw7-BXRaTIw7.mjs"), v(t.default);
    case "file_lines":
      return t = await import("./file-lines.CV0rqSHA-CV0rqSHA.mjs"), v(t.default);
    case "file_magnifier_filled":
      return t = await import("./file-magnifier-filled.d_QzWEUX-d_QzWEUX.mjs"), v(t.default);
    case "file_magnifier":
      return t = await import("./file-magnifier.th7Q8is1-th7Q8is1.mjs"), v(t.default);
    case "file_minus_filled":
      return t = await import("./file-minus-filled.BiqRIxcj-BiqRIxcj.mjs"), v(t.default);
    case "file_minus":
      return t = await import("./file-minus.CQSI9Bze-CQSI9Bze.mjs"), v(t.default);
    case "file_pen_filled":
      return t = await import("./file-pen-filled.CISTbAbi-CISTbAbi.mjs"), v(t.default);
    case "file_pen":
      return t = await import("./file-pen.BVzFHbiU-BVzFHbiU.mjs"), v(t.default);
    case "file_plus_filled":
      return t = await import("./file-plus-filled.CUl1EFKT-CUl1EFKT.mjs"), v(t.default);
    case "file_plus":
      return t = await import("./file-plus.BvQCWK9w-BvQCWK9w.mjs"), v(t.default);
    case "file_x_mark_filled":
      return t = await import("./file-x-mark-filled.D4bYOPP3-D4bYOPP3.mjs"), v(t.default);
    case "file_x_mark":
      return t = await import("./file-x-mark.CpX6v-FN-CpX6v-FN.mjs"), v(t.default);
    case "file_zipper_filled":
      return t = await import("./file-zipper-filled.DLZvuPZJ-DLZvuPZJ.mjs"), v(t.default);
    case "file_zipper":
      return t = await import("./file-zipper.UBof_-iU-UBof_-iU.mjs"), v(t.default);
    case "file":
      return t = await import("./file.epELrrqh-epELrrqh.mjs"), v(t.default);
    case "film":
      return t = await import("./film.C8XW5zTN-C8XW5zTN.mjs"), v(t.default);
    case "fingerprint":
      return t = await import("./fingerprint.BvewPip5-BvewPip5.mjs"), v(t.default);
    case "flag_filled":
      return t = await import("./flag-filled.D5oF75gl-D5oF75gl.mjs"), v(t.default);
    case "flag_slash_filled":
      return t = await import("./flag-slash-filled.DUKd0ERb-DUKd0ERb.mjs"), v(t.default);
    case "flag_slash":
      return t = await import("./flag-slash.BnQT-iF3-BnQT-iF3.mjs"), v(t.default);
    case "flag":
      return t = await import("./flag.BMydsXYT-BMydsXYT.mjs"), v(t.default);
    case "flame_filled":
      return t = await import("./flame-filled.BcAhpYDe-BcAhpYDe.mjs"), v(t.default);
    case "flame":
      return t = await import("./flame.pgQFTXm5-pgQFTXm5.mjs"), v(t.default);
    case "floppy_disk_filled":
      return t = await import("./floppy-disk-filled.PgenmmWf-PgenmmWf.mjs"), v(t.default);
    case "floppy_disk":
      return t = await import("./floppy-disk.BHaKUDjl-BHaKUDjl.mjs"), v(t.default);
    case "flower_filled":
      return t = await import("./flower-filled.DJyXkykh-DJyXkykh.mjs"), v(t.default);
    case "flower":
      return t = await import("./flower.D2abzcXl-D2abzcXl.mjs"), v(t.default);
    case "folder_check_filled":
      return t = await import("./folder-check-filled.DnJwC_Ht-DnJwC_Ht.mjs"), v(t.default);
    case "folder_check":
      return t = await import("./folder-check.BUIIm4XN-BUIIm4XN.mjs"), v(t.default);
    case "folder_closed_filled":
      return t = await import("./folder-closed-filled.X9ETt8gc-X9ETt8gc.mjs"), v(t.default);
    case "folder_closed":
      return t = await import("./folder-closed.BxX2zATN-BxX2zATN.mjs"), v(t.default);
    case "folder_code_filled":
      return t = await import("./folder-code-filled.D1hA9u2p-D1hA9u2p.mjs"), v(t.default);
    case "folder_code":
      return t = await import("./folder-code.VLoy4zI8-VLoy4zI8.mjs"), v(t.default);
    case "folder_cogwheel_filled":
      return t = await import("./folder-cogwheel-filled.C3ASa2cm-C3ASa2cm.mjs"), v(t.default);
    case "folder_cogwheel":
      return t = await import("./folder-cogwheel.COApbwwd-COApbwwd.mjs"), v(t.default);
    case "folder_filled":
      return t = await import("./folder-filled.Cn9n_jlY-Cn9n_jlY.mjs"), v(t.default);
    case "folder_magnifier_filled":
      return t = await import("./folder-magnifier-filled.DyTVpPHb-DyTVpPHb.mjs"), v(t.default);
    case "folder_magnifier":
      return t = await import("./folder-magnifier.CQYB75xo-CQYB75xo.mjs"), v(t.default);
    case "folder_minus_filled":
      return t = await import("./folder-minus-filled.CkLqNWqF-CkLqNWqF.mjs"), v(t.default);
    case "folder_minus":
      return t = await import("./folder-minus.Ckg6YjAg-Ckg6YjAg.mjs"), v(t.default);
    case "folder_open_filled":
      return t = await import("./folder-open-filled.3_YNJaqs-3_YNJaqs.mjs"), v(t.default);
    case "folder_open":
      return t = await import("./folder-open.BpfswKWN-BpfswKWN.mjs"), v(t.default);
    case "folder_pen_filled":
      return t = await import("./folder-pen-filled.UbpsUQ6p-UbpsUQ6p.mjs"), v(t.default);
    case "folder_pen":
      return t = await import("./folder-pen.Dww-a5g--Dww-a5g-.mjs"), v(t.default);
    case "folder_plus_filled":
      return t = await import("./folder-plus-filled.BS6r7mYK-BS6r7mYK.mjs"), v(t.default);
    case "folder_plus":
      return t = await import("./folder-plus.COxH_6MF-COxH_6MF.mjs"), v(t.default);
    case "folder_user_filled":
      return t = await import("./folder-user-filled.CkiOLqaW-CkiOLqaW.mjs"), v(t.default);
    case "folder_user":
      return t = await import("./folder-user.DkOW-U6z-DkOW-U6z.mjs"), v(t.default);
    case "folder_x_mark_filled":
      return t = await import("./folder-x-mark-filled.v3lEviAe-v3lEviAe.mjs"), v(t.default);
    case "folder_x_mark":
      return t = await import("./folder-x-mark.DGXMrVAo-DGXMrVAo.mjs"), v(t.default);
    case "folder":
      return t = await import("./folder.DZ-mrfbu-DZ-mrfbu.mjs"), v(t.default);
    case "fork":
      return t = await import("./fork.lKZJthgq-lKZJthgq.mjs"), v(t.default);
    case "formatting_slash":
      return t = await import("./formatting-slash.8GeaWUmP-8GeaWUmP.mjs"), v(t.default);
    case "fortnite_creative":
      return t = await import("./fortnite-creative.BbwWZyZy-BbwWZyZy.mjs"), v(t.default);
    case "fortnite":
      return t = await import("./fortnite.CtY6BOT6-CtY6BOT6.mjs"), v(t.default);
    case "forward_end_filled":
      return t = await import("./forward-end-filled.iKY72de2-iKY72de2.mjs"), v(t.default);
    case "forward_end":
      return t = await import("./forward-end.BCZ2G9BT-BCZ2G9BT.mjs"), v(t.default);
    case "forward_filled":
      return t = await import("./forward-filled.CtDyHXCr-CtDyHXCr.mjs"), v(t.default);
    case "forward":
      return t = await import("./forward.CwSk1HSX-CwSk1HSX.mjs"), v(t.default);
    case "four_lines_horizontal_align_center":
      return t = await import("./four-lines-horizontal-align-center.DSQ7-vdv-DSQ7-vdv.mjs"), v(t.default);
    case "four_lines_horizontal_align_left":
      return t = await import("./four-lines-horizontal-align-left.DO6LgGtf-DO6LgGtf.mjs"), v(t.default);
    case "four_lines_horizontal_align_right":
      return t = await import("./four-lines-horizontal-align-right.DL9OVcqi-DL9OVcqi.mjs"), v(t.default);
    case "four_lines_horizontal":
      return t = await import("./four-lines-horizontal.CqFKbFAs-CqFKbFAs.mjs"), v(t.default);
    case "funnel_filled":
      return t = await import("./funnel-filled.CLu168-c-DXpLDZCf.mjs"), v(t.default);
    case "funnel":
      return t = await import("./funnel.COD--Kka-COD--Kka.mjs"), v(t.default);
    case "gamepad_check_filled":
      return t = await import("./gamepad-check-filled.Bn6nNuuM-Bn6nNuuM.mjs"), v(t.default);
    case "gamepad_check":
      return t = await import("./gamepad-check.Dmybu2_8-Dmybu2_8.mjs"), v(t.default);
    case "gamepad_cogwheel_filled":
      return t = await import("./gamepad-cogwheel-filled.xOH2Yalp-xOH2Yalp.mjs"), v(t.default);
    case "gamepad_cogwheel":
      return t = await import("./gamepad-cogwheel.CdPHS5Ei-CdPHS5Ei.mjs"), v(t.default);
    case "gamepad_filled":
      return t = await import("./gamepad-filled.BBPDs0Ml-BBPDs0Ml.mjs"), v(t.default);
    case "gamepad_minus_filled":
      return t = await import("./gamepad-minus-filled.CaXnGp6--CaXnGp6-.mjs"), v(t.default);
    case "gamepad_minus":
      return t = await import("./gamepad-minus.srY4A1JP-srY4A1JP.mjs"), v(t.default);
    case "gamepad_plus_filled":
      return t = await import("./gamepad-plus-filled.B4ldW8nY-B4ldW8nY.mjs"), v(t.default);
    case "gamepad_plus":
      return t = await import("./gamepad-plus.BBLqxFaU-BBLqxFaU.mjs"), v(t.default);
    case "gamepad_trend_up_filled":
      return t = await import("./gamepad-trend-up-filled.DvhMbxJx-DvhMbxJx.mjs"), v(t.default);
    case "gamepad_trend_up":
      return t = await import("./gamepad-trend-up.D9nm0PkX-D9nm0PkX.mjs"), v(t.default);
    case "gamepad_x_mark_filled":
      return t = await import("./gamepad-x-mark-filled.ClcdE2RM-ClcdE2RM.mjs"), v(t.default);
    case "gamepad_x_mark":
      return t = await import("./gamepad-x-mark.BedMQhAS-BedMQhAS.mjs"), v(t.default);
    case "gamepad":
      return t = await import("./gamepad.C_jEoUgx-C_jEoUgx.mjs"), v(t.default);
    case "ghost_filled":
      return t = await import("./ghost-filled.BFjPtU_D-BFjPtU_D.mjs"), v(t.default);
    case "ghost":
      return t = await import("./ghost.HjUr36uP-HjUr36uP.mjs"), v(t.default);
    case "gif":
      return t = await import("./gif.DY-QRYTe-DY-QRYTe.mjs"), v(t.default);
    case "gift_arrow_left_filled":
      return t = await import("./gift-arrow-left-filled.CocjqU1q-CocjqU1q.mjs"), v(t.default);
    case "gift_arrow_left":
      return t = await import("./gift-arrow-left.Ck2H92Wq-Ck2H92Wq.mjs"), v(t.default);
    case "gift_arrow_right_filled":
      return t = await import("./gift-arrow-right-filled.Dk7jIziR-Dk7jIziR.mjs"), v(t.default);
    case "gift_arrow_right":
      return t = await import("./gift-arrow-right.B5qwg396-B5qwg396.mjs"), v(t.default);
    case "gift_card_filled":
      return t = await import("./gift-card-filled.2nBiRD2x-2nBiRD2x.mjs"), v(t.default);
    case "gift_card":
      return t = await import("./gift-card.Du29hKuU-Du29hKuU.mjs"), v(t.default);
    case "gift_filled":
      return t = await import("./gift-filled.CYBN45OC-CYBN45OC.mjs"), v(t.default);
    case "gift":
      return t = await import("./gift.flgden0a-flgden0a.mjs"), v(t.default);
    case "github":
      return t = await import("./github.bQxfAREC-bQxfAREC.mjs"), v(t.default);
    case "gizmo":
      return t = await import("./gizmo.DJIBJdIH-DJIBJdIH.mjs"), v(t.default);
    case "glasses_filled":
      return t = await import("./glasses-filled.6VHSi7gU-CRz1oEem.mjs"), v(t.default);
    case "glasses":
      return t = await import("./glasses.BDPcWI0I-BDPcWI0I.mjs"), v(t.default);
    case "globe_location":
      return t = await import("./globe-location.DsXwPNWa-DsXwPNWa.mjs"), v(t.default);
    case "globe":
      return t = await import("./globe.D8CEr5Rm-D8CEr5Rm.mjs"), v(t.default);
    case "google":
      return t = await import("./google.Duxu2Rwu-Duxu2Rwu.mjs"), v(t.default);
    case "graduation_cap_filled":
      return t = await import("./graduation-cap-filled.94x6YcsH-94x6YcsH.mjs"), v(t.default);
    case "graduation_cap":
      return t = await import("./graduation-cap.BiTGthmj-BiTGthmj.mjs"), v(t.default);
    case "guitar_filled":
      return t = await import("./guitar-filled.BY0abHt8-BY0abHt8.mjs"), v(t.default);
    case "guitar":
      return t = await import("./guitar.DnDSaGQa-DnDSaGQa.mjs"), v(t.default);
    case "hand_heart_filled":
      return t = await import("./hand-heart-filled.pKqMlm7K-pKqMlm7K.mjs"), v(t.default);
    case "hand_heart":
      return t = await import("./hand-heart.DDv_G76q-DDv_G76q.mjs"), v(t.default);
    case "hashtag":
      return t = await import("./hashtag.BXELwIsz-BXELwIsz.mjs"), v(t.default);
    case "heading":
      return t = await import("./heading.DQofBerc-DQofBerc.mjs"), v(t.default);
    case "headphones_filled":
      return t = await import("./headphones-filled.CCJCeDIq-CCJCeDIq.mjs"), v(t.default);
    case "headphones_mic_filled":
      return t = await import("./headphones-mic-filled.D8-9Jr3Q-D8-9Jr3Q.mjs"), v(t.default);
    case "headphones_mic":
      return t = await import("./headphones-mic.BRMC_Bas-BRMC_Bas.mjs"), v(t.default);
    case "headphones_slash_filled":
      return t = await import("./headphones-slash-filled.BGU7aofb-BGU7aofb.mjs"), v(t.default);
    case "headphones_slash":
      return t = await import("./headphones-slash.du49R52f-du49R52f.mjs"), v(t.default);
    case "headphones":
      return t = await import("./headphones.Dxp07Onb-Dxp07Onb.mjs"), v(t.default);
    case "heart_filled":
      return t = await import("./heart-filled.Bmdl619Q-Bmdl619Q.mjs"), v(t.default);
    case "heart":
      return t = await import("./heart.DXqt3Wa9-DXqt3Wa9.mjs"), v(t.default);
    case "highlight_shadow_circle_filled":
      return t = await import("./highlight-shadow-circle-filled.SxUK3rsw-SxUK3rsw.mjs"), v(t.default);
    case "highlight_shadow_circle":
      return t = await import("./highlight-shadow-circle.DejKxlZt-DejKxlZt.mjs"), v(t.default);
    case "hook":
      return t = await import("./hook.DRjdkMzz-DRjdkMzz.mjs"), v(t.default);
    case "houdini":
      return t = await import("./houdini.BL4oFaIb-D8GZXYzX.mjs"), v(t.default);
    case "hourglass_filled":
      return t = await import("./hourglass-filled.C8k7GEt3-C8k7GEt3.mjs"), v(t.default);
    case "hourglass":
      return t = await import("./hourglass.Cs8u55dh-Cs8u55dh.mjs"), v(t.default);
    case "house_filled":
      return t = await import("./house-filled.Dtjsp_eL-Dtjsp_eL.mjs"), v(t.default);
    case "house":
      return t = await import("./house.2c061fn2-2c061fn2.mjs"), v(t.default);
    case "id_card_filled":
      return t = await import("./id-card-filled.BIoxbhU3-BIoxbhU3.mjs"), v(t.default);
    case "id_card_pen_filled":
      return t = await import("./id-card-pen-filled.1Ge_Ah8F-1Ge_Ah8F.mjs"), v(t.default);
    case "id_card_pen":
      return t = await import("./id-card-pen.CrUWxAEC-CrUWxAEC.mjs"), v(t.default);
    case "id_card":
      return t = await import("./id-card.D5Jted5A-D5Jted5A.mjs"), v(t.default);
    case "image_carousel_filled":
      return t = await import("./image-carousel-filled.BVmDtRVp-BVmDtRVp.mjs"), v(t.default);
    case "image_carousel":
      return t = await import("./image-carousel.9qL2PlXz-9qL2PlXz.mjs"), v(t.default);
    case "image_filled":
      return t = await import("./image-filled.Bdi2T4HW-Bdi2T4HW.mjs"), v(t.default);
    case "image_landscape_filled":
      return t = await import("./image-landscape-filled.DVHNtGuv-DVHNtGuv.mjs"), v(t.default);
    case "image_landscape_magnifier_filled":
      return t = await import("./image-landscape-magnifier-filled.B4p6_s0o-B4p6_s0o.mjs"), v(t.default);
    case "image_landscape_magnifier":
      return t = await import("./image-landscape-magnifier.Czr9GdNG-Czr9GdNG.mjs"), v(t.default);
    case "image_landscape":
      return t = await import("./image-landscape.BbyQ0eZ4-BbyQ0eZ4.mjs"), v(t.default);
    case "image_panorama_filled":
      return t = await import("./image-panorama-filled.C9hDm5JE-C9hDm5JE.mjs"), v(t.default);
    case "image_panorama":
      return t = await import("./image-panorama.DciNIkt0-DciNIkt0.mjs"), v(t.default);
    case "image_polaroid_filled":
      return t = await import("./image-polaroid-filled.Dfkp7NVB-Dfkp7NVB.mjs"), v(t.default);
    case "image_polaroid":
      return t = await import("./image-polaroid.CLit_8Hq-CLit_8Hq.mjs"), v(t.default);
    case "image_slash_filled":
      return t = await import("./image-slash-filled.yZgj-Anr-yZgj-Anr.mjs"), v(t.default);
    case "image_slash":
      return t = await import("./image-slash.DiyCEgQ0-DiyCEgQ0.mjs"), v(t.default);
    case "image":
      return t = await import("./image.Co6iiQhC-Co6iiQhC.mjs"), v(t.default);
    case "images_stacked_filled":
      return t = await import("./images-stacked-filled.BN0-s5XU-BN0-s5XU.mjs"), v(t.default);
    case "images_stacked":
      return t = await import("./images-stacked.BGX-zsHe-BGX-zsHe.mjs"), v(t.default);
    case "imdb":
      return t = await import("./imdb.C0QnF8Fm-C0QnF8Fm.mjs"), v(t.default);
    case "infinity":
      return t = await import("./infinity.sBOBEAps-IPnkUukV.mjs"), v(t.default);
    case "info_circle_filled":
      return t = await import("./info-circle-filled.C2DVOR-A-C2DVOR-A.mjs"), v(t.default);
    case "info_circle":
      return t = await import("./info-circle.CdVaFPWm-CdVaFPWm.mjs"), v(t.default);
    case "instagram":
      return t = await import("./instagram.BeFLUKil-BeFLUKil.mjs"), v(t.default);
    case "italic":
      return t = await import("./italic.z5bk6dDf-z5bk6dDf.mjs"), v(t.default);
    case "jpg":
      return t = await import("./jpg.Cl5FUfgB-Cl5FUfgB.mjs"), v(t.default);
    case "key_filled":
      return t = await import("./key-filled.B9QZheQU-B9QZheQU.mjs"), v(t.default);
    case "key":
      return t = await import("./key.CRz1S3t9-CRz1S3t9.mjs"), v(t.default);
    case "keyboard_filled":
      return t = await import("./keyboard-filled.DF4S-FU6-DF4S-FU6.mjs"), v(t.default);
    case "keyboard":
      return t = await import("./keyboard.DFV_zk2v-DFV_zk2v.mjs"), v(t.default);
    case "keytar_filled":
      return t = await import("./keytar-filled.fpzRbz1Z-fpzRbz1Z.mjs"), v(t.default);
    case "keytar":
      return t = await import("./keytar.B-wxuQUg-B-wxuQUg.mjs"), v(t.default);
    case "kids_web_services":
      return t = await import("./kids-web-services.FNW89m6u-FNW89m6u.mjs"), v(t.default);
    case "lab_beaker_filled":
      return t = await import("./lab-beaker-filled.DKsRKnEG-DKsRKnEG.mjs"), v(t.default);
    case "lab_beaker":
      return t = await import("./lab-beaker.DTZBvCxp-DTZBvCxp.mjs"), v(t.default);
    case "lamp_filled":
      return t = await import("./lamp-filled.v3WZ6sP2-v3WZ6sP2.mjs"), v(t.default);
    case "lamp":
      return t = await import("./lamp.tqui30AC-tqui30AC.mjs"), v(t.default);
    case "language":
      return t = await import("./language.CBcOq1T6-CBcOq1T6.mjs"), v(t.default);
    case "laptop_filled":
      return t = await import("./laptop-filled.DM9bSaUu-DM9bSaUu.mjs"), v(t.default);
    case "laptop":
      return t = await import("./laptop._Gs8m8bS-_Gs8m8bS.mjs"), v(t.default);
    case "layout_1_filled":
      return t = await import("./layout-1-filled.BOgrL00I-BOgrL00I.mjs"), v(t.default);
    case "layout_1":
      return t = await import("./layout-1._XHZ-sT_-_XHZ-sT_.mjs"), v(t.default);
    case "layout_2_filled":
      return t = await import("./layout-2-filled.Buzme8yX-Buzme8yX.mjs"), v(t.default);
    case "layout_2":
      return t = await import("./layout-2.C2YLR-Rn-C2YLR-Rn.mjs"), v(t.default);
    case "layout_3_filled":
      return t = await import("./layout-3-filled.CWkiBupM-CWkiBupM.mjs"), v(t.default);
    case "layout_3":
      return t = await import("./layout-3.CkIMv5hx-CkIMv5hx.mjs"), v(t.default);
    case "layout_4_filled":
      return t = await import("./layout-4-filled.ylGgpC_u-ylGgpC_u.mjs"), v(t.default);
    case "layout_4":
      return t = await import("./layout-4.BctsRe-P-BctsRe-P.mjs"), v(t.default);
    case "layout_5_filled":
      return t = await import("./layout-5-filled.Bq4mdM9m-Bq4mdM9m.mjs"), v(t.default);
    case "layout_5":
      return t = await import("./layout-5.7UcEtZZf-7UcEtZZf.mjs"), v(t.default);
    case "layout_6_filled":
      return t = await import("./layout-6-filled.CiO9J99y-CiO9J99y.mjs"), v(t.default);
    case "layout_6":
      return t = await import("./layout-6.D4TwwXKd-D4TwwXKd.mjs"), v(t.default);
    case "leaf_filled":
      return t = await import("./leaf-filled.ioGqJOl9-ioGqJOl9.mjs"), v(t.default);
    case "leaf":
      return t = await import("./leaf.BaB0ucN9-BaB0ucN9.mjs"), v(t.default);
    case "legal_hammer_filled":
      return t = await import("./legal-hammer-filled.nI5rcC_5-nI5rcC_5.mjs"), v(t.default);
    case "legal_hammer_slash_filled":
      return t = await import("./legal-hammer-slash-filled.Biv_OQ_B-DNPy0KcQ.mjs"), v(t.default);
    case "legal_hammer_slash":
      return t = await import("./legal-hammer-slash.BlR7pNpU-BlR7pNpU.mjs"), v(t.default);
    case "legal_hammer":
      return t = await import("./legal-hammer.BqFkVtsC-BqFkVtsC.mjs"), v(t.default);
    case "lego_brick_filled":
      return t = await import("./lego-brick-filled.COqhg9W5-COqhg9W5.mjs"), v(t.default);
    case "lego_brick":
      return t = await import("./lego-brick.BPSMUHEX-BPSMUHEX.mjs"), v(t.default);
    case "lego_head_filled":
      return t = await import("./lego-head-filled.CrVh3nHM-CrVh3nHM.mjs"), v(t.default);
    case "lego_head":
      return t = await import("./lego-head.CEKZXem7-CEKZXem7.mjs"), v(t.default);
    case "lego":
      return t = await import("./lego.CVTTcAPJ-CVTTcAPJ.mjs"), v(t.default);
    case "letter_m_arrow_down_rectangle_filled":
      return t = await import("./letter-m-arrow-down-rectangle-filled.BiCYaz15-BiCYaz15.mjs"), v(t.default);
    case "letter_m_arrow_down_rectangle":
      return t = await import("./letter-m-arrow-down-rectangle.BZT2bvPT-BZT2bvPT.mjs"), v(t.default);
    case "life_preserver":
      return t = await import("./life-preserver.5NbwI7Kj-5NbwI7Kj.mjs"), v(t.default);
    case "lightbulb_filled":
      return t = await import("./lightbulb-filled.23JglFsC-23JglFsC.mjs"), v(t.default);
    case "lightbulb":
      return t = await import("./lightbulb.CSGDi2fR-CSGDi2fR.mjs"), v(t.default);
    case "line_bars_vertical":
      return t = await import("./line-bars-vertical.Cp3CmZqz-Cp3CmZqz.mjs"), v(t.default);
    case "lines_horizontal":
      return t = await import("./lines-horizontal.BZFgMcme-BZFgMcme.mjs"), v(t.default);
    case "lines_square_stack_filled":
      return t = await import("./lines-square-stack-filled.CTF_du-2-CTF_du-2.mjs"), v(t.default);
    case "lines_square_stack":
      return t = await import("./lines-square-stack.BIAKPiUh-BIAKPiUh.mjs"), v(t.default);
    case "link_broken":
      return t = await import("./link-broken.DfhEuCgh-DfhEuCgh.mjs"), v(t.default);
    case "link":
      return t = await import("./link.CbZU4-EY-CbZU4-EY.mjs"), v(t.default);
    case "linkedin":
      return t = await import("./linkedin.DBhVuQHi-Dnsq4Dgk.mjs"), v(t.default);
    case "linux":
      return t = await import("./linux.CqKPV5FZ-CqKPV5FZ.mjs"), v(t.default);
    case "list_check":
      return t = await import("./list-check.Bi7yIGUM-Bi7yIGUM.mjs"), v(t.default);
    case "list_cogwheel":
      return t = await import("./list-cogwheel.7VO1mMoi-7VO1mMoi.mjs"), v(t.default);
    case "list_magnifier":
      return t = await import("./list-magnifier.BWguAe9--BWguAe9-.mjs"), v(t.default);
    case "list_minus":
      return t = await import("./list-minus.B8X_vhag-B8X_vhag.mjs"), v(t.default);
    case "list_plus":
      return t = await import("./list-plus.Cu9ZV38E-Cu9ZV38E.mjs"), v(t.default);
    case "list_timer":
      return t = await import("./list-timer.CC2qf9M8-CC2qf9M8.mjs"), v(t.default);
    case "list_x_mark":
      return t = await import("./list-x-mark.BGvxz--A-BGvxz--A.mjs"), v(t.default);
    case "loading":
      return t = await import("./loading.Dn901fkd-Dn901fkd.mjs"), v(t.default);
    case "location_drop_filled":
      return t = await import("./location-drop-filled.B2uEC8a8-B2uEC8a8.mjs"), v(t.default);
    case "location_drop":
      return t = await import("./location-drop.r42cdG18-r42cdG18.mjs"), v(t.default);
    case "lock_arrows_filled":
      return t = await import("./lock-arrows-filled.DOr3rM9t-DOr3rM9t.mjs"), v(t.default);
    case "lock_arrows":
      return t = await import("./lock-arrows.C3zXx0xU-C3zXx0xU.mjs"), v(t.default);
    case "lock_filled":
      return t = await import("./lock-filled.Dd4S6QDi-Dd4S6QDi.mjs"), v(t.default);
    case "lock_open_filled":
      return t = await import("./lock-open-filled.D81jfKfK-D81jfKfK.mjs"), v(t.default);
    case "lock_open":
      return t = await import("./lock-open.Cu1y2ll2-Cu1y2ll2.mjs"), v(t.default);
    case "lock_pen_filled":
      return t = await import("./lock-pen-filled.q2L0vR4--q2L0vR4-.mjs"), v(t.default);
    case "lock_pen":
      return t = await import("./lock-pen.Co8fptW2-Co8fptW2.mjs"), v(t.default);
    case "lock_question_filled":
      return t = await import("./lock-question-filled.BZAVIx8D-BZAVIx8D.mjs"), v(t.default);
    case "lock_question":
      return t = await import("./lock-question.DReMmFo2-DReMmFo2.mjs"), v(t.default);
    case "lock":
      return t = await import("./lock.UBt_9FfT-UBt_9FfT.mjs"), v(t.default);
    case "macos":
      return t = await import("./macos.D_OMlJe8-D_OMlJe8.mjs"), v(t.default);
    case "macro_filled":
      return t = await import("./macro-filled.dJ5wvc5F-dJ5wvc5F.mjs"), v(t.default);
    case "macro":
      return t = await import("./macro.CkbolJ0f-CkbolJ0f.mjs"), v(t.default);
    case "magazine_check_filled":
      return t = await import("./magazine-check-filled.BIX8jiuB-BIX8jiuB.mjs"), v(t.default);
    case "magazine_check":
      return t = await import("./magazine-check.is0qda6M-is0qda6M.mjs"), v(t.default);
    case "magazine_filled":
      return t = await import("./magazine-filled.CIKQlSHc-CIKQlSHc.mjs"), v(t.default);
    case "magazine_link_filled":
      return t = await import("./magazine-link-filled.ByAAiA0E-ByAAiA0E.mjs"), v(t.default);
    case "magazine_link":
      return t = await import("./magazine-link.DIlo_RDH-DIlo_RDH.mjs"), v(t.default);
    case "magazine":
      return t = await import("./magazine.FhJXREIE-FhJXREIE.mjs"), v(t.default);
    case "magnet_filled":
      return t = await import("./magnet-filled.CNEm_Bmt-CNEm_Bmt.mjs"), v(t.default);
    case "magnet":
      return t = await import("./magnet.CU43wpBp-CU43wpBp.mjs"), v(t.default);
    case "magnifier_filled":
      return t = await import("./magnifier-filled.CUSfrKp5-CUSfrKp5.mjs"), v(t.default);
    case "magnifier_minus_filled":
      return t = await import("./magnifier-minus-filled.CwNbv5Kj-CwNbv5Kj.mjs"), v(t.default);
    case "magnifier_minus":
      return t = await import("./magnifier-minus.bFPGgQiL-bFPGgQiL.mjs"), v(t.default);
    case "magnifier_plus_filled":
      return t = await import("./magnifier-plus-filled.DT6UMGeX-DT6UMGeX.mjs"), v(t.default);
    case "magnifier_plus":
      return t = await import("./magnifier-plus.CeDHRBn6-CeDHRBn6.mjs"), v(t.default);
    case "magnifier":
      return t = await import("./magnifier.D87sMV3t-D87sMV3t.mjs"), v(t.default);
    case "materialx":
      return t = await import("./materialx.CHkK8_oQ-CHkK8_oQ.mjs"), v(t.default);
    case "medal_1_filled":
      return t = await import("./medal-1-filled.DpPZu4S0-DpPZu4S0.mjs"), v(t.default);
    case "medal_1":
      return t = await import("./medal-1.uJXloO1u-uJXloO1u.mjs"), v(t.default);
    case "medal_2_filled":
      return t = await import("./medal-2-filled.Dlz2ajjf-Dlz2ajjf.mjs"), v(t.default);
    case "medal_2":
      return t = await import("./medal-2.b7xm_LgF-b7xm_LgF.mjs"), v(t.default);
    case "medal_3_filled":
      return t = await import("./medal-3-filled.BHfi7LfC-BHfi7LfC.mjs"), v(t.default);
    case "medal_3":
      return t = await import("./medal-3.BdBMenuA-BdBMenuA.mjs"), v(t.default);
    case "medal_star_filled":
      return t = await import("./medal-star-filled.CnN0S5yQ-CnN0S5yQ.mjs"), v(t.default);
    case "medal_star":
      return t = await import("./medal-star.BUIePWt--BUIePWt-.mjs"), v(t.default);
    case "merge_x_mark":
      return t = await import("./merge-x-mark.DZnJTrol-DZnJTrol.mjs"), v(t.default);
    case "merge":
      return t = await import("./merge.CevWru8q-CevWru8q.mjs"), v(t.default);
    case "metahuman":
      return t = await import("./metahuman.BujZafR1-BujZafR1.mjs"), v(t.default);
    case "meteor_filled":
      return t = await import("./meteor-filled.BPU6o4Oc-BPU6o4Oc.mjs"), v(t.default);
    case "meteor":
      return t = await import("./meteor.C9JUv0jh-C9JUv0jh.mjs"), v(t.default);
    case "mic_blocked_filled":
      return t = await import("./mic-blocked-filled.BSVm2LA--BSVm2LA-.mjs"), v(t.default);
    case "mic_blocked":
      return t = await import("./mic-blocked.BSbyztRB-BSbyztRB.mjs"), v(t.default);
    case "mic_filled":
      return t = await import("./mic-filled.DWZU62vm-DWZU62vm.mjs"), v(t.default);
    case "mic_slash_filled":
      return t = await import("./mic-slash-filled.DRrJ9gFh-DRrJ9gFh.mjs"), v(t.default);
    case "mic_slash":
      return t = await import("./mic-slash.CGiViv0r-CGiViv0r.mjs"), v(t.default);
    case "mic":
      return t = await import("./mic.BQAaVDtq-BQAaVDtq.mjs"), v(t.default);
    case "military_badge_filled":
      return t = await import("./military-badge-filled.B67AhEDA-B67AhEDA.mjs"), v(t.default);
    case "military_badge":
      return t = await import("./military-badge.CngJq3n6-CngJq3n6.mjs"), v(t.default);
    case "minecraft":
      return t = await import("./minecraft.D9ms79AV-D9ms79AV.mjs"), v(t.default);
    case "minus_circle_filled":
      return t = await import("./minus-circle-filled.Cj2dED0M-Cj2dED0M.mjs"), v(t.default);
    case "minus_circle":
      return t = await import("./minus-circle.DfQmr3l8-DfQmr3l8.mjs"), v(t.default);
    case "minus_square_filled":
      return t = await import("./minus-square-filled.ma5Na3jc-ma5Na3jc.mjs"), v(t.default);
    case "minus_square":
      return t = await import("./minus-square.viz5WVVp-viz5WVVp.mjs"), v(t.default);
    case "minus":
      return t = await import("./minus.Bui2gha4-Bui2gha4.mjs"), v(t.default);
    case "mixer":
      return t = await import("./mixer.De1FHk0G-De1FHk0G.mjs"), v(t.default);
    case "moon_filled":
      return t = await import("./moon-filled.hLHnUZoe-lxvGwvnz.mjs"), v(t.default);
    case "moon":
      return t = await import("./moon.Byhl64dh-Byhl64dh.mjs"), v(t.default);
    case "mouse_filled":
      return t = await import("./mouse-filled.DBA1u5xK-DBA1u5xK.mjs"), v(t.default);
    case "mouse":
      return t = await import("./mouse.Z0cyw7G5-Z0cyw7G5.mjs"), v(t.default);
    case "multiple_shapes_filled":
      return t = await import("./multiple-shapes-filled.dXBWj9Or-dXBWj9Or.mjs"), v(t.default);
    case "multiple_shapes":
      return t = await import("./multiple-shapes.BcRV4FQw-BcRV4FQw.mjs"), v(t.default);
    case "music_note_filled":
      return t = await import("./music-note-filled.CL02y0-u-CEzc7LKu.mjs"), v(t.default);
    case "music_note":
      return t = await import("./music-note.DIY4r5tX-DIY4r5tX.mjs"), v(t.default);
    case "mydisney":
      return t = await import("./mydisney.B_2Cva2J-B_2Cva2J.mjs"), v(t.default);
    case "naver":
      return t = await import("./naver.CIT9oz2t-CIT9oz2t.mjs"), v(t.default);
    case "network":
      return t = await import("./network.Bj2Bszmc-Bj2Bszmc.mjs"), v(t.default);
    case "newspaper_filled":
      return t = await import("./newspaper-filled.yaLWVZ2--yaLWVZ2-.mjs"), v(t.default);
    case "newspaper":
      return t = await import("./newspaper.NfZQeAgV-NfZQeAgV.mjs"), v(t.default);
    case "nintendo_switch":
      return t = await import("./nintendo-switch.BHyhFinS-BHyhFinS.mjs"), v(t.default);
    case "nintendo":
      return t = await import("./nintendo.C3WjDDnV-C3WjDDnV.mjs"), v(t.default);
    case "node_filled":
      return t = await import("./node-filled.DDdwSwFY-DDdwSwFY.mjs"), v(t.default);
    case "node":
      return t = await import("./node.EFVaviVy-EFVaviVy.mjs"), v(t.default);
    case "note_filled":
      return t = await import("./note-filled.DhaQBE9k-DhaQBE9k.mjs"), v(t.default);
    case "note_pen_filled":
      return t = await import("./note-pen-filled.CSBLMsff-CSBLMsff.mjs"), v(t.default);
    case "note_pen":
      return t = await import("./note-pen.DJgfh2Vr-DJgfh2Vr.mjs"), v(t.default);
    case "note":
      return t = await import("./note.Cr885C-_-Cr885C-_.mjs"), v(t.default);
    case "notebook_filled":
      return t = await import("./notebook-filled.DP4hleCj-DP4hleCj.mjs"), v(t.default);
    case "notebook_pen_filled":
      return t = await import("./notebook-pen-filled.38gwoUCz-38gwoUCz.mjs"), v(t.default);
    case "notebook_pen":
      return t = await import("./notebook-pen.DUDF4Jso-DUDF4Jso.mjs"), v(t.default);
    case "notebook":
      return t = await import("./notebook.BKkkyAQA-BKkkyAQA.mjs"), v(t.default);
    case "numbered_list":
      return t = await import("./numbered-list.CzkhazmK-CzkhazmK.mjs"), v(t.default);
    case "off":
      return t = await import("./off.DzRFGo5V-DzRFGo5V.mjs"), v(t.default);
    case "paint_brush_filled":
      return t = await import("./paint-brush-filled.DxbrCw4A-DxbrCw4A.mjs"), v(t.default);
    case "paint_brush":
      return t = await import("./paint-brush.DhTsDoWo-DhTsDoWo.mjs"), v(t.default);
    case "palette_filled":
      return t = await import("./palette-filled.DlFD2f93-DlFD2f93.mjs"), v(t.default);
    case "palette":
      return t = await import("./palette.Da4Py9kX-Da4Py9kX.mjs"), v(t.default);
    case "paper_clip":
      return t = await import("./paper-clip.B_MErVWG-B_MErVWG.mjs"), v(t.default);
    case "paper_plane_filled":
      return t = await import("./paper-plane-filled.D4ahysCa-D4ahysCa.mjs"), v(t.default);
    case "paper_plane":
      return t = await import("./paper-plane.BS21xUvi-BS21xUvi.mjs"), v(t.default);
    case "paragraph":
      return t = await import("./paragraph.DJLc-Cv7-DJLc-Cv7.mjs"), v(t.default);
    case "parent_child_check_filled":
      return t = await import("./parent-child-check-filled.CfV_nf3V-CfV_nf3V.mjs"), v(t.default);
    case "parent_child_check":
      return t = await import("./parent-child-check.BAo5YJiu-BAo5YJiu.mjs"), v(t.default);
    case "parent_child_cogwheel_filled":
      return t = await import("./parent-child-cogwheel-filled.DgNQcmAm-DgNQcmAm.mjs"), v(t.default);
    case "parent_child_cogwheel":
      return t = await import("./parent-child-cogwheel.D7Gf_BIp-D7Gf_BIp.mjs"), v(t.default);
    case "parent_child_filled":
      return t = await import("./parent-child-filled.36bw7wFI-36bw7wFI.mjs"), v(t.default);
    case "parent_child":
      return t = await import("./parent-child.BwNM-Emr-BwNM-Emr.mjs"), v(t.default);
    case "passport_filled":
      return t = await import("./passport-filled.BSiiIdvL-BSiiIdvL.mjs"), v(t.default);
    case "passport":
      return t = await import("./passport.RCXXoNYV-RCXXoNYV.mjs"), v(t.default);
    case "password_field_filled":
      return t = await import("./password-field-filled.CICZJUIQ-CICZJUIQ.mjs"), v(t.default);
    case "password_field":
      return t = await import("./password-field.lXLkin-K-lXLkin-K.mjs"), v(t.default);
    case "pause_circle_filled":
      return t = await import("./pause-circle-filled.CIXgkInu-CIXgkInu.mjs"), v(t.default);
    case "pause_circle":
      return t = await import("./pause-circle.DIkQ_U8g-DIkQ_U8g.mjs"), v(t.default);
    case "pause_filled":
      return t = await import("./pause-filled.Do8EaMJB-Do8EaMJB.mjs"), v(t.default);
    case "pause":
      return t = await import("./pause.DUdBRvdT-DUdBRvdT.mjs"), v(t.default);
    case "paw_filled":
      return t = await import("./paw-filled.CowIxYpC-CowIxYpC.mjs"), v(t.default);
    case "paw":
      return t = await import("./paw.Cy2zhT2G-Cy2zhT2G.mjs"), v(t.default);
    case "pen_ruler_filled":
      return t = await import("./pen-ruler-filled.CHJMZ7XM-CHJMZ7XM.mjs"), v(t.default);
    case "pen_ruler":
      return t = await import("./pen-ruler.5o8F1GJB-5o8F1GJB.mjs"), v(t.default);
    case "pencil_filled":
      return t = await import("./pencil-filled.DFlFRgbg-DFlFRgbg.mjs"), v(t.default);
    case "pencil_scribble_filled":
      return t = await import("./pencil-scribble-filled.qK0lAao3-Df4wkl28.mjs"), v(t.default);
    case "pencil_scribble":
      return t = await import("./pencil-scribble.zemdDKcL-zemdDKcL.mjs"), v(t.default);
    case "pencil_slash_filled":
      return t = await import("./pencil-slash-filled.Bpo0sSbk-B6djEDkx.mjs"), v(t.default);
    case "pencil_slash":
      return t = await import("./pencil-slash.xcyM8K7W-xcyM8K7W.mjs"), v(t.default);
    case "pencil_square":
      return t = await import("./pencil-square.UzNmtfBO-UzNmtfBO.mjs"), v(t.default);
    case "pencil":
      return t = await import("./pencil.BkkESZIo-BkkESZIo.mjs"), v(t.default);
    case "percent_seal_filled":
      return t = await import("./percent-seal-filled.CHJK-rJ--CHJK-rJ-.mjs"), v(t.default);
    case "percent_seal":
      return t = await import("./percent-seal.dN4eNvpm-dN4eNvpm.mjs"), v(t.default);
    case "percent":
      return t = await import("./percent.n2nms-5I-n2nms-5I.mjs"), v(t.default);
    case "person_dancing_filled":
      return t = await import("./person-dancing-filled.BHI9H2Fi-BHI9H2Fi.mjs"), v(t.default);
    case "person_dancing":
      return t = await import("./person-dancing._dbDUk-e-_dbDUk-e.mjs"), v(t.default);
    case "phone_filled":
      return t = await import("./phone-filled.BsDnynMF-BsDnynMF.mjs"), v(t.default);
    case "phone":
      return t = await import("./phone.CQx1djkU-CQx1djkU.mjs"), v(t.default);
    case "photo_frame":
      return t = await import("./photo-frame.DrFzOYJl-DrFzOYJl.mjs"), v(t.default);
    case "pin_filled":
      return t = await import("./pin-filled.B5XCbkNK-B5XCbkNK.mjs"), v(t.default);
    case "pin":
      return t = await import("./pin.DWyjWPR_-DWyjWPR_.mjs"), v(t.default);
    case "pinterest":
      return t = await import("./pinterest.D7nUwTsa-D7nUwTsa.mjs"), v(t.default);
    case "plane_filled":
      return t = await import("./plane-filled.BB8dVF32-BB8dVF32.mjs"), v(t.default);
    case "plane":
      return t = await import("./plane.ClaqYrRl-ClaqYrRl.mjs"), v(t.default);
    case "play_circle_filled":
      return t = await import("./play-circle-filled.e8s1CsZH-e8s1CsZH.mjs"), v(t.default);
    case "play_circle":
      return t = await import("./play-circle.BNajA6lO-BNajA6lO.mjs"), v(t.default);
    case "play_filled":
      return t = await import("./play-filled.Dvukt4h3-Dvukt4h3.mjs"), v(t.default);
    case "play":
      return t = await import("./play.CzVQLLzE-CzVQLLzE.mjs"), v(t.default);
    case "playstation":
      return t = await import("./playstation.CGAgFuWl-CGAgFuWl.mjs"), v(t.default);
    case "plus_circle_filled":
      return t = await import("./plus-circle-filled.QbtWDUiC-QbtWDUiC.mjs"), v(t.default);
    case "plus_circle":
      return t = await import("./plus-circle.BBRjW2kf-BBRjW2kf.mjs"), v(t.default);
    case "plus_square_filled":
      return t = await import("./plus-square-filled.jQL3TVj5-jQL3TVj5.mjs"), v(t.default);
    case "plus_square":
      return t = await import("./plus-square.BvIZ2PhL-BvIZ2PhL.mjs"), v(t.default);
    case "plus":
      return t = await import("./plus.DvOd4JfE-DvOd4JfE.mjs"), v(t.default);
    case "png":
      return t = await import("./png.vnYh5ksp-vnYh5ksp.mjs"), v(t.default);
    case "poster_filled":
      return t = await import("./poster-filled.UiQMnj6H-UiQMnj6H.mjs"), v(t.default);
    case "poster":
      return t = await import("./poster.CRsqNi-i-CRsqNi-i.mjs"), v(t.default);
    case "postparty":
      return t = await import("./postparty.Cm4kaRVx-Cm4kaRVx.mjs"), v(t.default);
    case "power_cord_filled":
      return t = await import("./power-cord-filled.6gVzL3t_-BvPsqY2q.mjs"), v(t.default);
    case "power_cord":
      return t = await import("./power-cord.DcHNEkWk-DcHNEkWk.mjs"), v(t.default);
    case "pro":
      return t = await import("./pro.C-BhFvhy-C-BhFvhy.mjs"), v(t.default);
    case "prompt_check_filled":
      return t = await import("./prompt-check-filled.DSnrepBm-DSnrepBm.mjs"), v(t.default);
    case "prompt_check":
      return t = await import("./prompt-check.mO5krZST-mO5krZST.mjs"), v(t.default);
    case "prompt_exclamation_filled":
      return t = await import("./prompt-exclamation-filled.CQrqtWv3-CQrqtWv3.mjs"), v(t.default);
    case "prompt_exclamation":
      return t = await import("./prompt-exclamation.DxdvwZEI-DxdvwZEI.mjs"), v(t.default);
    case "prompt_info_filled":
      return t = await import("./prompt-info-filled.DK9JJ76q-DK9JJ76q.mjs"), v(t.default);
    case "prompt_info":
      return t = await import("./prompt-info.D6OnlQ27-D6OnlQ27.mjs"), v(t.default);
    case "prompt_x_mark_filled":
      return t = await import("./prompt-x-mark-filled.Ciw7XFeY-Ciw7XFeY.mjs"), v(t.default);
    case "prompt_x_mark":
      return t = await import("./prompt-x-mark.DUIdAIGY-DUIdAIGY.mjs"), v(t.default);
    case "pull_request":
      return t = await import("./pull-request.DlOJgJdQ-DlOJgJdQ.mjs"), v(t.default);
    case "puzzle_filled":
      return t = await import("./puzzle-filled.m6telrFD-m6telrFD.mjs"), v(t.default);
    case "puzzle":
      return t = await import("./puzzle.DihgS3WU-DihgS3WU.mjs"), v(t.default);
    case "qr_code":
      return t = await import("./qr-code.CRdzEF7k-CRdzEF7k.mjs"), v(t.default);
    case "question_circle_filled":
      return t = await import("./question-circle-filled.ieQOaRrC-ieQOaRrC.mjs"), v(t.default);
    case "question_circle":
      return t = await import("./question-circle.DZrwNAeP-DZrwNAeP.mjs"), v(t.default);
    case "quixel":
      return t = await import("./quixel.CAShk2Bu-CAShk2Bu.mjs"), v(t.default);
    case "realitycapture":
      return t = await import("./realitycapture.DDFXiwte-DDFXiwte.mjs"), v(t.default);
    case "realityscan":
      return t = await import("./realityscan.Dd1HWjfA-Dd1HWjfA.mjs"), v(t.default);
    case "receipt_arrow_turn_up_left_filled":
      return t = await import("./receipt-arrow-turn-up-left-filled.lNdCIjaN-lNdCIjaN.mjs"), v(t.default);
    case "receipt_arrow_turn_up_left":
      return t = await import("./receipt-arrow-turn-up-left.DZc8zB05-DZc8zB05.mjs"), v(t.default);
    case "receipt_dollar_sign_filled":
      return t = await import("./receipt-dollar-sign-filled.D_oidV_n-D_oidV_n.mjs"), v(t.default);
    case "receipt_dollar_sign":
      return t = await import("./receipt-dollar-sign.BxxtF9cF-BxxtF9cF.mjs"), v(t.default);
    case "receipt_filled":
      return t = await import("./receipt-filled.BHtVSFaj-BHtVSFaj.mjs"), v(t.default);
    case "receipt_percentage_filled":
      return t = await import("./receipt-percentage-filled.BR_5uR56-BR_5uR56.mjs"), v(t.default);
    case "receipt_percentage":
      return t = await import("./receipt-percentage.DJKLrYuO-DJKLrYuO.mjs"), v(t.default);
    case "receipt":
      return t = await import("./receipt.DFiXJaqP-DFiXJaqP.mjs"), v(t.default);
    case "rectangle_stacked_filled":
      return t = await import("./rectangle-stacked-filled.KLZO87NG-KLZO87NG.mjs"), v(t.default);
    case "rectangle_stacked":
      return t = await import("./rectangle-stacked.C-xumzMh-C-xumzMh.mjs"), v(t.default);
    case "reddit":
      return t = await import("./reddit.DspRDTU0-DspRDTU0.mjs"), v(t.default);
    case "resolution_16k":
      return t = await import("./resolution-16k.BdndTB-F-BdndTB-F.mjs"), v(t.default);
    case "resolution_4k":
      return t = await import("./resolution-4k.DQlU0D2W-DQlU0D2W.mjs"), v(t.default);
    case "resolution_8k":
      return t = await import("./resolution-8k.Ba7zrL9L-Ba7zrL9L.mjs"), v(t.default);
    case "roblox":
      return t = await import("./roblox.BSwVd7vq-D2U9k1My.mjs"), v(t.default);
    case "robot_filled":
      return t = await import("./robot-filled.BDSIOOT5-BDSIOOT5.mjs"), v(t.default);
    case "robot_surprised_filled":
      return t = await import("./robot-surprised-filled.Dd-c4Nx7-Dd-c4Nx7.mjs"), v(t.default);
    case "robot_surprised":
      return t = await import("./robot-surprised.BoQO1Nwq-BoQO1Nwq.mjs"), v(t.default);
    case "robot_x_marks_filled":
      return t = await import("./robot-x-marks-filled.D9CaP8oG-D9CaP8oG.mjs"), v(t.default);
    case "robot_x_marks":
      return t = await import("./robot-x-marks.zuzfy-Iu-zuzfy-Iu.mjs"), v(t.default);
    case "robot":
      return t = await import("./robot.Bx2gQavN-Bx2gQavN.mjs"), v(t.default);
    case "rocket_filled":
      return t = await import("./rocket-filled.Do2L0hC_-Do2L0hC_.mjs"), v(t.default);
    case "rocket_league_sideswipe":
      return t = await import("./rocket-league-sideswipe.CiwqUq37-CiwqUq37.mjs"), v(t.default);
    case "rocket_league":
      return t = await import("./rocket-league.LvRYj9Ix-LvRYj9Ix.mjs"), v(t.default);
    case "rocket":
      return t = await import("./rocket.kPLRuTjh-kPLRuTjh.mjs"), v(t.default);
    case "route_end":
      return t = await import("./route-end.DwjcHRgA-DwjcHRgA.mjs"), v(t.default);
    case "route_start":
      return t = await import("./route-start.B5Cj4PYQ-B5Cj4PYQ.mjs"), v(t.default);
    case "rss":
      return t = await import("./rss.CmM8PjQs-CmM8PjQs.mjs"), v(t.default);
    case "ruble_sign_circle_filled":
      return t = await import("./ruble-sign-circle-filled.Cl7mBraw-Cl7mBraw.mjs"), v(t.default);
    case "ruble_sign_circle":
      return t = await import("./ruble-sign-circle.DEHry4IP-DEHry4IP.mjs"), v(t.default);
    case "ruler_filled":
      return t = await import("./ruler-filled.BcLbUOsC-BcLbUOsC.mjs"), v(t.default);
    case "ruler":
      return t = await import("./ruler.DbN1mSJd-DbN1mSJd.mjs"), v(t.default);
    case "rupee_sign_circle_filled":
      return t = await import("./rupee-sign-circle-filled.SCgQpCk_-SCgQpCk_.mjs"), v(t.default);
    case "rupee_sign_circle":
      return t = await import("./rupee-sign-circle.B7mmuEPJ-B7mmuEPJ.mjs"), v(t.default);
    case "salesforce":
      return t = await import("./salesforce.zEH_afkM-zEH_afkM.mjs"), v(t.default);
    case "samsung":
      return t = await import("./samsung.BUrWctQa-BUrWctQa.mjs"), v(t.default);
    case "scales_filled":
      return t = await import("./scales-filled.DOtVSlh5-DOtVSlh5.mjs"), v(t.default);
    case "scales":
      return t = await import("./scales.CX8o4oRv-CX8o4oRv.mjs"), v(t.default);
    case "scan_cube":
      return t = await import("./scan-cube.CT5jEFOj-CT5jEFOj.mjs"), v(t.default);
    case "scan_qr_code":
      return t = await import("./scan-qr-code.CdYk5pXi-CdYk5pXi.mjs"), v(t.default);
    case "scan":
      return t = await import("./scan.B3TUUitp-B3TUUitp.mjs"), v(t.default);
    case "screen_dashboard_filled":
      return t = await import("./screen-dashboard-filled.BKxAz7Ee-BKxAz7Ee.mjs"), v(t.default);
    case "screen_dashboard":
      return t = await import("./screen-dashboard.DHlukGxO-DHlukGxO.mjs"), v(t.default);
    case "screen_presentation_filled":
      return t = await import("./screen-presentation-filled.CqaejnCA-CqaejnCA.mjs"), v(t.default);
    case "screen_presentation":
      return t = await import("./screen-presentation.CCeQz7i7-CCeQz7i7.mjs"), v(t.default);
    case "screen_slideshow_filled":
      return t = await import("./screen-slideshow-filled.CGdU3a2o-CGdU3a2o.mjs"), v(t.default);
    case "screen_slideshow":
      return t = await import("./screen-slideshow.BgMdTotJ-BgMdTotJ.mjs"), v(t.default);
    case "scroll_filled":
      return t = await import("./scroll-filled.BLk4A1nK-BLk4A1nK.mjs"), v(t.default);
    case "scroll":
      return t = await import("./scroll.Dd18uea--Dd18uea-.mjs"), v(t.default);
    case "server_filled":
      return t = await import("./server-filled.C2Mqwo75-C2Mqwo75.mjs"), v(t.default);
    case "server":
      return t = await import("./server.cnfpq_uR-cnfpq_uR.mjs"), v(t.default);
    case "shield_check_filled":
      return t = await import("./shield-check-filled.XR2DV85g-XR2DV85g.mjs"), v(t.default);
    case "shield_check_pen_filled":
      return t = await import("./shield-check-pen-filled.BSL6rpl9-BSL6rpl9.mjs"), v(t.default);
    case "shield_check_pen":
      return t = await import("./shield-check-pen.DpXNx7QK-DpXNx7QK.mjs"), v(t.default);
    case "shield_check":
      return t = await import("./shield-check.DAGQstxc-DAGQstxc.mjs"), v(t.default);
    case "shield_filled":
      return t = await import("./shield-filled.Djbq6i_O-Djbq6i_O.mjs"), v(t.default);
    case "shield_lock_filled":
      return t = await import("./shield-lock-filled.D05lzv4F-D05lzv4F.mjs"), v(t.default);
    case "shield_lock":
      return t = await import("./shield-lock.BuTH5HN_-BuTH5HN_.mjs"), v(t.default);
    case "shield_plus_filled":
      return t = await import("./shield-plus-filled.C3HsoEzT-C3HsoEzT.mjs"), v(t.default);
    case "shield_plus":
      return t = await import("./shield-plus.Bz_U0dA9-Bz_U0dA9.mjs"), v(t.default);
    case "shield_slash_filled":
      return t = await import("./shield-slash-filled.D9f2c9es-Bgasm3F-.mjs"), v(t.default);
    case "shield_slash":
      return t = await import("./shield-slash.BZ-q2pPM-BZ-q2pPM.mjs"), v(t.default);
    case "shield_x_mark_filled":
      return t = await import("./shield-x-mark-filled.oxFO0aGv-oxFO0aGv.mjs"), v(t.default);
    case "shield_x_mark":
      return t = await import("./shield-x-mark.Dc97U6mA-Dc97U6mA.mjs"), v(t.default);
    case "shield":
      return t = await import("./shield.5tP4Vr1--5tP4Vr1-.mjs"), v(t.default);
    case "shoes_filled":
      return t = await import("./shoes-filled.gJC4NO0--gJC4NO0-.mjs"), v(t.default);
    case "shoes":
      return t = await import("./shoes.DCz3lEV5-DCz3lEV5.mjs"), v(t.default);
    case "shooting_star":
      return t = await import("./shooting-star.aPjZuhsv-aPjZuhsv.mjs"), v(t.default);
    case "shopping_bag_clock_filled":
      return t = await import("./shopping-bag-clock-filled.Cx7BrCsA-Cx7BrCsA.mjs"), v(t.default);
    case "shopping_bag_clock":
      return t = await import("./shopping-bag-clock.BCGboG9W-BCGboG9W.mjs"), v(t.default);
    case "shopping_bag_filled":
      return t = await import("./shopping-bag-filled.DBl_8NqD-DBl_8NqD.mjs"), v(t.default);
    case "shopping_bag":
      return t = await import("./shopping-bag.uPA4XX41-uPA4XX41.mjs"), v(t.default);
    case "shopping_cart_check_filled":
      return t = await import("./shopping-cart-check-filled.PwdcagT9-PwdcagT9.mjs"), v(t.default);
    case "shopping_cart_check":
      return t = await import("./shopping-cart-check.FQvFUhOt-FQvFUhOt.mjs"), v(t.default);
    case "shopping_cart_filled":
      return t = await import("./shopping-cart-filled.iZepmIRh-iZepmIRh.mjs"), v(t.default);
    case "shopping_cart_minus_filled":
      return t = await import("./shopping-cart-minus-filled.BW2qhDFe-BW2qhDFe.mjs"), v(t.default);
    case "shopping_cart_minus":
      return t = await import("./shopping-cart-minus.BuQg7TOu-BuQg7TOu.mjs"), v(t.default);
    case "shopping_cart_plus_filled":
      return t = await import("./shopping-cart-plus-filled.BhVyTYPL-BhVyTYPL.mjs"), v(t.default);
    case "shopping_cart_plus":
      return t = await import("./shopping-cart-plus.CDU1CohN-CDU1CohN.mjs"), v(t.default);
    case "shopping_cart_trend_up_filled":
      return t = await import("./shopping-cart-trend-up-filled.DgAmkCJt-DgAmkCJt.mjs"), v(t.default);
    case "shopping_cart_trend_up":
      return t = await import("./shopping-cart-trend-up.C4LpVuwh-C4LpVuwh.mjs"), v(t.default);
    case "shopping_cart":
      return t = await import("./shopping-cart.NTTDz4mY-NTTDz4mY.mjs"), v(t.default);
    case "signal":
      return t = await import("./signal.CLzY05jQ-CLzY05jQ.mjs"), v(t.default);
    case "sketchfab":
      return t = await import("./sketchfab.C6rmM0_6-C6rmM0_6.mjs"), v(t.default);
    case "skyscraper_filled":
      return t = await import("./skyscraper-filled.BwVDjIML-BwVDjIML.mjs"), v(t.default);
    case "skyscraper":
      return t = await import("./skyscraper.D7ctIvxQ-D7ctIvxQ.mjs"), v(t.default);
    case "slack":
      return t = await import("./slack.BrOzQlph-BrOzQlph.mjs"), v(t.default);
    case "slash_circle":
      return t = await import("./slash-circle.XPSiGZKY-XPSiGZKY.mjs"), v(t.default);
    case "slider_compare_filled":
      return t = await import("./slider-compare-filled.DW-cfTeD-DW-cfTeD.mjs"), v(t.default);
    case "slider_compare":
      return t = await import("./slider-compare.D4dOO8FQ-D4dOO8FQ.mjs"), v(t.default);
    case "slider_sequence_filled":
      return t = await import("./slider-sequence-filled.C7mDovQx-C7mDovQx.mjs"), v(t.default);
    case "slider_sequence":
      return t = await import("./slider-sequence.BqK8GL80-BqK8GL80.mjs"), v(t.default);
    case "sliders_horizontal_filled":
      return t = await import("./sliders-horizontal-filled.CBdSWDey-CBdSWDey.mjs"), v(t.default);
    case "sliders_horizontal":
      return t = await import("./sliders-horizontal.ySgmIkO0-ySgmIkO0.mjs"), v(t.default);
    case "snapchat":
      return t = await import("./snapchat.BPsn1NX6-BPsn1NX6.mjs"), v(t.default);
    case "snowflake":
      return t = await import("./snowflake.uZMAiAh5-uZMAiAh5.mjs"), v(t.default);
    case "sparkle_filled":
      return t = await import("./sparkle-filled.ZSeAc83a-QOP4GJby.mjs"), v(t.default);
    case "sparkle":
      return t = await import("./sparkle.BHqjtkTs-BHqjtkTs.mjs"), v(t.default);
    case "speaker_high_filled":
      return t = await import("./speaker-high-filled.DA8aLi-q-DA8aLi-q.mjs"), v(t.default);
    case "speaker_high":
      return t = await import("./speaker-high.22ZRNg-P-22ZRNg-P.mjs"), v(t.default);
    case "speaker_locked_filled":
      return t = await import("./speaker-locked-filled.BeCwD747-BeCwD747.mjs"), v(t.default);
    case "speaker_locked":
      return t = await import("./speaker-locked.BxAw6rFX-BxAw6rFX.mjs"), v(t.default);
    case "speaker_low_filled":
      return t = await import("./speaker-low-filled.pAMyYWVN-pAMyYWVN.mjs"), v(t.default);
    case "speaker_low":
      return t = await import("./speaker-low.Dtqcm0RW-Dtqcm0RW.mjs"), v(t.default);
    case "speaker_medium_filled":
      return t = await import("./speaker-medium-filled.6pCLbpBn-6pCLbpBn.mjs"), v(t.default);
    case "speaker_medium":
      return t = await import("./speaker-medium.nR95FU8t-nR95FU8t.mjs"), v(t.default);
    case "speaker_minus_filled":
      return t = await import("./speaker-minus-filled.0VuY9bEn-0VuY9bEn.mjs"), v(t.default);
    case "speaker_minus":
      return t = await import("./speaker-minus.C5mVwFkz-C5mVwFkz.mjs"), v(t.default);
    case "speaker_plus_filled":
      return t = await import("./speaker-plus-filled.oLNnL60i-oLNnL60i.mjs"), v(t.default);
    case "speaker_plus":
      return t = await import("./speaker-plus.DNnNXRDd-DNnNXRDd.mjs"), v(t.default);
    case "speaker_slash_filled":
      return t = await import("./speaker-slash-filled.Cc-5HOVp-Cc-5HOVp.mjs"), v(t.default);
    case "speaker_slash":
      return t = await import("./speaker-slash.1a1yfxcY-1a1yfxcY.mjs"), v(t.default);
    case "speaker_x_mark_filled":
      return t = await import("./speaker-x-mark-filled.DlDzUf2f-DlDzUf2f.mjs"), v(t.default);
    case "speaker_x_mark":
      return t = await import("./speaker-x-mark.DYZFfVty-DYZFfVty.mjs"), v(t.default);
    case "speedometer_filled":
      return t = await import("./speedometer-filled.DyFE5mfX-DyFE5mfX.mjs"), v(t.default);
    case "speedometer":
      return t = await import("./speedometer.I9wCdTnM-I9wCdTnM.mjs"), v(t.default);
    case "spotlight_filled":
      return t = await import("./spotlight-filled.C8ISmNt6-C8ISmNt6.mjs"), v(t.default);
    case "spotlight":
      return t = await import("./spotlight.CKtb15hD-CKtb15hD.mjs"), v(t.default);
    case "spraycan_filled":
      return t = await import("./spraycan-filled.D4ezDskT-D4ezDskT.mjs"), v(t.default);
    case "spraycan":
      return t = await import("./spraycan.DZ-RGXFH-DZ-RGXFH.mjs"), v(t.default);
    case "square_badge_filled":
      return t = await import("./square-badge-filled.XvlQe2ur-XvlQe2ur.mjs"), v(t.default);
    case "square_badge":
      return t = await import("./square-badge.CMBbk20D-CMBbk20D.mjs"), v(t.default);
    case "square_filled":
      return t = await import("./square-filled.CgMOTUyV-CgMOTUyV.mjs"), v(t.default);
    case "square_four_dots_diagonal_line":
      return t = await import("./square-four-dots-diagonal-line.gTKwgot_-gTKwgot_.mjs"), v(t.default);
    case "square_four_wavy_lines_filled":
      return t = await import("./square-four-wavy-lines-filled.BOT0gvNt-BOT0gvNt.mjs"), v(t.default);
    case "square_four_wavy_lines":
      return t = await import("./square-four-wavy-lines.DK4xWr8P-DK4xWr8P.mjs"), v(t.default);
    case "square_grid_2x2_filled":
      return t = await import("./square-grid-2x2-filled.Cwe6HTe6-Cwe6HTe6.mjs"), v(t.default);
    case "square_grid_2x2":
      return t = await import("./square-grid-2x2.Cx5Zeeyb-Cx5Zeeyb.mjs"), v(t.default);
    case "square_grid_plus_filled":
      return t = await import("./square-grid-plus-filled.DsW11c3B-DsW11c3B.mjs"), v(t.default);
    case "square_grid_plus":
      return t = await import("./square-grid-plus.Bpv5sNuM-Bpv5sNuM.mjs"), v(t.default);
    case "square_line_bottom_filled":
      return t = await import("./square-line-bottom-filled.tE9nQrgK-tE9nQrgK.mjs"), v(t.default);
    case "square_line_bottom":
      return t = await import("./square-line-bottom.d66FWhv4-d66FWhv4.mjs"), v(t.default);
    case "square_line_left_filled":
      return t = await import("./square-line-left-filled.5sg42gVY-5sg42gVY.mjs"), v(t.default);
    case "square_line_left":
      return t = await import("./square-line-left.DTc8FdJa-DTc8FdJa.mjs"), v(t.default);
    case "square_line_right_filled":
      return t = await import("./square-line-right-filled.DJwggRZ7-DJwggRZ7.mjs"), v(t.default);
    case "square_line_right":
      return t = await import("./square-line-right.DXbnHUc4-DXbnHUc4.mjs"), v(t.default);
    case "square_line_top_filled":
      return t = await import("./square-line-top-filled.DzITcHD--DzITcHD-.mjs"), v(t.default);
    case "square_line_top":
      return t = await import("./square-line-top.DN0vwdAy-DN0vwdAy.mjs"), v(t.default);
    case "square_on_tilted_square_filled":
      return t = await import("./square-on-tilted-square-filled.ZtMsoSuW-ZtMsoSuW.mjs"), v(t.default);
    case "square_on_tilted_square":
      return t = await import("./square-on-tilted-square.DFNu_Akq-DFNu_Akq.mjs"), v(t.default);
    case "square_split_horizontally_filled":
      return t = await import("./square-split-horizontally-filled.wl0GApnc-wl0GApnc.mjs"), v(t.default);
    case "square_split_horizontally":
      return t = await import("./square-split-horizontally.9E66MZQk-9E66MZQk.mjs"), v(t.default);
    case "square_split_vertically_filled":
      return t = await import("./square-split-vertically-filled.7-XvDEcN-7-XvDEcN.mjs"), v(t.default);
    case "square_split_vertically":
      return t = await import("./square-split-vertically.DUuwYSj9-DUuwYSj9.mjs"), v(t.default);
    case "square":
      return t = await import("./square.BdfqpSw5-BdfqpSw5.mjs"), v(t.default);
    case "stack_1_filled":
      return t = await import("./stack-1-filled.DV9d806G-DV9d806G.mjs"), v(t.default);
    case "stack_1":
      return t = await import("./stack-1.CdOuAhg1-CdOuAhg1.mjs"), v(t.default);
    case "stack_2_filled":
      return t = await import("./stack-2-filled.BSImVHOu-BSImVHOu.mjs"), v(t.default);
    case "stack_2":
      return t = await import("./stack-2.DpbK633H-DpbK633H.mjs"), v(t.default);
    case "stack_3_filled":
      return t = await import("./stack-3-filled.DhN-SP6r-DhN-SP6r.mjs"), v(t.default);
    case "stack_3":
      return t = await import("./stack-3.CLLckMTW-CLLckMTW.mjs"), v(t.default);
    case "stacked_squares_diagonal_cutouts":
      return t = await import("./stacked-squares-diagonal-cutouts.BTdCeMUr-BTdCeMUr.mjs"), v(t.default);
    case "stacked_squares_filled":
      return t = await import("./stacked-squares-filled.CnPBG6dV-CnPBG6dV.mjs"), v(t.default);
    case "stacked_squares":
      return t = await import("./stacked-squares.RD7L5oJQ-RD7L5oJQ.mjs"), v(t.default);
    case "stamp_filled":
      return t = await import("./stamp-filled.CNifRT9F-CNifRT9F.mjs"), v(t.default);
    case "stamp":
      return t = await import("./stamp.Nq3pSais-Nq3pSais.mjs"), v(t.default);
    case "star_circle_filled":
      return t = await import("./star-circle-filled.Ben37kN9-Ben37kN9.mjs"), v(t.default);
    case "star_circle":
      return t = await import("./star-circle.DaTW_gG8-DaTW_gG8.mjs"), v(t.default);
    case "star_filled":
      return t = await import("./star-filled.CgtGhNW--CgtGhNW-.mjs"), v(t.default);
    case "star_trail_filled":
      return t = await import("./star-trail-filled.ClumlMWd-ClumlMWd.mjs"), v(t.default);
    case "star_trail":
      return t = await import("./star-trail.BfZpy_ND-BfZpy_ND.mjs"), v(t.default);
    case "star":
      return t = await import("./star.BfP2riWv-BfP2riWv.mjs"), v(t.default);
    case "steam":
      return t = await import("./steam.1PWBjZF2-1PWBjZF2.mjs"), v(t.default);
    case "sterling_sign_circle_filled":
      return t = await import("./sterling-sign-circle-filled.B_8_rgyx-C5JAOr6H.mjs"), v(t.default);
    case "sterling_sign_circle":
      return t = await import("./sterling-sign-circle.C7EcIqG8-C7EcIqG8.mjs"), v(t.default);
    case "sticker_filled":
      return t = await import("./sticker-filled.JkK-FBal-JkK-FBal.mjs"), v(t.default);
    case "sticker":
      return t = await import("./sticker.D7-Jxu_1-D7-Jxu_1.mjs"), v(t.default);
    case "stop_circle_filled":
      return t = await import("./stop-circle-filled.D0abYUhE-D0abYUhE.mjs"), v(t.default);
    case "stop_circle":
      return t = await import("./stop-circle.BdPczmMm-BdPczmMm.mjs"), v(t.default);
    case "stop_filled":
      return t = await import("./stop-filled.SQKhvr4x-SQKhvr4x.mjs"), v(t.default);
    case "stop":
      return t = await import("./stop.BdfqpSw5-BdfqpSw5.mjs"), v(t.default);
    case "store_filled":
      return t = await import("./store-filled.BNW23a4k-BNW23a4k.mjs"), v(t.default);
    case "store":
      return t = await import("./store.DMtZtae--DMtZtae-.mjs"), v(t.default);
    case "strike_through":
      return t = await import("./strike-through.CyJxn76V-CyJxn76V.mjs"), v(t.default);
    case "student_filled":
      return t = await import("./student-filled.2lCWaZwc-2lCWaZwc.mjs"), v(t.default);
    case "student":
      return t = await import("./student.w8Ifrt7t-w8Ifrt7t.mjs"), v(t.default);
    case "sun_filled":
      return t = await import("./sun-filled.DLq2_seP-DLq2_seP.mjs"), v(t.default);
    case "sun":
      return t = await import("./sun.CXJe2K5G-CXJe2K5G.mjs"), v(t.default);
    case "sunbed_umbrella_filled":
      return t = await import("./sunbed-umbrella-filled.Dobf9XZm-Dobf9XZm.mjs"), v(t.default);
    case "sunbed_umbrella":
      return t = await import("./sunbed-umbrella.DmDK-fYZ-DmDK-fYZ.mjs"), v(t.default);
    case "svg":
      return t = await import("./svg.OTY0rL-Y-OTY0rL-Y.mjs"), v(t.default);
    case "t_shirt_filled":
      return t = await import("./t-shirt-filled.Ci7zhWY6-Ci7zhWY6.mjs"), v(t.default);
    case "t_shirt":
      return t = await import("./t-shirt.R6p-i3n1-R6p-i3n1.mjs"), v(t.default);
    case "tablet_filled":
      return t = await import("./tablet-filled.DlqdZPJk-DlqdZPJk.mjs"), v(t.default);
    case "tablet":
      return t = await import("./tablet.BSnOKdoE-BSnOKdoE.mjs"), v(t.default);
    case "tag_filled":
      return t = await import("./tag-filled.D8fxCC1s-D8fxCC1s.mjs"), v(t.default);
    case "tag":
      return t = await import("./tag.BAXkKokd-BAXkKokd.mjs"), v(t.default);
    case "talk_bubble_badge_filled":
      return t = await import("./talk-bubble-badge-filled.DreAgXtq-DreAgXtq.mjs"), v(t.default);
    case "talk_bubble_badge":
      return t = await import("./talk-bubble-badge.BWnsVDZO-BWnsVDZO.mjs"), v(t.default);
    case "talk_bubble_dots_filled":
      return t = await import("./talk-bubble-dots-filled.DdC26MON-DdC26MON.mjs"), v(t.default);
    case "talk_bubble_dots":
      return t = await import("./talk-bubble-dots.D2_xDIb4-D2_xDIb4.mjs"), v(t.default);
    case "talk_bubble_exclamation_filled":
      return t = await import("./talk-bubble-exclamation-filled.Cjv5EUrm-Cjv5EUrm.mjs"), v(t.default);
    case "talk_bubble_exclamation":
      return t = await import("./talk-bubble-exclamation.oEsSH6N2-oEsSH6N2.mjs"), v(t.default);
    case "talk_bubble_filled":
      return t = await import("./talk-bubble-filled.C9_o-caU-Cmn38SBb.mjs"), v(t.default);
    case "talk_bubble_slash_filled":
      return t = await import("./talk-bubble-slash-filled.BmpvDL-D-lBMa9xOh.mjs"), v(t.default);
    case "talk_bubble_slash":
      return t = await import("./talk-bubble-slash.Cq_vr2rI-Cq_vr2rI.mjs"), v(t.default);
    case "talk_bubble":
      return t = await import("./talk-bubble.CtnYYxK9-CtnYYxK9.mjs"), v(t.default);
    case "talk_bubbles_filled":
      return t = await import("./talk-bubbles-filled.CpR6_dgP-CpR6_dgP.mjs"), v(t.default);
    case "talk_bubbles":
      return t = await import("./talk-bubbles.N8sKhcJW-N8sKhcJW.mjs"), v(t.default);
    case "target_arrow":
      return t = await import("./target-arrow.BG9KSLPI-BG9KSLPI.mjs"), v(t.default);
    case "target_cursor":
      return t = await import("./target-cursor.CGdZSsHq-CGdZSsHq.mjs"), v(t.default);
    case "template_filled":
      return t = await import("./template-filled.CYCiTNAE-CYCiTNAE.mjs"), v(t.default);
    case "template":
      return t = await import("./template.DNXQy1RI-DNXQy1RI.mjs"), v(t.default);
    case "terminal_filled":
      return t = await import("./terminal-filled.IzdCjIEY-IzdCjIEY.mjs"), v(t.default);
    case "terminal":
      return t = await import("./terminal.C5_M-vxP-C5_M-vxP.mjs"), v(t.default);
    case "terrain_upward_lines_filled":
      return t = await import("./terrain-upward-lines-filled.CEhjtc7g-CEhjtc7g.mjs"), v(t.default);
    case "terrain_upward_lines":
      return t = await import("./terrain-upward-lines.k-QiMROs-k-QiMROs.mjs"), v(t.default);
    case "text_field_filled":
      return t = await import("./text-field-filled.BZIoQd_2-BZIoQd_2.mjs"), v(t.default);
    case "text_field":
      return t = await import("./text-field.CS_c3cDK-CS_c3cDK.mjs"), v(t.default);
    case "text":
      return t = await import("./text.uBTsO1wV-uBTsO1wV.mjs"), v(t.default);
    case "three_lines_horizontal_decrease":
      return t = await import("./three-lines-horizontal-decrease.OO_wINNZ-OO_wINNZ.mjs"), v(t.default);
    case "threelateral":
      return t = await import("./threelateral.B1XVNwzn-B1XVNwzn.mjs"), v(t.default);
    case "thumb_down_filled":
      return t = await import("./thumb-down-filled.0NQVYDrz-0NQVYDrz.mjs"), v(t.default);
    case "thumb_down":
      return t = await import("./thumb-down.DZboWZBS-DZboWZBS.mjs"), v(t.default);
    case "thumb_up_filled":
      return t = await import("./thumb-up-filled.CZ9rPfNU-CZ9rPfNU.mjs"), v(t.default);
    case "thumb_up":
      return t = await import("./thumb-up.Cb-427Fq-Cb-427Fq.mjs"), v(t.default);
    case "tiktok":
      return t = await import("./tiktok.CKuYEC6K-C5RmSnib.mjs"), v(t.default);
    case "timer":
      return t = await import("./timer.BckEdUzQ-BckEdUzQ.mjs"), v(t.default);
    case "trash_filled":
      return t = await import("./trash-filled.EehdtB05-EehdtB05.mjs"), v(t.default);
    case "trash":
      return t = await import("./trash.CPQzOQQD-CPQzOQQD.mjs"), v(t.default);
    case "tray_filled":
      return t = await import("./tray-filled.CQVP_rlX-CQVP_rlX.mjs"), v(t.default);
    case "tray":
      return t = await import("./tray.Bc5Tg-kY-Bc5Tg-kY.mjs"), v(t.default);
    case "tree_filled":
      return t = await import("./tree-filled.D39M2ZAd-D39M2ZAd.mjs"), v(t.default);
    case "tree":
      return t = await import("./tree.Da8leLhf-Da8leLhf.mjs"), v(t.default);
    case "trello":
      return t = await import("./trello.DK7n4_ut-DK7n4_ut.mjs"), v(t.default);
    case "triangle_filled":
      return t = await import("./triangle-filled.CuumNs6t-CuumNs6t.mjs"), v(t.default);
    case "triangle":
      return t = await import("./triangle.DwJ38yZi-DwJ38yZi.mjs"), v(t.default);
    case "trophy_filled":
      return t = await import("./trophy-filled.DUKIi94Y-DUKIi94Y.mjs"), v(t.default);
    case "trophy":
      return t = await import("./trophy.Bpn8tORJ-Bpn8tORJ.mjs"), v(t.default);
    case "tumblr":
      return t = await import("./tumblr.Bf-yRQOk-Bf-yRQOk.mjs"), v(t.default);
    case "twinmotion":
      return t = await import("./twinmotion.DzVhb570-DzVhb570.mjs"), v(t.default);
    case "twitch":
      return t = await import("./twitch.C228Em66-C228Em66.mjs"), v(t.default);
    case "twitter_x":
      return t = await import("./twitter-x.BsaC8aT_-BsaC8aT_.mjs"), v(t.default);
    case "umbrella_filled":
      return t = await import("./umbrella-filled.Gm1okay4-Gm1okay4.mjs"), v(t.default);
    case "umbrella":
      return t = await import("./umbrella.CxOddSOj-CxOddSOj.mjs"), v(t.default);
    case "underline":
      return t = await import("./underline.CeahOtig-CeahOtig.mjs"), v(t.default);
    case "unity":
      return t = await import("./unity.BjAlPTY3-BjAlPTY3.mjs"), v(t.default);
    case "unreal_engine":
      return t = await import("./unreal-engine.CwUu8k_L-CwUu8k_L.mjs"), v(t.default);
    case "uplay":
      return t = await import("./uplay.MPrx3jwF-MPrx3jwF.mjs"), v(t.default);
    case "user_arrows_filled":
      return t = await import("./user-arrows-filled.DQ1IfJjK-DQ1IfJjK.mjs"), v(t.default);
    case "user_arrows":
      return t = await import("./user-arrows.DugKWnZm-DugKWnZm.mjs"), v(t.default);
    case "user_check_filled":
      return t = await import("./user-check-filled.DL9dQ3ol-DL9dQ3ol.mjs"), v(t.default);
    case "user_check":
      return t = await import("./user-check.DNHJzTyY-DNHJzTyY.mjs"), v(t.default);
    case "user_cogwheel_filled":
      return t = await import("./user-cogwheel-filled.C9HCZakA-C9HCZakA.mjs"), v(t.default);
    case "user_cogwheel":
      return t = await import("./user-cogwheel.Bo5WdO7E-Bo5WdO7E.mjs"), v(t.default);
    case "user_filled":
      return t = await import("./user-filled.D-ir8K6E-D-ir8K6E.mjs"), v(t.default);
    case "user_glow_filled":
      return t = await import("./user-glow-filled.DHossbSM-DHossbSM.mjs"), v(t.default);
    case "user_glow":
      return t = await import("./user-glow.DqyG3xaa-DqyG3xaa.mjs"), v(t.default);
    case "user_group_filled":
      return t = await import("./user-group-filled.6pD5lnZO-6pD5lnZO.mjs"), v(t.default);
    case "user_group":
      return t = await import("./user-group.AocJrQhU-AocJrQhU.mjs"), v(t.default);
    case "user_link_filled":
      return t = await import("./user-link-filled.ENI87MhK-ENI87MhK.mjs"), v(t.default);
    case "user_link":
      return t = await import("./user-link.CXTavcZx-CXTavcZx.mjs"), v(t.default);
    case "user_list_filled":
      return t = await import("./user-list-filled.D0Sg7OPz-D0Sg7OPz.mjs"), v(t.default);
    case "user_list":
      return t = await import("./user-list.CB4TOyeW-CB4TOyeW.mjs"), v(t.default);
    case "user_magnifier_filled":
      return t = await import("./user-magnifier-filled.DCHSahA8-DCHSahA8.mjs"), v(t.default);
    case "user_magnifier":
      return t = await import("./user-magnifier.Dq1noWxk-Dq1noWxk.mjs"), v(t.default);
    case "user_minus_filled":
      return t = await import("./user-minus-filled.DN1gWZLP-DN1gWZLP.mjs"), v(t.default);
    case "user_minus":
      return t = await import("./user-minus.Hgsr8y0Y-Hgsr8y0Y.mjs"), v(t.default);
    case "user_plus_filled":
      return t = await import("./user-plus-filled.C9xsGRqf-C9xsGRqf.mjs"), v(t.default);
    case "user_plus":
      return t = await import("./user-plus.LqWxXXab-LqWxXXab.mjs"), v(t.default);
    case "user_target_filled":
      return t = await import("./user-target-filled.ChMh9tTl-ChMh9tTl.mjs"), v(t.default);
    case "user_target":
      return t = await import("./user-target.hzOPfCs1-hzOPfCs1.mjs"), v(t.default);
    case "user_x_mark_filled":
      return t = await import("./user-x-mark-filled.COlMbiBL-COlMbiBL.mjs"), v(t.default);
    case "user_x_mark":
      return t = await import("./user-x-mark.a2_pneRQ-a2_pneRQ.mjs"), v(t.default);
    case "user":
      return t = await import("./user.Ca1Dqpjj-Ca1Dqpjj.mjs"), v(t.default);
    case "users_filled":
      return t = await import("./users-filled.BCnU1_Dw-BCnU1_Dw.mjs"), v(t.default);
    case "users":
      return t = await import("./users.mKdCTOcN-mKdCTOcN.mjs"), v(t.default);
    case "v_bucks_filled":
      return t = await import("./v-bucks-filled.BjkPxpY5-BjkPxpY5.mjs"), v(t.default);
    case "v_bucks":
      return t = await import("./v-bucks._VvyWQ5O-_VvyWQ5O.mjs"), v(t.default);
    case "v_ray":
      return t = await import("./v-ray.BqD1r57Y-BqD1r57Y.mjs"), v(t.default);
    case "verse":
      return t = await import("./verse.Cy1PfXqh-Cy1PfXqh.mjs"), v(t.default);
    case "video_filled":
      return t = await import("./video-filled.CtXUtXZG-CtXUtXZG.mjs"), v(t.default);
    case "video_slash_filled":
      return t = await import("./video-slash-filled.D0njLwPD-D0njLwPD.mjs"), v(t.default);
    case "video_slash":
      return t = await import("./video-slash.BCKh4tas-BCKh4tas.mjs"), v(t.default);
    case "video":
      return t = await import("./video.iSbwUitI-iSbwUitI.mjs"), v(t.default);
    case "view_360_degree":
      return t = await import("./view-360-degree.B_Js9T8p-B_Js9T8p.mjs"), v(t.default);
    case "vimeo":
      return t = await import("./vimeo.9tSTovtX-9tSTovtX.mjs"), v(t.default);
    case "vk":
      return t = await import("./vk.CmIB7kdh-CmIB7kdh.mjs"), v(t.default);
    case "wallet_filled":
      return t = await import("./wallet-filled.C5RaMtem-C5RaMtem.mjs"), v(t.default);
    case "wallet":
      return t = await import("./wallet.BUuWKqyf-BUuWKqyf.mjs"), v(t.default);
    case "waveform":
      return t = await import("./waveform.Dd7iAECq-Dd7iAECq.mjs"), v(t.default);
    case "wavy_lines_horizontal":
      return t = await import("./wavy-lines-horizontal.MOOc55rb-MOOc55rb.mjs"), v(t.default);
    case "webhooks":
      return t = await import("./webhooks.CmatbdD2-CmatbdD2.mjs"), v(t.default);
    case "wegame":
      return t = await import("./wegame.DeffJ30i-DeffJ30i.mjs"), v(t.default);
    case "weibo":
      return t = await import("./weibo.DyUXLdqk-DyUXLdqk.mjs"), v(t.default);
    case "wheel":
      return t = await import("./wheel.Bg4FPQhe-Bg4FPQhe.mjs"), v(t.default);
    case "wifi_exclamation":
      return t = await import("./wifi-exclamation.rZW2cJm8-rZW2cJm8.mjs"), v(t.default);
    case "wifi_slash":
      return t = await import("./wifi-slash.Cdj8tmFt-Cdj8tmFt.mjs"), v(t.default);
    case "wifi":
      return t = await import("./wifi.MwC9R83i-MwC9R83i.mjs"), v(t.default);
    case "windows":
      return t = await import("./windows.CL6oj3iF-CL6oj3iF.mjs"), v(t.default);
    case "wireframe_circle":
      return t = await import("./wireframe-circle.d8gdXCKb-d8gdXCKb.mjs"), v(t.default);
    case "wrapper_filled":
      return t = await import("./wrapper-filled.Bzi_mjG6-Bzi_mjG6.mjs"), v(t.default);
    case "wrapper":
      return t = await import("./wrapper.CaHubA3V-CaHubA3V.mjs"), v(t.default);
    case "wrench_filled":
      return t = await import("./wrench-filled.Dl3oMj9F-Dl3oMj9F.mjs"), v(t.default);
    case "wrench":
      return t = await import("./wrench.CWf8lfR5-CWf8lfR5.mjs"), v(t.default);
    case "x_mark_circle_filled":
      return t = await import("./x-mark-circle-filled.CsiDWnEK-CsiDWnEK.mjs"), v(t.default);
    case "x_mark_circle":
      return t = await import("./x-mark-circle.D6_s9Xhx-D6_s9Xhx.mjs"), v(t.default);
    case "x_mark_square_filled":
      return t = await import("./x-mark-square-filled.BRQImxA4-BRQImxA4.mjs"), v(t.default);
    case "x_mark_square":
      return t = await import("./x-mark-square.D1aRweZV-D1aRweZV.mjs"), v(t.default);
    case "x_mark":
      return t = await import("./x-mark.CMjRQoJG-CMjRQoJG.mjs"), v(t.default);
    case "xbox":
      return t = await import("./xbox.BVjP_uT0-BVjP_uT0.mjs"), v(t.default);
    case "yen_sign_circle_filled":
      return t = await import("./yen-sign-circle-filled.D7JUkV39-D7JUkV39.mjs"), v(t.default);
    case "yen_sign_circle":
      return t = await import("./yen-sign-circle.oTGQNGZA-oTGQNGZA.mjs"), v(t.default);
    case "yk":
      return t = await import("./yk.CgVEpyWM-CgVEpyWM.mjs"), v(t.default);
    case "youtube":
      return t = await import("./youtube.C2ZKmD_u-C2ZKmD_u.mjs"), v(t.default);
    case "zbrush":
      return t = await import("./zbrush.BiIrJ-ki-BiIrJ-ki.mjs"), v(t.default);
    default:
      return null;
  }
};
var age = Object.defineProperty, ige = Object.getOwnPropertyDescriptor, pg = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? ige(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && age(t, r, o), o;
};
let Xl = class extends Dm {
  constructor() {
    super(...arguments), this.icon = "", this.accentColor = "", this.textColor = "";
  }
  render() {
    const e = this.icon;
    return e ? he`${Wre(
      oge(e).then((t) => t || (console.warn("epic-wf-eds-icon invalid icon passed, make sure to pass snake_case"), "")),
      he``
    )}` : he``;
  }
};
Xl.styles = oE`
		${Pu(nge)}
	`;
pg([
  Te()
], Xl.prototype, "icon", 2);
pg([
  Te()
], Xl.prototype, "accentColor", 2);
pg([
  Te()
], Xl.prototype, "textColor", 2);
Xl = pg([
  rge("epic-wf-eds-icon")
], Xl);
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var wJ = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], jh = /* @__PURE__ */ wJ.join(","), _J = typeof Element > "u", ms = _J ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Ih = !_J && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e?.ownerDocument;
}, Nh = function e(t, r) {
  var n;
  r === void 0 && (r = !0);
  var o = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "inert"), a = o === "" || o === "true", i = a || r && t && e(t.parentNode);
  return i;
}, sge = function(e) {
  var t, r = e == null || (t = e.getAttribute) === null || t === void 0 ? void 0 : t.call(e, "contenteditable");
  return r === "" || r === "true";
}, EJ = function(e, t, r) {
  if (Nh(e))
    return [];
  var n = Array.prototype.slice.apply(e.querySelectorAll(jh));
  return t && ms.call(e, jh) && n.unshift(e), n = n.filter(r), n;
}, xJ = function e(t, r, n) {
  for (var o = [], a = Array.from(t); a.length; ) {
    var i = a.shift();
    if (!Nh(i, !1))
      if (i.tagName === "SLOT") {
        var s = i.assignedElements(), d = s.length ? s : i.children, l = e(d, !0, n);
        n.flatten ? o.push.apply(o, l) : o.push({
          scopeParent: i,
          candidates: l
        });
      } else {
        var p = ms.call(i, jh);
        p && n.filter(i) && (r || !t.includes(i)) && o.push(i);
        var f = i.shadowRoot || // check for an undisclosed shadow
        typeof n.getShadowRoot == "function" && n.getShadowRoot(i), h = !Nh(f, !1) && (!n.shadowRootFilter || n.shadowRootFilter(i));
        if (f && h) {
          var m = e(f === !0 ? i.children : f.children, !0, n);
          n.flatten ? o.push.apply(o, m) : o.push({
            scopeParent: i,
            candidates: m
          });
        } else
          a.unshift.apply(a, i.children);
      }
  }
  return o;
}, SJ = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, Ni = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || sge(e)) && !SJ(e) ? 0 : e.tabIndex;
}, lge = function(e, t) {
  var r = Ni(e);
  return r < 0 && t && !SJ(e) ? 0 : r;
}, cge = function(e, t) {
  return e.tabIndex === t.tabIndex ? e.documentOrder - t.documentOrder : e.tabIndex - t.tabIndex;
}, TJ = function(e) {
  return e.tagName === "INPUT";
}, uge = function(e) {
  return TJ(e) && e.type === "hidden";
}, dge = function(e) {
  var t = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return t;
}, pge = function(e, t) {
  for (var r = 0; r < e.length; r++)
    if (e[r].checked && e[r].form === t)
      return e[r];
}, fge = function(e) {
  if (!e.name)
    return !0;
  var t = e.form || Ih(e), r = function(a) {
    return t.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, n;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    n = r(window.CSS.escape(e.name));
  else
    try {
      n = r(e.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var o = pge(n, e.form);
  return !o || o === e;
}, hge = function(e) {
  return TJ(e) && e.type === "radio";
}, mge = function(e) {
  return hge(e) && !fge(e);
}, yge = function(e) {
  var t, r = e && Ih(e), n = (t = r) === null || t === void 0 ? void 0 : t.host, o = !1;
  if (r && r !== e) {
    var a, i, s;
    for (o = !!((a = n) !== null && a !== void 0 && (i = a.ownerDocument) !== null && i !== void 0 && i.contains(n) || e != null && (s = e.ownerDocument) !== null && s !== void 0 && s.contains(e)); !o && n; ) {
      var d, l, p;
      r = Ih(n), n = (d = r) === null || d === void 0 ? void 0 : d.host, o = !!((l = n) !== null && l !== void 0 && (p = l.ownerDocument) !== null && p !== void 0 && p.contains(n));
    }
  }
  return o;
}, RR = function(e) {
  var t = e.getBoundingClientRect(), r = t.width, n = t.height;
  return r === 0 && n === 0;
}, gge = function(e, t) {
  var r = t.displayCheck, n = t.getShadowRoot;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var o = ms.call(e, "details>summary:first-of-type"), a = o ? e.parentElement : e;
  if (ms.call(a, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof n == "function") {
      for (var i = e; e; ) {
        var s = e.parentElement, d = Ih(e);
        if (s && !s.shadowRoot && n(s) === !0)
          return RR(e);
        e.assignedSlot ? e = e.assignedSlot : !s && d !== e.ownerDocument ? e = d.host : e = s;
      }
      e = i;
    }
    if (yge(e))
      return !e.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return RR(e);
  return !1;
}, bge = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var t = e.parentElement; t; ) {
      if (t.tagName === "FIELDSET" && t.disabled) {
        for (var r = 0; r < t.children.length; r++) {
          var n = t.children.item(r);
          if (n.tagName === "LEGEND")
            return ms.call(t, "fieldset[disabled] *") ? !0 : !n.contains(e);
        }
        return !0;
      }
      t = t.parentElement;
    }
  return !1;
}, Mh = function(e, t) {
  return !(t.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Nh(t) || uge(t) || gge(t, e) || // For a details element with a summary, the summary element gets the focus
  dge(t) || bge(t));
}, Y_ = function(e, t) {
  return !(mge(t) || Ni(t) < 0 || !Mh(e, t));
}, vge = function(e) {
  var t = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(t) || t >= 0);
}, wge = function e(t) {
  var r = [], n = [];
  return t.forEach(function(o, a) {
    var i = !!o.scopeParent, s = i ? o.scopeParent : o, d = lge(s, i), l = i ? e(o.candidates) : s;
    d === 0 ? i ? r.push.apply(r, l) : r.push(s) : n.push({
      documentOrder: a,
      tabIndex: d,
      item: o,
      isScope: i,
      content: l
    });
  }), n.sort(cge).reduce(function(o, a) {
    return a.isScope ? o.push.apply(o, a.content) : o.push(a.content), o;
  }, []).concat(r);
}, _ge = function(e, t) {
  t = t || {};
  var r;
  return t.getShadowRoot ? r = xJ([e], t.includeContainer, {
    filter: Y_.bind(null, t),
    flatten: !1,
    getShadowRoot: t.getShadowRoot,
    shadowRootFilter: vge
  }) : r = EJ(e, t.includeContainer, Y_.bind(null, t)), wge(r);
}, Ege = function(e, t) {
  t = t || {};
  var r;
  return t.getShadowRoot ? r = xJ([e], t.includeContainer, {
    filter: Mh.bind(null, t),
    flatten: !0,
    getShadowRoot: t.getShadowRoot
  }) : r = EJ(e, t.includeContainer, Mh.bind(null, t)), r;
}, Vs = function(e, t) {
  if (t = t || {}, !e)
    throw new Error("No node provided");
  return ms.call(e, jh) === !1 ? !1 : Y_(t, e);
}, xge = /* @__PURE__ */ wJ.concat("iframe").join(","), _v = function(e, t) {
  if (t = t || {}, !e)
    throw new Error("No node provided");
  return ms.call(e, xge) === !1 ? !1 : Mh(t, e);
};
/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function jR(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function IR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jR(Object(r), !0).forEach(function(n) {
      Sge(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : jR(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function Sge(e, t, r) {
  return t = Age(t), t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function Tge(e, t) {
  if (typeof e != "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Age(e) {
  var t = Tge(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
var NR = {
  activateTrap: function(e, t) {
    if (e.length > 0) {
      var r = e[e.length - 1];
      r !== t && r.pause();
    }
    var n = e.indexOf(t);
    n === -1 || e.splice(n, 1), e.push(t);
  },
  deactivateTrap: function(e, t) {
    var r = e.indexOf(t);
    r !== -1 && e.splice(r, 1), e.length > 0 && e[e.length - 1].unpause();
  }
}, $ge = function(e) {
  return e.tagName && e.tagName.toLowerCase() === "input" && typeof e.select == "function";
}, Cge = function(e) {
  return e?.key === "Escape" || e?.key === "Esc" || e?.keyCode === 27;
}, zu = function(e) {
  return e?.key === "Tab" || e?.keyCode === 9;
}, kge = function(e) {
  return zu(e) && !e.shiftKey;
}, Pge = function(e) {
  return zu(e) && e.shiftKey;
}, MR = function(e) {
  return setTimeout(e, 0);
}, DR = function(e, t) {
  var r = -1;
  return e.every(function(n, o) {
    return t(n) ? (r = o, !1) : !0;
  }), r;
}, au = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return typeof e == "function" ? e.apply(void 0, r) : e;
}, Wp = function(e) {
  return e.target.shadowRoot && typeof e.composedPath == "function" ? e.composedPath()[0] : e.target;
}, Oge = [], Rge = function(e, t) {
  var r = t?.document || document, n = t?.trapStack || Oge, o = IR({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0,
    isKeyForward: kge,
    isKeyBackward: Pge
  }, t), a = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  }, i, s = function(O, k, M) {
    return O && O[k] !== void 0 ? O[k] : o[M || k];
  }, d = function(O, k) {
    var M = typeof k?.composedPath == "function" ? k.composedPath() : void 0;
    return a.containerGroups.findIndex(function(L) {
      var $ = L.container, I = L.tabbableNodes;
      return $.contains(O) || M?.includes($) || I.find(function(D) {
        return D === O;
      });
    });
  }, l = function(O) {
    var k = o[O];
    if (typeof k == "function") {
      for (var M = arguments.length, L = new Array(M > 1 ? M - 1 : 0), $ = 1; $ < M; $++)
        L[$ - 1] = arguments[$];
      k = k.apply(void 0, L);
    }
    if (k === !0 && (k = void 0), !k) {
      if (k === void 0 || k === !1)
        return k;
      throw new Error("`".concat(O, "` was specified but was not a node, or did not return a node"));
    }
    var I = k;
    if (typeof k == "string" && (I = r.querySelector(k), !I))
      throw new Error("`".concat(O, "` as selector refers to no known node"));
    return I;
  }, p = function() {
    var O = l("initialFocus");
    if (O === !1)
      return !1;
    if (O === void 0 || !_v(O, o.tabbableOptions))
      if (d(r.activeElement) >= 0)
        O = r.activeElement;
      else {
        var k = a.tabbableGroups[0], M = k && k.firstTabbableNode;
        O = M || l("fallbackFocus");
      }
    if (!O)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return O;
  }, f = function() {
    if (a.containerGroups = a.containers.map(function(O) {
      var k = _ge(O, o.tabbableOptions), M = Ege(O, o.tabbableOptions), L = k.length > 0 ? k[0] : void 0, $ = k.length > 0 ? k[k.length - 1] : void 0, I = M.find(function(J) {
        return Vs(J);
      }), D = M.slice().reverse().find(function(J) {
        return Vs(J);
      }), F = !!k.find(function(J) {
        return Ni(J) > 0;
      });
      return {
        container: O,
        tabbableNodes: k,
        focusableNodes: M,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: F,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: L,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: $,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: I,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: D,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(J) {
          var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, ce = k.indexOf(J);
          return ce < 0 ? oe ? M.slice(M.indexOf(J) + 1).find(function(le) {
            return Vs(le);
          }) : M.slice(0, M.indexOf(J)).reverse().find(function(le) {
            return Vs(le);
          }) : k[ce + (oe ? 1 : -1)];
        }
      };
    }), a.tabbableGroups = a.containerGroups.filter(function(O) {
      return O.tabbableNodes.length > 0;
    }), a.tabbableGroups.length <= 0 && !l("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    if (a.containerGroups.find(function(O) {
      return O.posTabIndexesFound;
    }) && a.containerGroups.length > 1)
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
  }, h = function O(k) {
    var M = k.activeElement;
    if (M)
      return M.shadowRoot && M.shadowRoot.activeElement !== null ? O(M.shadowRoot) : M;
  }, m = function O(k) {
    if (k !== !1 && k !== h(document)) {
      if (!k || !k.focus) {
        O(p());
        return;
      }
      k.focus({
        preventScroll: !!o.preventScroll
      }), a.mostRecentlyFocusedNode = k, $ge(k) && k.select();
    }
  }, g = function(O) {
    var k = l("setReturnFocus", O);
    return k || (k === !1 ? !1 : O);
  }, w = function(O) {
    var k = O.target, M = O.event, L = O.isBackward, $ = L === void 0 ? !1 : L;
    k = k || Wp(M), f();
    var I = null;
    if (a.tabbableGroups.length > 0) {
      var D = d(k, M), F = D >= 0 ? a.containerGroups[D] : void 0;
      if (D < 0)
        $ ? I = a.tabbableGroups[a.tabbableGroups.length - 1].lastTabbableNode : I = a.tabbableGroups[0].firstTabbableNode;
      else if ($) {
        var J = DR(a.tabbableGroups, function(_e) {
          var de = _e.firstTabbableNode;
          return k === de;
        });
        if (J < 0 && (F.container === k || _v(k, o.tabbableOptions) && !Vs(k, o.tabbableOptions) && !F.nextTabbableNode(k, !1)) && (J = D), J >= 0) {
          var oe = J === 0 ? a.tabbableGroups.length - 1 : J - 1, ce = a.tabbableGroups[oe];
          I = Ni(k) >= 0 ? ce.lastTabbableNode : ce.lastDomTabbableNode;
        } else zu(M) || (I = F.nextTabbableNode(k, !1));
      } else {
        var le = DR(a.tabbableGroups, function(_e) {
          var de = _e.lastTabbableNode;
          return k === de;
        });
        if (le < 0 && (F.container === k || _v(k, o.tabbableOptions) && !Vs(k, o.tabbableOptions) && !F.nextTabbableNode(k)) && (le = D), le >= 0) {
          var re = le === a.tabbableGroups.length - 1 ? 0 : le + 1, we = a.tabbableGroups[re];
          I = Ni(k) >= 0 ? we.firstTabbableNode : we.firstDomTabbableNode;
        } else zu(M) || (I = F.nextTabbableNode(k));
      }
    } else
      I = l("fallbackFocus");
    return I;
  }, _ = function(O) {
    var k = Wp(O);
    if (!(d(k, O) >= 0)) {
      if (au(o.clickOutsideDeactivates, O)) {
        i.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: o.returnFocusOnDeactivate
        });
        return;
      }
      au(o.allowOutsideClick, O) || O.preventDefault();
    }
  }, b = function(O) {
    var k = Wp(O), M = d(k, O) >= 0;
    if (M || k instanceof Document)
      M && (a.mostRecentlyFocusedNode = k);
    else {
      O.stopImmediatePropagation();
      var L, $ = !0;
      if (a.mostRecentlyFocusedNode)
        if (Ni(a.mostRecentlyFocusedNode) > 0) {
          var I = d(a.mostRecentlyFocusedNode), D = a.containerGroups[I].tabbableNodes;
          if (D.length > 0) {
            var F = D.findIndex(function(J) {
              return J === a.mostRecentlyFocusedNode;
            });
            F >= 0 && (o.isKeyForward(a.recentNavEvent) ? F + 1 < D.length && (L = D[F + 1], $ = !1) : F - 1 >= 0 && (L = D[F - 1], $ = !1));
          }
        } else
          a.containerGroups.some(function(J) {
            return J.tabbableNodes.some(function(oe) {
              return Ni(oe) > 0;
            });
          }) || ($ = !1);
      else
        $ = !1;
      $ && (L = w({
        // move FROM the MRU node, not event-related node (which will be the node that is
        //  outside the trap causing the focus escape we're trying to fix)
        target: a.mostRecentlyFocusedNode,
        isBackward: o.isKeyBackward(a.recentNavEvent)
      })), m(L || a.mostRecentlyFocusedNode || p());
    }
    a.recentNavEvent = void 0;
  }, x = function(O) {
    var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    a.recentNavEvent = O;
    var M = w({
      event: O,
      isBackward: k
    });
    M && (zu(O) && O.preventDefault(), m(M));
  }, P = function(O) {
    if (Cge(O) && au(o.escapeDeactivates, O) !== !1) {
      O.preventDefault(), i.deactivate();
      return;
    }
    (o.isKeyForward(O) || o.isKeyBackward(O)) && x(O, o.isKeyBackward(O));
  }, R = function(O) {
    var k = Wp(O);
    d(k, O) >= 0 || au(o.clickOutsideDeactivates, O) || au(o.allowOutsideClick, O) || (O.preventDefault(), O.stopImmediatePropagation());
  }, N = function() {
    if (a.active)
      return NR.activateTrap(n, i), a.delayInitialFocusTimer = o.delayInitialFocus ? MR(function() {
        m(p());
      }) : m(p()), r.addEventListener("focusin", b, !0), r.addEventListener("mousedown", _, {
        capture: !0,
        passive: !1
      }), r.addEventListener("touchstart", _, {
        capture: !0,
        passive: !1
      }), r.addEventListener("click", R, {
        capture: !0,
        passive: !1
      }), r.addEventListener("keydown", P, {
        capture: !0,
        passive: !1
      }), i;
  }, C = function() {
    if (a.active)
      return r.removeEventListener("focusin", b, !0), r.removeEventListener("mousedown", _, !0), r.removeEventListener("touchstart", _, !0), r.removeEventListener("click", R, !0), r.removeEventListener("keydown", P, !0), i;
  }, A = function(O) {
    var k = O.some(function(M) {
      var L = Array.from(M.removedNodes);
      return L.some(function($) {
        return $ === a.mostRecentlyFocusedNode;
      });
    });
    k && m(p());
  }, E = typeof window < "u" && "MutationObserver" in window ? new MutationObserver(A) : void 0, T = function() {
    E && (E.disconnect(), a.active && !a.paused && a.containers.map(function(O) {
      E.observe(O, {
        subtree: !0,
        childList: !0
      });
    }));
  };
  return i = {
    get active() {
      return a.active;
    },
    get paused() {
      return a.paused;
    },
    activate: function(O) {
      if (a.active)
        return this;
      var k = s(O, "onActivate"), M = s(O, "onPostActivate"), L = s(O, "checkCanFocusTrap");
      L || f(), a.active = !0, a.paused = !1, a.nodeFocusedBeforeActivation = r.activeElement, k?.();
      var $ = function() {
        L && f(), N(), T(), M?.();
      };
      return L ? (L(a.containers.concat()).then($, $), this) : ($(), this);
    },
    deactivate: function(O) {
      if (!a.active)
        return this;
      var k = IR({
        onDeactivate: o.onDeactivate,
        onPostDeactivate: o.onPostDeactivate,
        checkCanReturnFocus: o.checkCanReturnFocus
      }, O);
      clearTimeout(a.delayInitialFocusTimer), a.delayInitialFocusTimer = void 0, C(), a.active = !1, a.paused = !1, T(), NR.deactivateTrap(n, i);
      var M = s(k, "onDeactivate"), L = s(k, "onPostDeactivate"), $ = s(k, "checkCanReturnFocus"), I = s(k, "returnFocus", "returnFocusOnDeactivate");
      M?.();
      var D = function() {
        MR(function() {
          I && m(g(a.nodeFocusedBeforeActivation)), L?.();
        });
      };
      return I && $ ? ($(g(a.nodeFocusedBeforeActivation)).then(D, D), this) : (D(), this);
    },
    pause: function(O) {
      if (a.paused || !a.active)
        return this;
      var k = s(O, "onPause"), M = s(O, "onPostPause");
      return a.paused = !0, k?.(), C(), T(), M?.(), this;
    },
    unpause: function(O) {
      if (!a.paused || !a.active)
        return this;
      var k = s(O, "onUnpause"), M = s(O, "onPostUnpause");
      return a.paused = !1, k?.(), f(), N(), T(), M?.(), this;
    },
    updateContainerElements: function(O) {
      var k = [].concat(O).filter(Boolean);
      return a.containers = k.map(function(M) {
        return typeof M == "string" ? r.querySelector(M) : M;
      }), a.active && f(), T(), this;
    }
  }, i.updateContainerElements(e), i;
};
function hn(e) {
  return e.nextElementSibling;
}
function bf(e) {
  return e.shadowRoot?.querySelector(".main-link");
}
function Zs(e) {
  return e;
}
let qR = class X_ {
  static waitForDisplay(t, r) {
    t.style.getPropertyValue("display") !== "none" ? r() : new ResizeObserver((n, o) => {
      for (const a of n)
        a.target === t && t.style.display !== "none" && (r(), o.disconnect());
    }).observe(t);
  }
  trapFocusIn(t, r) {
    if (!t) {
      console.debug("Focus trpping empty container");
      return;
    }
    const { returnFocusTo: n, fallbackFocus: o, onDeactivate: a, onEscapeDeactivates: i } = r;
    if (this._returnFocusTo = n, this._onDeactivate = a, this._onEscapeDeactivates = i, this._globalFocusTrap)
      X_.waitForDisplay(t, () => {
        this._globalFocusTrap && (this._globalFocusTrap.updateContainerElements(t), this._globalFocusTrap.activate());
      });
    else {
      const s = {
        onDeactivate: () => {
          this._onDeactivate && this._onDeactivate();
        },
        clickOutsideDeactivates: !0,
        fallbackFocus: () => o,
        tabbableOptions: {
          getShadowRoot: !0
        },
        escapeDeactivates: (d) => (this._onEscapeDeactivates && this._onEscapeDeactivates(d), !0),
        isKeyForward: (d) => d.key === "ArrowDown" || d.key === "Tab",
        isKeyBackward: (d) => d.key === "ArrowUp" || d.shiftKey && d.key === "Tab"
      };
      s.setReturnFocus = (d) => this._returnFocusTo ? this._returnFocusTo : !1, s.checkCanFocusTrap = (d) => new Promise((l) => {
        X_.waitForDisplay(d[0], l);
      });
      try {
        this._globalFocusTrap = Rge(t, s), this._globalFocusTrap.activate();
      } catch (d) {
        console.debug(d);
      }
    }
  }
  untrapFocus() {
    this._globalFocusTrap && this._globalFocusTrap.deactivate();
  }
  get active() {
    return this._globalFocusTrap ? this._globalFocusTrap.active : !1;
  }
};
const AJ = (e) => !!(e.menu?.__typename === "NavSimpleMenu" && e?.menu?.links), jge = (e) => !!(e.menu?.__typename === "NavMegaMenu" && e?.menu?.sections), Ige = (e) => !!(e.menu?.__typename === "NavVerticalMenu" && e?.menu?.sections), Q_ = (e) => e ? AJ(e) || jge(e) || Ige(e) : !1;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const gr = (e) => (t, r) => {
  r !== void 0 ? r.addInitializer((() => {
    customElements.define(e, t);
  })) : customElements.define(e, t);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function mA(e) {
  return ge({ ...e, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Nge = (e, t, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(e, t, r), r);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Mge(e, t) {
  return (r, n, o) => {
    const a = (i) => i.renderRoot?.querySelector(e) ?? null;
    return Nge(r, n, { get() {
      return a(this);
    } });
  };
}
const Dge = ':host{position:relative;height:2rem}:host:before{content:"";position:absolute;z-index:0;inset:0;border-radius:624.9375rem;opacity:.1;-webkit-backdrop-filter:blur(2.34375rem);backdrop-filter:blur(2.34375rem);pointer-events:none;transition:opacity var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}:host .balance-pill{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none;height:2rem;padding-inline:.75rem;border-radius:1.5rem;display:flex;align-items:center}:host .balance-pill>*{pointer-events:none}:host .balance-pill:not([disabled]){cursor:pointer}:host .balance-pill:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}:host .balance-pill epic-wf-eds-icon{width:1.25rem}:host .balance-pill_content{display:flex;gap:.5rem}:host .balance-pill_content_balance{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;font-weight:500;color:transparent}@media (max-width: 1279.9px){:host .balance-pill[data-collapsible=true]{padding-inline:.375rem}:host .balance-pill[data-collapsible=true] epic-wf-eds-icon{width:1.5rem}:host .balance-pill[data-collapsible=true] .balance-pill_content_balance{display:none}}:host(:hover):before{opacity:.2}:host([gradient=blue]):before{background:var(--gradient-blue, linear-gradient(225deg, #dfbaf8 0%, #33bfff 100%))}:host([gradient=blue]) .balance-pill_content_balance{background:var(--gradient-blue, linear-gradient(225deg, #dfbaf8 0%, #33bfff 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=indigo]):before{background:var(--gradient-indigo, linear-gradient(225deg, #f1b8dd 0%, #868afd 100%))}:host([gradient=indigo]) .balance-pill_content_balance{background:var(--gradient-indigo, linear-gradient(225deg, #f1b8dd 0%, #868afd 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=purple]):before{background:var(--gradient-purple, linear-gradient(225deg, #feb4b4 0%, #bb6bf0 100%))}:host([gradient=purple]) .balance-pill_content_balance{background:var(--gradient-purple, linear-gradient(225deg, #feb4b4 0%, #bb6bf0 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=pink]):before{background:var(--gradient-pink, linear-gradient(225deg, #ffc6a3 0%, #e166b6 100%))}:host([gradient=pink]) .balance-pill_content_balance{background:var(--gradient-pink, linear-gradient(225deg, #ffc6a3 0%, #e166b6 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=red]):before{background:var(--gradient-red, linear-gradient(225deg, #fcd796 0%, #fd5e5e 100%))}:host([gradient=red]) .balance-pill_content_balance{background:var(--gradient-red, linear-gradient(225deg, #fcd796 0%, #fd5e5e 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=orange]):before{background:var(--gradient-orange, linear-gradient(225deg, #fbed9c 0%, #fe8539 100%))}:host([gradient=orange]) .balance-pill_content_balance{background:var(--gradient-orange, linear-gradient(225deg, #fbed9c 0%, #fe8539 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=amber]):before{background:var(--gradient-amber, linear-gradient(225deg, #d7f4b0 0%, #f9a91f 100%))}:host([gradient=amber]) .balance-pill_content_balance{background:var(--gradient-amber, linear-gradient(225deg, #d7f4b0 0%, #f9a91f 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=yellow]):before{background:var(--gradient-yellow, linear-gradient(225deg, #b4f2b8 0%, #f7d82b 100%))}:host([gradient=yellow]) .balance-pill_content_balance{background:var(--gradient-yellow, linear-gradient(225deg, #b4f2b8 0%, #f7d82b 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=lime]):before{background:var(--gradient-lime, linear-gradient(225deg, #a8ebe1 0%, #aae755 100%))}:host([gradient=lime]) .balance-pill_content_balance{background:var(--gradient-lime, linear-gradient(225deg, #a8ebe1 0%, #aae755 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=green]):before{background:var(--gradient-green, linear-gradient(225deg, #a0e1ff 0%, #5fe367 100%))}:host([gradient=green]) .balance-pill_content_balance{background:var(--gradient-green, linear-gradient(225deg, #a0e1ff 0%, #5fe367 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=cyan]):before{background:var(--gradient-cyan, linear-gradient(225deg, #c7c8fe 0%, #44d5bf 100%))}:host([gradient=cyan]) .balance-pill_content_balance{background:var(--gradient-cyan, linear-gradient(225deg, #c7c8fe 0%, #44d5bf 100%));background-clip:text;-webkit-background-clip:text}:host([gradient=blue]) epic-wf-eds-icon{fill:#33bfff}:host([gradient=lime]) epic-wf-eds-icon{fill:#c1ed82}:host([gradient=yellow]) epic-wf-eds-icon{fill:#f9e264}:host([gradient=red]) epic-wf-eds-icon{fill:#fd5e5e}:host([gradient=pink]) epic-wf-eds-icon{fill:#e98fc9}:host([gradient=purple]) epic-wf-eds-icon{fill:#bb6bf0}:host([gradient=indigo]) epic-wf-eds-icon{fill:#868afd}:host([gradient=cyan]) epic-wf-eds-icon{fill:#76e0d0}:host([gradient=green]) epic-wf-eds-icon{fill:#8aea90}:host([gradient=amber]) epic-wf-eds-icon{fill:#f9a91f}:host([gradient=orange]) epic-wf-eds-icon{fill:#fe8539}:host([gradient=brown]) epic-wf-eds-icon{fill:#a98166}';
var qge = Object.defineProperty, Lge = Object.getOwnPropertyDescriptor, ua = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? Lge(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && qge(t, r, o), o;
};
let Un = class extends Rt {
  constructor() {
    super(...arguments), this.label = "", this.balance = "", this.icon = "", this.gradient = "", this.collapsible = !0, this.hrefTemplate = "", this.domain = "", this.locale = "";
  }
  render() {
    const e = fo({ domain: this.domain, hrefTemplate: this.hrefTemplate, locale: this.locale }), t = be`
			<div class="balance-pill_content">
				<epic-wf-eds-icon icon=${this.icon}></epic-wf-eds-icon>
				<span class="balance-pill_content_balance">${this.balance}</span>
			</div>
		`, r = this.gradient || "green", n = `${this.label} ${this.balance}`;
    return e ? be` <a
				class="balance-pill"
				data-collapsible=${this.collapsible}
				iconcolor=${r}
				gradient=${r}
				href=${e}
				title=${n}
				>${t}</a
			>` : be` <button
			class="balance-pill"
			data-collapsible=${this.collapsible}
			iconcolor=${r}
			gradient=${r}
			title=${n}
		>
			${t}
		</button>`;
  }
};
Un.styles = Ut`
		${Nt(Dge)}
	`;
ua([
  ge()
], Un.prototype, "label", 2);
ua([
  ge()
], Un.prototype, "balance", 2);
ua([
  ge()
], Un.prototype, "icon", 2);
ua([
  ge()
], Un.prototype, "gradient", 2);
ua([
  ge({ type: Boolean, converter: Cr })
], Un.prototype, "collapsible", 2);
ua([
  ge()
], Un.prototype, "hrefTemplate", 2);
ua([
  ge()
], Un.prototype, "domain", 2);
ua([
  ge()
], Un.prototype, "locale", 2);
Un = ua([
  cg("epic-wf-balance-pill")
], Un);
const Fge = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{display:block;position:relative;width:100%}.main-link{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.main-link>*{pointer-events:none}.main-link:not([disabled]){cursor:pointer}.main-link:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){.main-link{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){.main-link{--link-inline-padding-fallback: .75rem}}.main-link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){.main-link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}.main-link:hover,.main-link.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.main-link:focus-visible{border-radius:.875rem}@media (min-width: 720px){.main-link.parent:hover,.main-link.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}@media (max-width: 719.9px){.main-link{background-color:transparent;border-radius:.75rem;margin:0;padding-block:.75rem;padding-inline:.5rem;text-align:start;width:100%}}@media (max-width: 959.9px){.main-link:focus-visible{outline-offset:-.125rem}}@media (min-width: 720px){.main-link:hover,.main-link.active{background-color:transparent}}.main-link .label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.main-link .icon-wrapper{display:flex}.main-link svg{transition:transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));fill:var(--color-text-primary, #ffffff);flex-shrink:0;height:.75rem;width:.75rem}@media (max-width: 719.9px){.main-link svg{fill:var(--color-text-secondary, rgba(255, 255, 255, .65))}}@media (max-width: 719.9px){.main-link .chevron svg{height:1.25rem;width:1.25rem;transform:rotate(-90deg)}}@media (max-width: 719.9px){.main-link .chevron.rtl svg{transform:rotate(90deg)}}.main-link.active .chevron svg{transform:rotate(180deg);fill:var(--color-text-secondary, rgba(255, 255, 255, .65))}";
var Uge = Object.defineProperty, Bge = Object.getOwnPropertyDescriptor, Tn = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? Bge(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && Uge(t, r, o), o;
};
let fr = class extends Rt {
  constructor() {
    super(...arguments), this.hrefTemplate = "", this.locale = "", this.domain = "", this.key = "", this.label = "", this.owner = "", this.rtl = !1, this.active = !1, this.hasMenu = !1, this.isParent = !1, this.isMobile = !1;
  }
  render() {
    const e = fo({ domain: this.domain, hrefTemplate: this.hrefTemplate, locale: this.locale });
    if (this.label) {
      if (!this.hasMenu && !e)
        return console.debug("main-link needs an href attribute and/or associated with a menu!"), be``;
    } else return console.debug("main-link label attribute is missing!"), be``;
    const t = be`
			<span aria-hidden="true" class="icon-wrapper chevron ${this.rtl ? "rtl" : ""}"
				>${oo(QN)}</span
			>
		`, r = `main-link ${this.active ? "active" : ""} ${this.isParent ? "parent" : ""}`, n = be`<span class="label">${this.label}</span> ${this.hasMenu ? t : ""}`, o = this.hasMenu && this.isMobile;
    return e && !o ? be`
				<a
					aria-expanded="${Ar(
      this.hasMenu && this.active ? !0 : this.hasMenu && !this.active ? !1 : void 0
    )}"
					class="${r}"
					href=${e}
				>
					${n}
				</a>
				<slot></slot>
			` : be`
			<button aria-expanded="${this.active}" class="${r}">${n}</button>
			<slot></slot>
		`;
  }
};
fr.styles = Ut`
		${Nt(Fge)}
	`;
Tn([
  ge()
], fr.prototype, "hrefTemplate", 2);
Tn([
  ge()
], fr.prototype, "locale", 2);
Tn([
  ge()
], fr.prototype, "domain", 2);
Tn([
  ge()
], fr.prototype, "key", 2);
Tn([
  ge()
], fr.prototype, "label", 2);
Tn([
  ge()
], fr.prototype, "owner", 2);
Tn([
  ge({ type: Boolean })
], fr.prototype, "rtl", 2);
Tn([
  ge({ type: Boolean, converter: Cr })
], fr.prototype, "active", 2);
Tn([
  ge({ type: Boolean, converter: Cr })
], fr.prototype, "hasMenu", 2);
Tn([
  ge({ type: Boolean, converter: Cr })
], fr.prototype, "isParent", 2);
Tn([
  ge({ type: Boolean, converter: Cr })
], fr.prototype, "isMobile", 2);
fr = Tn([
  cg("epic-wf-main-link")
], fr);
const Hge = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{color:var(--color-text-primary, white)}:host .description-cta{display:flex;flex-direction:column}:host .description-cta__description{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;padding-inline:.5rem;padding-block-end:1rem;padding-block-start:.625rem;white-space:wrap}:host .description-cta__description.compact{padding-block-start:0}:host .description-cta__button{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));--link-block-padding: .25rem;--link-inline-padding: .75rem;border-radius:.375rem;background-color:var(--color-fill-primary-default, #26bbff);margin:0;text-align:center;font-weight:500;font-weight:400;background-color:var(--color-fill-secondary-default, rgba(255, 255, 255, .15));margin-inline:.5rem;margin-block-end:.5rem;margin-block-start:.625rem}:host .description-cta__button>*{pointer-events:none}:host .description-cta__button:not([disabled]){cursor:pointer}:host .description-cta__button:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){:host .description-cta__button{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){:host .description-cta__button{--link-inline-padding-fallback: .75rem}}:host .description-cta__button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){:host .description-cta__button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}:host .description-cta__button:hover,:host .description-cta__button.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}:host .description-cta__button:focus-visible{border-radius:.875rem}@media (min-width: 720px){:host .description-cta__button.parent:hover,:host .description-cta__button.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}:host .description-cta__button:focus-visible{outline-color:#fff;outline-offset:.125rem}:host .description-cta__button:hover{background-color:var(--color-fill-primary-hover, #72d3ff)}:host .description-cta__button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:500;line-height:100%;letter-spacing:.02em;font-size:.875rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;justify-content:center;color:var(--color-text-on-accent, #000000);line-height:1.5rem}@media (max-width: 719.9px){:host .description-cta__button{--link-block-padding: .5rem;--link-inline-padding: .75rem;flex:1}:host .description-cta__button .label{line-height:1rem}}:host .description-cta__button:hover{background-color:var(--color-fill-secondary-hover, rgba(255, 255, 255, .35))}:host .description-cta__button .label{color:var(--color-text-primary, #ffffff)}:host .description-cta__button.compact{margin-block-start:0}";
var Vge = Object.defineProperty, zge = Object.getOwnPropertyDescriptor, yA = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? zge(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && Vge(t, r, o), o;
};
let kd = class extends fr {
  constructor() {
    super(...arguments), this.description = "", this.compact = !1;
  }
  render() {
    const t = fo({
      domain: this.domain,
      hrefTemplate: this.hrefTemplate,
      locale: this.locale
    });
    return !this.description && !this.label ? (console.debug("description-cta description and label attributes are missing!"), be``) : be`
			<div class="description-cta">
				${Ar(this.description) ? be`<span class="description-cta__description ${this.compact ? "compact" : ""}">${this.description}</span>` : void 0}
				${Ar(this.label) ? t ? be`
								<a class="description-cta__button ${this.compact ? "compact" : ""}" href="${t}">
									<span class="label">${this.label}</span>
								</a>
							` : be`
								<button class="description-cta__button ${this.compact ? "compact" : ""}">
									<span class="label">${this.label}</span>
								</button>
							` : void 0}
			</div>
		`;
  }
};
kd.styles = Ut`
		${Nt(Hge)}
	`;
yA([
  ge()
], kd.prototype, "description", 2);
yA([
  ge({ type: Boolean, converter: Cr })
], kd.prototype, "compact", 2);
kd = yA([
  gr("epic-wf-description-cta")
], kd);
function Jge(e, t) {
  return be`
		<epic-wf-nav-vertical-menu>
			${t.sections.map((r) => {
    if (r.__typename === "NavMenuSection")
      return be`
						<epic-wf-menu-section .eyebrow=${!0}>
							<h4 slot="heading">${r.heading}</h4>

							<div slot="content">
								${r.items.map((n) => {
        if (n.__typename === "NavMenuIconLink") {
          if (n.hidden) return be``;
          const o = {
            __typename: "NavLink",
            id: n.id,
            hrefTemplate: n.hrefTemplate,
            relativePath: n.relativePath,
            locale: n.locale,
            key: n.key,
            label: n.label || "",
            owner: n.owner
          };
          return be`
											<epic-wf-menu-item
												@click=${(a) => e?.handleAnchorClick(a, o, -1)}
												label=${n.label || ""}
												hrefTemplate=${n.hrefTemplate || ""}
												locale=${n.locale || ""}
												owner=${n.owner || ""}
												key=${n.key || ""}
												startIcon=${n.startIcon || ""}
												startIconColor=${r.brandColor || r.accentColor || ""}
												endIcon=${n.endIcon || ""}
											>
											</epic-wf-menu-item>
										`;
        }
        return be``;
      })}
							</div>
						</epic-wf-menu-section>
					`;
    if (r.__typename === "NavMenuCtaSection") {
      const n = {
        __typename: "NavLink",
        id: r.id,
        hrefTemplate: r.hrefTemplate,
        relativePath: r.relativePath,
        locale: r.locale,
        key: r.key,
        label: r.label || "",
        owner: r.owner
      };
      return be`
						<epic-wf-menu-section .eyebrow=${!0}>
							<h4 slot="heading">${r.heading}</h4>

							<div slot="content">
								<epic-wf-description-cta
									@click=${(o) => e?.handleAnchorClick(o, n, -1)}
									description=${r.description || ""}
									label=${r.label || ""}
									hrefTemplate=${r.hrefTemplate || ""}
									locale=${r.locale || ""}
									owner=${r.owner || ""}
									key=${r.key || ""}
									.compact=${r.compact || !1}
								>
								</epic-wf-description-cta>
							</div>
						</epic-wf-menu-section>
					`;
    }
    return be``;
  })}
		</epic-wf-nav-vertical-menu>
	`;
}
const Wge = (e, t, r) => be`
		<epic-wf-simple-menu>
			<div class="menu-heading"><h2>${e.commonStrings?.mobileMainMenuHeading}</h2></div>
			<div class="menu-wrap" role="list">
				${t?.links.map(
  (n) => be`
						<epic-wf-menu-item
							role="listitem"
							@click=${(o) => e.onLinkClick(o, n)}
							hrefTemplate=${n.hrefTemplate || ""}
							locale=${e.getMappedHygraphLocale(n.locale || "")}
							label=${n.label || ""}
							endIcon=${n.endIcon || ""}
							domain=${e?.domain || ""}
						></epic-wf-menu-item>
					`
)}
			</div>
		</epic-wf-simple-menu>
	`, Gge = '.visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{min-width:10rem}.condensed-menu{list-style:none;margin:0;padding:0;position:relative;width:100%;min-width:12.5rem;max-width:12.5rem;box-sizing:border-box;padding-block:.5rem;padding-inline:.5rem}@media (min-width: 720px){.condensed-menu .bg-filter{background:var(--color-background-transparent-menu, rgba(48, 48, 52, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));border-radius:var(--size-border-radius-16, 16px);border:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1));inset:-1px;position:absolute;overflow:hidden;z-index:-1;content:"";display:block;box-shadow:0 32px 16px #0000001a,0 16px 8px #0000001a,0 8px 4px #0000001a,0 4px 2px #0000001a,0 2px 1px #0000001a}}.condensed-menu__item{position:relative}.condensed-menu__item epic-wf-simple-menu,.condensed-menu__item epic-wf-nav-vertical-menu{inset-block-start:-.5rem;inset-inline-start:100%;position:absolute;z-index:1;min-width:15rem;max-width:15rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.condensed-menu__item:not([active=true]) epic-wf-simple-menu,.condensed-menu__item:not([active=true]) epic-wf-nav-vertical-menu{opacity:0;pointer-events:none;visibility:hidden}.condensed-menu__item.hidden{display:none;opacity:0;pointer-events:none;visibility:hidden}.condensed-menu__item .friendly-box{position:absolute}.condensed-menu__link{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));flex-direction:row;flex-wrap:nowrap;text-align:start;width:100%}.condensed-menu__link>*{pointer-events:none}.condensed-menu__link:not([disabled]){cursor:pointer}.condensed-menu__link:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){.condensed-menu__link{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){.condensed-menu__link{--link-inline-padding-fallback: .75rem}}.condensed-menu__link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){.condensed-menu__link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}.condensed-menu__link:hover,.condensed-menu__link.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.condensed-menu__link:focus-visible{border-radius:.875rem}@media (min-width: 720px){.condensed-menu__link.parent:hover,.condensed-menu__link.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}.condensed-menu__link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex-grow:1}.condensed-menu__link .icon-wrapper{display:flex}.condensed-menu__link svg{transition:transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));fill:var(--color-text-primary, #ffffff);flex-shrink:0;height:.75rem;width:.75rem;padding:.25rem}@media (max-width: 719.9px){.condensed-menu{display:none}}.condensed-menu .condensed-menu__item:hover{z-index:4}.condensed-menu .condensed-menu__item:hover .friendly-box{margin-block-start:-.375rem;height:2.5rem;inset-block-start:100%;inset-inline-start:50%;position:absolute;transform:translate(calc(-50% * var(--transform-direction)));min-width:5.625rem;width:100%;pointer-events:all;z-index:-1}.condensed-menu .condensed-menu__item:hover .friendly-box:before,.condensed-menu .condensed-menu__item:hover .friendly-box:after{content:"";position:absolute;height:2rem;width:4rem;transform-origin:top}@media (max-width: 719.9px){.condensed-menu .condensed-menu__item:hover .friendly-box:before,.condensed-menu .condensed-menu__item:hover .friendly-box:after{display:none}}.condensed-menu .condensed-menu__item:hover .friendly-box:before{transform:rotate(calc(-35deg * var(--transform-direction)));inset-inline-start:-3.5rem}.condensed-menu .condensed-menu__item:hover .friendly-box:after{transform:rotate(calc(35deg * var(--transform-direction)));inset-inline-end:-3.5rem}.condensed-menu .condensed-menu__item:hover .friendly-box--inline-end{height:2rem;width:2rem;min-width:2rem;inset-block-start:initial;inset-inline-start:100%}.condensed-menu .condensed-menu__item:hover .friendly-box--inline-end:before,.condensed-menu .condensed-menu__item:hover .friendly-box--inline-end:after{width:3rem;transform-origin:center}.condensed-menu .condensed-menu__item:hover .friendly-box--inline-end:before{transform:rotate(calc(-35deg * var(--transform-direction)));inset-inline-start:initial;inset-inline-end:0;inset-block-start:-1.5rem}.condensed-menu .condensed-menu__item:hover .friendly-box--inline-end:after{transform:rotate(calc(35deg * var(--transform-direction)));inset-inline-start:initial;inset-inline-end:0;inset-block-end:-1.5rem}@media (max-width: 719.9px){.condensed-menu .friendly-box{display:none}}.condensed-menu .menu-heading{display:none}';
var Kge = Object.defineProperty, Yge = Object.getOwnPropertyDescriptor, ai = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? Yge(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && Kge(t, r, o), o;
};
let mo = class extends Rt {
  constructor() {
    super(...arguments), this.mainLinks = new Array(), this.rtl = !1, this.hasOpenMenu = !1, this.active = -1, this.domain = "", this.locale = "", this.keysShown = -1;
  }
  closeMenu() {
    this.active = -1, this.hasOpenMenu = !1;
  }
  handleAnchorClick(e, t, r) {
    Q_(t) ? (e.preventDefault(), this.handleButtonClick(e, r)) : this.onLinkClick(e, t);
  }
  handleKeyDown(e, t, r = !1) {
    ["Space", "Enter", "NumpadEnter"].includes(e.code) && (["Enter", "NumpadEnter"].includes(e.code) && r || (e.preventDefault(), this.handleButtonClick(e, t)));
  }
  handleButtonClick(e, t) {
    const r = this.active;
    this.active = r === t ? -1 : t, this.hasOpenMenu = r !== t, this.onSubmenu(e, this.hasOpenMenu, this.closeMenu.bind(this));
  }
  handlePointerEnter(e, t, r) {
    TP(e) || (this.active = t, r && (this.hasOpenMenu = !0), this.onSubmenu(e, this.hasOpenMenu, this.closeMenu.bind(this)));
  }
  handlePointerLeave(e) {
    TP(e) || (this.active = -1, this.hasOpenMenu = !1, this.onSubmenu(e, this.hasOpenMenu, this.closeMenu.bind(this)));
  }
  /**
   * Set by parent in order for the parent Navigation class to react
   */
  onSubmenu(e, t, r) {
  }
  /**
   * Set by parent in order to keep a reference from the parent Navigation class
   */
  onLinkClick(e, t) {
  }
  /**
   * Set by parent in order to keep a reference from the parent Navigation class
   */
  getMappedHygraphLocale(e) {
    return e;
  }
  render() {
    return be`
			<ul class="condensed-menu ${this.hasOpenMenu ? "has-open-menu" : null}">
				<li class="bg-filter"></li>
				${this.mainLinks.map((e, t) => {
      if (!e || !e.label)
        return;
      const r = Q_(e), n = !!e?.hrefTemplate, o = this.keysShown >= 0 && this.keysShown <= t, a = be`
						<span aria-hidden="true" class="icon-wrapper">
							${this.rtl ? oo(zre) : oo(Jre)}
						</span>
						<div class="friendly-box friendly-box--inline-end"></div>
					`, i = this.active === t ? "true" : "false", s = be`
						<a
							@click=${(h) => this.handleAnchorClick(h, e, t)}
							@keydown=${(h) => this.handleKeyDown(h, t, n)}
							@pointerenter=${(h) => this.handlePointerEnter(h, t, r)}
							aria-expanded=${i}
							class="condensed-menu__link"
							data-key=${Ar(e.key || "")}
							href=${fo({
        hrefTemplate: e.hrefTemplate,
        domain: this.domain,
        locale: this.locale
      })}
						>
							<span class="label">${e.label}</span>
							${a}
						</a>
					`, d = be`
						<a
							@click=${(h) => this.handleAnchorClick(h, e, t)}
							@pointerenter=${(h) => this.handlePointerEnter(h, t, r)}
							class="condensed-menu__link"
							data-key=${Ar(e.key || "")}
							href=${fo({
        hrefTemplate: e.hrefTemplate,
        domain: this.domain,
        locale: this.locale
      })}
						>
							<span class="label">${e.label}</span>
						</a>
					`, l = r ? s : d, p = e.hrefTemplate ? l : be`
								<button
									@click=${(h) => this.handleButtonClick(h, t)}
									@pointerenter=${(h) => this.handlePointerEnter(h, t, r)}
									aria-expanded="${this.active === t ? "true" : "false"}"
									label=${e.label}
									class="condensed-menu__link"
									data-key=${Ar(e.key || "")}
								>
									<span class="label">${e.label}</span>
									${a}
								</button>
							`;
      let f = "";
      return r && e.menu && (AJ(e) && "links" in e.menu ? f = Wge(this, e.menu) : "sections" in e.menu && (f = Jge(this, e.menu))), be`
						<li
							@pointerleave=${this.handlePointerLeave}
							active=${this.active === t}
							aria-hidden="${!o}"
							class="condensed-menu__item ${r ? "has-submenu" : ""} ${o ? "" : "hidden"}"
							label=${e.label}
							data-key=${e?.key || ""}
						>
							${p} ${f}
						</li>
					`;
    })}
			</ul>
		`;
  }
};
mo.styles = Ut`
		${Nt(Gge)}
	`;
ai([
  ge({ type: Array })
], mo.prototype, "mainLinks", 2);
ai([
  ge({ type: Boolean })
], mo.prototype, "rtl", 2);
ai([
  mA()
], mo.prototype, "hasOpenMenu", 2);
ai([
  mA()
], mo.prototype, "active", 2);
ai([
  ge()
], mo.prototype, "domain", 2);
ai([
  ge()
], mo.prototype, "locale", 2);
ai([
  ge({ type: Number })
], mo.prototype, "keysShown", 2);
mo = ai([
  gr("epic-wf-condensed-menu")
], mo);
const $J = {
  md: 960
}, Xge = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.cta-button{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));--link-block-padding: .25rem;--link-inline-padding: .75rem;border-radius:.375rem;background-color:var(--color-fill-primary-default, #26bbff);margin:0;text-align:center;font-weight:500}.cta-button>*{pointer-events:none}.cta-button:not([disabled]){cursor:pointer}.cta-button:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){.cta-button{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){.cta-button{--link-inline-padding-fallback: .75rem}}.cta-button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){.cta-button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}.cta-button:hover,.cta-button.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.cta-button:focus-visible{border-radius:.875rem}@media (min-width: 720px){.cta-button.parent:hover,.cta-button.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}.cta-button:focus-visible{outline-color:#fff;outline-offset:.125rem}.cta-button:hover{background-color:var(--color-fill-primary-hover, #72d3ff)}.cta-button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:500;line-height:100%;letter-spacing:.02em;font-size:.875rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;justify-content:center;color:var(--color-text-on-accent, #000000);line-height:1.5rem}@media (max-width: 719.9px){.cta-button{--link-block-padding: .5rem;--link-inline-padding: .75rem;flex:1}.cta-button .label{line-height:1rem}}.cta-button.small{--link-block-padding: .375rem;--link-inline-padding: .5rem}";
var Qge = Object.defineProperty, Zge = Object.getOwnPropertyDescriptor, js = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? Zge(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && Qge(t, r, o), o;
};
let aa = class extends Rt {
  constructor() {
    super(...arguments), this.label = "", this.href = "", this.domain = "", this.locale = "", this.target = "", this.small = !1;
  }
  render() {
    if (!this.href || !this.label)
      return be``;
    const t = fo({ domain: this.domain, hrefTemplate: this.href, locale: this.locale });
    return be`
			<a class=${`cta-button ${this.small ? "small" : ""}`} href=${t} .target=${this.target}>
				<span class="label">${this.label}</span>
			</a>
		`;
  }
};
aa.styles = Ut`
		${Nt(Xge)}
	`;
js([
  ge()
], aa.prototype, "label", 2);
js([
  ge()
], aa.prototype, "href", 2);
js([
  ge()
], aa.prototype, "domain", 2);
js([
  ge()
], aa.prototype, "locale", 2);
js([
  ge()
], aa.prototype, "target", 2);
js([
  ge({ type: Boolean, reflect: !0 })
], aa.prototype, "small", 2);
aa = js([
  gr("epic-wf-cta-button")
], aa);
const ebe = ":host{display:inline-flex;height:2rem;width:2rem}:host svg{transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));--avatar-background: var(--color-border-subtle, rgba(255, 255, 255, .15));fill:var(--color-text-primary, #ffffff);flex-grow:1}:host svg circle{fill:var(--color-fill-avatar-circle, #a9d34f);stroke:var(--color-background-default, #101014)}:host svg:hover{fill:var(--color-text-primary, #ffffff)}";
var tbe = Object.defineProperty, rbe = Object.getOwnPropertyDescriptor, CJ = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? rbe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && tbe(t, r, o), o;
};
let Dh = class extends Rt {
  constructor() {
    super(...arguments), this.isLoggedIn = !1;
  }
  render() {
    const e = this.isLoggedIn ? Nye`<circle cx="28" cy="28" r="5" stroke-width="2" />` : "";
    return be`
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
				<rect width="32" height="32" fill="var(--avatar-background)" rx="16" />
				${e}
				<path
					fill-rule="evenodd"
					d="M16 9.75a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5ZM12.25 12a3.75 3.75 0 1 1 7.5 0 3.75 3.75 0 0 1-7.5 0Zm.39 6.75a1.25 1.25 0 0 0-1.226 1.005l-.678 3.392a.75.75 0 1 1-1.471-.294l.678-3.392a2.75 2.75 0 0 1 2.697-2.211h6.72a2.75 2.75 0 0 1 2.697 2.21l.679 3.393a.75.75 0 0 1-1.471.294l-.679-3.392a1.25 1.25 0 0 0-1.226-1.005h-6.72Z"
					clip-rule="evenodd"
				/>
			</svg>
		`;
  }
};
Dh.styles = Ut`
		${Nt(ebe)}
	`;
CJ([
  ge({ type: Boolean, converter: Cr })
], Dh.prototype, "isLoggedIn", 2);
Dh = CJ([
  gr("epic-wf-avatar-icon")
], Dh);
var nbe = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let LR = class extends Rt {
  render() {
    return be`<svg
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 2 32"
			height="32"
			width="2"
			fill="var(--color-border-subtle, #303034)"
		>
			<path d="M0 0h2v32H0z" />
		</svg>`;
  }
};
LR = nbe([
  gr("epic-wf-bar-icon")
], LR);
const obe = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{flex:1}:host .image-card{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));border-radius:.75rem;margin:0;width:100%;height:5.5rem;color:var(--color-text-primary, #ffffff);text-align:start;--link-block-padding: 0;--link-inline-padding: 0;--link-outline-offset: pxToRem(-1);background:var(--color-background-transparent-elevated-high-default, rgba(255, 255, 255, .1))}:host .image-card>*{pointer-events:none}:host .image-card:not([disabled]){cursor:pointer}:host .image-card:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){:host .image-card{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){:host .image-card{--link-inline-padding-fallback: .75rem}}:host .image-card .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){:host .image-card .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}:host .image-card:hover,:host .image-card.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}:host .image-card:focus-visible{border-radius:.875rem}@media (min-width: 720px){:host .image-card.parent:hover,:host .image-card.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}@media (max-width: 1279.9px){:host .image-card{--link-block-padding: 0}}:host .image-card:hover{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15))}:host .image-card:hover .image{transform:scale(1.1)}:host .image-card .image-card-content{display:flex;height:100%}:host .image-card .image-card-content .image-wrapper{border-start-start-radius:.75rem;border-end-start-radius:.75rem;position:relative;overflow:hidden;min-width:max-content;width:7.3125rem;z-index:-1}:host .image-card .image-card-content .image-wrapper .image{transition:transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.45, 0, .55, 1));height:100%;width:inherit;object-fit:cover}:host .image-card .image-card-content .text-wrapper{padding-block:.75rem;padding-inline:1rem;display:flex;flex-direction:column;justify-content:center;gap:.375rem}:host .image-card .image-card-content .text-wrapper span{text-overflow:ellipsis;overflow:hidden;-webkit-box-orient:vertical;display:-webkit-box}:host .image-card .image-card-content .text-wrapper span p{margin-block:0;margin-inline:0}:host .image-card .image-card-content .text-wrapper span.eyebrow{font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:100%;text-transform:uppercase;font-size:10px;letter-spacing:1px;line-clamp:1;-webkit-line-clamp:1}:host .image-card .image-card-content .text-wrapper span.description{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;line-height:19.6px;letter-spacing:2%;line-clamp:2;-webkit-line-clamp:2}";
var abe = Object.defineProperty, ibe = Object.getOwnPropertyDescriptor, fg = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? ibe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && abe(t, r, o), o;
};
let Ql = class extends fr {
  constructor() {
    super(...arguments), this.image = {}, this.eyebrow = "", this.description = "";
  }
  render() {
    const e = fo({ domain: this.domain, hrefTemplate: this.hrefTemplate, locale: this.locale });
    if (!this.image?.url)
      return console.debug("image-card image.url attribute is missing!"), be``;
    if (!this.description)
      return console.debug("image-card description attribute is missing!"), be``;
    const t = be`
			<div class="image-card-content">
				<div class="image-wrapper">
					<img class="image" src=${this.image?.url || ""} alt=${this.image?.altText || ""} />
				</div>
				<div class="text-wrapper">
					<span class="eyebrow" lang=${this.locale}><p>${this.eyebrow}</p></span>
					<span class="description" lang=${this.locale}><p>${this.description}</p></span>
				</div>
			</div>
		`;
    return e ? be` <a class="image-card" href="${e}">${t}</a> ` : be` <button class="image-card">${t}</button> `;
  }
};
Ql.styles = Ut`
		${Nt(obe)}
	`;
fg([
  ge({ type: Object })
], Ql.prototype, "image", 2);
fg([
  ge()
], Ql.prototype, "eyebrow", 2);
fg([
  ge()
], Ql.prototype, "description", 2);
Ql = fg([
  gr("epic-wf-image-card")
], Ql);
const sbe = ":host{display:flex;align-items:center}:host .logo{display:block;display:flex;align-items:center}:host .logo__img{display:block}:host .logo__img--icon{display:none}@media (min-width: 360px) and (max-width: 399.9px){:host .logo .logo__img{height:1.75rem;width:auto}}@media (min-width: 340px) and (max-width: 359.9px){:host .logo .logo__img{height:1.625rem;width:auto}}@media (max-width: 339.9px){:host .logo--has-icon .logo__img{display:none}:host .logo--has-icon .logo__img--icon{display:block}}@media (min-width: 720px) and (max-width: 1279.9px){:host .logo--has-icon .logo__img{display:none}:host .logo--has-icon .logo__img--icon{display:block}}@media (max-width: 375px){:host .logo.logo--has-icon.logo--top-cta .logo__img{display:none}:host .logo.logo--has-icon.logo--top-cta .logo__img--icon{display:block;height:2rem;width:auto}}:host a[href].logo{cursor:pointer}:host a[href].logo:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}:host a[href].logo:focus-visible{outline-offset:.125rem}@media (min-width: 720px){:host a[href].logo{transition:opacity var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}:host a[href].logo:hover{opacity:.7}}";
var lbe = Object.defineProperty, cbe = Object.getOwnPropertyDescriptor, wo = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? cbe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && lbe(t, r, o), o;
};
let wn = class extends Rt {
  constructor() {
    super(...arguments), this.domain = "", this.hrefTemplate = "", this.locale = "", this.logo = {}, this.iconOnlyLogo = {}, this.forDrawer = !1, this.validMobileTopCta = !1, this.logoAlt = "", this.width = 32;
  }
  render() {
    const e = !!(this.logo && this.logo?.url), t = !!(this.iconOnlyLogo && this.iconOnlyLogo?.url), r = fo({ domain: this.domain, hrefTemplate: this.hrefTemplate, locale: this.locale }), n = !!r, o = e ? be`
					<img
						alt=${this.logoAlt}
						class="logo__img"
						fetchpriority="high"
						height="32"
						src=${this.logo.url}
						width=${this.width || "auto"}
					/>
				` : null, a = t ? be`
					<img
						alt=${this.logoAlt}
						class="logo__img logo__img--icon"
						height="32"
						src=${this.iconOnlyLogo.url}
						width="32"
					/>
				` : null, i = `logo ${t ? "logo--has-icon" : ""} ${this.validMobileTopCta ? "logo--top-cta" : ""}`;
    return n ? be`<a href=${r} class=${i}>${o}${a}</a>` : be`<span class=${i}>${o}${a}</span>`;
  }
};
wn.styles = Ut`
		${Nt(sbe)}
	`;
wo([
  ge()
], wn.prototype, "domain", 2);
wo([
  ge()
], wn.prototype, "hrefTemplate", 2);
wo([
  ge()
], wn.prototype, "locale", 2);
wo([
  ge({ type: Object })
], wn.prototype, "logo", 2);
wo([
  ge({ type: Object })
], wn.prototype, "iconOnlyLogo", 2);
wo([
  ge({ type: Boolean, reflect: !0 })
], wn.prototype, "forDrawer", 2);
wo([
  ge({ type: Boolean, reflect: !0 })
], wn.prototype, "validMobileTopCta", 2);
wo([
  ge()
], wn.prototype, "logoAlt", 2);
wo([
  ge({ type: Number })
], wn.prototype, "width", 2);
wn = wo([
  gr("epic-wf-property-logo")
], wn);
var ir = /* @__PURE__ */ ((e) => (e.SEARCH = "epic-wf-nav-on-search", e.SEARCH_INPUT = "epic-wf-nav-on-input", e.SEARCH_KEYDOWN = "epic-wf-nav-search-on-keydown", e.SEARCH_ACTIVATED = "epic-wf-nav-search-activated", e.NAV_LINK_CLICK = "epic-wf-nav-link-on-click", e.PROPERTY_LOGO_CLICK = "epic-wf-prop-logo-on-click", e.LOCALE_LINK_CLICK = "epic-wf-locale-on-click", e.CTA_CLICK = "epic-wf-cta-on-click", e.ACCOUNT_LINK_CLICK = "epic-wf-account-link-on-click", e.DRAWER_TOGGLE = "epic-wf-drawer-on-toggle", e.IS_READY = "epic-wf-nav-is-ready", e.SEARCH_SET_INPUT_VALUE = "epic-wf-nav-set-input-value", e.SEARCH_SET_INPUT_STATE = "epic-wf-nav-set-input-state", e.SEARCH_CLEAR_INPUT_VALUE = "epic-wf-nav-clear-input-value", e.SEARCH_READY = "epic-wf-nav-search-ready", e.SEARCH_INPUT_FOCUSED = "epic-wf-nav-search-input-focus", e.SEARCH_INPUT_BLURED = "epic-wf-nav-search-input-blur", e.WALLET_BALANCE_CLICK = "epic-wf-nav-wallet-balance-click", e.REWARDS_BALANCE_CLICK = "epic-wf-nav-rewards-balance-click", e.VBUCKS_BALANCE_CLICK = "epic-wf-nav-vbucks-balance-click", e.ICON_CLICK = "epic-wf-nav-icon-click", e))(ir || {});
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ube = (e, t, r) => {
  for (const n of t) if (n[0] === e) return (0, n[1])();
  return r?.();
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const FR = gJ(class extends bJ {
  constructor(e) {
    if (super(e), e.type !== yJ.ATTRIBUTE || e.name !== "class" || e.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(e) {
    return " " + Object.keys(e).filter(((t) => e[t])).join(" ") + " ";
  }
  update(e, [t]) {
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), e.strings !== void 0 && (this.nt = new Set(e.strings.join(" ").split(/\s/).filter(((n) => n !== ""))));
      for (const n in t) t[n] && !this.nt?.has(n) && this.st.add(n);
      return this.render(t);
    }
    const r = e.element.classList;
    for (const n of this.st) n in t || (r.remove(n), this.st.delete(n));
    for (const n in t) {
      const o = !!t[n];
      o === this.st.has(n) || this.nt?.has(n) || (o ? (r.add(n), this.st.add(n)) : (r.remove(n), this.st.delete(n)));
    }
    return Wa;
  }
}), dbe = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}@keyframes fade-in{0%{opacity:0}to{opacity:1}}@media (max-width: 719.9px){:host{flex:1}}:host button{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none}:host button>*{pointer-events:none}:host button:not([disabled]){cursor:pointer}:host button:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}:host svg{fill:currentColor}:host input[type=search]::-webkit-search-decoration,:host input[type=search]::-webkit-search-cancel-button,:host input[type=search]::-webkit-search-results-button,:host input[type=search]::-webkit-search-results-decoration{display:none}:host .icon-wrapper{display:flex}:host .search-form{align-items:center;display:flex;width:var(--search-box-width);column-gap:1rem}:host .search-form.active .search-button{display:none}:host .search-form:not(.active) .search{display:none}:host .search-form:not(.prestine) .search-button,:host .search-form:not(.prestine) .search{animation:fade-in var(--easing-duration, .18s) ease-in-out}:host .search-button{color:var(--color-text-primary, #ffffff);display:flex;padding-block:.25rem;padding-inline:.25rem;transition:color var(--easing-duration, .18s) var(--easing, cubic-bezier(.65, 0, .35, 1))}:host .search-button:hover{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}:host .search-button svg{transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));fill:currentColor;height:1.5rem;width:1.5rem}:host .search{align-items:center;outline-offset:.125rem;border-radius:var(--size-border-radius-full, 9999px);border:var(--size-border-width-ui-sm, 1px) solid var(--color-border-subtle, rgba(255, 255, 255, .15));background:var(--color-fill-input-default, rgba(255, 255, 255, .05));color:var(--color-text-primary, #ffffff);display:flex;gap:.75rem;height:2.5rem;padding-inline:1rem;transition:opacity .2s ease-in-out;width:var(--search-box-width);flex-grow:1}:host .search:focus-within{outline:.125rem solid var(--color-text-primary, #ffffff)}:host .search__icon{display:flex}:host .search__icon svg{width:1.25rem;height:1.25rem}:host .search__submit{order:-1}:host .search__submit svg{fill:var(--color-text-secondary, rgba(255, 255, 255, .65));transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}:host .search__submit:hover svg{fill:var(--color-text-primary, #ffffff)}:host .search__input{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;background-color:transparent;border:none;color:var(--color-text-primary, #ffffff);flex:1 0 auto;height:100%;outline:none;padding:0;width:5.875rem}@media (min-width: 1280px){:host .search__input{width:10.75rem}}@media (min-width: 1440px){:host .search__input{width:12.5rem}}:host .search__input::placeholder{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}:host .search__close{align-items:center;display:flex;width:1.25rem;height:1.25rem;justify-content:center}:host .search__close svg{width:1rem;height:1rem;fill:var(--color-text-secondary, rgba(255, 255, 255, .65));transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}:host .search__close:hover svg{fill:var(--color-text-primary, #ffffff)}@media (max-width: 719.9px){:host .search__close{display:none}}:host .close-button{font-family:Inter,sans-serif;font-style:normal;font-weight:500;line-height:100%;letter-spacing:.02em;font-size:.875rem;background:transparent;border-radius:.25rem;color:var(--color-text-primary, #ffffff);display:none;height:2.5rem;padding-block:.5rem;padding-inline:0rem;text-align:center;vertical-align:middle}@media (max-width: 719.9px){:host .close-button{display:block}}:host .close-button.cancel-button{flex-shrink:0}:host([mode=static]){display:flex;flex-wrap:nowrap;width:100%}:host([mode=static]) .active{border-color:var(--color-border-default, rgba(255, 255, 255, .35));border-radius:1.5rem;grid-template-columns:1.25rem auto;width:100%}:host([mode=static]) .search__input:invalid~.search__close{visibility:hidden}@media (min-width: 720px){:host([mode=static]){max-width:50rem}}";
var pbe = Object.defineProperty, fbe = Object.getOwnPropertyDescriptor, en = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? fbe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && pbe(t, r, o), o;
};
const hbe = ["normal", "static", "trigger"], mbe = {
  fromAttribute: (e, t) => hbe.includes(e) ? e : "normal",
  toAttribute: (e, t) => e
};
let $r = class extends Rt {
  constructor() {
    super(...arguments), this.activateSearchLabel = "Open Search", this.deactivateSearchLabel = "Close Search", this.inputLabel = "Search the Epic Games website", this.placeholderLabel = "Search...", this.submitLabel = "Search", this.cancelLabel = "Cancel", this.mode = "normal", this.opened = !1, this.isMobile = !1, this._prestine = !0, this.handleEvent = (e) => {
      if (!this._inputElement) return;
      const { value: t, options: r } = e?.detail || {};
      r?.focus && this._inputElement.focus(), typeof t == "string" && (this._inputElement.value = t), r?.blur && this._inputElement.blur();
    };
  }
  render() {
    return be`
			${ube(
      this.mode,
      [
        ["normal", this.normalMode.bind(this)],
        ["static", this.staticMode.bind(this)],
        ["trigger", this.triggerMode.bind(this)]
      ],
      this.normalMode
    )}
		`;
  }
  updated() {
    this.opened && this._inputElement && this._inputElement.focus();
  }
  firstUpdated() {
    if (this._prestine && this._inputElement && typeof this.initSearchValue == "string") {
      const e = this.initSearchValue;
      this.handleEvent({
        detail: { value: e, options: { focus: !0 } }
      });
    }
    this.dispatchEvent(
      new CustomEvent(ir.SEARCH_READY, {
        detail: { ready: !0 },
        bubbles: !0,
        composed: !0
      })
    );
  }
  /* ***************************** */
  /* Templates and Private methods */
  /* ***************************** */
  normalMode() {
    const e = { active: this.opened || this.isStaticMode, prestine: this._prestine };
    return be`
			<form
				@keydown=${this._keypress}
				@submit=${this._submit}
				autocomplete="off"
				class="search-form ${FR(e)}"
				role="search"
			>
				${this.opened ? this.activeTemplate() : this.deactiveTemplate()} ${this.cancelBtnTemplate()}
			</form>
		`;
  }
  staticMode() {
    const e = this.opened || !this.isMobile, t = { active: e, prestine: this._prestine };
    return be`
			<form
				@keydown=${this._keypress}
				@submit=${this._submit}
				autocomplete="off"
				class="search-form ${FR(t)}"
				role="search"
			>
				${e ? this.activeTemplate() : this.deactiveTemplate()} ${this.cancelBtnTemplate()}
			</form>
		`;
  }
  triggerMode() {
    return be`<button
			@click=${this._toggleActive}
			aria-label=${this.opened ? this.deactivateSearchLabel || "Close Search" : this.activateSearchLabel || "Open Search"}
			class="search-button"
		>
			<span aria-hidden="true" class="icon-wrapper">${oo(zb)}</span>
		</button>`;
  }
  activeTemplate() {
    const e = be`<button
			@click=${this._deactivate}
			aria-label=${this.deactivateSearchLabel || "Close Search"}
			class="search__close"
			type="reset"
		>
			<span aria-hidden="true" class="icon-wrapper">${oo(ZN)}</span>
		</button>`;
    return be`
			<div class="search">
				<input
					aria-label=${this.inputLabel}
					class="search__input"
					id="search"
					inputmode="search"
					placeholder="${this.placeholderLabel}"
					type="search"
					required
					@input=${this._onInput}
					@focus=${this._onFocus}
					@blur=${this._onBlur}
				/>
				<button class="search__submit" type="submit">
					<div aria-hidden="true" class="search__icon">${oo(zb)}</div>
					<span class="visually-hidden">${this.submitLabel}</span>
				</button>
				${e}
			</div>
		`;
  }
  deactiveTemplate() {
    return this.isStaticMode && !this.isMobile ? null : be`<button
			@click=${this._activate}
			aria-label=${this.activateSearchLabel || "Open Search"}
			title=${this.activateSearchLabel || "Open Search"}
			class="search-button"
		>
			<span aria-hidden="true" class="icon-wrapper">${oo(zb)}</span>
		</button>`;
  }
  cancelBtnTemplate() {
    return this.isStaticMode ? this.isMobile && this.opened ? be`<button @click="${this._deactivate}" class="close-button cancel-button" type="reset">
					${this.cancelLabel}
				</button>` : null : this.opened ? be`<button @click="${this._deactivate}" class="close-button cancel-button" type="reset">
				${this.cancelLabel}
			</button>` : null;
  }
  get isStaticMode() {
    return this.mode === "static";
  }
  _setOpenedFlag(e) {
    this.opened = e, this.opened ? this.setAttribute("opened", "") : this.removeAttribute("opened");
  }
  /* ************** */
  /* Event handlers */
  /* ************** */
  _toggleActive(e) {
    this._prestine = !1, this._setOpenedFlag(!this.opened), this.dispatchEvent(
      new CustomEvent(ir.SEARCH_ACTIVATED, {
        detail: { activated: this.opened },
        bubbles: !0,
        composed: !0
      })
    );
  }
  _activate(e) {
    this._prestine = !1, this._setOpenedFlag(!0), this.dispatchEvent(
      new CustomEvent(ir.SEARCH_ACTIVATED, {
        detail: { activated: !0 },
        bubbles: !0,
        composed: !0
      })
    );
  }
  _deactivate(e) {
    this.isStaticMode && !this.isMobile || (this._prestine = !1, this._setOpenedFlag(!1), this.dispatchEvent(
      new CustomEvent(ir.SEARCH_ACTIVATED, {
        detail: { activated: !1 },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _submit(e) {
    e.stopPropagation(), e.preventDefault(), (this.opened || this.isStaticMode) && (e.preventDefault(), e.stopPropagation(), this._onSearch(e));
  }
  _keypress(e) {
    if (this.opened || this.isStaticMode)
      switch (e.key) {
        case "Escape": {
          e.preventDefault(), e.stopPropagation(), this._deactivate();
          break;
        }
        default: {
          e.stopPropagation();
          const t = e.target;
          if (!t)
            return;
          setTimeout(() => {
            this.dispatchEvent(
              new CustomEvent(ir.SEARCH_KEYDOWN, {
                detail: { originalEvent: e, value: t?.value ?? "" },
                bubbles: !0,
                composed: !0
              })
            );
          }, 0);
        }
      }
  }
  _onSearch(e) {
    if (this._inputElement) {
      const t = this._inputElement.value;
      t.length > 0 && (setTimeout(() => {
        this.dispatchEvent(
          new CustomEvent(ir.SEARCH, {
            detail: { originalEvent: e, value: t },
            bubbles: !0,
            composed: !0
          })
        );
      }, 0), this._deactivate());
    }
  }
  _onInput(e) {
    const t = e.target;
    t && setTimeout(() => {
      this.dispatchEvent(
        new CustomEvent(ir.SEARCH_INPUT, {
          detail: { originalEvent: e, value: t?.value ?? "" },
          bubbles: !0,
          composed: !0
        })
      );
    }, 0);
  }
  _onFocus(e) {
    this.isStaticMode && !this.isMobile && this.dispatchEvent(
      new CustomEvent(ir.SEARCH_ACTIVATED, {
        detail: { activated: !0 },
        bubbles: !0,
        composed: !0
      })
    ), this.dispatchEvent(
      new CustomEvent(ir.SEARCH_INPUT_FOCUSED, {
        detail: { focus: !0, originalEvent: e },
        bubbles: !0,
        composed: !0
      })
    );
  }
  _onBlur(e) {
    this.isStaticMode && !this.isMobile && this.dispatchEvent(
      new CustomEvent(ir.SEARCH_ACTIVATED, {
        detail: { activated: !1 },
        bubbles: !0,
        composed: !0
      })
    ), this.dispatchEvent(
      new CustomEvent(ir.SEARCH_INPUT_BLURED, {
        detail: { blur: !0, originalEvent: e },
        bubbles: !0,
        composed: !0
      })
    );
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener(ir.SEARCH_SET_INPUT_VALUE, this.handleEvent), document.addEventListener(ir.SEARCH_SET_INPUT_STATE, this.handleEvent), document.addEventListener(ir.SEARCH_CLEAR_INPUT_VALUE, this.handleEvent);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener(ir.SEARCH_SET_INPUT_VALUE, this.handleEvent), document.removeEventListener(ir.SEARCH_SET_INPUT_STATE, this.handleEvent), document.removeEventListener(ir.SEARCH_CLEAR_INPUT_VALUE, this.handleEvent);
  }
};
$r.styles = Ut`
		${Nt(dbe)}
	`;
en([
  ge()
], $r.prototype, "activateSearchLabel", 2);
en([
  ge()
], $r.prototype, "deactivateSearchLabel", 2);
en([
  ge()
], $r.prototype, "inputLabel", 2);
en([
  ge()
], $r.prototype, "placeholderLabel", 2);
en([
  ge()
], $r.prototype, "submitLabel", 2);
en([
  ge()
], $r.prototype, "cancelLabel", 2);
en([
  ge({ type: String, attribute: !0, reflect: !0, converter: mbe })
], $r.prototype, "mode", 2);
en([
  ge({ type: Boolean })
], $r.prototype, "opened", 2);
en([
  ge({ type: Boolean })
], $r.prototype, "isMobile", 2);
en([
  ge({ type: String })
], $r.prototype, "initSearchValue", 2);
en([
  mA()
], $r.prototype, "_prestine", 2);
en([
  Mge("#search")
], $r.prototype, "_inputElement", 2);
$r = en([
  gr("epic-wf-search-box")
], $r);
const ybe = ":host{align-items:flex-start;box-sizing:border-box;display:flex;flex-direction:column;color-scheme:var(--eg-global-nav-color-scheme, dark)}@media (min-width: 720px){:host{box-shadow:0 32px 16px #0000001a,0 16px 8px #0000001a,0 8px 4px #0000001a,0 4px 2px #0000001a,0 2px 1px #0000001a;background:var(--color-background-transparent-menu, rgba(48, 48, 52, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));border-radius:var(--size-border-radius-16, 16px);border:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1));align-items:stretch;min-width:10rem;padding-block:.5rem;padding-inline:.5rem;max-height:min(100vh - var(--eg-global-nav-height, 4.5rem),45rem);overflow:hidden}}", gbe = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{color:var(--color-text-primary, white);max-width:100%}:host .menu-item{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));width:100%;display:flex;align-items:center;gap:1rem}:host .menu-item>*{pointer-events:none}:host .menu-item:not([disabled]){cursor:pointer}:host .menu-item:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){:host .menu-item{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){:host .menu-item{--link-inline-padding-fallback: .75rem}}:host .menu-item .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){:host .menu-item .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}:host .menu-item:hover,:host .menu-item.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}:host .menu-item:focus-visible{border-radius:.875rem}@media (min-width: 720px){:host .menu-item.parent:hover,:host .menu-item.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}:host .menu-item.no-hover:hover{cursor:default;background-color:transparent}:host .menu-item__content{display:flex;align-items:center;gap:.5rem;max-width:100%;flex-grow:1}:host .menu-item.center :host .menu-item__content,:host .menu-item.center .label{width:100%;justify-content:center}:host .menu-item.icon-space .label{margin-inline-start:1.75rem}:host .menu-item .label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:start}:host .menu-item epic-wf-eds-icon{flex-shrink:0;width:1.25rem}";
var bbe = Object.defineProperty, vbe = Object.getOwnPropertyDescriptor, An = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? vbe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && bbe(t, r, o), o;
};
let Rr = class extends fr {
  constructor() {
    super(...arguments), this.startIcon = "", this.startIconColor = "", this.startIconPadding = 0, this.noInteraction = !1, this.iconSpace = !1, this.endIcon = "", this.endIconColor = "", this._labelStyle = "", this._labelAfterStyle = "", this._labelBeforeStyle = "", this.centerLabel = !1;
  }
  get labelStyle() {
    return this._labelStyle;
  }
  set labelStyle(e) {
    const t = Wb(e), r = this._labelStyle;
    this._labelStyle = t, this.requestUpdate("labelStyle", r);
  }
  get labelAfterStyle() {
    return this._labelAfterStyle;
  }
  set labelAfterStyle(e) {
    const t = Wb(e), r = this._labelAfterStyle;
    this._labelAfterStyle = t, this.requestUpdate("labelAfterStyle", r);
  }
  get labelBeforeStyle() {
    return this._labelBeforeStyle;
  }
  set labelBeforeStyle(e) {
    const t = Wb(e), r = this._labelBeforeStyle;
    this._labelBeforeStyle = t, this.requestUpdate("labelBeforeStyle", r);
  }
  render() {
    const e = fo({
      domain: this.domain,
      hrefTemplate: this.hrefTemplate,
      locale: this.locale
    });
    let t;
    this.startIcon && (t = be`<epic-wf-eds-icon
				icon=${this.startIcon || ""}
				accentColor=${this.startIconColor || ""}
				style="padding: ${this.startIconPadding || 0}px;"
			></epic-wf-eds-icon>`);
    let r;
    this.endIcon && (r = be`<epic-wf-eds-icon
				icon=${this.endIcon || ""}
				textColor=${this.endIconColor || ""}
			></epic-wf-eds-icon>`);
    const n = be`
			${Ar(this.labelStyle) ? be`
						<style>
							.menu-item span.label {${this.labelStyle};}
						</style>
					` : void 0}
			${Ar(this.labelBeforeStyle) ? be`
						<style>
							.menu-item .label::before {${this.labelBeforeStyle};}
						</style>
					` : void 0}
			${Ar(this.labelAfterStyle) ? be`
						<style>
							.menu-item .label::after {${this.labelAfterStyle};}
						</style>
					` : void 0}
			<div class="menu-item__content">
				${Ar(t)}
				<slot name="pre-label"></slot>
				<span class="label">${this.label}</span>
				<slot name="post-label"></slot>
				${Ar(r)}
			</div>
		`, o = this.noInteraction ? "no-hover" : "", a = this.centerLabel ? "center" : "", i = !this.startIcon && this.iconSpace ? "icon-space" : "", s = `${o} ${a} ${i}`;
    return e ? be`<a class="menu-item ${s}" href="${e}">${n}</a> ` : this.noInteraction ? be`<span class="menu-item ${s}">${n}</span> ` : be` <button class="menu-item ${s}">${n}</button> `;
  }
};
Rr.styles = Ut`
		${Nt(gbe)}
	`;
An([
  ge()
], Rr.prototype, "startIcon", 2);
An([
  ge()
], Rr.prototype, "startIconColor", 2);
An([
  ge({ type: Number, converter: Zre })
], Rr.prototype, "startIconPadding", 2);
An([
  ge({ type: Boolean, converter: Cr })
], Rr.prototype, "noInteraction", 2);
An([
  ge({ type: Boolean, converter: Cr })
], Rr.prototype, "iconSpace", 2);
An([
  ge()
], Rr.prototype, "endIcon", 2);
An([
  ge()
], Rr.prototype, "endIconColor", 2);
An([
  ge()
], Rr.prototype, "labelStyle", 1);
An([
  ge()
], Rr.prototype, "labelAfterStyle", 1);
An([
  ge()
], Rr.prototype, "labelBeforeStyle", 1);
An([
  ge({ type: Boolean, converter: Cr })
], Rr.prototype, "centerLabel", 2);
Rr = An([
  gr("epic-wf-menu-item")
], Rr);
var wbe = Object.defineProperty, _be = Object.getOwnPropertyDescriptor, kJ = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? _be(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && wbe(t, r, o), o;
};
let qh = class extends Rt {
  constructor() {
    super(...arguments), this.links = new Array();
  }
  render() {
    return be` <slot> </slot> `;
  }
};
qh.styles = Ut`
		${Nt(ybe)}
	`;
kJ([
  ge({ type: Array })
], qh.prototype, "links", 2);
qh = kJ([
  gr("epic-wf-simple-menu")
], qh);
const Ebe = ":host{align-items:stretch;box-sizing:border-box;display:flex;flex-direction:column}@media (min-width: 720px){:host{box-shadow:0 32px 16px #0000001a,0 16px 8px #0000001a,0 8px 4px #0000001a,0 4px 2px #0000001a,0 2px 1px #0000001a;background:var(--color-background-transparent-menu, rgba(48, 48, 52, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));border-radius:var(--size-border-radius-16, 16px);border:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1));min-width:16.25rem;max-width:18.75rem}:host ::slotted(*:not(:last-child)){border-bottom:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1))}}@media (max-width: 719.9px){:host ::slotted(epic-wf-menu-section){padding:0;min-width:initial}}";
var xbe = Object.defineProperty, Sbe = Object.getOwnPropertyDescriptor, PJ = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? Sbe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && xbe(t, r, o), o;
};
let Lh = class extends Rt {
  constructor() {
    super(...arguments), this.sections = new Array();
  }
  render() {
    return be` <slot> </slot> `;
  }
};
Lh.styles = Ut`
		${Nt(Ebe)}
	`;
PJ([
  ge({ type: Array })
], Lh.prototype, "sections", 2);
Lh = PJ([
  gr("epic-wf-nav-vertical-menu")
], Lh);
const Tbe = ":host{align-items:stretch;box-sizing:border-box;display:flex;flex-direction:column}@media (min-width: 720px){:host{box-shadow:0 32px 16px #0000001a,0 16px 8px #0000001a,0 8px 4px #0000001a,0 4px 2px #0000001a,0 2px 1px #0000001a;background:var(--color-background-transparent-menu, rgba(48, 48, 52, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));border-radius:var(--size-border-radius-16, 16px);border:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1))}}@media (min-width: 1280px){:host{width:77rem}}@media (max-width: 719.9px){:host{width:100%;gap:2rem}}";
var Abe = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let Z_ = class extends Rt {
  render() {
    return be` <slot></slot> `;
  }
};
Z_.styles = Ut`
		${Nt(Tbe)}
	`;
Z_ = Abe([
  gr("epic-wf-nav-mega-menu")
], Z_);
const $be = ':host{min-width:16rem;box-sizing:border-box;max-height:33rem;display:flex;flex-direction:row}@media (max-width: 959.9px){:host{flex-direction:column;flex-wrap:nowrap}}@media (max-width: 1279.9px){:host{min-width:100%;padding:0rem;max-height:initial;gap:.125rem;flex-wrap:wrap}}@media (min-width: 1280px){:host{max-height:21.5rem}}:host ::slotted(epic-wf-menu-section){box-sizing:border-box;padding:2rem;min-width:19.25rem}@media (max-width: 1439.9px){:host ::slotted(epic-wf-menu-section){padding:.5rem 1.5rem}}@media (max-width: 1279.9px){:host ::slotted(epic-wf-menu-section){padding:.5rem 1rem;min-width:16.25rem}}@media (max-width: 959.9px){:host ::slotted(epic-wf-menu-section){padding:.25rem .5rem;min-width:18.125rem}}@media (max-width: 719.9px){:host ::slotted(epic-wf-menu-section){padding:0;min-width:initial;max-width:100%}}:host ::slotted(epic-wf-menu-section[data-columns="2"]){min-width:20rem}:host ::slotted(epic-wf-menu-section:not(:last-child)){border-right:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1))}@media (min-width: 960px){:host ::slotted(epic-wf-menu-section:not(:last-child)){max-width:20rem}}@media (max-width: 1439.9px){:host ::slotted(epic-wf-menu-section:not(:last-child)){border-right:initial}}:host ::slotted(epic-wf-menu-section.expand){flex:1}';
var Cbe = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let e0 = class extends Rt {
  render() {
    return be` <slot></slot> `;
  }
};
e0.styles = Ut`
		${Nt($be)}
	`;
e0 = Cbe([
  gr("epic-wf-nav-mega-menu-main-section")
], e0);
const kbe = ":host{display:flex;flex-direction:row;padding:2rem;border-top:var(--size-border-width-1, 1px) solid var(--color-border-subdued, rgba(255, 255, 255, .1))}@media (max-width: 1439.9px){:host{padding:.5rem 1.5rem}}@media (max-width: 1279.9px){:host{padding:.5rem 1rem}}@media (max-width: 959.9px){:host{display:none}}@media (max-width: 719.9px){:host{padding:0;flex-direction:column;border-top:initial;display:flex}}:host ::slotted(epic-wf-menu-section){padding:0}";
var Pbe = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let t0 = class extends Rt {
  render() {
    return be` <slot></slot> `;
  }
};
t0.styles = Ut`
		${Nt(kbe)}
	`;
t0 = Pbe([
  gr("epic-wf-nav-mega-menu-news-section")
], t0);
const Obe = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{display:flex;flex-grow:1;min-width:0}::slotted{display:contents}::slotted(.main-nav__list){list-style:none;margin:0;padding:0;align-items:center;display:flex;column-gap:0;flex-grow:1}@media (max-width: 719.9px){::slotted(.main-nav__list){flex-direction:column;align-items:flex-start}}@media (min-width: 720px){::slotted(.main-nav__list){display:flex;max-height:72px;overflow:hidden}}", Rbe = ':host{content:"";display:flex;flex:1;min-width:0;width:0}:host div{display:none;pointer-events:none}';
var jbe = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let r0 = class extends Rt {
  render() {
    return be`<span></span>`;
  }
};
r0.styles = Ut`
		${Nt(Rbe)}
	`;
r0 = jbe([
  gr("epic-wf-nav-main-menu-filler")
], r0);
var Ibe = (e, t, r, n) => {
  for (var o = t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = i(o) || o);
  return o;
};
let n0 = class extends Rt {
  render() {
    return be`<slot name="list"></slot>`;
  }
};
n0.styles = Ut`
		${Nt(Obe)}
	`;
n0 = Ibe([
  gr("epic-wf-nav-main-menu")
], n0);
const Nbe = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{color:var(--color-text-primary, #ffffff);padding:.5rem}:host .heading{font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:120%;letter-spacing:-.005rem;font-size:1.25rem;letter-spacing:-.01875rem;width:100%;height:2.5rem;padding-inline:.5rem;display:flex;align-items:center}:host .heading.eyebrow{font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:100%;text-transform:uppercase;font-size:10px;letter-spacing:1px;color:var(--color-text-secondary, rgba(255, 255, 255, .65))}:host ::slotted(h3){font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:120%;letter-spacing:-.005rem;font-size:1.25rem;letter-spacing:-.01875rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-block:0}:host ::slotted(h4){font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:100%;text-transform:uppercase;font-size:10px;letter-spacing:1px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-block:0}:host ::slotted([slot=content]){display:flex;width:100%;align-content:flex-start;flex-direction:column;box-sizing:border-box}@media (min-width: 720px){:host ::slotted([slot=content].wrap){display:grid;grid-template-columns:repeat(auto-fit,minmax(0,1fr));grid-auto-flow:column;grid-template-rows:repeat(6,auto);width:100%;row-gap:0;column-gap:.5rem}}@media (min-width: 960px) and (max-width: 1279.9px){:host ::slotted([slot=content].wrap){grid-template-rows:repeat(10,auto)}}@media (max-width: 719.9px){:host ::slotted([slot=content].wrap){max-height:initial;flex-wrap:nowrap}}:host ::slotted([slot=content].row){flex-direction:row;column-gap:1rem;padding:.5rem}@media (max-width: 959.9px){:host ::slotted([slot=content].row){flex-direction:column;row-gap:.5rem}}";
var Mbe = Object.defineProperty, Dbe = Object.getOwnPropertyDescriptor, hg = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? Dbe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && Mbe(t, r, o), o;
};
let Zl = class extends Rt {
  constructor() {
    super(...arguments), this.compact = !1, this.eyebrow = !1, this.headingDisabled = !1;
  }
  render() {
    const e = this.eyebrow ? "eyebrow" : "", t = be`<div class="heading ${e}">
			<slot name="heading"></slot>
		</div>`;
    return be`
			<section>
				${this.headingDisabled ? be`` : t}
				<slot name="content"></slot>
			</section>
		`;
  }
};
Zl.styles = Ut`
		${Nt(Nbe)}
	`;
hg([
  ge({ type: Boolean, converter: Cr })
], Zl.prototype, "compact", 2);
hg([
  ge({ type: Boolean, converter: Cr })
], Zl.prototype, "eyebrow", 2);
hg([
  ge({ type: Boolean, converter: Cr })
], Zl.prototype, "headingDisabled", 2);
Zl = hg([
  gr("epic-wf-menu-section")
], Zl);
var Pn = /* @__PURE__ */ ((e) => (e.LTR = "ltr", e.RTL = "rtl", e))(Pn || {});
const jt = ({ hrefTemplate: e = "", domain: t = "", locale: r = "" }) => {
  if (!e)
    return "";
  const n = r?.replace(/_/g, "-");
  let o = e;
  return t ? o = o.replace(/({|%7B)domain(}|%7D)/gi, t || "") : o = o.replace(/\/?({|%7B)domain(}|%7D)/gi, t || ""), n ? o = o.replace(/({|%7B)locale(}|%7D)/gi, n || "") : o = o.replace(/\/?({|%7B)locale(}|%7D)/gi, n || ""), o;
};
var Fh = { NODE_ENV: "production" };
const Qi = (e) => e?.pointerType === "touch", da = (e, t) => !!(e && e === "true"), xr = (e) => {
  if (e && typeof e == "string")
    try {
      return JSON.parse(e);
    } catch {
      console.warn("jsonConverter could not parse", e);
    }
  return e;
}, gA = (e) => e && typeof e == "string" ? +e : e, qbe = ["ar", "ar-ar", "ar-AR"], UR = (e) => !e || typeof e != "string" ? !1 : qbe.includes(e);
var iu = {}, Dr = {}, BR;
function Lbe() {
  if (BR) return Dr;
  BR = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.pickupWithVariantKey = Dr.extractVariantKeys = Dr.mergeScreenshotOptions = Dr.createBaseScreenshotOptions = Dr.expandViewportsOption = void 0;
  const e = {
    waitAssets: !0,
    waitImages: !1,
    waitFor: "",
    fullPage: !0,
    skip: !1,
    focus: "",
    hover: "",
    click: "",
    variants: {},
    omitBackground: !1,
    captureBeyondViewport: !0,
    clip: null,
    forwardConsoleLogs: !1,
    trace: !1
  };
  function t(i) {
    if (!i.viewports)
      return i;
    const { viewports: s } = i, d = { ...i };
    delete d.viewports;
    const l = Array.isArray(s) ? s : Object.keys(s);
    if (!l.length)
      return i;
    const p = (h) => Array.isArray(s) ? h : s[h], f = { ...i.variants };
    return l.slice(1).forEach((h) => f[h] = { viewport: p(h) }), d.viewport = p(l[0]), d.variants = f, l.length > 1 && (d.defaultVariantSuffix = l[0]), d;
  }
  Dr.expandViewportsOption = t;
  function r({ delay: i, disableWaitAssets: s, viewports: d }) {
    return d.length > 1 ? {
      ...e,
      delay: i,
      waitAssets: !s,
      viewport: d[0],
      variants: d.slice(1).reduce((l, p) => ({ ...l, [p]: { viewport: p } }), {}),
      defaultVariantSuffix: d[0]
    } : {
      ...e,
      delay: i,
      waitAssets: !s,
      viewport: d[0],
      defaultVariantSuffix: ""
    };
  }
  Dr.createBaseScreenshotOptions = r;
  function n(i, s) {
    const d = Object.assign({}, i, s);
    return !i.viewport || typeof i.viewport == "string" ? s.viewport && (d.viewport = s.viewport) : s.viewport && (typeof s.viewport == "object" ? d.viewport = {
      ...i.viewport,
      ...s.viewport
    } : d.viewport = s.viewport), i.variants && (d.variants = n(i.variants, s.variants || {})), d;
  }
  Dr.mergeScreenshotOptions = n;
  function o({ variants: i, defaultVariantSuffix: s }) {
    if (!i)
      return [null, []];
    let d;
    const l = Object.keys(i).reduce((p, f) => {
      const h = [], m = (g, w = []) => {
        if (s && s === g)
          return h.push([g, ...w]), !0;
        if (!i[g])
          return d = {
            type: "notFound",
            from: w[0],
            to: g
          }, !1;
        if (w.find((x) => x === g))
          return d = {
            type: "circular",
            refs: [g, ...w]
          }, !1;
        const _ = i[g].extends, b = Array.isArray(_) ? _ : typeof _ == "string" ? [_] : [];
        return b.length ? b.every((x) => m(x, [g, ...w])) : (h.push([g, ...w]), !0);
      };
      return m(f), [...p, ...h.map((g) => ({ isDefault: !1, keys: g }))];
    }, []);
    return d ? [d, []] : [null, l];
  }
  Dr.extractVariantKeys = o;
  function a(i, s) {
    if (s.isDefault)
      return i;
    const d = Object.assign({}, i), l = d.variants || {};
    delete d.variants;
    const p = s.keys[0] && s.keys[0] === i.defaultVariantSuffix ? 1 : 0;
    return s.keys.slice(p).reduce((f, h) => n(f, l[h]), d);
  }
  return Dr.pickupWithVariantKey = a, Dr;
}
var HR;
function Fbe() {
  if (HR) return iu;
  HR = 1, Object.defineProperty(iu, "__esModule", { value: !0 }), iu.triggerScreenshot = void 0;
  const e = /* @__PURE__ */ Lbe();
  function t(f) {
    const h = window;
    if (h.emitCapture)
      return f(h);
  }
  function r(f) {
    const { searchParams: h } = new URL(f), m = h.get("id"), g = h.get("selectedKind"), w = h.get("selectedStory");
    if (m)
      return m;
    if (g && w)
      return `${g}/${w}`;
    throw new Error();
  }
  function n(f = 0) {
    return new Promise((h) => setTimeout(h, f));
  }
  function o(f) {
    if (!f)
      return Promise.resolve();
    if (typeof f == "string") {
      const h = window[f];
      return typeof h != "function" ? Promise.resolve() : Promise.resolve().then(() => h());
    } else return typeof f == "function" ? f() : Promise.resolve();
  }
  function a(f) {
    return new Promise((h) => f.requestIdleCallback(h, { timeout: 3e3 }));
  }
  function i(f, h, m) {
    h && (f.optionStore || (f.optionStore = {}), f.optionStore[h] || (f.optionStore[h] = []), f.optionStore[h].push(m));
  }
  function s(f, h) {
    if (!f.optionStore || !f.optionStore[h])
      return null;
    const m = f.optionStore[h];
    return delete f.optionStore[h], m;
  }
  function d(f = {}, h) {
    let m;
    h && h.id ? m = h.id : h && h.story && h.kind ? m = h.kind + "/" + h.story : m = r(location.href), t((g) => i(g, m, f));
  }
  function l() {
    t(async (f) => {
      await f.waitBrowserMetricsStable();
      const [h, m] = await Promise.all([
        f.getBaseScreenshotOptions(),
        // Options set via CLI
        f.getCurrentVariantKey()
        // Variant key for this capturing process
      ]), g = r(location.href), w = s(f, g);
      if (!w)
        return;
      const _ = w.reduce((x, P) => (0, e.mergeScreenshotOptions)(x, (0, e.expandViewportsOption)(P)), h), b = (0, e.pickupWithVariantKey)(_, m);
      if (b.skip)
        return f.emitCapture(b, g);
      await n(b.delay), await o(b.waitFor), await a(f), await f.emitCapture(b, g);
    });
  }
  function p(f, h) {
    d(f, h), Promise.resolve().then(l);
  }
  return iu.triggerScreenshot = p, iu;
}
var Ube = Fbe(), Bbe = Object.create, mg = Object.defineProperty, Hbe = Object.getOwnPropertyDescriptor, OJ = Object.getOwnPropertyNames, Vbe = Object.getPrototypeOf, zbe = Object.prototype.hasOwnProperty, u = (e, t) => mg(e, "name", { value: t, configurable: !0 }), Gp = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
}), G = (e, t) => function() {
  return t || (0, e[OJ(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, vp = (e, t) => {
  for (var r in t)
    mg(e, r, { get: t[r], enumerable: !0 });
}, Jbe = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of OJ(t))
      !zbe.call(e, o) && o !== r && mg(e, o, { get: () => t[o], enumerable: !(n = Hbe(t, o)) || n.enumerable });
  return e;
}, ar = (e, t, r) => (r = e != null ? Bbe(Vbe(e)) : {}, Jbe(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? mg(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), Wbe = 5e3;
function bA() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
u(bA, "isTestEnvironment");
function vA(e = !0) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  const t = document.createElement("style");
  t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(t);
  const r = document.createElement("style");
  return r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(r), document.body.clientHeight, document.head.removeChild(t), () => {
    r.parentNode?.removeChild(r);
  };
}
u(vA, "pauseAnimations");
async function wA(e) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let t = !1;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((r) => {
      setTimeout(() => {
        const n = [globalThis.document, ..._A(globalThis.document)], o = /* @__PURE__ */ u(async () => {
          if (t || e?.aborted)
            return;
          const a = n.flatMap((i) => i?.getAnimations?.() || []).filter((i) => i.playState === "running" && !RJ(i));
          a.length > 0 && (await Promise.all(a.map((i) => i.finished)), await o());
        }, "checkAnimationsFinished");
        o().then(r);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (r) => setTimeout(() => {
        t = !0, r(void 0);
      }, Wbe)
    )
  ]);
}
u(wA, "waitForAnimations");
function _A(e) {
  return [e, ...e.querySelectorAll("*")].reduce((t, r) => ("shadowRoot" in r && r.shadowRoot && t.push(r.shadowRoot, ..._A(r.shadowRoot)), t), []);
}
u(_A, "getShadowRoots");
function RJ(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    const t = getComputedStyle(e.effect.target, e.effect.pseudoElement), r = t.animationName?.split(", ").indexOf(e.animationName);
    return t.animationIterationCount.split(", ")[r] === "infinite";
  }
  return !1;
}
u(RJ, "isInfiniteAnimation");
var jJ = G({
  "../node_modules/picoquery/lib/string-util.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeString = n;
    var t = Array.from({ length: 256 }, (o, a) => "%" + ((a < 16 ? "0" : "") + a.toString(16)).toUpperCase()), r = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function n(o) {
      const a = o.length;
      if (a === 0)
        return "";
      let i = "", s = 0, d = 0;
      e: for (; d < a; d++) {
        let l = o.charCodeAt(d);
        for (; l < 128; ) {
          if (r[l] !== 1 && (s < d && (i += o.slice(s, d)), s = d + 1, i += t[l]), ++d === a)
            break e;
          l = o.charCodeAt(d);
        }
        if (s < d && (i += o.slice(s, d)), l < 2048) {
          s = d + 1, i += t[192 | l >> 6] + t[128 | l & 63];
          continue;
        }
        if (l < 55296 || l >= 57344) {
          s = d + 1, i += t[224 | l >> 12] + t[128 | l >> 6 & 63] + t[128 | l & 63];
          continue;
        }
        if (++d, d >= a)
          throw new Error("URI malformed");
        const p = o.charCodeAt(d) & 1023;
        s = d + 1, l = 65536 + ((l & 1023) << 10 | p), i += t[240 | l >> 18] + t[128 | l >> 12 & 63] + t[128 | l >> 6 & 63] + t[128 | l & 63];
      }
      return s === 0 ? o : s < a ? i + o.slice(s) : i;
    }
    u(n, "encodeString");
  }
}), EA = G({
  "../node_modules/picoquery/lib/shared.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0;
    var t = jJ(), r = /* @__PURE__ */ u((a) => {
      switch (typeof a) {
        case "string":
          return (0, t.encodeString)(a);
        case "bigint":
        case "boolean":
          return "" + a;
        case "number":
          if (Number.isFinite(a))
            return a < 1e21 ? "" + a : (0, t.encodeString)("" + a);
          break;
      }
      return a instanceof Date ? (0, t.encodeString)(a.toISOString()) : "";
    }, "defaultValueSerializer");
    e.defaultValueSerializer = r;
    var n = /* @__PURE__ */ u((a) => a instanceof Date, "defaultShouldSerializeObject");
    e.defaultShouldSerializeObject = n;
    var o = /* @__PURE__ */ u((a) => a, "identityFunc");
    e.defaultOptions = {
      nesting: !0,
      nestingSyntax: "dot",
      arrayRepeat: !1,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: o,
      valueSerializer: e.defaultValueSerializer,
      keyDeserializer: o,
      shouldSerializeObject: e.defaultShouldSerializeObject
    };
  }
}), IJ = G({
  "../node_modules/picoquery/lib/object-util.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getDeepObject = o, e.stringifyObject = p;
    var t = EA(), r = jJ();
    function n(f) {
      return f === "__proto__" || f === "constructor" || f === "prototype";
    }
    u(n, "isPrototypeKey");
    function o(f, h, m, g, w) {
      if (n(h))
        return f;
      const _ = f[h];
      return typeof _ == "object" && _ !== null ? _ : !g && (w || typeof m == "number" || typeof m == "string" && m * 0 === 0 && m.indexOf(".") === -1) ? f[h] = [] : f[h] = {};
    }
    u(o, "getDeepObject");
    var a = 20, i = "[]", s = "[", d = "]", l = ".";
    function p(f, h, m = 0, g, w) {
      const { nestingSyntax: _ = t.defaultOptions.nestingSyntax, arrayRepeat: b = t.defaultOptions.arrayRepeat, arrayRepeatSyntax: x = t.defaultOptions.arrayRepeatSyntax, nesting: P = t.defaultOptions.nesting, delimiter: R = t.defaultOptions.delimiter, valueSerializer: N = t.defaultOptions.valueSerializer, shouldSerializeObject: C = t.defaultOptions.shouldSerializeObject } = h, A = typeof R == "number" ? String.fromCharCode(R) : R, E = w === !0 && b, T = _ === "dot" || _ === "js" && !w;
      if (m > a)
        return "";
      let O = "", k = !0, M = !1;
      for (const L in f) {
        const $ = f[L];
        if ($ === void 0)
          continue;
        let I;
        g ? (I = g, E ? x === "bracket" && (I += i) : T ? (I += l, I += L) : (I += s, I += L, I += d)) : I = L, k || (O += A), typeof $ == "object" && $ !== null && !C($) ? (M = $.pop !== void 0, (P || b && M) && (O += p($, h, m + 1, I, M))) : (O += (0, r.encodeString)(I), O += "=", O += N($, L)), k && (k = !1);
      }
      return O;
    }
    u(p, "stringifyObject");
  }
}), Gbe = G({
  "../node_modules/picoquery/lib/decode-uri-component.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeURIComponent = o;
    var t = 12, r = 0, n = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function o(s) {
      let d = s.indexOf("%");
      if (d === -1)
        return s;
      const l = s.length;
      let p = "", f = 0, h = 0, m = d, g = t;
      for (; d > -1 && d < l; ) {
        const w = i(s[d + 1], 4), _ = i(s[d + 2], 0), b = w | _, x = n[b];
        if (g = n[256 + g + x], h = h << 6 | b & n[364 + x], g === t)
          p += s.slice(f, m), p += h <= 65535 ? String.fromCharCode(h) : String.fromCharCode(55232 + (h >> 10), 56320 + (h & 1023)), h = 0, f = d + 3, d = m = s.indexOf("%", f);
        else {
          if (g === r)
            return null;
          if (d += 3, d < l && s.charCodeAt(d) === 37)
            continue;
          return null;
        }
      }
      return p + s.slice(f);
    }
    u(o, "decodeURIComponent");
    var a = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function i(s, d) {
      const l = a[s];
      return l === void 0 ? 255 : l << d;
    }
    u(i, "hexCodeToInt");
  }
}), Kbe = G({
  "../node_modules/picoquery/lib/parse.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.numberValueDeserializer = e.numberKeyDeserializer = void 0, e.parse = l;
    var t = IJ(), r = EA(), n = Gbe(), o = /* @__PURE__ */ u((p) => {
      const f = Number(p);
      return Number.isNaN(f) ? p : f;
    }, "numberKeyDeserializer");
    e.numberKeyDeserializer = o;
    var a = /* @__PURE__ */ u((p) => {
      const f = Number(p);
      return Number.isNaN(f) ? p : f;
    }, "numberValueDeserializer");
    e.numberValueDeserializer = a;
    var i = /\+/g, s = /* @__PURE__ */ u(function() {
    }, "Empty");
    s.prototype = /* @__PURE__ */ Object.create(null);
    function d(p, f, h, m, g) {
      let w = p.substring(f, h);
      return m && (w = w.replace(i, " ")), g && (w = (0, n.decodeURIComponent)(w) || w), w;
    }
    u(d, "computeKeySlice");
    function l(p, f) {
      const { valueDeserializer: h = r.defaultOptions.valueDeserializer, keyDeserializer: m = r.defaultOptions.keyDeserializer, arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax, nesting: w = r.defaultOptions.nesting, arrayRepeat: _ = r.defaultOptions.arrayRepeat, nestingSyntax: b = r.defaultOptions.nestingSyntax, delimiter: x = r.defaultOptions.delimiter } = f ?? {}, P = typeof x == "string" ? x.charCodeAt(0) : x, R = b === "js", N = new s();
      if (typeof p != "string")
        return N;
      const C = p.length;
      let A = "", E = -1, T = -1, O = -1, k = N, M, L = "", $ = "", I = !1, D = !1, F = !1, J = !1, oe = !1, ce = !1, le = 0, re = -1, we = -1, _e = -1;
      for (let de = 0; de < C + 1; de++) {
        if (le = de !== C ? p.charCodeAt(de) : P, le === P) {
          if (ce = T > E, ce || (T = de), O !== T - 1 && ($ = d(p, O + 1, re > -1 ? re : T, F, I), L = m($), M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, R && oe, void 0))), ce || L !== "") {
            ce && (A = p.slice(T + 1, de), J && (A = A.replace(i, " ")), D && (A = (0, n.decodeURIComponent)(A) || A));
            const ne = h(A, L);
            if (_) {
              const $e = k[L];
              $e === void 0 ? re > -1 ? k[L] = [ne] : k[L] = ne : $e.pop ? $e.push(ne) : k[L] = [$e, ne];
            } else
              k[L] = ne;
          }
          A = "", E = de, T = de, I = !1, D = !1, F = !1, J = !1, oe = !1, re = -1, O = de, k = N, M = void 0, L = "";
        } else le === 93 ? (_ && g === "bracket" && _e === 91 && (re = we), w && (b === "index" || R) && T <= E && (O !== we && ($ = d(p, O + 1, de, F, I), L = m($), M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, void 0, void 0)), M = L, F = !1, I = !1), O = de, oe = !1)) : le === 46 ? w && (b === "dot" || R) && T <= E && (O !== we && ($ = d(p, O + 1, de, F, I), L = m($), M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, R)), M = L, F = !1, I = !1), oe = !0, O = de) : le === 91 ? w && (b === "index" || R) && T <= E && (O !== we && ($ = d(p, O + 1, de, F, I), L = m($), R && M !== void 0 && (k = (0, t.getDeepObject)(k, M, L, R)), M = L, F = !1, I = !1, oe = !1), O = de) : le === 61 ? T <= E ? T = de : D = !0 : le === 43 ? T > E ? J = !0 : F = !0 : le === 37 && (T > E ? D = !0 : I = !0);
        we = de, _e = le;
      }
      return N;
    }
    u(l, "parse");
  }
}), Ybe = G({
  "../node_modules/picoquery/lib/stringify.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringify = r;
    var t = IJ();
    function r(n, o) {
      if (n === null || typeof n != "object")
        return "";
      const a = o ?? {};
      return (0, t.stringifyObject)(n, a);
    }
    u(r, "stringify");
  }
}), xA = G({
  "../node_modules/picoquery/lib/main.js"(e) {
    var t = e && e.__createBinding || (Object.create ? function(a, i, s, d) {
      d === void 0 && (d = s);
      var l = Object.getOwnPropertyDescriptor(i, s);
      (!l || ("get" in l ? !i.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: /* @__PURE__ */ u(function() {
        return i[s];
      }, "get") }), Object.defineProperty(a, d, l);
    } : function(a, i, s, d) {
      d === void 0 && (d = s), a[d] = i[s];
    }), r = e && e.__exportStar || function(a, i) {
      for (var s in a) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, a, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringify = e.parse = void 0;
    var n = Kbe();
    Object.defineProperty(e, "parse", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return n.parse;
    }, "get") });
    var o = Ybe();
    Object.defineProperty(e, "stringify", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return o.stringify;
    }, "get") }), r(EA(), e);
  }
});
function Yr(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null ? Object.prototype.toString.call(e) === "[object Object]" : !1;
}
u(Yr, "isPlainObject");
function NJ(e) {
  return e == null || typeof e != "object" && typeof e != "function";
}
u(NJ, "isPrimitive");
function MJ(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
u(MJ, "isTypedArray");
function Uh(e) {
  return Object.getOwnPropertySymbols(e).filter((t) => Object.prototype.propertyIsEnumerable.call(e, t));
}
u(Uh, "getSymbols");
function Bh(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
u(Bh, "getTag");
var DJ = "[object RegExp]", qJ = "[object String]", LJ = "[object Number]", FJ = "[object Boolean]", o0 = "[object Arguments]", UJ = "[object Symbol]", BJ = "[object Date]", HJ = "[object Map]", VJ = "[object Set]", zJ = "[object Array]", Xbe = "[object Function]", JJ = "[object ArrayBuffer]", vf = "[object Object]", Qbe = "[object Error]", WJ = "[object DataView]", GJ = "[object Uint8Array]", KJ = "[object Uint8ClampedArray]", YJ = "[object Uint16Array]", XJ = "[object Uint32Array]", Zbe = "[object BigUint64Array]", QJ = "[object Int8Array]", ZJ = "[object Int16Array]", e8 = "[object Int32Array]", eve = "[object BigInt64Array]", t8 = "[object Float32Array]", r8 = "[object Float64Array]";
function ec(e, t) {
  const r = {}, n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const a = n[o], i = e[a];
    r[a] = t(i, a, e);
  }
  return r;
}
u(ec, "mapValues");
function SA(e) {
  return e === "__proto__";
}
u(SA, "isUnsafeProperty");
function a0(e) {
  return typeof e == "object" && e !== null;
}
u(a0, "isObjectLike");
function i0(e, t, r) {
  const n = Object.keys(t);
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    if (SA(a))
      continue;
    const i = t[a], s = e[a], d = r(s, i, a, e, t);
    d !== void 0 ? e[a] = d : Array.isArray(i) ? e[a] = i0(s ?? [], i, r) : a0(s) && a0(i) ? e[a] = i0(s ?? {}, i, r) : (s === void 0 || i !== void 0) && (e[a] = i);
  }
  return e;
}
u(i0, "mergeWith");
function tve(e, t) {
  const r = {};
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    Object.hasOwn(e, o) && (r[o] = e[o]);
  }
  return r;
}
u(tve, "pick");
function n8(e, t) {
  const r = {}, n = Object.keys(e);
  for (let o = 0; o < n.length; o++) {
    const a = n[o], i = e[a];
    t(i, a) && (r[a] = i);
  }
  return r;
}
u(n8, "pickBy");
function Bi(e, t, r, n = /* @__PURE__ */ new Map(), o = void 0) {
  const a = o?.(e, t, r, n);
  if (a !== void 0)
    return a;
  if (NJ(e))
    return e;
  if (n.has(e))
    return n.get(e);
  if (Array.isArray(e)) {
    const i = new Array(e.length);
    n.set(e, i);
    for (let s = 0; s < e.length; s++)
      i[s] = Bi(e[s], s, r, n, o);
    return Object.hasOwn(e, "index") && (i.index = e.index), Object.hasOwn(e, "input") && (i.input = e.input), i;
  }
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof RegExp) {
    const i = new RegExp(e.source, e.flags);
    return i.lastIndex = e.lastIndex, i;
  }
  if (e instanceof Map) {
    const i = /* @__PURE__ */ new Map();
    n.set(e, i);
    for (const [s, d] of e)
      i.set(s, Bi(d, s, r, n, o));
    return i;
  }
  if (e instanceof Set) {
    const i = /* @__PURE__ */ new Set();
    n.set(e, i);
    for (const s of e)
      i.add(Bi(s, void 0, r, n, o));
    return i;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(e))
    return e.subarray();
  if (MJ(e)) {
    const i = new (Object.getPrototypeOf(e)).constructor(e.length);
    n.set(e, i);
    for (let s = 0; s < e.length; s++)
      i[s] = Bi(e[s], s, r, n, o);
    return i;
  }
  if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
    return e.slice(0);
  if (e instanceof DataView) {
    const i = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
    return n.set(e, i), el(i, e, r, n, o), i;
  }
  if (typeof File < "u" && e instanceof File) {
    const i = new File([e], e.name, {
      type: e.type
    });
    return n.set(e, i), el(i, e, r, n, o), i;
  }
  if (e instanceof Blob) {
    const i = new Blob([e], { type: e.type });
    return n.set(e, i), el(i, e, r, n, o), i;
  }
  if (e instanceof Error) {
    const i = new e.constructor();
    return n.set(e, i), i.message = e.message, i.name = e.name, i.stack = e.stack, i.cause = e.cause, el(i, e, r, n, o), i;
  }
  if (typeof e == "object" && o8(e)) {
    const i = Object.create(Object.getPrototypeOf(e));
    return n.set(e, i), el(i, e, r, n, o), i;
  }
  return e;
}
u(Bi, "cloneDeepWithImpl");
function el(e, t, r = e, n, o) {
  const a = [...Object.keys(t), ...Uh(t)];
  for (let i = 0; i < a.length; i++) {
    const s = a[i], d = Object.getOwnPropertyDescriptor(e, s);
    (d == null || d.writable) && (e[s] = Bi(t[s], s, r, n, o));
  }
}
u(el, "copyProperties");
function o8(e) {
  switch (Bh(e)) {
    case o0:
    case zJ:
    case JJ:
    case WJ:
    case FJ:
    case BJ:
    case t8:
    case r8:
    case QJ:
    case ZJ:
    case e8:
    case HJ:
    case LJ:
    case vf:
    case DJ:
    case VJ:
    case qJ:
    case UJ:
    case GJ:
    case KJ:
    case YJ:
    case XJ:
      return !0;
    default:
      return !1;
  }
}
u(o8, "isCloneableObject");
function a8(e) {
  return Bi(e, void 0, e, /* @__PURE__ */ new Map(), void 0);
}
u(a8, "cloneDeep");
function dl(e, t) {
  const r = Object.keys(t);
  for (let n = 0; n < r.length; n++) {
    const o = r[n];
    if (SA(o))
      continue;
    const a = t[o], i = e[o];
    Array.isArray(a) ? Array.isArray(i) ? e[o] = dl(i, a) : e[o] = dl([], a) : Yr(a) ? Yr(i) ? e[o] = dl(i, a) : e[o] = dl({}, a) : (i === void 0 || a !== void 0) && (e[o] = a);
  }
  return e;
}
u(dl, "merge");
function rve(e, t) {
  return dl(a8(e), t);
}
u(rve, "toMerged");
function s0({
  code: e,
  category: t
}) {
  const r = String(e).padStart(4, "0");
  return `SB_${t}_${r}`;
}
u(s0, "parseErrorCode");
function l0(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e))
    return e;
  try {
    const t = new URL(e);
    return t.searchParams.set("ref", "error"), t.toString();
  } catch {
    return e;
  }
}
u(l0, "appendErrorRef");
var i8 = class s8 extends Error {
  constructor(t) {
    super(s8.getFullMessage(t)), this.data = {}, this.fromStorybook = !0, this.category = t.category, this.documentation = t.documentation ?? !1, this.code = t.code;
  }
  get fullErrorCode() {
    return s0({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    const t = this.constructor.name;
    return `${this.fullErrorCode} (${t})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: t,
    code: r,
    category: n,
    message: o
  }) {
    let a;
    return t === !0 ? a = `https://storybook.js.org/error/${s0({ code: r, category: n })}?ref=error` : typeof t == "string" ? a = l0(t) : Array.isArray(t) && (a = `
${t.map((i) => `	- ${l0(i)}`).join(`
`)}`), `${o}${a != null ? `

More info: ${a}
` : ""}`;
  }
};
u(i8, "StorybookError");
var Bt = i8;
function Be(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  var n = Array.from(typeof e == "string" ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var o = n.reduce(function(s, d) {
    var l = d.match(/\n([\t ]+|(?!\s).)/g);
    return l ? s.concat(l.map(function(p) {
      var f, h;
      return (h = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && h !== void 0 ? h : 0;
    })) : s;
  }, []);
  if (o.length) {
    var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, o) + "}", "g");
    n = n.map(function(s) {
      return s.replace(a, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var i = n[0];
  return t.forEach(function(s, d) {
    var l = i.match(/(?:^|\n)( *)$/), p = l ? l[1] : "", f = s;
    typeof s == "string" && s.includes(`
`) && (f = String(s).split(`
`).map(function(h, m) {
      return m === 0 ? h : "" + p + h;
    }).join(`
`)), i += f + n[d + 1];
  }), i;
}
u(Be, "dedent");
var l8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: Be`
        Couldn't find story matching id '${e.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${e.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    }), this.data = e;
  }
};
u(l8, "MissingStoryAfterHmrError");
var nve = l8, c8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: Be`
        We detected that you use an implicit action arg while ${e.phase} of your story.  
        ${e.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${e.name}: fn()
          }`
    }), this.data = e;
  }
};
u(c8, "ImplicitActionsDuringRendering");
var ove = c8, u8 = class extends Bt {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: Be`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
u(u8, "CalledExtractOnStoreError");
var ave = u8, d8 = class extends Bt {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: Be`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
u(d8, "MissingRenderToCanvasError");
var ive = d8, p8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: Be`
        Called \`Preview.${e.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${e.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    }), this.data = e;
  }
};
u(p8, "CalledPreviewMethodBeforeInitializationError");
var ln = p8, f8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: Be`
        Error fetching \`/index.json\`:
        
        ${e.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    }), this.data = e;
  }
};
u(f8, "StoryIndexFetchError");
var sve = f8, h8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: Be`
        Tried to render docs entry ${e.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    }), this.data = e;
  }
};
u(h8, "MdxFileWithNoCsfReferencesError");
var lve = h8, m8 = class extends Bt {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: Be`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
u(m8, "EmptyIndexError");
var cve = m8, y8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: Be`
        Couldn't find story matching '${e.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    }), this.data = e;
  }
};
u(y8, "NoStoryMatchError");
var uve = y8, g8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: Be`
        Couldn't find story matching id '${e.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    }), this.data = e;
  }
};
u(g8, "MissingStoryFromCsfFileError");
var dve = g8, b8 = class extends Bt {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: Be`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
u(b8, "StoryStoreAccessedBeforeInitializationError");
var pve = b8, v8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: Be`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${e.playFunction}`
    }), this.data = e;
  }
};
u(v8, "MountMustBeDestructuredError");
var w8 = v8, _8 = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: Be`
        No render function available for storyId '${e.id}'
      `
    }), this.data = e;
  }
};
u(_8, "NoRenderFunctionError");
var fve = _8, E8 = class extends Bt {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: Be`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // ðŸ‘ˆ mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
u(E8, "NoStoryMountedError");
var hve = E8, mve = class extends Bt {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${e.status.typeId}" but was added to store with typeId "${e.typeId}". Full status: ${JSON.stringify(
        e.status,
        null,
        2
      )}`
    }), this.data = e;
  }
};
u(mve, "StatusTypeIdMismatchError");
var yve = class extends Bt {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: Be`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
u(yve, "NextJsSharpError");
var gve = class extends Bt {
  constructor(e) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: Be`
        Tried to access router mocks from "${e.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    }), this.data = e;
  }
};
u(gve, "NextjsRouterMocksNotAvailable");
var bve = class extends Bt {
  constructor(e) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: Be`
        There was a failure when generating detailed ArgTypes in ${e.language} for:
        ${JSON.stringify(e.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    }), this.data = e;
  }
};
u(bve, "UnknownArgTypesError");
var vve = class extends Bt {
  constructor(e) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: Be`
        Encountered an unsupported value "${e.value}" when setting the viewport ${e.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    }), this.data = e;
  }
};
u(vve, "UnsupportedViewportDimensionError");
var wve = class extends Bt {
  constructor() {
    super({
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
u(wve, "ElementA11yParameterError");
var _ve = G({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(e, t) {
    (function(r, n) {
      typeof e == "object" && typeof t < "u" ? n(e) : typeof define == "function" && define.amd ? define(["exports"], n) : (r = typeof globalThis < "u" ? globalThis : r || self, n(r.jtpp = {}));
    })(e, function(r) {
      function n(y) {
        return y.text !== void 0 && y.text !== "" ? `'${y.type}' with value '${y.text}'` : `'${y.type}'`;
      }
      u(n, "tokenToString");
      const o = class x8 extends Error {
        constructor(S) {
          super(`No parslet found for token: ${n(S)}`), this.token = S, Object.setPrototypeOf(this, x8.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      u(o, "NoParsletFoundError");
      let a = o;
      const i = class S8 extends Error {
        constructor(S) {
          super(`The parsing ended early. The next token was: ${n(S)}`), this.token = S, Object.setPrototypeOf(this, S8.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      u(i, "EarlyEndOfParseError");
      let s = i;
      const d = class T8 extends Error {
        constructor(S, j) {
          let U = `Unexpected type: '${S.type}'.`;
          j !== void 0 && (U += ` Message: ${j}`), super(U), Object.setPrototypeOf(this, T8.prototype);
        }
      };
      u(d, "UnexpectedTypeError");
      let l = d;
      function p(y) {
        return (S) => S.startsWith(y) ? { type: y, text: y } : null;
      }
      u(p, "makePunctuationRule");
      function f(y) {
        let S = 0, j;
        const U = y[0];
        let Q = !1;
        if (U !== "'" && U !== '"')
          return null;
        for (; S < y.length; ) {
          if (S++, j = y[S], !Q && j === U) {
            S++;
            break;
          }
          Q = !Q && j === "\\";
        }
        if (j !== U)
          throw new Error("Unterminated String");
        return y.slice(0, S);
      }
      u(f, "getQuoted");
      const h = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), m = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function g(y) {
        let S = y[0];
        if (!h.test(S))
          return null;
        let j = 1;
        do {
          if (S = y[j], !m.test(S))
            break;
          j++;
        } while (j < y.length);
        return y.slice(0, j);
      }
      u(g, "getIdentifier");
      const w = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function _(y) {
        var S, j;
        return (j = (S = w.exec(y)) === null || S === void 0 ? void 0 : S[0]) !== null && j !== void 0 ? j : null;
      }
      u(_, "getNumber");
      const b = /* @__PURE__ */ u((y) => {
        const S = g(y);
        return S == null ? null : {
          type: "Identifier",
          text: S
        };
      }, "identifierRule");
      function x(y) {
        return (S) => {
          if (!S.startsWith(y))
            return null;
          const j = S[y.length];
          return j !== void 0 && m.test(j) ? null : {
            type: y,
            text: y
          };
        };
      }
      u(x, "makeKeyWordRule");
      const P = /* @__PURE__ */ u((y) => {
        const S = f(y);
        return S == null ? null : {
          type: "StringValue",
          text: S
        };
      }, "stringValueRule"), R = /* @__PURE__ */ u((y) => y.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, "eofRule"), N = /* @__PURE__ */ u((y) => {
        const S = _(y);
        return S === null ? null : {
          type: "Number",
          text: S
        };
      }, "numberRule"), C = [
        R,
        p("=>"),
        p("("),
        p(")"),
        p("{"),
        p("}"),
        p("["),
        p("]"),
        p("|"),
        p("&"),
        p("<"),
        p(">"),
        p(","),
        p(";"),
        p("*"),
        p("?"),
        p("!"),
        p("="),
        p(":"),
        p("..."),
        p("."),
        p("#"),
        p("~"),
        p("/"),
        p("@"),
        x("undefined"),
        x("null"),
        x("function"),
        x("this"),
        x("new"),
        x("module"),
        x("event"),
        x("extends"),
        x("external"),
        x("infer"),
        x("typeof"),
        x("keyof"),
        x("readonly"),
        x("import"),
        x("is"),
        x("in"),
        x("asserts"),
        N,
        b,
        P
      ], A = /^\s*\n\s*/, E = class wf {
        static create(S) {
          const j = this.read(S);
          S = j.text;
          const U = this.read(S);
          return S = U.text, new wf(S, void 0, j.token, U.token);
        }
        constructor(S, j, U, Q) {
          this.text = "", this.text = S, this.previous = j, this.current = U, this.next = Q;
        }
        static read(S, j = !1) {
          j = j || A.test(S), S = S.trim();
          for (const U of C) {
            const Q = U(S);
            if (Q !== null) {
              const ie = Object.assign(Object.assign({}, Q), { startOfLine: j });
              return S = S.slice(ie.text.length), { text: S, token: ie };
            }
          }
          throw new Error("Unexpected Token " + S);
        }
        advance() {
          const S = wf.read(this.text);
          return new wf(S.text, this.current, this.next, S.token);
        }
      };
      u(E, "Lexer");
      let T = E;
      function O(y) {
        if (y === void 0)
          throw new Error("Unexpected undefined");
        if (y.type === "JsdocTypeKeyValue" || y.type === "JsdocTypeParameterList" || y.type === "JsdocTypeProperty" || y.type === "JsdocTypeReadonlyProperty" || y.type === "JsdocTypeObjectField" || y.type === "JsdocTypeJsdocObjectField" || y.type === "JsdocTypeIndexSignature" || y.type === "JsdocTypeMappedType" || y.type === "JsdocTypeTypeParameter")
          throw new l(y);
        return y;
      }
      u(O, "assertRootResult");
      function k(y) {
        return y.type === "JsdocTypeKeyValue" ? L(y) : O(y);
      }
      u(k, "assertPlainKeyValueOrRootResult");
      function M(y) {
        return y.type === "JsdocTypeName" ? y : L(y);
      }
      u(M, "assertPlainKeyValueOrNameResult");
      function L(y) {
        if (y.type !== "JsdocTypeKeyValue")
          throw new l(y);
        return y;
      }
      u(L, "assertPlainKeyValueResult");
      function $(y) {
        var S;
        if (y.type === "JsdocTypeVariadic") {
          if (((S = y.element) === null || S === void 0 ? void 0 : S.type) === "JsdocTypeName")
            return y;
          throw new l(y);
        }
        if (y.type !== "JsdocTypeNumber" && y.type !== "JsdocTypeName")
          throw new l(y);
        return y;
      }
      u($, "assertNumberOrVariadicNameResult");
      function I(y) {
        if (y.type === "JsdocTypeTuple" || y.type === "JsdocTypeGeneric" && y.meta.brackets === "square")
          return y;
        throw new l(y);
      }
      u(I, "assertArrayOrTupleResult");
      function D(y) {
        return y.type === "JsdocTypeIndexSignature" || y.type === "JsdocTypeMappedType";
      }
      u(D, "isSquaredProperty");
      var F;
      (function(y) {
        y[y.ALL = 0] = "ALL", y[y.PARAMETER_LIST = 1] = "PARAMETER_LIST", y[y.OBJECT = 2] = "OBJECT", y[y.KEY_VALUE = 3] = "KEY_VALUE", y[y.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", y[y.UNION = 5] = "UNION", y[y.INTERSECTION = 6] = "INTERSECTION", y[y.PREFIX = 7] = "PREFIX", y[y.INFIX = 8] = "INFIX", y[y.TUPLE = 9] = "TUPLE", y[y.SYMBOL = 10] = "SYMBOL", y[y.OPTIONAL = 11] = "OPTIONAL", y[y.NULLABLE = 12] = "NULLABLE", y[y.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", y[y.FUNCTION = 14] = "FUNCTION", y[y.ARROW = 15] = "ARROW", y[y.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", y[y.GENERIC = 17] = "GENERIC", y[y.NAME_PATH = 18] = "NAME_PATH", y[y.PARENTHESIS = 19] = "PARENTHESIS", y[y.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(F || (F = {}));
      const J = class {
        constructor(y, S, j) {
          this.grammar = y, typeof S == "string" ? this._lexer = T.create(S) : this._lexer = S, this.baseParser = j;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          const y = this.parseType(F.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new s(this.lexer.current);
          return y;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(y) {
          return O(this.parseIntermediateType(y));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(y) {
          const S = this.tryParslets(null, y);
          if (S === null)
            throw new a(this.lexer.current);
          return this.parseInfixIntermediateType(S, y);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(y, S) {
          let j = this.tryParslets(y, S);
          for (; j !== null; )
            y = j, j = this.tryParslets(y, S);
          return y;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(y, S) {
          for (const j of this.grammar) {
            const U = j(this, S, y);
            if (U !== null)
              return U;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(y) {
          return Array.isArray(y) || (y = [y]), y.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
        }
        acceptLexerState(y) {
          this._lexer = y.lexer;
        }
      };
      u(J, "Parser");
      let oe = J;
      function ce(y) {
        return y === "}" || y === "EOF" || y === "|" || y === "," || y === ")" || y === ">";
      }
      u(ce, "isQuestionMarkUnknownType");
      const le = /* @__PURE__ */ u((y, S, j) => {
        const U = y.lexer.current.type, Q = y.lexer.next.type;
        return j == null && U === "?" && !ce(Q) || j != null && U === "?" ? (y.consume("?"), j == null ? {
          type: "JsdocTypeNullable",
          element: y.parseType(F.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: O(j),
          meta: {
            position: "suffix"
          }
        }) : null;
      }, "nullableParslet");
      function re(y) {
        const S = /* @__PURE__ */ u((j, U, Q) => {
          const ie = j.lexer.current.type, pe = j.lexer.next.type;
          if (Q === null) {
            if ("parsePrefix" in y && y.accept(ie, pe))
              return y.parsePrefix(j);
          } else if ("parseInfix" in y && y.precedence > U && y.accept(ie, pe))
            return y.parseInfix(j, Q);
          return null;
        }, "parslet");
        return Object.defineProperty(S, "name", {
          value: y.name
        }), S;
      }
      u(re, "composeParslet");
      const we = re({
        name: "optionalParslet",
        accept: /* @__PURE__ */ u((y) => y === "=", "accept"),
        precedence: F.OPTIONAL,
        parsePrefix: /* @__PURE__ */ u((y) => (y.consume("="), {
          type: "JsdocTypeOptional",
          element: y.parseType(F.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }), "parsePrefix"),
        parseInfix: /* @__PURE__ */ u((y, S) => (y.consume("="), {
          type: "JsdocTypeOptional",
          element: O(S),
          meta: {
            position: "suffix"
          }
        }), "parseInfix")
      }), _e = re({
        name: "numberParslet",
        accept: /* @__PURE__ */ u((y) => y === "Number", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          const S = parseFloat(y.lexer.current.text);
          return y.consume("Number"), {
            type: "JsdocTypeNumber",
            value: S
          };
        }, "parsePrefix")
      }), de = re({
        name: "parenthesisParslet",
        accept: /* @__PURE__ */ u((y) => y === "(", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          if (y.consume("("), y.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          const S = y.parseIntermediateType(F.ALL);
          if (!y.consume(")"))
            throw new Error("Unterminated parenthesis");
          return S.type === "JsdocTypeParameterList" ? S : S.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [S]
          } : {
            type: "JsdocTypeParenthesis",
            element: O(S)
          };
        }, "parsePrefix")
      }), ne = re({
        name: "specialTypesParslet",
        accept: /* @__PURE__ */ u((y, S) => y === "?" && ce(S) || y === "null" || y === "undefined" || y === "*", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          if (y.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (y.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (y.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (y.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + y.lexer.current.text);
        }, "parsePrefix")
      }), $e = re({
        name: "notNullableParslet",
        accept: /* @__PURE__ */ u((y) => y === "!", "accept"),
        precedence: F.NULLABLE,
        parsePrefix: /* @__PURE__ */ u((y) => (y.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: y.parseType(F.NULLABLE),
          meta: {
            position: "prefix"
          }
        }), "parsePrefix"),
        parseInfix: /* @__PURE__ */ u((y, S) => (y.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: O(S),
          meta: {
            position: "suffix"
          }
        }), "parseInfix")
      });
      function Se({ allowTrailingComma: y }) {
        return re({
          name: "parameterListParslet",
          accept: /* @__PURE__ */ u((S) => S === ",", "accept"),
          precedence: F.PARAMETER_LIST,
          parseInfix: /* @__PURE__ */ u((S, j) => {
            const U = [
              k(j)
            ];
            S.consume(",");
            do
              try {
                const Q = S.parseIntermediateType(F.PARAMETER_LIST);
                U.push(k(Q));
              } catch (Q) {
                if (Q instanceof a)
                  break;
                throw Q;
              }
            while (S.consume(","));
            if (U.length > 0 && U.slice(0, -1).some((Q) => Q.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements: U
            };
          }, "parseInfix")
        });
      }
      u(Se, "createParameterListParslet");
      const nt = re({
        name: "genericParslet",
        accept: /* @__PURE__ */ u((y, S) => y === "<" || y === "." && S === "<", "accept"),
        precedence: F.GENERIC,
        parseInfix: /* @__PURE__ */ u((y, S) => {
          const j = y.consume(".");
          y.consume("<");
          const U = [];
          let Q = !1;
          if (y.consume("infer")) {
            Q = !0;
            const ie = y.parseIntermediateType(F.SYMBOL);
            if (ie.type !== "JsdocTypeName")
              throw new l(ie, "A typescript asserts always has to have a name on the left side.");
            U.push(ie);
          } else
            do
              U.push(y.parseType(F.PARAMETER_LIST));
            while (y.consume(","));
          if (!y.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: O(S), elements: U }, Q ? { infer: !0 } : {}), { meta: {
            brackets: "angle",
            dot: j
          } });
        }, "parseInfix")
      }), We = re({
        name: "unionParslet",
        accept: /* @__PURE__ */ u((y) => y === "|", "accept"),
        precedence: F.UNION,
        parseInfix: /* @__PURE__ */ u((y, S) => {
          y.consume("|");
          const j = [];
          do
            j.push(y.parseType(F.UNION));
          while (y.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [O(S), ...j]
          };
        }, "parseInfix")
      }), q = [
        le,
        we,
        _e,
        de,
        ne,
        $e,
        Se({
          allowTrailingComma: !0
        }),
        nt,
        We,
        we
      ];
      function te({ allowSquareBracketsOnAnyType: y, allowJsdocNamePaths: S, pathGrammar: j }) {
        return /* @__PURE__ */ u(function(U, Q, ie) {
          if (ie == null || Q >= F.NAME_PATH)
            return null;
          const pe = U.lexer.current.type, Pe = U.lexer.next.type;
          if (!(pe === "." && Pe !== "<" || pe === "[" && (y || ie.type === "JsdocTypeName") || S && (pe === "~" || pe === "#")))
            return null;
          let Oe, Ge = !1;
          U.consume(".") ? Oe = "property" : U.consume("[") ? (Oe = "property-brackets", Ge = !0) : U.consume("~") ? Oe = "inner" : (U.consume("#"), Oe = "instance");
          const Jt = j !== null ? new oe(j, U.lexer, U) : U, xt = Jt.parseIntermediateType(F.NAME_PATH);
          U.acceptLexerState(Jt);
          let kn;
          switch (xt.type) {
            case "JsdocTypeName":
              kn = {
                type: "JsdocTypeProperty",
                value: xt.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              kn = {
                type: "JsdocTypeProperty",
                value: xt.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              kn = {
                type: "JsdocTypeProperty",
                value: xt.value,
                meta: {
                  quote: xt.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (xt.specialType === "event")
                kn = xt;
              else
                throw new l(xt, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new l(xt, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (Ge && !U.consume("]")) {
            const Yc = U.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${Yc.type}' with text '${Yc.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: O(ie),
            right: kn,
            pathType: Oe
          };
        }, "namePathParslet");
      }
      u(te, "createNamePathParslet");
      function ae({ allowedAdditionalTokens: y }) {
        return re({
          name: "nameParslet",
          accept: /* @__PURE__ */ u((S) => S === "Identifier" || S === "this" || S === "new" || y.includes(S), "accept"),
          parsePrefix: /* @__PURE__ */ u((S) => {
            const { type: j, text: U } = S.lexer.current;
            return S.consume(j), {
              type: "JsdocTypeName",
              value: U
            };
          }, "parsePrefix")
        });
      }
      u(ae, "createNameParslet");
      const ue = re({
        name: "stringValueParslet",
        accept: /* @__PURE__ */ u((y) => y === "StringValue", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          const S = y.lexer.current.text;
          return y.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: S.slice(1, -1),
            meta: {
              quote: S[0] === "'" ? "single" : "double"
            }
          };
        }, "parsePrefix")
      });
      function se({ pathGrammar: y, allowedTypes: S }) {
        return re({
          name: "specialNamePathParslet",
          accept: /* @__PURE__ */ u((j) => S.includes(j), "accept"),
          parsePrefix: /* @__PURE__ */ u((j) => {
            const U = j.lexer.current.type;
            if (j.consume(U), !j.consume(":"))
              return {
                type: "JsdocTypeName",
                value: U
              };
            let Q, ie = j.lexer.current;
            if (j.consume("StringValue"))
              Q = {
                type: "JsdocTypeSpecialNamePath",
                value: ie.text.slice(1, -1),
                specialType: U,
                meta: {
                  quote: ie.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let Oe = "";
              const Ge = ["Identifier", "@", "/"];
              for (; Ge.some((Jt) => j.consume(Jt)); )
                Oe += ie.text, ie = j.lexer.current;
              Q = {
                type: "JsdocTypeSpecialNamePath",
                value: Oe,
                specialType: U,
                meta: {
                  quote: void 0
                }
              };
            }
            const pe = new oe(y, j.lexer, j), Pe = pe.parseInfixIntermediateType(Q, F.ALL);
            return j.acceptLexerState(pe), O(Pe);
          }, "parsePrefix")
        });
      }
      u(se, "createSpecialNamePathParslet");
      const ye = [
        ae({
          allowedAdditionalTokens: ["external", "module"]
        }),
        ue,
        _e,
        te({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: null
        })
      ], fe = [
        ...ye,
        se({
          allowedTypes: ["event"],
          pathGrammar: ye
        })
      ];
      function Ae(y) {
        let S;
        if (y.type === "JsdocTypeParameterList")
          S = y.elements;
        else if (y.type === "JsdocTypeParenthesis")
          S = [y.element];
        else
          throw new l(y);
        return S.map((j) => k(j));
      }
      u(Ae, "getParameters");
      function Fe(y) {
        const S = Ae(y);
        if (S.some((j) => j.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return S;
      }
      u(Fe, "getUnnamedParameters");
      function dt({ allowNamedParameters: y, allowNoReturnType: S, allowWithoutParenthesis: j, allowNewAsFunctionKeyword: U }) {
        return re({
          name: "functionParslet",
          accept: /* @__PURE__ */ u((Q, ie) => Q === "function" || U && Q === "new" && ie === "(", "accept"),
          parsePrefix: /* @__PURE__ */ u((Q) => {
            const ie = Q.consume("new");
            Q.consume("function");
            const pe = Q.lexer.current.type === "(";
            if (!pe) {
              if (!j)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let Pe = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: !1,
              constructor: ie,
              parenthesis: pe
            };
            const Oe = Q.parseIntermediateType(F.FUNCTION);
            if (y === void 0)
              Pe.parameters = Fe(Oe);
            else {
              if (ie && Oe.type === "JsdocTypeFunction" && Oe.arrow)
                return Pe = Oe, Pe.constructor = !0, Pe;
              Pe.parameters = Ae(Oe);
              for (const Ge of Pe.parameters)
                if (Ge.type === "JsdocTypeKeyValue" && !y.includes(Ge.key))
                  throw new Error(`only allowed named parameters are ${y.join(", ")} but got ${Ge.type}`);
            }
            if (Q.consume(":"))
              Pe.returnType = Q.parseType(F.PREFIX);
            else if (!S)
              throw new Error("function is missing return type");
            return Pe;
          }, "parsePrefix")
        });
      }
      u(dt, "createFunctionParslet");
      function pt({ allowPostfix: y, allowEnclosingBrackets: S }) {
        return re({
          name: "variadicParslet",
          accept: /* @__PURE__ */ u((j) => j === "...", "accept"),
          precedence: F.PREFIX,
          parsePrefix: /* @__PURE__ */ u((j) => {
            j.consume("...");
            const U = S && j.consume("[");
            try {
              const Q = j.parseType(F.PREFIX);
              if (U && !j.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: O(Q),
                meta: {
                  position: "prefix",
                  squareBrackets: U
                }
              };
            } catch (Q) {
              if (Q instanceof a) {
                if (U)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: !1
                  }
                };
              } else
                throw Q;
            }
          }, "parsePrefix"),
          parseInfix: y ? (j, U) => (j.consume("..."), {
            type: "JsdocTypeVariadic",
            element: O(U),
            meta: {
              position: "suffix",
              squareBrackets: !1
            }
          }) : void 0
        });
      }
      u(pt, "createVariadicParslet");
      const it = re({
        name: "symbolParslet",
        accept: /* @__PURE__ */ u((y) => y === "(", "accept"),
        precedence: F.SYMBOL,
        parseInfix: /* @__PURE__ */ u((y, S) => {
          if (S.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          y.consume("(");
          const j = {
            type: "JsdocTypeSymbol",
            value: S.value
          };
          if (!y.consume(")")) {
            const U = y.parseIntermediateType(F.SYMBOL);
            if (j.element = $(U), !y.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return j;
        }, "parseInfix")
      }), Ht = re({
        name: "arrayBracketsParslet",
        precedence: F.ARRAY_BRACKETS,
        accept: /* @__PURE__ */ u((y, S) => y === "[" && S === "]", "accept"),
        parseInfix: /* @__PURE__ */ u((y, S) => (y.consume("["), y.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            O(S)
          ],
          meta: {
            brackets: "square",
            dot: !1
          }
        }), "parseInfix")
      });
      function _t({ objectFieldGrammar: y, allowKeyTypes: S }) {
        return re({
          name: "objectParslet",
          accept: /* @__PURE__ */ u((j) => j === "{", "accept"),
          parsePrefix: /* @__PURE__ */ u((j) => {
            j.consume("{");
            const U = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!j.consume("}")) {
              let Q;
              const ie = new oe(y, j.lexer, j);
              for (; ; ) {
                ie.acceptLexerState(j);
                let pe = ie.parseIntermediateType(F.OBJECT);
                j.acceptLexerState(ie), pe === void 0 && S && (pe = j.parseIntermediateType(F.OBJECT));
                let Pe = !1;
                if (pe.type === "JsdocTypeNullable" && (Pe = !0, pe = pe.element), pe.type === "JsdocTypeNumber" || pe.type === "JsdocTypeName" || pe.type === "JsdocTypeStringValue") {
                  let Oe;
                  pe.type === "JsdocTypeStringValue" && (Oe = pe.meta.quote), U.elements.push({
                    type: "JsdocTypeObjectField",
                    key: pe.value.toString(),
                    right: void 0,
                    optional: Pe,
                    readonly: !1,
                    meta: {
                      quote: Oe
                    }
                  });
                } else if (pe.type === "JsdocTypeObjectField" || pe.type === "JsdocTypeJsdocObjectField")
                  U.elements.push(pe);
                else
                  throw new l(pe);
                if (j.lexer.current.startOfLine)
                  Q = "linebreak", j.consume(",") || j.consume(";");
                else if (j.consume(","))
                  Q = "comma";
                else if (j.consume(";"))
                  Q = "semicolon";
                else
                  break;
                if (j.lexer.current.type === "}")
                  break;
              }
              if (U.meta.separator = Q ?? "comma", Q === "linebreak" && (U.meta.propertyIndent = "  "), !j.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return U;
          }, "parsePrefix")
        });
      }
      u(_t, "createObjectParslet");
      function Et({ allowSquaredProperties: y, allowKeyTypes: S, allowReadonly: j, allowOptional: U }) {
        return re({
          name: "objectFieldParslet",
          precedence: F.KEY_VALUE,
          accept: /* @__PURE__ */ u((Q) => Q === ":", "accept"),
          parseInfix: /* @__PURE__ */ u((Q, ie) => {
            var pe;
            let Pe = !1, Oe = !1;
            U && ie.type === "JsdocTypeNullable" && (Pe = !0, ie = ie.element), j && ie.type === "JsdocTypeReadonlyProperty" && (Oe = !0, ie = ie.element);
            const Ge = (pe = Q.baseParser) !== null && pe !== void 0 ? pe : Q;
            if (Ge.acceptLexerState(Q), ie.type === "JsdocTypeNumber" || ie.type === "JsdocTypeName" || ie.type === "JsdocTypeStringValue" || D(ie)) {
              if (D(ie) && !y)
                throw new l(ie);
              Ge.consume(":");
              let Jt;
              ie.type === "JsdocTypeStringValue" && (Jt = ie.meta.quote);
              const xt = Ge.parseType(F.KEY_VALUE);
              return Q.acceptLexerState(Ge), {
                type: "JsdocTypeObjectField",
                key: D(ie) ? ie : ie.value.toString(),
                right: xt,
                optional: Pe,
                readonly: Oe,
                meta: {
                  quote: Jt
                }
              };
            } else {
              if (!S)
                throw new l(ie);
              Ge.consume(":");
              const Jt = Ge.parseType(F.KEY_VALUE);
              return Q.acceptLexerState(Ge), {
                type: "JsdocTypeJsdocObjectField",
                left: O(ie),
                right: Jt
              };
            }
          }, "parseInfix")
        });
      }
      u(Et, "createObjectFieldParslet");
      function Nr({ allowOptional: y, allowVariadic: S }) {
        return re({
          name: "keyValueParslet",
          precedence: F.KEY_VALUE,
          accept: /* @__PURE__ */ u((j) => j === ":", "accept"),
          parseInfix: /* @__PURE__ */ u((j, U) => {
            let Q = !1, ie = !1;
            if (y && U.type === "JsdocTypeNullable" && (Q = !0, U = U.element), S && U.type === "JsdocTypeVariadic" && U.element !== void 0 && (ie = !0, U = U.element), U.type !== "JsdocTypeName")
              throw new l(U);
            j.consume(":");
            const pe = j.parseType(F.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: U.value,
              right: pe,
              optional: Q,
              variadic: ie
            };
          }, "parseInfix")
        });
      }
      u(Nr, "createKeyValueParslet");
      const To = [
        ...q,
        dt({
          allowWithoutParenthesis: !0,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        ue,
        se({
          allowedTypes: ["module", "external", "event"],
          pathGrammar: fe
        }),
        pt({
          allowEnclosingBrackets: !0,
          allowPostfix: !0
        }),
        ae({
          allowedAdditionalTokens: ["keyof"]
        }),
        it,
        Ht,
        te({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: fe
        })
      ], di = [
        ...To,
        _t({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            ae({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            Et({
              allowSquaredProperties: !1,
              allowKeyTypes: !0,
              allowOptional: !1,
              allowReadonly: !1
            }),
            ...To
          ],
          allowKeyTypes: !0
        }),
        Nr({
          allowOptional: !0,
          allowVariadic: !0
        })
      ], Ao = re({
        name: "typeOfParslet",
        accept: /* @__PURE__ */ u((y) => y === "typeof", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => (y.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: y.parseType(F.KEY_OF_TYPE_OF)
        }), "parsePrefix")
      }), pi = [
        ae({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        le,
        we,
        ue,
        _e,
        Et({
          allowSquaredProperties: !1,
          allowKeyTypes: !1,
          allowOptional: !1,
          allowReadonly: !1
        })
      ], fi = [
        ...q,
        _t({
          allowKeyTypes: !1,
          objectFieldGrammar: pi
        }),
        ae({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        Ao,
        dt({
          allowWithoutParenthesis: !1,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        pt({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        // additional name parslet is needed for some special cases
        ae({
          allowedAdditionalTokens: ["keyof"]
        }),
        se({
          allowedTypes: ["module"],
          pathGrammar: fe
        }),
        te({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: fe
        }),
        Nr({
          allowOptional: !1,
          allowVariadic: !1
        }),
        it
      ], hi = re({
        name: "assertsParslet",
        accept: /* @__PURE__ */ u((y) => y === "asserts", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          y.consume("asserts");
          const S = y.parseIntermediateType(F.SYMBOL);
          if (S.type !== "JsdocTypeName")
            throw new l(S, "A typescript asserts always has to have a name on the left side.");
          return y.consume("is") ? {
            type: "JsdocTypeAsserts",
            left: S,
            right: O(y.parseIntermediateType(F.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: S
          };
        }, "parsePrefix")
      });
      function $o({ allowQuestionMark: y }) {
        return re({
          name: "tupleParslet",
          accept: /* @__PURE__ */ u((S) => S === "[", "accept"),
          parsePrefix: /* @__PURE__ */ u((S) => {
            S.consume("[");
            const j = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (S.consume("]"))
              return j;
            const U = S.parseIntermediateType(F.ALL);
            if (U.type === "JsdocTypeParameterList" ? U.elements[0].type === "JsdocTypeKeyValue" ? j.elements = U.elements.map(L) : j.elements = U.elements.map(O) : U.type === "JsdocTypeKeyValue" ? j.elements = [L(U)] : j.elements = [O(U)], !S.consume("]"))
              throw new Error("Unterminated '['");
            if (j.elements.some((Q) => Q.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return j;
          }, "parsePrefix")
        });
      }
      u($o, "createTupleParslet");
      const mi = re({
        name: "keyOfParslet",
        accept: /* @__PURE__ */ u((y) => y === "keyof", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => (y.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: O(y.parseType(F.KEY_OF_TYPE_OF))
        }), "parsePrefix")
      }), yi = re({
        name: "importParslet",
        accept: /* @__PURE__ */ u((y) => y === "import", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          if (y.consume("import"), !y.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          const S = y.parseType(F.PREFIX);
          if (S.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!y.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: S
          };
        }, "parsePrefix")
      }), gi = re({
        name: "readonlyPropertyParslet",
        accept: /* @__PURE__ */ u((y) => y === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => (y.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: y.parseIntermediateType(F.KEY_VALUE)
        }), "parsePrefix")
      }), bi = re({
        name: "arrowFunctionParslet",
        precedence: F.ARROW,
        accept: /* @__PURE__ */ u((y) => y === "=>", "accept"),
        parseInfix: /* @__PURE__ */ u((y, S) => (y.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: Ae(S).map(M),
          arrow: !0,
          constructor: !1,
          parenthesis: !0,
          returnType: y.parseType(F.OBJECT)
        }), "parseInfix")
      }), vi = re({
        name: "genericArrowFunctionParslet",
        accept: /* @__PURE__ */ u((y) => y === "<", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          const S = [];
          y.consume("<");
          do {
            let U, Q = y.parseIntermediateType(F.SYMBOL);
            if (Q.type === "JsdocTypeOptional" && (Q = Q.element, U = y.parseType(F.SYMBOL)), Q.type !== "JsdocTypeName")
              throw new l(Q);
            let ie;
            y.consume("extends") && (ie = y.parseType(F.SYMBOL), ie.type === "JsdocTypeOptional" && (ie = ie.element, U = y.parseType(F.SYMBOL)));
            const pe = {
              type: "JsdocTypeTypeParameter",
              name: Q
            };
            if (ie !== void 0 && (pe.constraint = ie), U !== void 0 && (pe.defaultValue = U), S.push(pe), y.consume(">"))
              break;
          } while (y.consume(","));
          const j = y.parseIntermediateType(F.SYMBOL);
          return j.typeParameters = S, j;
        }, "parsePrefix")
      }), wi = re({
        name: "intersectionParslet",
        accept: /* @__PURE__ */ u((y) => y === "&", "accept"),
        precedence: F.INTERSECTION,
        parseInfix: /* @__PURE__ */ u((y, S) => {
          y.consume("&");
          const j = [];
          do
            j.push(y.parseType(F.INTERSECTION));
          while (y.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [O(S), ...j]
          };
        }, "parseInfix")
      }), _i = re({
        name: "predicateParslet",
        precedence: F.INFIX,
        accept: /* @__PURE__ */ u((y) => y === "is", "accept"),
        parseInfix: /* @__PURE__ */ u((y, S) => {
          if (S.type !== "JsdocTypeName")
            throw new l(S, "A typescript predicate always has to have a name on the left side.");
          return y.consume("is"), {
            type: "JsdocTypePredicate",
            left: S,
            right: O(y.parseIntermediateType(F.INFIX))
          };
        }, "parseInfix")
      }), Ei = re({
        name: "objectSquareBracketPropertyParslet",
        accept: /* @__PURE__ */ u((y) => y === "[", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => {
          if (y.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          y.consume("[");
          const S = y.lexer.current.text;
          y.consume("Identifier");
          let j;
          if (y.consume(":")) {
            const U = y.baseParser;
            U.acceptLexerState(y), j = {
              type: "JsdocTypeIndexSignature",
              key: S,
              right: U.parseType(F.INDEX_BRACKETS)
            }, y.acceptLexerState(U);
          } else if (y.consume("in")) {
            const U = y.baseParser;
            U.acceptLexerState(y), j = {
              type: "JsdocTypeMappedType",
              key: S,
              right: U.parseType(F.ARRAY_BRACKETS)
            }, y.acceptLexerState(U);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!y.consume("]"))
            throw new Error("Unterminated square brackets");
          return j;
        }, "parsePrefix")
      }), xi = re({
        name: "readonlyArrayParslet",
        accept: /* @__PURE__ */ u((y) => y === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ u((y) => (y.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: I(y.parseIntermediateType(F.ALL))
        }), "parsePrefix")
      }), Si = re({
        name: "conditionalParslet",
        precedence: F.INFIX,
        accept: /* @__PURE__ */ u((y) => y === "extends", "accept"),
        parseInfix: /* @__PURE__ */ u((y, S) => {
          y.consume("extends");
          const j = y.parseType(F.KEY_OF_TYPE_OF).element, U = y.parseType(F.INFIX);
          return y.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: O(S),
            extendsType: j,
            trueType: U,
            falseType: y.parseType(F.INFIX)
          };
        }, "parseInfix")
      }), Ti = [
        gi,
        ae({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        le,
        we,
        ue,
        _e,
        Et({
          allowSquaredProperties: !0,
          allowKeyTypes: !1,
          allowOptional: !0,
          allowReadonly: !0
        }),
        Ei
      ], Ai = [
        ...q,
        _t({
          allowKeyTypes: !1,
          objectFieldGrammar: Ti
        }),
        xi,
        Ao,
        mi,
        yi,
        ue,
        dt({
          allowWithoutParenthesis: !0,
          allowNoReturnType: !1,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: !0
        }),
        $o({
          allowQuestionMark: !1
        }),
        pt({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        hi,
        Si,
        ae({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        se({
          allowedTypes: ["module"],
          pathGrammar: fe
        }),
        Ht,
        bi,
        vi,
        te({
          allowSquareBracketsOnAnyType: !0,
          allowJsdocNamePaths: !1,
          pathGrammar: fe
        }),
        wi,
        _i,
        Nr({
          allowVariadic: !0,
          allowOptional: !0
        })
      ];
      function $n(y, S) {
        switch (S) {
          case "closure":
            return new oe(fi, y).parse();
          case "jsdoc":
            return new oe(di, y).parse();
          case "typescript":
            return new oe(Ai, y).parse();
        }
      }
      u($n, "parse");
      function Co(y, S = ["typescript", "closure", "jsdoc"]) {
        let j;
        for (const U of S)
          try {
            return $n(y, U);
          } catch (Q) {
            j = Q;
          }
        throw j;
      }
      u(Co, "tryParse");
      function K(y, S) {
        const j = y[S.type];
        if (j === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${S.type}.`);
        return j(S, (U) => K(y, U));
      }
      u(K, "transform");
      function Ce(y) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      u(Ce, "notAvailableTransform");
      function sr(y) {
        const S = {
          params: []
        };
        for (const j of y.parameters)
          j.type === "JsdocTypeKeyValue" ? j.key === "this" ? S.this = j.right : j.key === "new" ? S.new = j.right : S.params.push(j) : S.params.push(j);
        return S;
      }
      u(sr, "extractSpecialParams");
      function Cn(y, S, j) {
        return y === "prefix" ? j + S : S + j;
      }
      u(Cn, "applyPosition");
      function Vt(y, S) {
        switch (S) {
          case "double":
            return `"${y}"`;
          case "single":
            return `'${y}'`;
          case void 0:
            return y;
        }
      }
      u(Vt, "quote");
      function $i() {
        return {
          JsdocTypeParenthesis: /* @__PURE__ */ u((y, S) => `(${y.element !== void 0 ? S(y.element) : ""})`, "JsdocTypeParenthesis"),
          JsdocTypeKeyof: /* @__PURE__ */ u((y, S) => `keyof ${S(y.element)}`, "JsdocTypeKeyof"),
          JsdocTypeFunction: /* @__PURE__ */ u((y, S) => {
            var j;
            if (y.arrow) {
              if (y.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let U = `${y.typeParameters !== void 0 ? `<${(j = y.typeParameters.map(S).join(", ")) !== null && j !== void 0 ? j : ""}>` : ""}(${y.parameters.map(S).join(", ")}) => ${S(y.returnType)}`;
              return y.constructor && (U = "new " + U), U;
            } else {
              let U = y.constructor ? "new" : "function";
              return y.parenthesis && (U += `(${y.parameters.map(S).join(", ")})`, y.returnType !== void 0 && (U += `: ${S(y.returnType)}`)), U;
            }
          }, "JsdocTypeFunction"),
          JsdocTypeName: /* @__PURE__ */ u((y) => y.value, "JsdocTypeName"),
          JsdocTypeTuple: /* @__PURE__ */ u((y, S) => `[${y.elements.map(S).join(", ")}]`, "JsdocTypeTuple"),
          JsdocTypeVariadic: /* @__PURE__ */ u((y, S) => y.meta.position === void 0 ? "..." : Cn(y.meta.position, S(y.element), "..."), "JsdocTypeVariadic"),
          JsdocTypeNamePath: /* @__PURE__ */ u((y, S) => {
            const j = S(y.left), U = S(y.right);
            switch (y.pathType) {
              case "inner":
                return `${j}~${U}`;
              case "instance":
                return `${j}#${U}`;
              case "property":
                return `${j}.${U}`;
              case "property-brackets":
                return `${j}[${U}]`;
            }
          }, "JsdocTypeNamePath"),
          JsdocTypeStringValue: /* @__PURE__ */ u((y) => Vt(y.value, y.meta.quote), "JsdocTypeStringValue"),
          JsdocTypeAny: /* @__PURE__ */ u(() => "*", "JsdocTypeAny"),
          JsdocTypeGeneric: /* @__PURE__ */ u((y, S) => {
            if (y.meta.brackets === "square") {
              const j = y.elements[0], U = S(j);
              return j.type === "JsdocTypeUnion" || j.type === "JsdocTypeIntersection" ? `(${U})[]` : `${U}[]`;
            } else
              return `${S(y.left)}${y.meta.dot ? "." : ""}<${y.infer === !0 ? "infer " : ""}${y.elements.map(S).join(", ")}>`;
          }, "JsdocTypeGeneric"),
          JsdocTypeImport: /* @__PURE__ */ u((y, S) => `import(${S(y.element)})`, "JsdocTypeImport"),
          JsdocTypeObjectField: /* @__PURE__ */ u((y, S) => {
            let j = "";
            return y.readonly && (j += "readonly "), typeof y.key == "string" ? j += Vt(y.key, y.meta.quote) : j += S(y.key), y.optional && (j += "?"), y.right === void 0 ? j : j + `: ${S(y.right)}`;
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ u((y, S) => `${S(y.left)}: ${S(y.right)}`, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ u((y, S) => {
            let j = y.key;
            return y.optional && (j += "?"), y.variadic && (j = "..." + j), y.right === void 0 ? j : j + `: ${S(y.right)}`;
          }, "JsdocTypeKeyValue"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ u((y) => `${y.specialType}:${Vt(y.value, y.meta.quote)}`, "JsdocTypeSpecialNamePath"),
          JsdocTypeNotNullable: /* @__PURE__ */ u((y, S) => Cn(y.meta.position, S(y.element), "!"), "JsdocTypeNotNullable"),
          JsdocTypeNull: /* @__PURE__ */ u(() => "null", "JsdocTypeNull"),
          JsdocTypeNullable: /* @__PURE__ */ u((y, S) => Cn(y.meta.position, S(y.element), "?"), "JsdocTypeNullable"),
          JsdocTypeNumber: /* @__PURE__ */ u((y) => y.value.toString(), "JsdocTypeNumber"),
          JsdocTypeObject: /* @__PURE__ */ u((y, S) => {
            var j, U;
            return `{${(y.meta.separator === "linebreak" && y.elements.length > 1 ? `
` + ((j = y.meta.propertyIndent) !== null && j !== void 0 ? j : "") : "") + y.elements.map(S).join(y.meta.separator === "comma" ? ", " : y.meta.separator === "linebreak" ? `
` + ((U = y.meta.propertyIndent) !== null && U !== void 0 ? U : "") : "; ") + (y.meta.separator === "linebreak" && y.elements.length > 1 ? `
` : "")}}`;
          }, "JsdocTypeObject"),
          JsdocTypeOptional: /* @__PURE__ */ u((y, S) => Cn(y.meta.position, S(y.element), "="), "JsdocTypeOptional"),
          JsdocTypeSymbol: /* @__PURE__ */ u((y, S) => `${y.value}(${y.element !== void 0 ? S(y.element) : ""})`, "JsdocTypeSymbol"),
          JsdocTypeTypeof: /* @__PURE__ */ u((y, S) => `typeof ${S(y.element)}`, "JsdocTypeTypeof"),
          JsdocTypeUndefined: /* @__PURE__ */ u(() => "undefined", "JsdocTypeUndefined"),
          JsdocTypeUnion: /* @__PURE__ */ u((y, S) => y.elements.map(S).join(" | "), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ u(() => "?", "JsdocTypeUnknown"),
          JsdocTypeIntersection: /* @__PURE__ */ u((y, S) => y.elements.map(S).join(" & "), "JsdocTypeIntersection"),
          JsdocTypeProperty: /* @__PURE__ */ u((y) => Vt(y.value, y.meta.quote), "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ u((y, S) => `${S(y.left)} is ${S(y.right)}`, "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ u((y, S) => `[${y.key}: ${S(y.right)}]`, "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ u((y, S) => `[${y.key} in ${S(y.right)}]`, "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ u((y, S) => `asserts ${S(y.left)} is ${S(y.right)}`, "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ u((y, S) => `readonly ${S(y.element)}`, "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ u((y, S) => `asserts ${S(y.element)}`, "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ u((y, S) => `${S(y.checksType)} extends ${S(y.extendsType)} ? ${S(y.trueType)} : ${S(y.falseType)}`, "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ u((y, S) => `${S(y.name)}${y.constraint !== void 0 ? ` extends ${S(y.constraint)}` : ""}${y.defaultValue !== void 0 ? ` = ${S(y.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
        };
      }
      u($i, "stringifyRules");
      const Ub = $i();
      function Hc(y) {
        return K(Ub, y);
      }
      u(Hc, "stringify");
      const Bb = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function zt(y) {
        const S = {
          type: "NameExpression",
          name: y
        };
        return Bb.includes(y) && (S.reservedWord = !0), S;
      }
      u(zt, "makeName");
      const Hb = {
        JsdocTypeOptional: /* @__PURE__ */ u((y, S) => {
          const j = S(y.element);
          return j.optional = !0, j;
        }, "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ u((y, S) => {
          const j = S(y.element);
          return j.nullable = !0, j;
        }, "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ u((y, S) => {
          const j = S(y.element);
          return j.nullable = !1, j;
        }, "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ u((y, S) => {
          if (y.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          const j = S(y.element);
          return j.repeatable = !0, j;
        }, "JsdocTypeVariadic"),
        JsdocTypeAny: /* @__PURE__ */ u(() => ({
          type: "AllLiteral"
        }), "JsdocTypeAny"),
        JsdocTypeNull: /* @__PURE__ */ u(() => ({
          type: "NullLiteral"
        }), "JsdocTypeNull"),
        JsdocTypeStringValue: /* @__PURE__ */ u((y) => zt(Vt(y.value, y.meta.quote)), "JsdocTypeStringValue"),
        JsdocTypeUndefined: /* @__PURE__ */ u(() => ({
          type: "UndefinedLiteral"
        }), "JsdocTypeUndefined"),
        JsdocTypeUnknown: /* @__PURE__ */ u(() => ({
          type: "UnknownLiteral"
        }), "JsdocTypeUnknown"),
        JsdocTypeFunction: /* @__PURE__ */ u((y, S) => {
          const j = sr(y), U = {
            type: "FunctionType",
            params: j.params.map(S)
          };
          return j.this !== void 0 && (U.this = S(j.this)), j.new !== void 0 && (U.new = S(j.new)), y.returnType !== void 0 && (U.result = S(y.returnType)), U;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ u((y, S) => ({
          type: "TypeApplication",
          applications: y.elements.map((j) => S(j)),
          expression: S(y.left)
        }), "JsdocTypeGeneric"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ u((y) => zt(y.specialType + ":" + Vt(y.value, y.meta.quote)), "JsdocTypeSpecialNamePath"),
        JsdocTypeName: /* @__PURE__ */ u((y) => y.value !== "function" ? zt(y.value) : {
          type: "FunctionType",
          params: []
        }, "JsdocTypeName"),
        JsdocTypeNumber: /* @__PURE__ */ u((y) => zt(y.value.toString()), "JsdocTypeNumber"),
        JsdocTypeObject: /* @__PURE__ */ u((y, S) => {
          const j = {
            type: "RecordType",
            fields: []
          };
          for (const U of y.elements)
            U.type !== "JsdocTypeObjectField" && U.type !== "JsdocTypeJsdocObjectField" ? j.fields.push({
              type: "FieldType",
              key: S(U),
              value: void 0
            }) : j.fields.push(S(U));
          return j;
        }, "JsdocTypeObject"),
        JsdocTypeObjectField: /* @__PURE__ */ u((y, S) => {
          if (typeof y.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: zt(Vt(y.key, y.meta.quote)),
            value: y.right === void 0 ? void 0 : S(y.right)
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ u((y, S) => ({
          type: "FieldType",
          key: S(y.left),
          value: S(y.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeUnion: /* @__PURE__ */ u((y, S) => ({
          type: "TypeUnion",
          elements: y.elements.map((j) => S(j))
        }), "JsdocTypeUnion"),
        JsdocTypeKeyValue: /* @__PURE__ */ u((y, S) => ({
          type: "FieldType",
          key: zt(y.key),
          value: y.right === void 0 ? void 0 : S(y.right)
        }), "JsdocTypeKeyValue"),
        JsdocTypeNamePath: /* @__PURE__ */ u((y, S) => {
          const j = S(y.left);
          let U;
          y.right.type === "JsdocTypeSpecialNamePath" ? U = S(y.right).name : U = Vt(y.right.value, y.right.meta.quote);
          const Q = y.pathType === "inner" ? "~" : y.pathType === "instance" ? "#" : ".";
          return zt(`${j.name}${Q}${U}`);
        }, "JsdocTypeNamePath"),
        JsdocTypeSymbol: /* @__PURE__ */ u((y) => {
          let S = "", j = y.element, U = !1;
          return j?.type === "JsdocTypeVariadic" && (j.meta.position === "prefix" ? S = "..." : U = !0, j = j.element), j?.type === "JsdocTypeName" ? S += j.value : j?.type === "JsdocTypeNumber" && (S += j.value.toString()), U && (S += "..."), zt(`${y.value}(${S})`);
        }, "JsdocTypeSymbol"),
        JsdocTypeParenthesis: /* @__PURE__ */ u((y, S) => S(O(y.element)), "JsdocTypeParenthesis"),
        JsdocTypeMappedType: Ce,
        JsdocTypeIndexSignature: Ce,
        JsdocTypeImport: Ce,
        JsdocTypeKeyof: Ce,
        JsdocTypeTuple: Ce,
        JsdocTypeTypeof: Ce,
        JsdocTypeIntersection: Ce,
        JsdocTypeProperty: Ce,
        JsdocTypePredicate: Ce,
        JsdocTypeAsserts: Ce,
        JsdocTypeReadonlyArray: Ce,
        JsdocTypeAssertsPlain: Ce,
        JsdocTypeConditional: Ce,
        JsdocTypeTypeParameter: Ce
      };
      function Vc(y) {
        return K(Hb, y);
      }
      u(Vc, "catharsisTransform");
      function lr(y) {
        switch (y) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      u(lr, "getQuoteStyle");
      function zc(y) {
        switch (y) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      u(zc, "getMemberType");
      function ko(y, S) {
        return S.length === 2 ? {
          type: y,
          left: S[0],
          right: S[1]
        } : {
          type: y,
          left: S[0],
          right: ko(y, S.slice(1))
        };
      }
      u(ko, "nestResults");
      const Vb = {
        JsdocTypeOptional: /* @__PURE__ */ u((y, S) => ({
          type: "OPTIONAL",
          value: S(y.element),
          meta: {
            syntax: y.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }), "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ u((y, S) => ({
          type: "NULLABLE",
          value: S(y.element),
          meta: {
            syntax: y.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }), "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ u((y, S) => ({
          type: "NOT_NULLABLE",
          value: S(y.element),
          meta: {
            syntax: y.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ u((y, S) => {
          const j = {
            type: "VARIADIC",
            meta: {
              syntax: y.meta.position === "prefix" ? "PREFIX_DOTS" : y.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return y.element !== void 0 && (j.value = S(y.element)), j;
        }, "JsdocTypeVariadic"),
        JsdocTypeName: /* @__PURE__ */ u((y) => ({
          type: "NAME",
          name: y.value
        }), "JsdocTypeName"),
        JsdocTypeTypeof: /* @__PURE__ */ u((y, S) => ({
          type: "TYPE_QUERY",
          name: S(y.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeTuple: /* @__PURE__ */ u((y, S) => ({
          type: "TUPLE",
          entries: y.elements.map(S)
        }), "JsdocTypeTuple"),
        JsdocTypeKeyof: /* @__PURE__ */ u((y, S) => ({
          type: "KEY_QUERY",
          value: S(y.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeImport: /* @__PURE__ */ u((y) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: lr(y.element.meta.quote),
            string: y.element.value
          }
        }), "JsdocTypeImport"),
        JsdocTypeUndefined: /* @__PURE__ */ u(() => ({
          type: "NAME",
          name: "undefined"
        }), "JsdocTypeUndefined"),
        JsdocTypeAny: /* @__PURE__ */ u(() => ({
          type: "ANY"
        }), "JsdocTypeAny"),
        JsdocTypeFunction: /* @__PURE__ */ u((y, S) => {
          const j = sr(y), U = {
            type: y.arrow ? "ARROW" : "FUNCTION",
            params: j.params.map((Q) => {
              if (Q.type === "JsdocTypeKeyValue") {
                if (Q.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: Q.key,
                  typeName: S(Q.right)
                };
              } else
                return S(Q);
            }),
            new: null,
            returns: null
          };
          return j.this !== void 0 ? U.this = S(j.this) : y.arrow || (U.this = null), j.new !== void 0 && (U.new = S(j.new)), y.returnType !== void 0 && (U.returns = S(y.returnType)), U;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ u((y, S) => {
          const j = {
            type: "GENERIC",
            subject: S(y.left),
            objects: y.elements.map(S),
            meta: {
              syntax: y.meta.brackets === "square" ? "SQUARE_BRACKET" : y.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return y.meta.brackets === "square" && y.elements[0].type === "JsdocTypeFunction" && !y.elements[0].parenthesis && (j.objects[0] = {
            type: "NAME",
            name: "function"
          }), j;
        }, "JsdocTypeGeneric"),
        JsdocTypeObjectField: /* @__PURE__ */ u((y, S) => {
          if (typeof y.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (y.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: y.key,
              quoteStyle: lr(y.meta.quote),
              value: null,
              readonly: !1
            };
          let j = S(y.right);
          return y.optional && (j = {
            type: "OPTIONAL",
            value: j,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: y.key.toString(),
            quoteStyle: lr(y.meta.quote),
            value: j,
            readonly: !1
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ u(() => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        }, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: /* @__PURE__ */ u((y, S) => {
          if (y.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: y.key,
              quoteStyle: "none",
              value: null,
              readonly: !1
            };
          let j = S(y.right);
          return y.optional && (j = {
            type: "OPTIONAL",
            value: j,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: y.key,
            quoteStyle: "none",
            value: j,
            readonly: !1
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeObject: /* @__PURE__ */ u((y, S) => {
          const j = [];
          for (const U of y.elements)
            (U.type === "JsdocTypeObjectField" || U.type === "JsdocTypeJsdocObjectField") && j.push(S(U));
          return {
            type: "RECORD",
            entries: j
          };
        }, "JsdocTypeObject"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ u((y) => {
          if (y.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${y.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: lr(y.meta.quote),
              path: y.value
            }
          };
        }, "JsdocTypeSpecialNamePath"),
        JsdocTypeNamePath: /* @__PURE__ */ u((y, S) => {
          let j = !1, U, Q;
          y.right.type === "JsdocTypeSpecialNamePath" && y.right.specialType === "event" ? (j = !0, U = y.right.value, Q = lr(y.right.meta.quote)) : (U = y.right.value, Q = lr(y.right.meta.quote));
          const ie = {
            type: zc(y.pathType),
            owner: S(y.left),
            name: U,
            quoteStyle: Q,
            hasEventPrefix: j
          };
          if (ie.owner.type === "MODULE") {
            const pe = ie.owner;
            return ie.owner = ie.owner.value, pe.value = ie, pe;
          } else
            return ie;
        }, "JsdocTypeNamePath"),
        JsdocTypeUnion: /* @__PURE__ */ u((y, S) => ko("UNION", y.elements.map(S)), "JsdocTypeUnion"),
        JsdocTypeParenthesis: /* @__PURE__ */ u((y, S) => ({
          type: "PARENTHESIS",
          value: S(O(y.element))
        }), "JsdocTypeParenthesis"),
        JsdocTypeNull: /* @__PURE__ */ u(() => ({
          type: "NAME",
          name: "null"
        }), "JsdocTypeNull"),
        JsdocTypeUnknown: /* @__PURE__ */ u(() => ({
          type: "UNKNOWN"
        }), "JsdocTypeUnknown"),
        JsdocTypeStringValue: /* @__PURE__ */ u((y) => ({
          type: "STRING_VALUE",
          quoteStyle: lr(y.meta.quote),
          string: y.value
        }), "JsdocTypeStringValue"),
        JsdocTypeIntersection: /* @__PURE__ */ u((y, S) => ko("INTERSECTION", y.elements.map(S)), "JsdocTypeIntersection"),
        JsdocTypeNumber: /* @__PURE__ */ u((y) => ({
          type: "NUMBER_VALUE",
          number: y.value.toString()
        }), "JsdocTypeNumber"),
        JsdocTypeSymbol: Ce,
        JsdocTypeProperty: Ce,
        JsdocTypePredicate: Ce,
        JsdocTypeMappedType: Ce,
        JsdocTypeIndexSignature: Ce,
        JsdocTypeAsserts: Ce,
        JsdocTypeReadonlyArray: Ce,
        JsdocTypeAssertsPlain: Ce,
        JsdocTypeConditional: Ce,
        JsdocTypeTypeParameter: Ce
      };
      function Jc(y) {
        return K(Vb, y);
      }
      u(Jc, "jtpTransform");
      function Wc() {
        return {
          JsdocTypeIntersection: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeIntersection",
            elements: y.elements.map(S)
          }), "JsdocTypeIntersection"),
          JsdocTypeGeneric: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeGeneric",
            left: S(y.left),
            elements: y.elements.map(S),
            meta: {
              dot: y.meta.dot,
              brackets: y.meta.brackets
            }
          }), "JsdocTypeGeneric"),
          JsdocTypeNullable: /* @__PURE__ */ u((y) => y, "JsdocTypeNullable"),
          JsdocTypeUnion: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeUnion",
            elements: y.elements.map(S)
          }), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ u((y) => y, "JsdocTypeUnknown"),
          JsdocTypeUndefined: /* @__PURE__ */ u((y) => y, "JsdocTypeUndefined"),
          JsdocTypeTypeof: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeTypeof",
            element: S(y.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeSymbol: /* @__PURE__ */ u((y, S) => {
            const j = {
              type: "JsdocTypeSymbol",
              value: y.value
            };
            return y.element !== void 0 && (j.element = S(y.element)), j;
          }, "JsdocTypeSymbol"),
          JsdocTypeOptional: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeOptional",
            element: S(y.element),
            meta: {
              position: y.meta.position
            }
          }), "JsdocTypeOptional"),
          JsdocTypeObject: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: y.elements.map(S)
          }), "JsdocTypeObject"),
          JsdocTypeNumber: /* @__PURE__ */ u((y) => y, "JsdocTypeNumber"),
          JsdocTypeNull: /* @__PURE__ */ u((y) => y, "JsdocTypeNull"),
          JsdocTypeNotNullable: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeNotNullable",
            element: S(y.element),
            meta: {
              position: y.meta.position
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ u((y) => y, "JsdocTypeSpecialNamePath"),
          JsdocTypeObjectField: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeObjectField",
            key: y.key,
            right: y.right === void 0 ? void 0 : S(y.right),
            optional: y.optional,
            readonly: y.readonly,
            meta: y.meta
          }), "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeJsdocObjectField",
            left: S(y.left),
            right: S(y.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeKeyValue",
            key: y.key,
            right: y.right === void 0 ? void 0 : S(y.right),
            optional: y.optional,
            variadic: y.variadic
          }), "JsdocTypeKeyValue"),
          JsdocTypeImport: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeImport",
            element: S(y.element)
          }), "JsdocTypeImport"),
          JsdocTypeAny: /* @__PURE__ */ u((y) => y, "JsdocTypeAny"),
          JsdocTypeStringValue: /* @__PURE__ */ u((y) => y, "JsdocTypeStringValue"),
          JsdocTypeNamePath: /* @__PURE__ */ u((y) => y, "JsdocTypeNamePath"),
          JsdocTypeVariadic: /* @__PURE__ */ u((y, S) => {
            const j = {
              type: "JsdocTypeVariadic",
              meta: {
                position: y.meta.position,
                squareBrackets: y.meta.squareBrackets
              }
            };
            return y.element !== void 0 && (j.element = S(y.element)), j;
          }, "JsdocTypeVariadic"),
          JsdocTypeTuple: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeTuple",
            elements: y.elements.map(S)
          }), "JsdocTypeTuple"),
          JsdocTypeName: /* @__PURE__ */ u((y) => y, "JsdocTypeName"),
          JsdocTypeFunction: /* @__PURE__ */ u((y, S) => {
            const j = {
              type: "JsdocTypeFunction",
              arrow: y.arrow,
              parameters: y.parameters.map(S),
              constructor: y.constructor,
              parenthesis: y.parenthesis
            };
            return y.returnType !== void 0 && (j.returnType = S(y.returnType)), j;
          }, "JsdocTypeFunction"),
          JsdocTypeKeyof: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeKeyof",
            element: S(y.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeParenthesis: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeParenthesis",
            element: S(y.element)
          }), "JsdocTypeParenthesis"),
          JsdocTypeProperty: /* @__PURE__ */ u((y) => y, "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypePredicate",
            left: S(y.left),
            right: S(y.right)
          }), "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeIndexSignature",
            key: y.key,
            right: S(y.right)
          }), "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeMappedType",
            key: y.key,
            right: S(y.right)
          }), "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeAsserts",
            left: S(y.left),
            right: S(y.right)
          }), "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeReadonlyArray",
            element: S(y.element)
          }), "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeAssertsPlain",
            element: S(y.element)
          }), "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeConditional",
            checksType: S(y.checksType),
            extendsType: S(y.extendsType),
            trueType: S(y.trueType),
            falseType: S(y.falseType)
          }), "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ u((y, S) => ({
            type: "JsdocTypeTypeParameter",
            name: S(y.name),
            constraint: y.constraint !== void 0 ? S(y.constraint) : void 0,
            defaultValue: y.defaultValue !== void 0 ? S(y.defaultValue) : void 0
          }), "JsdocTypeTypeParameter")
        };
      }
      u(Wc, "identityTransformRules");
      const Gc = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function Po(y, S, j, U, Q) {
        U?.(y, S, j);
        const ie = Gc[y.type];
        for (const pe of ie) {
          const Pe = y[pe];
          if (Pe !== void 0)
            if (Array.isArray(Pe))
              for (const Oe of Pe)
                Po(Oe, y, pe, U, Q);
            else
              Po(Pe, y, pe, U, Q);
        }
        Q?.(y, S, j);
      }
      u(Po, "_traverse");
      function Kc(y, S, j) {
        Po(y, void 0, void 0, S, j);
      }
      u(Kc, "traverse"), r.catharsisTransform = Vc, r.identityTransformRules = Wc, r.jtpTransform = Jc, r.parse = $n, r.stringify = Hc, r.stringifyRules = $i, r.transform = K, r.traverse = Kc, r.tryParse = Co, r.visitorKeys = Gc;
    });
  }
}), Eve = ["null", "undefined"];
function yg(e) {
  return Eve.some((t) => t === e);
}
u(yg, "isDefaultValueBlacklisted");
var xve = /* @__PURE__ */ u((e) => {
  if (!e)
    return "";
  if (typeof e == "string")
    return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, "str");
function TA(e) {
  return !!e.__docgenInfo;
}
u(TA, "hasDocgen");
function Sve(e) {
  return e != null && Object.keys(e).length > 0;
}
u(Sve, "isValidDocgenSection");
function Tve(e, t) {
  return TA(e) ? e.__docgenInfo[t] : null;
}
u(Tve, "getDocgenSection");
function A8(e) {
  return TA(e) ? xve(e.__docgenInfo.description) : "";
}
u(A8, "getDocgenDescription");
var Ma;
(function(e) {
  e.start = "/**", e.nostart = "/***", e.delim = "*", e.end = "*/";
})(Ma = Ma || (Ma = {}));
function $8(e) {
  return /^\s+$/.test(e);
}
u($8, "isSpace");
function C8(e) {
  const t = e.match(/\r+$/);
  return t == null ? ["", e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
u(C8, "splitCR");
function Zi(e) {
  const t = e.match(/^\s+/);
  return t == null ? ["", e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
u(Zi, "splitSpace");
function k8(e) {
  return e.split(/\n/);
}
u(k8, "splitLines");
function P8(e = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: !1, description: "", problems: [], source: [] }, e);
}
u(P8, "seedSpec");
function O8(e = {}) {
  return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, e);
}
u(O8, "seedTokens");
var Ave = /^@\S+/;
function R8({ fence: e = "```" } = {}) {
  const t = j8(e), r = /* @__PURE__ */ u((n, o) => t(n) ? !o : o, "toggleFence");
  return /* @__PURE__ */ u(function(n) {
    const o = [[]];
    let a = !1;
    for (const i of n)
      Ave.test(i.tokens.description) && !a ? o.push([i]) : o[o.length - 1].push(i), a = r(i.tokens.description, a);
    return o;
  }, "parseBlock");
}
u(R8, "getParser");
function j8(e) {
  return typeof e == "string" ? (t) => t.split(e).length % 2 === 0 : e;
}
u(j8, "getFencer");
function I8({ startLine: e = 0, markers: t = Ma } = {}) {
  let r = null, n = e;
  return /* @__PURE__ */ u(function(o) {
    let a = o;
    const i = O8();
    if ([i.lineEnd, a] = C8(a), [i.start, a] = Zi(a), r === null && a.startsWith(t.start) && !a.startsWith(t.nostart) && (r = [], i.delimiter = a.slice(0, t.start.length), a = a.slice(t.start.length), [i.postDelimiter, a] = Zi(a)), r === null)
      return n++, null;
    const s = a.trimRight().endsWith(t.end);
    if (i.delimiter === "" && a.startsWith(t.delim) && !a.startsWith(t.end) && (i.delimiter = t.delim, a = a.slice(t.delim.length), [i.postDelimiter, a] = Zi(a)), s) {
      const d = a.trimRight();
      i.end = a.slice(d.length - t.end.length), a = d.slice(0, -t.end.length);
    }
    if (i.description = a, r.push({ number: n, source: o, tokens: i }), n++, s) {
      const d = r.slice();
      return r = null, d;
    }
    return null;
  }, "parseSource");
}
u(I8, "getParser");
function N8({ tokenizers: e }) {
  return /* @__PURE__ */ u(function(t) {
    var r;
    let n = P8({ source: t });
    for (const o of e)
      if (n = o(n), !((r = n.problems[n.problems.length - 1]) === null || r === void 0) && r.critical)
        break;
    return n;
  }, "parseSpec");
}
u(N8, "getParser");
function M8() {
  return (e) => {
    const { tokens: t } = e.source[0], r = t.description.match(/\s*(@(\S+))(\s*)/);
    return r === null ? (e.problems.push({
      code: "spec:tag:prefix",
      message: 'tag should start with "@" symbol',
      line: e.source[0].number,
      critical: !0
    }), e) : (t.tag = r[1], t.postTag = r[3], t.description = t.description.slice(r[0].length), e.tag = r[2], e);
  };
}
u(M8, "tagTokenizer");
function D8(e = "compact") {
  const t = q8(e);
  return (r) => {
    let n = 0, o = [];
    for (const [s, { tokens: d }] of r.source.entries()) {
      let l = "";
      if (s === 0 && d.description[0] !== "{")
        return r;
      for (const p of d.description)
        if (p === "{" && n++, p === "}" && n--, l += p, n === 0)
          break;
      if (o.push([d, l]), n === 0)
        break;
    }
    if (n !== 0)
      return r.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: r.source[0].number,
        critical: !0
      }), r;
    const a = [], i = o[0][0].postDelimiter.length;
    for (const [s, [d, l]] of o.entries())
      d.type = l, s > 0 && (d.type = d.postDelimiter.slice(i) + l, d.postDelimiter = d.postDelimiter.slice(0, i)), [d.postType, d.description] = Zi(d.description.slice(l.length)), a.push(d.type);
    return a[0] = a[0].slice(1), a[a.length - 1] = a[a.length - 1].slice(0, -1), r.type = t(a), r;
  };
}
u(D8, "typeTokenizer");
var $ve = /* @__PURE__ */ u((e) => e.trim(), "trim");
function q8(e) {
  return e === "compact" ? (t) => t.map($ve).join("") : e === "preserve" ? (t) => t.join(`
`) : e;
}
u(q8, "getJoiner");
var Cve = /* @__PURE__ */ u((e) => e && e.startsWith('"') && e.endsWith('"'), "isQuoted");
function L8() {
  const e = /* @__PURE__ */ u((t, { tokens: r }, n) => r.type === "" ? t : n, "typeEnd");
  return (t) => {
    const { tokens: r } = t.source[t.source.reduce(e, 0)], n = r.description.trimLeft(), o = n.split('"');
    if (o.length > 1 && o[0] === "" && o.length % 2 === 1)
      return t.name = o[1], r.name = `"${o[1]}"`, [r.postName, r.description] = Zi(n.slice(r.name.length)), t;
    let a = 0, i = "", s = !1, d;
    for (const p of n) {
      if (a === 0 && $8(p))
        break;
      p === "[" && a++, p === "]" && a--, i += p;
    }
    if (a !== 0)
      return t.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: t.source[0].number,
        critical: !0
      }), t;
    const l = i;
    if (i[0] === "[" && i[i.length - 1] === "]") {
      s = !0, i = i.slice(1, -1);
      const p = i.split("=");
      if (i = p[0].trim(), p[1] !== void 0 && (d = p.slice(1).join("=").trim()), i === "")
        return t.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: t.source[0].number,
          critical: !0
        }), t;
      if (d === "")
        return t.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: t.source[0].number,
          critical: !0
        }), t;
      if (!Cve(d) && /=(?!>)/.test(d))
        return t.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: t.source[0].number,
          critical: !0
        }), t;
    }
    return t.optional = s, t.name = i, r.name = l, d !== void 0 && (t.default = d), [r.postName, r.description] = Zi(n.slice(r.name.length)), t;
  };
}
u(L8, "nameTokenizer");
function F8(e = "compact", t = Ma) {
  const r = AA(e);
  return (n) => (n.description = r(n.source, t), n);
}
u(F8, "descriptionTokenizer");
function AA(e) {
  return e === "compact" ? U8 : e === "preserve" ? B8 : e;
}
u(AA, "getJoiner");
function U8(e, t = Ma) {
  return e.map(({ tokens: { description: r } }) => r.trim()).filter((r) => r !== "").join(" ");
}
u(U8, "compactJoiner");
var kve = /* @__PURE__ */ u((e, { tokens: t }, r) => t.type === "" ? e : r, "lineNo"), Pve = /* @__PURE__ */ u(({ tokens: e }) => (e.delimiter === "" ? e.start : e.postDelimiter.slice(1)) + e.description, "getDescription");
function B8(e, t = Ma) {
  if (e.length === 0)
    return "";
  e[0].tokens.description === "" && e[0].tokens.delimiter === t.start && (e = e.slice(1));
  const r = e[e.length - 1];
  return r !== void 0 && r.tokens.description === "" && r.tokens.end.endsWith(t.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(kve, 0)), e.map(Pve).join(`
`);
}
u(B8, "preserveJoiner");
function H8({ startLine: e = 0, fence: t = "```", spacing: r = "compact", markers: n = Ma, tokenizers: o = [
  M8(),
  D8(r),
  L8(),
  F8(r)
] } = {}) {
  if (e < 0 || e % 1 > 0)
    throw new Error("Invalid startLine");
  const a = I8({ startLine: e, markers: n }), i = R8({ fence: t }), s = N8({ tokenizers: o }), d = AA(r);
  return function(l) {
    const p = [];
    for (const f of k8(l)) {
      const h = a(f);
      if (h === null)
        continue;
      const m = i(h), g = m.slice(1).map(s);
      p.push({
        description: d(m[0], n),
        tags: g,
        source: h,
        problems: g.reduce((w, _) => w.concat(_.problems), [])
      });
    }
    return p;
  };
}
u(H8, "getParser");
function V8(e) {
  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.lineEnd;
}
u(V8, "join");
function Ove() {
  return (e) => e.source.map(({ tokens: t }) => V8(t)).join(`
`);
}
u(Ove, "getStringifier");
function z8(e, t = {}) {
  return H8(t)(e);
}
u(z8, "parse");
var $A = ar(_ve(), 1);
function J8(e) {
  return e != null && e.includes("@");
}
u(J8, "containsJsDoc");
function W8(e) {
  const t = `/**
` + (e ?? "").split(`
`).map((n) => ` * ${n}`).join(`
`) + `
*/`, r = z8(t, {
    spacing: "preserve"
  });
  if (!r || r.length === 0)
    throw new Error("Cannot parse JSDoc tags.");
  return r[0];
}
u(W8, "parse");
var Rve = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
}, jve = /* @__PURE__ */ u((e, t = Rve) => {
  if (!J8(e))
    return {
      includesJsDoc: !1,
      ignore: !1
    };
  const r = W8(e), n = G8(r, t.tags);
  return n.ignore ? {
    includesJsDoc: !0,
    ignore: !0
  } : {
    includesJsDoc: !0,
    ignore: !1,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: r.description.trim(),
    extractedTags: n
  };
}, "parseJsDoc");
function G8(e, t) {
  const r = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: !1
  };
  for (const n of e.tags)
    if (!(t !== void 0 && !t.includes(n.tag)))
      if (n.tag === "ignore") {
        r.ignore = !0;
        break;
      } else
        switch (n.tag) {
          // arg & argument are aliases for param.
          case "param":
          case "arg":
          case "argument": {
            const o = Y8(n);
            o != null && (r.params == null && (r.params = []), r.params.push(o));
            break;
          }
          case "deprecated": {
            const o = X8(n);
            o != null && (r.deprecated = o);
            break;
          }
          case "returns": {
            const o = Q8(n);
            o != null && (r.returns = o);
            break;
          }
        }
  return r;
}
u(G8, "extractJsDocTags");
function K8(e) {
  return e.replace(/[\.-]$/, "");
}
u(K8, "normaliseParamName");
function Y8(e) {
  if (!e.name || e.name === "-")
    return null;
  const t = PA(e.type);
  return {
    name: e.name,
    type: t,
    description: kA(e.description),
    getPrettyName: /* @__PURE__ */ u(() => K8(e.name), "getPrettyName"),
    getTypeName: /* @__PURE__ */ u(() => t ? OA(t) : null, "getTypeName")
  };
}
u(Y8, "extractParam");
function X8(e) {
  return e.name ? CA(e.name, e.description) : null;
}
u(X8, "extractDeprecated");
function CA(e, t) {
  const r = e === "" ? t : `${e} ${t}`;
  return kA(r);
}
u(CA, "joinNameAndDescription");
function kA(e) {
  const t = e.replace(/^- /g, "").trim();
  return t === "" ? null : t;
}
u(kA, "normaliseDescription");
function Q8(e) {
  const t = PA(e.type);
  return t ? {
    type: t,
    description: CA(e.name, e.description),
    getTypeName: /* @__PURE__ */ u(() => OA(t), "getTypeName")
  } : null;
}
u(Q8, "extractReturns");
var ii = (0, $A.stringifyRules)(), Ive = ii.JsdocTypeObject;
ii.JsdocTypeAny = () => "any";
ii.JsdocTypeObject = (e, t) => `(${Ive(e, t)})`;
ii.JsdocTypeOptional = (e, t) => t(e.element);
ii.JsdocTypeNullable = (e, t) => t(e.element);
ii.JsdocTypeNotNullable = (e, t) => t(e.element);
ii.JsdocTypeUnion = (e, t) => e.elements.map(t).join("|");
function PA(e) {
  try {
    return (0, $A.parse)(e, "typescript");
  } catch {
    return null;
  }
}
u(PA, "extractType");
function OA(e) {
  return (0, $A.transform)(ii, e);
}
u(OA, "extractTypeName");
var Nve = 90, Mve = 50;
function RA(e) {
  return e.length > Nve;
}
u(RA, "isTooLongForTypeSummary");
function Z8(e) {
  return e.length > Mve;
}
u(Z8, "isTooLongForDefaultValueSummary");
function rr(e, t) {
  return e === t ? { summary: e } : { summary: e, detail: t };
}
u(rr, "createSummaryValue");
function Dve(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!yg(r))
      return Z8(r) ? rr(t?.name, r) : rr(r);
  }
  return null;
}
u(Dve, "createDefaultValue");
function jA({ name: e, value: t, elements: r, raw: n }) {
  return t ?? (r != null ? r.map(jA).join(" | ") : n ?? e);
}
u(jA, "generateUnionElement");
function e6({ name: e, raw: t, elements: r }) {
  return r != null ? rr(r.map(jA).join(" | ")) : t != null ? rr(t.replace(/^\|\s*/, "")) : rr(e);
}
u(e6, "generateUnion");
function t6({ type: e, raw: t }) {
  return t != null ? rr(t) : rr(e);
}
u(t6, "generateFuncSignature");
function r6({ type: e, raw: t }) {
  return t != null ? RA(t) ? rr(e, t) : rr(t) : rr(e);
}
u(r6, "generateObjectSignature");
function n6(e) {
  const { type: t } = e;
  return t === "object" ? r6(e) : t6(e);
}
u(n6, "generateSignature");
function o6({ name: e, raw: t }) {
  return t != null ? RA(t) ? rr(e, t) : rr(t) : rr(e);
}
u(o6, "generateDefault");
function qve(e) {
  if (e == null)
    return null;
  switch (e.name) {
    case "union":
      return e6(e);
    case "signature":
      return n6(e);
    default:
      return o6(e);
  }
}
u(qve, "createType");
function Lve({ defaultValue: e }) {
  if (e != null) {
    const { value: t } = e;
    if (!yg(t))
      return rr(t);
  }
  return null;
}
u(Lve, "createDefaultValue");
function Fve({ tsType: e, required: t }) {
  if (e == null)
    return null;
  let r = e.name;
  return t || (r = r.replace(" | undefined", "")), rr(
    ["Array", "Record", "signature"].includes(e.name) ? e.raw : r
  );
}
u(Fve, "createType");
function a6(e) {
  return e != null ? rr(e.name) : null;
}
u(a6, "createType");
function i6(e) {
  const { computed: t, func: r } = e;
  return typeof t > "u" && typeof r > "u";
}
u(i6, "isReactDocgenTypescript");
function s6(e) {
  return e ? e.name === "string" ? !0 : e.name === "enum" ? Array.isArray(e.value) && e.value.every(
    ({ value: t }) => typeof t == "string" && t[0] === '"' && t[t.length - 1] === '"'
  ) : !1 : !1;
}
u(s6, "isStringValued");
function l6(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!yg(r))
      return i6(e) && s6(t) ? rr(JSON.stringify(r)) : rr(r);
  }
  return null;
}
u(l6, "createDefaultValue");
function Uve(e, t, r) {
  const { description: n, required: o, defaultValue: a } = r;
  return {
    name: e,
    type: a6(t),
    required: o,
    description: n,
    defaultValue: l6(a, t)
  };
}
u(Uve, "createBasicPropDef");
function Bve(e, t) {
  if (t?.includesJsDoc) {
    const { description: r, extractedTags: n } = t;
    r != null && (e.description = t.description);
    const o = {
      ...n,
      params: n?.params?.map(
        (a) => ({
          name: a.getPrettyName(),
          description: a.description
        })
      )
    };
    Object.values(o).filter(Boolean).length > 0 && (e.jsDocTags = o);
  }
  return e;
}
u(Bve, "applyJsDocResult");
function Hve(e, t, r, n) {
  const o = jve(t.description);
  return o.includesJsDoc && o.ignore ? null : {
    propDef: n(e, t, o),
    jsDocTags: o.extractedTags,
    docgenInfo: t,
    typeSystem: r
  };
}
u(Hve, "extractProp");
function Vve(e) {
  return e != null ? A8(e) : "";
}
u(Vve, "extractComponentDescription");
var Ka = /* @__PURE__ */ u((...e) => {
  const t = {}, r = e.filter(Boolean), n = r.reduce((o, a) => (Object.entries(a).forEach(([i, s]) => {
    const d = o[i];
    Array.isArray(s) || typeof d > "u" ? o[i] = s : Yr(s) && Yr(d) ? t[i] = !0 : typeof s < "u" && (o[i] = s);
  }), o), {});
  return Object.keys(t).forEach((o) => {
    const a = r.filter(Boolean).map((i) => i[o]).filter((i) => typeof i < "u");
    a.every((i) => Yr(i)) ? n[o] = Ka(...a) : n[o] = a[a.length - 1];
  }), n;
}, "combineParameters"), zve = "storybook/docs", Jve = `${zve}/snippet-rendered`;
function c6() {
}
u(c6, "noop");
function u6(e, t) {
  return e === t || Number.isNaN(e) && Number.isNaN(t);
}
u(u6, "eq");
function d6(e, t, r) {
  return pl(e, t, void 0, void 0, void 0, void 0, r);
}
u(d6, "isEqualWith");
function pl(e, t, r, n, o, a, i) {
  const s = i(e, t, r, n, o, a);
  if (s !== void 0)
    return s;
  if (typeof e == typeof t)
    switch (typeof e) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return e === t;
      case "number":
        return e === t || Object.is(e, t);
      case "function":
        return e === t;
      case "object":
        return Sl(e, t, a, i);
    }
  return Sl(e, t, a, i);
}
u(pl, "isEqualWithImpl");
function Sl(e, t, r, n) {
  if (Object.is(e, t))
    return !0;
  let o = Bh(e), a = Bh(t);
  if (o === o0 && (o = vf), a === o0 && (a = vf), o !== a)
    return !1;
  switch (o) {
    case qJ:
      return e.toString() === t.toString();
    case LJ: {
      const d = e.valueOf(), l = t.valueOf();
      return u6(d, l);
    }
    case FJ:
    case BJ:
    case UJ:
      return Object.is(e.valueOf(), t.valueOf());
    case DJ:
      return e.source === t.source && e.flags === t.flags;
    case Xbe:
      return e === t;
  }
  r = r ?? /* @__PURE__ */ new Map();
  const i = r.get(e), s = r.get(t);
  if (i != null && s != null)
    return i === t;
  r.set(e, t), r.set(t, e);
  try {
    switch (o) {
      case HJ: {
        if (e.size !== t.size)
          return !1;
        for (const [d, l] of e.entries())
          if (!t.has(d) || !pl(l, t.get(d), d, e, t, r, n))
            return !1;
        return !0;
      }
      case VJ: {
        if (e.size !== t.size)
          return !1;
        const d = Array.from(e.values()), l = Array.from(t.values());
        for (let p = 0; p < d.length; p++) {
          const f = d[p], h = l.findIndex((m) => pl(f, m, void 0, e, t, r, n));
          if (h === -1)
            return !1;
          l.splice(h, 1);
        }
        return !0;
      }
      case zJ:
      case GJ:
      case KJ:
      case YJ:
      case XJ:
      case Zbe:
      case QJ:
      case ZJ:
      case e8:
      case eve:
      case t8:
      case r8: {
        if (typeof Buffer < "u" && Buffer.isBuffer(e) !== Buffer.isBuffer(t) || e.length !== t.length)
          return !1;
        for (let d = 0; d < e.length; d++)
          if (!pl(e[d], t[d], d, e, t, r, n))
            return !1;
        return !0;
      }
      case JJ:
        return e.byteLength !== t.byteLength ? !1 : Sl(new Uint8Array(e), new Uint8Array(t), r, n);
      case WJ:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset ? !1 : Sl(new Uint8Array(e), new Uint8Array(t), r, n);
      case Qbe:
        return e.name === t.name && e.message === t.message;
      case vf: {
        if (!(Sl(e.constructor, t.constructor, r, n) || Yr(e) && Yr(t)))
          return !1;
        const d = [...Object.keys(e), ...Uh(e)], l = [...Object.keys(t), ...Uh(t)];
        if (d.length !== l.length)
          return !1;
        for (let p = 0; p < d.length; p++) {
          const f = d[p], h = e[f];
          if (!Object.hasOwn(t, f))
            return !1;
          const m = t[f];
          if (!pl(h, m, f, e, t, r, n))
            return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    r.delete(e), r.delete(t);
  }
}
u(Sl, "areObjectsEqual");
function p6(e, t) {
  return d6(e, t, c6);
}
u(p6, "isEqual");
var Wve = "Invariant failed";
function uo(e, t) {
  if (!e)
    throw new Error(Wve);
}
u(uo, "invariant");
var f6 = G({
  "../node_modules/entities/lib/maps/entities.json"(e, t) {
    t.exports = { Aacute: "Ã", aacute: "Ã¡", Abreve: "Ä‚", abreve: "Äƒ", ac: "âˆ¾", acd: "âˆ¿", acE: "âˆ¾Ì³", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", Acy: "Ð", acy: "Ð°", AElig: "Ã†", aelig: "Ã¦", af: "â¡", Afr: "ð”„", afr: "ð”ž", Agrave: "Ã€", agrave: "Ã ", alefsym: "â„µ", aleph: "â„µ", Alpha: "Î‘", alpha: "Î±", Amacr: "Ä€", amacr: "Ä", amalg: "â¨¿", amp: "&", AMP: "&", andand: "â©•", And: "â©“", and: "âˆ§", andd: "â©œ", andslope: "â©˜", andv: "â©š", ang: "âˆ ", ange: "â¦¤", angle: "âˆ ", angmsdaa: "â¦¨", angmsdab: "â¦©", angmsdac: "â¦ª", angmsdad: "â¦«", angmsdae: "â¦¬", angmsdaf: "â¦­", angmsdag: "â¦®", angmsdah: "â¦¯", angmsd: "âˆ¡", angrt: "âˆŸ", angrtvb: "âŠ¾", angrtvbd: "â¦", angsph: "âˆ¢", angst: "Ã…", angzarr: "â¼", Aogon: "Ä„", aogon: "Ä…", Aopf: "ð”¸", aopf: "ð•’", apacir: "â©¯", ap: "â‰ˆ", apE: "â©°", ape: "â‰Š", apid: "â‰‹", apos: "'", ApplyFunction: "â¡", approx: "â‰ˆ", approxeq: "â‰Š", Aring: "Ã…", aring: "Ã¥", Ascr: "ð’œ", ascr: "ð’¶", Assign: "â‰”", ast: "*", asymp: "â‰ˆ", asympeq: "â‰", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", awconint: "âˆ³", awint: "â¨‘", backcong: "â‰Œ", backepsilon: "Ï¶", backprime: "â€µ", backsim: "âˆ½", backsimeq: "â‹", Backslash: "âˆ–", Barv: "â«§", barvee: "âŠ½", barwed: "âŒ…", Barwed: "âŒ†", barwedge: "âŒ…", bbrk: "âŽµ", bbrktbrk: "âŽ¶", bcong: "â‰Œ", Bcy: "Ð‘", bcy: "Ð±", bdquo: "â€ž", becaus: "âˆµ", because: "âˆµ", Because: "âˆµ", bemptyv: "â¦°", bepsi: "Ï¶", bernou: "â„¬", Bernoullis: "â„¬", Beta: "Î’", beta: "Î²", beth: "â„¶", between: "â‰¬", Bfr: "ð”…", bfr: "ð”Ÿ", bigcap: "â‹‚", bigcirc: "â—¯", bigcup: "â‹ƒ", bigodot: "â¨€", bigoplus: "â¨", bigotimes: "â¨‚", bigsqcup: "â¨†", bigstar: "â˜…", bigtriangledown: "â–½", bigtriangleup: "â–³", biguplus: "â¨„", bigvee: "â‹", bigwedge: "â‹€", bkarow: "â¤", blacklozenge: "â§«", blacksquare: "â–ª", blacktriangle: "â–´", blacktriangledown: "â–¾", blacktriangleleft: "â—‚", blacktriangleright: "â–¸", blank: "â£", blk12: "â–’", blk14: "â–‘", blk34: "â–“", block: "â–ˆ", bne: "=âƒ¥", bnequiv: "â‰¡âƒ¥", bNot: "â«­", bnot: "âŒ", Bopf: "ð”¹", bopf: "ð•“", bot: "âŠ¥", bottom: "âŠ¥", bowtie: "â‹ˆ", boxbox: "â§‰", boxdl: "â”", boxdL: "â••", boxDl: "â•–", boxDL: "â•—", boxdr: "â”Œ", boxdR: "â•’", boxDr: "â•“", boxDR: "â•”", boxh: "â”€", boxH: "â•", boxhd: "â”¬", boxHd: "â•¤", boxhD: "â•¥", boxHD: "â•¦", boxhu: "â”´", boxHu: "â•§", boxhU: "â•¨", boxHU: "â•©", boxminus: "âŠŸ", boxplus: "âŠž", boxtimes: "âŠ ", boxul: "â”˜", boxuL: "â•›", boxUl: "â•œ", boxUL: "â•", boxur: "â””", boxuR: "â•˜", boxUr: "â•™", boxUR: "â•š", boxv: "â”‚", boxV: "â•‘", boxvh: "â”¼", boxvH: "â•ª", boxVh: "â•«", boxVH: "â•¬", boxvl: "â”¤", boxvL: "â•¡", boxVl: "â•¢", boxVL: "â•£", boxvr: "â”œ", boxvR: "â•ž", boxVr: "â•Ÿ", boxVR: "â• ", bprime: "â€µ", breve: "Ë˜", Breve: "Ë˜", brvbar: "Â¦", bscr: "ð’·", Bscr: "â„¬", bsemi: "â", bsim: "âˆ½", bsime: "â‹", bsolb: "â§…", bsol: "\\", bsolhsub: "âŸˆ", bull: "â€¢", bullet: "â€¢", bump: "â‰Ž", bumpE: "âª®", bumpe: "â‰", Bumpeq: "â‰Ž", bumpeq: "â‰", Cacute: "Ä†", cacute: "Ä‡", capand: "â©„", capbrcup: "â©‰", capcap: "â©‹", cap: "âˆ©", Cap: "â‹’", capcup: "â©‡", capdot: "â©€", CapitalDifferentialD: "â……", caps: "âˆ©ï¸€", caret: "â", caron: "Ë‡", Cayleys: "â„­", ccaps: "â©", Ccaron: "ÄŒ", ccaron: "Ä", Ccedil: "Ã‡", ccedil: "Ã§", Ccirc: "Äˆ", ccirc: "Ä‰", Cconint: "âˆ°", ccups: "â©Œ", ccupssm: "â©", Cdot: "ÄŠ", cdot: "Ä‹", cedil: "Â¸", Cedilla: "Â¸", cemptyv: "â¦²", cent: "Â¢", centerdot: "Â·", CenterDot: "Â·", cfr: "ð” ", Cfr: "â„­", CHcy: "Ð§", chcy: "Ñ‡", check: "âœ“", checkmark: "âœ“", Chi: "Î§", chi: "Ï‡", circ: "Ë†", circeq: "â‰—", circlearrowleft: "â†º", circlearrowright: "â†»", circledast: "âŠ›", circledcirc: "âŠš", circleddash: "âŠ", CircleDot: "âŠ™", circledR: "Â®", circledS: "â“ˆ", CircleMinus: "âŠ–", CirclePlus: "âŠ•", CircleTimes: "âŠ—", cir: "â—‹", cirE: "â§ƒ", cire: "â‰—", cirfnint: "â¨", cirmid: "â«¯", cirscir: "â§‚", ClockwiseContourIntegral: "âˆ²", CloseCurlyDoubleQuote: "â€", CloseCurlyQuote: "â€™", clubs: "â™£", clubsuit: "â™£", colon: ":", Colon: "âˆ·", Colone: "â©´", colone: "â‰”", coloneq: "â‰”", comma: ",", commat: "@", comp: "âˆ", compfn: "âˆ˜", complement: "âˆ", complexes: "â„‚", cong: "â‰…", congdot: "â©­", Congruent: "â‰¡", conint: "âˆ®", Conint: "âˆ¯", ContourIntegral: "âˆ®", copf: "ð•”", Copf: "â„‚", coprod: "âˆ", Coproduct: "âˆ", copy: "Â©", COPY: "Â©", copysr: "â„—", CounterClockwiseContourIntegral: "âˆ³", crarr: "â†µ", cross: "âœ—", Cross: "â¨¯", Cscr: "ð’ž", cscr: "ð’¸", csub: "â«", csube: "â«‘", csup: "â«", csupe: "â«’", ctdot: "â‹¯", cudarrl: "â¤¸", cudarrr: "â¤µ", cuepr: "â‹ž", cuesc: "â‹Ÿ", cularr: "â†¶", cularrp: "â¤½", cupbrcap: "â©ˆ", cupcap: "â©†", CupCap: "â‰", cup: "âˆª", Cup: "â‹“", cupcup: "â©Š", cupdot: "âŠ", cupor: "â©…", cups: "âˆªï¸€", curarr: "â†·", curarrm: "â¤¼", curlyeqprec: "â‹ž", curlyeqsucc: "â‹Ÿ", curlyvee: "â‹Ž", curlywedge: "â‹", curren: "Â¤", curvearrowleft: "â†¶", curvearrowright: "â†·", cuvee: "â‹Ž", cuwed: "â‹", cwconint: "âˆ²", cwint: "âˆ±", cylcty: "âŒ­", dagger: "â€ ", Dagger: "â€¡", daleth: "â„¸", darr: "â†“", Darr: "â†¡", dArr: "â‡“", dash: "â€", Dashv: "â«¤", dashv: "âŠ£", dbkarow: "â¤", dblac: "Ë", Dcaron: "ÄŽ", dcaron: "Ä", Dcy: "Ð”", dcy: "Ð´", ddagger: "â€¡", ddarr: "â‡Š", DD: "â……", dd: "â…†", DDotrahd: "â¤‘", ddotseq: "â©·", deg: "Â°", Del: "âˆ‡", Delta: "Î”", delta: "Î´", demptyv: "â¦±", dfisht: "â¥¿", Dfr: "ð”‡", dfr: "ð”¡", dHar: "â¥¥", dharl: "â‡ƒ", dharr: "â‡‚", DiacriticalAcute: "Â´", DiacriticalDot: "Ë™", DiacriticalDoubleAcute: "Ë", DiacriticalGrave: "`", DiacriticalTilde: "Ëœ", diam: "â‹„", diamond: "â‹„", Diamond: "â‹„", diamondsuit: "â™¦", diams: "â™¦", die: "Â¨", DifferentialD: "â…†", digamma: "Ï", disin: "â‹²", div: "Ã·", divide: "Ã·", divideontimes: "â‹‡", divonx: "â‹‡", DJcy: "Ð‚", djcy: "Ñ’", dlcorn: "âŒž", dlcrop: "âŒ", dollar: "$", Dopf: "ð”»", dopf: "ð••", Dot: "Â¨", dot: "Ë™", DotDot: "âƒœ", doteq: "â‰", doteqdot: "â‰‘", DotEqual: "â‰", dotminus: "âˆ¸", dotplus: "âˆ”", dotsquare: "âŠ¡", doublebarwedge: "âŒ†", DoubleContourIntegral: "âˆ¯", DoubleDot: "Â¨", DoubleDownArrow: "â‡“", DoubleLeftArrow: "â‡", DoubleLeftRightArrow: "â‡”", DoubleLeftTee: "â«¤", DoubleLongLeftArrow: "âŸ¸", DoubleLongLeftRightArrow: "âŸº", DoubleLongRightArrow: "âŸ¹", DoubleRightArrow: "â‡’", DoubleRightTee: "âŠ¨", DoubleUpArrow: "â‡‘", DoubleUpDownArrow: "â‡•", DoubleVerticalBar: "âˆ¥", DownArrowBar: "â¤“", downarrow: "â†“", DownArrow: "â†“", Downarrow: "â‡“", DownArrowUpArrow: "â‡µ", DownBreve: "Ì‘", downdownarrows: "â‡Š", downharpoonleft: "â‡ƒ", downharpoonright: "â‡‚", DownLeftRightVector: "â¥", DownLeftTeeVector: "â¥ž", DownLeftVectorBar: "â¥–", DownLeftVector: "â†½", DownRightTeeVector: "â¥Ÿ", DownRightVectorBar: "â¥—", DownRightVector: "â‡", DownTeeArrow: "â†§", DownTee: "âŠ¤", drbkarow: "â¤", drcorn: "âŒŸ", drcrop: "âŒŒ", Dscr: "ð’Ÿ", dscr: "ð’¹", DScy: "Ð…", dscy: "Ñ•", dsol: "â§¶", Dstrok: "Ä", dstrok: "Ä‘", dtdot: "â‹±", dtri: "â–¿", dtrif: "â–¾", duarr: "â‡µ", duhar: "â¥¯", dwangle: "â¦¦", DZcy: "Ð", dzcy: "ÑŸ", dzigrarr: "âŸ¿", Eacute: "Ã‰", eacute: "Ã©", easter: "â©®", Ecaron: "Äš", ecaron: "Ä›", Ecirc: "ÃŠ", ecirc: "Ãª", ecir: "â‰–", ecolon: "â‰•", Ecy: "Ð­", ecy: "Ñ", eDDot: "â©·", Edot: "Ä–", edot: "Ä—", eDot: "â‰‘", ee: "â…‡", efDot: "â‰’", Efr: "ð”ˆ", efr: "ð”¢", eg: "âªš", Egrave: "Ãˆ", egrave: "Ã¨", egs: "âª–", egsdot: "âª˜", el: "âª™", Element: "âˆˆ", elinters: "â§", ell: "â„“", els: "âª•", elsdot: "âª—", Emacr: "Ä’", emacr: "Ä“", empty: "âˆ…", emptyset: "âˆ…", EmptySmallSquare: "â—»", emptyv: "âˆ…", EmptyVerySmallSquare: "â–«", emsp13: "â€„", emsp14: "â€…", emsp: "â€ƒ", ENG: "ÅŠ", eng: "Å‹", ensp: "â€‚", Eogon: "Ä˜", eogon: "Ä™", Eopf: "ð”¼", eopf: "ð•–", epar: "â‹•", eparsl: "â§£", eplus: "â©±", epsi: "Îµ", Epsilon: "Î•", epsilon: "Îµ", epsiv: "Ïµ", eqcirc: "â‰–", eqcolon: "â‰•", eqsim: "â‰‚", eqslantgtr: "âª–", eqslantless: "âª•", Equal: "â©µ", equals: "=", EqualTilde: "â‰‚", equest: "â‰Ÿ", Equilibrium: "â‡Œ", equiv: "â‰¡", equivDD: "â©¸", eqvparsl: "â§¥", erarr: "â¥±", erDot: "â‰“", escr: "â„¯", Escr: "â„°", esdot: "â‰", Esim: "â©³", esim: "â‰‚", Eta: "Î—", eta: "Î·", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", euro: "â‚¬", excl: "!", exist: "âˆƒ", Exists: "âˆƒ", expectation: "â„°", exponentiale: "â…‡", ExponentialE: "â…‡", fallingdotseq: "â‰’", Fcy: "Ð¤", fcy: "Ñ„", female: "â™€", ffilig: "ï¬ƒ", fflig: "ï¬€", ffllig: "ï¬„", Ffr: "ð”‰", ffr: "ð”£", filig: "ï¬", FilledSmallSquare: "â—¼", FilledVerySmallSquare: "â–ª", fjlig: "fj", flat: "â™­", fllig: "ï¬‚", fltns: "â–±", fnof: "Æ’", Fopf: "ð”½", fopf: "ð•—", forall: "âˆ€", ForAll: "âˆ€", fork: "â‹”", forkv: "â«™", Fouriertrf: "â„±", fpartint: "â¨", frac12: "Â½", frac13: "â…“", frac14: "Â¼", frac15: "â…•", frac16: "â…™", frac18: "â…›", frac23: "â…”", frac25: "â…–", frac34: "Â¾", frac35: "â…—", frac38: "â…œ", frac45: "â…˜", frac56: "â…š", frac58: "â…", frac78: "â…ž", frasl: "â„", frown: "âŒ¢", fscr: "ð’»", Fscr: "â„±", gacute: "Çµ", Gamma: "Î“", gamma: "Î³", Gammad: "Ïœ", gammad: "Ï", gap: "âª†", Gbreve: "Äž", gbreve: "ÄŸ", Gcedil: "Ä¢", Gcirc: "Äœ", gcirc: "Ä", Gcy: "Ð“", gcy: "Ð³", Gdot: "Ä ", gdot: "Ä¡", ge: "â‰¥", gE: "â‰§", gEl: "âªŒ", gel: "â‹›", geq: "â‰¥", geqq: "â‰§", geqslant: "â©¾", gescc: "âª©", ges: "â©¾", gesdot: "âª€", gesdoto: "âª‚", gesdotol: "âª„", gesl: "â‹›ï¸€", gesles: "âª”", Gfr: "ð”Š", gfr: "ð”¤", gg: "â‰«", Gg: "â‹™", ggg: "â‹™", gimel: "â„·", GJcy: "Ðƒ", gjcy: "Ñ“", gla: "âª¥", gl: "â‰·", glE: "âª’", glj: "âª¤", gnap: "âªŠ", gnapprox: "âªŠ", gne: "âªˆ", gnE: "â‰©", gneq: "âªˆ", gneqq: "â‰©", gnsim: "â‹§", Gopf: "ð”¾", gopf: "ð•˜", grave: "`", GreaterEqual: "â‰¥", GreaterEqualLess: "â‹›", GreaterFullEqual: "â‰§", GreaterGreater: "âª¢", GreaterLess: "â‰·", GreaterSlantEqual: "â©¾", GreaterTilde: "â‰³", Gscr: "ð’¢", gscr: "â„Š", gsim: "â‰³", gsime: "âªŽ", gsiml: "âª", gtcc: "âª§", gtcir: "â©º", gt: ">", GT: ">", Gt: "â‰«", gtdot: "â‹—", gtlPar: "â¦•", gtquest: "â©¼", gtrapprox: "âª†", gtrarr: "â¥¸", gtrdot: "â‹—", gtreqless: "â‹›", gtreqqless: "âªŒ", gtrless: "â‰·", gtrsim: "â‰³", gvertneqq: "â‰©ï¸€", gvnE: "â‰©ï¸€", Hacek: "Ë‡", hairsp: "â€Š", half: "Â½", hamilt: "â„‹", HARDcy: "Ðª", hardcy: "ÑŠ", harrcir: "â¥ˆ", harr: "â†”", hArr: "â‡”", harrw: "â†­", Hat: "^", hbar: "â„", Hcirc: "Ä¤", hcirc: "Ä¥", hearts: "â™¥", heartsuit: "â™¥", hellip: "â€¦", hercon: "âŠ¹", hfr: "ð”¥", Hfr: "â„Œ", HilbertSpace: "â„‹", hksearow: "â¤¥", hkswarow: "â¤¦", hoarr: "â‡¿", homtht: "âˆ»", hookleftarrow: "â†©", hookrightarrow: "â†ª", hopf: "ð•™", Hopf: "â„", horbar: "â€•", HorizontalLine: "â”€", hscr: "ð’½", Hscr: "â„‹", hslash: "â„", Hstrok: "Ä¦", hstrok: "Ä§", HumpDownHump: "â‰Ž", HumpEqual: "â‰", hybull: "âƒ", hyphen: "â€", Iacute: "Ã", iacute: "Ã­", ic: "â£", Icirc: "ÃŽ", icirc: "Ã®", Icy: "Ð˜", icy: "Ð¸", Idot: "Ä°", IEcy: "Ð•", iecy: "Ðµ", iexcl: "Â¡", iff: "â‡”", ifr: "ð”¦", Ifr: "â„‘", Igrave: "ÃŒ", igrave: "Ã¬", ii: "â…ˆ", iiiint: "â¨Œ", iiint: "âˆ­", iinfin: "â§œ", iiota: "â„©", IJlig: "Ä²", ijlig: "Ä³", Imacr: "Äª", imacr: "Ä«", image: "â„‘", ImaginaryI: "â…ˆ", imagline: "â„", imagpart: "â„‘", imath: "Ä±", Im: "â„‘", imof: "âŠ·", imped: "Æµ", Implies: "â‡’", incare: "â„…", in: "âˆˆ", infin: "âˆž", infintie: "â§", inodot: "Ä±", intcal: "âŠº", int: "âˆ«", Int: "âˆ¬", integers: "â„¤", Integral: "âˆ«", intercal: "âŠº", Intersection: "â‹‚", intlarhk: "â¨—", intprod: "â¨¼", InvisibleComma: "â£", InvisibleTimes: "â¢", IOcy: "Ð", iocy: "Ñ‘", Iogon: "Ä®", iogon: "Ä¯", Iopf: "ð•€", iopf: "ð•š", Iota: "Î™", iota: "Î¹", iprod: "â¨¼", iquest: "Â¿", iscr: "ð’¾", Iscr: "â„", isin: "âˆˆ", isindot: "â‹µ", isinE: "â‹¹", isins: "â‹´", isinsv: "â‹³", isinv: "âˆˆ", it: "â¢", Itilde: "Ä¨", itilde: "Ä©", Iukcy: "Ð†", iukcy: "Ñ–", Iuml: "Ã", iuml: "Ã¯", Jcirc: "Ä´", jcirc: "Äµ", Jcy: "Ð™", jcy: "Ð¹", Jfr: "ð”", jfr: "ð”§", jmath: "È·", Jopf: "ð•", jopf: "ð•›", Jscr: "ð’¥", jscr: "ð’¿", Jsercy: "Ðˆ", jsercy: "Ñ˜", Jukcy: "Ð„", jukcy: "Ñ”", Kappa: "Îš", kappa: "Îº", kappav: "Ï°", Kcedil: "Ä¶", kcedil: "Ä·", Kcy: "Ðš", kcy: "Ðº", Kfr: "ð”Ž", kfr: "ð”¨", kgreen: "Ä¸", KHcy: "Ð¥", khcy: "Ñ…", KJcy: "ÐŒ", kjcy: "Ñœ", Kopf: "ð•‚", kopf: "ð•œ", Kscr: "ð’¦", kscr: "ð“€", lAarr: "â‡š", Lacute: "Ä¹", lacute: "Äº", laemptyv: "â¦´", lagran: "â„’", Lambda: "Î›", lambda: "Î»", lang: "âŸ¨", Lang: "âŸª", langd: "â¦‘", langle: "âŸ¨", lap: "âª…", Laplacetrf: "â„’", laquo: "Â«", larrb: "â‡¤", larrbfs: "â¤Ÿ", larr: "â†", Larr: "â†ž", lArr: "â‡", larrfs: "â¤", larrhk: "â†©", larrlp: "â†«", larrpl: "â¤¹", larrsim: "â¥³", larrtl: "â†¢", latail: "â¤™", lAtail: "â¤›", lat: "âª«", late: "âª­", lates: "âª­ï¸€", lbarr: "â¤Œ", lBarr: "â¤Ž", lbbrk: "â²", lbrace: "{", lbrack: "[", lbrke: "â¦‹", lbrksld: "â¦", lbrkslu: "â¦", Lcaron: "Ä½", lcaron: "Ä¾", Lcedil: "Ä»", lcedil: "Ä¼", lceil: "âŒˆ", lcub: "{", Lcy: "Ð›", lcy: "Ð»", ldca: "â¤¶", ldquo: "â€œ", ldquor: "â€ž", ldrdhar: "â¥§", ldrushar: "â¥‹", ldsh: "â†²", le: "â‰¤", lE: "â‰¦", LeftAngleBracket: "âŸ¨", LeftArrowBar: "â‡¤", leftarrow: "â†", LeftArrow: "â†", Leftarrow: "â‡", LeftArrowRightArrow: "â‡†", leftarrowtail: "â†¢", LeftCeiling: "âŒˆ", LeftDoubleBracket: "âŸ¦", LeftDownTeeVector: "â¥¡", LeftDownVectorBar: "â¥™", LeftDownVector: "â‡ƒ", LeftFloor: "âŒŠ", leftharpoondown: "â†½", leftharpoonup: "â†¼", leftleftarrows: "â‡‡", leftrightarrow: "â†”", LeftRightArrow: "â†”", Leftrightarrow: "â‡”", leftrightarrows: "â‡†", leftrightharpoons: "â‡‹", leftrightsquigarrow: "â†­", LeftRightVector: "â¥Ž", LeftTeeArrow: "â†¤", LeftTee: "âŠ£", LeftTeeVector: "â¥š", leftthreetimes: "â‹‹", LeftTriangleBar: "â§", LeftTriangle: "âŠ²", LeftTriangleEqual: "âŠ´", LeftUpDownVector: "â¥‘", LeftUpTeeVector: "â¥ ", LeftUpVectorBar: "â¥˜", LeftUpVector: "â†¿", LeftVectorBar: "â¥’", LeftVector: "â†¼", lEg: "âª‹", leg: "â‹š", leq: "â‰¤", leqq: "â‰¦", leqslant: "â©½", lescc: "âª¨", les: "â©½", lesdot: "â©¿", lesdoto: "âª", lesdotor: "âªƒ", lesg: "â‹šï¸€", lesges: "âª“", lessapprox: "âª…", lessdot: "â‹–", lesseqgtr: "â‹š", lesseqqgtr: "âª‹", LessEqualGreater: "â‹š", LessFullEqual: "â‰¦", LessGreater: "â‰¶", lessgtr: "â‰¶", LessLess: "âª¡", lesssim: "â‰²", LessSlantEqual: "â©½", LessTilde: "â‰²", lfisht: "â¥¼", lfloor: "âŒŠ", Lfr: "ð”", lfr: "ð”©", lg: "â‰¶", lgE: "âª‘", lHar: "â¥¢", lhard: "â†½", lharu: "â†¼", lharul: "â¥ª", lhblk: "â–„", LJcy: "Ð‰", ljcy: "Ñ™", llarr: "â‡‡", ll: "â‰ª", Ll: "â‹˜", llcorner: "âŒž", Lleftarrow: "â‡š", llhard: "â¥«", lltri: "â—º", Lmidot: "Ä¿", lmidot: "Å€", lmoustache: "âŽ°", lmoust: "âŽ°", lnap: "âª‰", lnapprox: "âª‰", lne: "âª‡", lnE: "â‰¨", lneq: "âª‡", lneqq: "â‰¨", lnsim: "â‹¦", loang: "âŸ¬", loarr: "â‡½", lobrk: "âŸ¦", longleftarrow: "âŸµ", LongLeftArrow: "âŸµ", Longleftarrow: "âŸ¸", longleftrightarrow: "âŸ·", LongLeftRightArrow: "âŸ·", Longleftrightarrow: "âŸº", longmapsto: "âŸ¼", longrightarrow: "âŸ¶", LongRightArrow: "âŸ¶", Longrightarrow: "âŸ¹", looparrowleft: "â†«", looparrowright: "â†¬", lopar: "â¦…", Lopf: "ð•ƒ", lopf: "ð•", loplus: "â¨­", lotimes: "â¨´", lowast: "âˆ—", lowbar: "_", LowerLeftArrow: "â†™", LowerRightArrow: "â†˜", loz: "â—Š", lozenge: "â—Š", lozf: "â§«", lpar: "(", lparlt: "â¦“", lrarr: "â‡†", lrcorner: "âŒŸ", lrhar: "â‡‹", lrhard: "â¥­", lrm: "â€Ž", lrtri: "âŠ¿", lsaquo: "â€¹", lscr: "ð“", Lscr: "â„’", lsh: "â†°", Lsh: "â†°", lsim: "â‰²", lsime: "âª", lsimg: "âª", lsqb: "[", lsquo: "â€˜", lsquor: "â€š", Lstrok: "Å", lstrok: "Å‚", ltcc: "âª¦", ltcir: "â©¹", lt: "<", LT: "<", Lt: "â‰ª", ltdot: "â‹–", lthree: "â‹‹", ltimes: "â‹‰", ltlarr: "â¥¶", ltquest: "â©»", ltri: "â—ƒ", ltrie: "âŠ´", ltrif: "â—‚", ltrPar: "â¦–", lurdshar: "â¥Š", luruhar: "â¥¦", lvertneqq: "â‰¨ï¸€", lvnE: "â‰¨ï¸€", macr: "Â¯", male: "â™‚", malt: "âœ ", maltese: "âœ ", Map: "â¤…", map: "â†¦", mapsto: "â†¦", mapstodown: "â†§", mapstoleft: "â†¤", mapstoup: "â†¥", marker: "â–®", mcomma: "â¨©", Mcy: "Ðœ", mcy: "Ð¼", mdash: "â€”", mDDot: "âˆº", measuredangle: "âˆ¡", MediumSpace: "âŸ", Mellintrf: "â„³", Mfr: "ð”", mfr: "ð”ª", mho: "â„§", micro: "Âµ", midast: "*", midcir: "â«°", mid: "âˆ£", middot: "Â·", minusb: "âŠŸ", minus: "âˆ’", minusd: "âˆ¸", minusdu: "â¨ª", MinusPlus: "âˆ“", mlcp: "â«›", mldr: "â€¦", mnplus: "âˆ“", models: "âŠ§", Mopf: "ð•„", mopf: "ð•ž", mp: "âˆ“", mscr: "ð“‚", Mscr: "â„³", mstpos: "âˆ¾", Mu: "Îœ", mu: "Î¼", multimap: "âŠ¸", mumap: "âŠ¸", nabla: "âˆ‡", Nacute: "Åƒ", nacute: "Å„", nang: "âˆ âƒ’", nap: "â‰‰", napE: "â©°Ì¸", napid: "â‰‹Ì¸", napos: "Å‰", napprox: "â‰‰", natural: "â™®", naturals: "â„•", natur: "â™®", nbsp: "Â ", nbump: "â‰ŽÌ¸", nbumpe: "â‰Ì¸", ncap: "â©ƒ", Ncaron: "Å‡", ncaron: "Åˆ", Ncedil: "Å…", ncedil: "Å†", ncong: "â‰‡", ncongdot: "â©­Ì¸", ncup: "â©‚", Ncy: "Ð", ncy: "Ð½", ndash: "â€“", nearhk: "â¤¤", nearr: "â†—", neArr: "â‡—", nearrow: "â†—", ne: "â‰ ", nedot: "â‰Ì¸", NegativeMediumSpace: "â€‹", NegativeThickSpace: "â€‹", NegativeThinSpace: "â€‹", NegativeVeryThinSpace: "â€‹", nequiv: "â‰¢", nesear: "â¤¨", nesim: "â‰‚Ì¸", NestedGreaterGreater: "â‰«", NestedLessLess: "â‰ª", NewLine: `
`, nexist: "âˆ„", nexists: "âˆ„", Nfr: "ð”‘", nfr: "ð”«", ngE: "â‰§Ì¸", nge: "â‰±", ngeq: "â‰±", ngeqq: "â‰§Ì¸", ngeqslant: "â©¾Ì¸", nges: "â©¾Ì¸", nGg: "â‹™Ì¸", ngsim: "â‰µ", nGt: "â‰«âƒ’", ngt: "â‰¯", ngtr: "â‰¯", nGtv: "â‰«Ì¸", nharr: "â†®", nhArr: "â‡Ž", nhpar: "â«²", ni: "âˆ‹", nis: "â‹¼", nisd: "â‹º", niv: "âˆ‹", NJcy: "ÐŠ", njcy: "Ñš", nlarr: "â†š", nlArr: "â‡", nldr: "â€¥", nlE: "â‰¦Ì¸", nle: "â‰°", nleftarrow: "â†š", nLeftarrow: "â‡", nleftrightarrow: "â†®", nLeftrightarrow: "â‡Ž", nleq: "â‰°", nleqq: "â‰¦Ì¸", nleqslant: "â©½Ì¸", nles: "â©½Ì¸", nless: "â‰®", nLl: "â‹˜Ì¸", nlsim: "â‰´", nLt: "â‰ªâƒ’", nlt: "â‰®", nltri: "â‹ª", nltrie: "â‹¬", nLtv: "â‰ªÌ¸", nmid: "âˆ¤", NoBreak: "â ", NonBreakingSpace: "Â ", nopf: "ð•Ÿ", Nopf: "â„•", Not: "â«¬", not: "Â¬", NotCongruent: "â‰¢", NotCupCap: "â‰­", NotDoubleVerticalBar: "âˆ¦", NotElement: "âˆ‰", NotEqual: "â‰ ", NotEqualTilde: "â‰‚Ì¸", NotExists: "âˆ„", NotGreater: "â‰¯", NotGreaterEqual: "â‰±", NotGreaterFullEqual: "â‰§Ì¸", NotGreaterGreater: "â‰«Ì¸", NotGreaterLess: "â‰¹", NotGreaterSlantEqual: "â©¾Ì¸", NotGreaterTilde: "â‰µ", NotHumpDownHump: "â‰ŽÌ¸", NotHumpEqual: "â‰Ì¸", notin: "âˆ‰", notindot: "â‹µÌ¸", notinE: "â‹¹Ì¸", notinva: "âˆ‰", notinvb: "â‹·", notinvc: "â‹¶", NotLeftTriangleBar: "â§Ì¸", NotLeftTriangle: "â‹ª", NotLeftTriangleEqual: "â‹¬", NotLess: "â‰®", NotLessEqual: "â‰°", NotLessGreater: "â‰¸", NotLessLess: "â‰ªÌ¸", NotLessSlantEqual: "â©½Ì¸", NotLessTilde: "â‰´", NotNestedGreaterGreater: "âª¢Ì¸", NotNestedLessLess: "âª¡Ì¸", notni: "âˆŒ", notniva: "âˆŒ", notnivb: "â‹¾", notnivc: "â‹½", NotPrecedes: "âŠ€", NotPrecedesEqual: "âª¯Ì¸", NotPrecedesSlantEqual: "â‹ ", NotReverseElement: "âˆŒ", NotRightTriangleBar: "â§Ì¸", NotRightTriangle: "â‹«", NotRightTriangleEqual: "â‹­", NotSquareSubset: "âŠÌ¸", NotSquareSubsetEqual: "â‹¢", NotSquareSuperset: "âŠÌ¸", NotSquareSupersetEqual: "â‹£", NotSubset: "âŠ‚âƒ’", NotSubsetEqual: "âŠˆ", NotSucceeds: "âŠ", NotSucceedsEqual: "âª°Ì¸", NotSucceedsSlantEqual: "â‹¡", NotSucceedsTilde: "â‰¿Ì¸", NotSuperset: "âŠƒâƒ’", NotSupersetEqual: "âŠ‰", NotTilde: "â‰", NotTildeEqual: "â‰„", NotTildeFullEqual: "â‰‡", NotTildeTilde: "â‰‰", NotVerticalBar: "âˆ¤", nparallel: "âˆ¦", npar: "âˆ¦", nparsl: "â«½âƒ¥", npart: "âˆ‚Ì¸", npolint: "â¨”", npr: "âŠ€", nprcue: "â‹ ", nprec: "âŠ€", npreceq: "âª¯Ì¸", npre: "âª¯Ì¸", nrarrc: "â¤³Ì¸", nrarr: "â†›", nrArr: "â‡", nrarrw: "â†Ì¸", nrightarrow: "â†›", nRightarrow: "â‡", nrtri: "â‹«", nrtrie: "â‹­", nsc: "âŠ", nsccue: "â‹¡", nsce: "âª°Ì¸", Nscr: "ð’©", nscr: "ð“ƒ", nshortmid: "âˆ¤", nshortparallel: "âˆ¦", nsim: "â‰", nsime: "â‰„", nsimeq: "â‰„", nsmid: "âˆ¤", nspar: "âˆ¦", nsqsube: "â‹¢", nsqsupe: "â‹£", nsub: "âŠ„", nsubE: "â«…Ì¸", nsube: "âŠˆ", nsubset: "âŠ‚âƒ’", nsubseteq: "âŠˆ", nsubseteqq: "â«…Ì¸", nsucc: "âŠ", nsucceq: "âª°Ì¸", nsup: "âŠ…", nsupE: "â«†Ì¸", nsupe: "âŠ‰", nsupset: "âŠƒâƒ’", nsupseteq: "âŠ‰", nsupseteqq: "â«†Ì¸", ntgl: "â‰¹", Ntilde: "Ã‘", ntilde: "Ã±", ntlg: "â‰¸", ntriangleleft: "â‹ª", ntrianglelefteq: "â‹¬", ntriangleright: "â‹«", ntrianglerighteq: "â‹­", Nu: "Î", nu: "Î½", num: "#", numero: "â„–", numsp: "â€‡", nvap: "â‰âƒ’", nvdash: "âŠ¬", nvDash: "âŠ­", nVdash: "âŠ®", nVDash: "âŠ¯", nvge: "â‰¥âƒ’", nvgt: ">âƒ’", nvHarr: "â¤„", nvinfin: "â§ž", nvlArr: "â¤‚", nvle: "â‰¤âƒ’", nvlt: "<âƒ’", nvltrie: "âŠ´âƒ’", nvrArr: "â¤ƒ", nvrtrie: "âŠµâƒ’", nvsim: "âˆ¼âƒ’", nwarhk: "â¤£", nwarr: "â†–", nwArr: "â‡–", nwarrow: "â†–", nwnear: "â¤§", Oacute: "Ã“", oacute: "Ã³", oast: "âŠ›", Ocirc: "Ã”", ocirc: "Ã´", ocir: "âŠš", Ocy: "Ðž", ocy: "Ð¾", odash: "âŠ", Odblac: "Å", odblac: "Å‘", odiv: "â¨¸", odot: "âŠ™", odsold: "â¦¼", OElig: "Å’", oelig: "Å“", ofcir: "â¦¿", Ofr: "ð”’", ofr: "ð”¬", ogon: "Ë›", Ograve: "Ã’", ograve: "Ã²", ogt: "â§", ohbar: "â¦µ", ohm: "Î©", oint: "âˆ®", olarr: "â†º", olcir: "â¦¾", olcross: "â¦»", oline: "â€¾", olt: "â§€", Omacr: "ÅŒ", omacr: "Å", Omega: "Î©", omega: "Ï‰", Omicron: "ÎŸ", omicron: "Î¿", omid: "â¦¶", ominus: "âŠ–", Oopf: "ð•†", oopf: "ð• ", opar: "â¦·", OpenCurlyDoubleQuote: "â€œ", OpenCurlyQuote: "â€˜", operp: "â¦¹", oplus: "âŠ•", orarr: "â†»", Or: "â©”", or: "âˆ¨", ord: "â©", order: "â„´", orderof: "â„´", ordf: "Âª", ordm: "Âº", origof: "âŠ¶", oror: "â©–", orslope: "â©—", orv: "â©›", oS: "â“ˆ", Oscr: "ð’ª", oscr: "â„´", Oslash: "Ã˜", oslash: "Ã¸", osol: "âŠ˜", Otilde: "Ã•", otilde: "Ãµ", otimesas: "â¨¶", Otimes: "â¨·", otimes: "âŠ—", Ouml: "Ã–", ouml: "Ã¶", ovbar: "âŒ½", OverBar: "â€¾", OverBrace: "âž", OverBracket: "âŽ´", OverParenthesis: "âœ", para: "Â¶", parallel: "âˆ¥", par: "âˆ¥", parsim: "â«³", parsl: "â«½", part: "âˆ‚", PartialD: "âˆ‚", Pcy: "ÐŸ", pcy: "Ð¿", percnt: "%", period: ".", permil: "â€°", perp: "âŠ¥", pertenk: "â€±", Pfr: "ð”“", pfr: "ð”­", Phi: "Î¦", phi: "Ï†", phiv: "Ï•", phmmat: "â„³", phone: "â˜Ž", Pi: "Î ", pi: "Ï€", pitchfork: "â‹”", piv: "Ï–", planck: "â„", planckh: "â„Ž", plankv: "â„", plusacir: "â¨£", plusb: "âŠž", pluscir: "â¨¢", plus: "+", plusdo: "âˆ”", plusdu: "â¨¥", pluse: "â©²", PlusMinus: "Â±", plusmn: "Â±", plussim: "â¨¦", plustwo: "â¨§", pm: "Â±", Poincareplane: "â„Œ", pointint: "â¨•", popf: "ð•¡", Popf: "â„™", pound: "Â£", prap: "âª·", Pr: "âª»", pr: "â‰º", prcue: "â‰¼", precapprox: "âª·", prec: "â‰º", preccurlyeq: "â‰¼", Precedes: "â‰º", PrecedesEqual: "âª¯", PrecedesSlantEqual: "â‰¼", PrecedesTilde: "â‰¾", preceq: "âª¯", precnapprox: "âª¹", precneqq: "âªµ", precnsim: "â‹¨", pre: "âª¯", prE: "âª³", precsim: "â‰¾", prime: "â€²", Prime: "â€³", primes: "â„™", prnap: "âª¹", prnE: "âªµ", prnsim: "â‹¨", prod: "âˆ", Product: "âˆ", profalar: "âŒ®", profline: "âŒ’", profsurf: "âŒ“", prop: "âˆ", Proportional: "âˆ", Proportion: "âˆ·", propto: "âˆ", prsim: "â‰¾", prurel: "âŠ°", Pscr: "ð’«", pscr: "ð“…", Psi: "Î¨", psi: "Ïˆ", puncsp: "â€ˆ", Qfr: "ð””", qfr: "ð”®", qint: "â¨Œ", qopf: "ð•¢", Qopf: "â„š", qprime: "â—", Qscr: "ð’¬", qscr: "ð“†", quaternions: "â„", quatint: "â¨–", quest: "?", questeq: "â‰Ÿ", quot: '"', QUOT: '"', rAarr: "â‡›", race: "âˆ½Ì±", Racute: "Å”", racute: "Å•", radic: "âˆš", raemptyv: "â¦³", rang: "âŸ©", Rang: "âŸ«", rangd: "â¦’", range: "â¦¥", rangle: "âŸ©", raquo: "Â»", rarrap: "â¥µ", rarrb: "â‡¥", rarrbfs: "â¤ ", rarrc: "â¤³", rarr: "â†’", Rarr: "â† ", rArr: "â‡’", rarrfs: "â¤ž", rarrhk: "â†ª", rarrlp: "â†¬", rarrpl: "â¥…", rarrsim: "â¥´", Rarrtl: "â¤–", rarrtl: "â†£", rarrw: "â†", ratail: "â¤š", rAtail: "â¤œ", ratio: "âˆ¶", rationals: "â„š", rbarr: "â¤", rBarr: "â¤", RBarr: "â¤", rbbrk: "â³", rbrace: "}", rbrack: "]", rbrke: "â¦Œ", rbrksld: "â¦Ž", rbrkslu: "â¦", Rcaron: "Å˜", rcaron: "Å™", Rcedil: "Å–", rcedil: "Å—", rceil: "âŒ‰", rcub: "}", Rcy: "Ð ", rcy: "Ñ€", rdca: "â¤·", rdldhar: "â¥©", rdquo: "â€", rdquor: "â€", rdsh: "â†³", real: "â„œ", realine: "â„›", realpart: "â„œ", reals: "â„", Re: "â„œ", rect: "â–­", reg: "Â®", REG: "Â®", ReverseElement: "âˆ‹", ReverseEquilibrium: "â‡‹", ReverseUpEquilibrium: "â¥¯", rfisht: "â¥½", rfloor: "âŒ‹", rfr: "ð”¯", Rfr: "â„œ", rHar: "â¥¤", rhard: "â‡", rharu: "â‡€", rharul: "â¥¬", Rho: "Î¡", rho: "Ï", rhov: "Ï±", RightAngleBracket: "âŸ©", RightArrowBar: "â‡¥", rightarrow: "â†’", RightArrow: "â†’", Rightarrow: "â‡’", RightArrowLeftArrow: "â‡„", rightarrowtail: "â†£", RightCeiling: "âŒ‰", RightDoubleBracket: "âŸ§", RightDownTeeVector: "â¥", RightDownVectorBar: "â¥•", RightDownVector: "â‡‚", RightFloor: "âŒ‹", rightharpoondown: "â‡", rightharpoonup: "â‡€", rightleftarrows: "â‡„", rightleftharpoons: "â‡Œ", rightrightarrows: "â‡‰", rightsquigarrow: "â†", RightTeeArrow: "â†¦", RightTee: "âŠ¢", RightTeeVector: "â¥›", rightthreetimes: "â‹Œ", RightTriangleBar: "â§", RightTriangle: "âŠ³", RightTriangleEqual: "âŠµ", RightUpDownVector: "â¥", RightUpTeeVector: "â¥œ", RightUpVectorBar: "â¥”", RightUpVector: "â†¾", RightVectorBar: "â¥“", RightVector: "â‡€", ring: "Ëš", risingdotseq: "â‰“", rlarr: "â‡„", rlhar: "â‡Œ", rlm: "â€", rmoustache: "âŽ±", rmoust: "âŽ±", rnmid: "â«®", roang: "âŸ­", roarr: "â‡¾", robrk: "âŸ§", ropar: "â¦†", ropf: "ð•£", Ropf: "â„", roplus: "â¨®", rotimes: "â¨µ", RoundImplies: "â¥°", rpar: ")", rpargt: "â¦”", rppolint: "â¨’", rrarr: "â‡‰", Rrightarrow: "â‡›", rsaquo: "â€º", rscr: "ð“‡", Rscr: "â„›", rsh: "â†±", Rsh: "â†±", rsqb: "]", rsquo: "â€™", rsquor: "â€™", rthree: "â‹Œ", rtimes: "â‹Š", rtri: "â–¹", rtrie: "âŠµ", rtrif: "â–¸", rtriltri: "â§Ž", RuleDelayed: "â§´", ruluhar: "â¥¨", rx: "â„ž", Sacute: "Åš", sacute: "Å›", sbquo: "â€š", scap: "âª¸", Scaron: "Å ", scaron: "Å¡", Sc: "âª¼", sc: "â‰»", sccue: "â‰½", sce: "âª°", scE: "âª´", Scedil: "Åž", scedil: "ÅŸ", Scirc: "Åœ", scirc: "Å", scnap: "âªº", scnE: "âª¶", scnsim: "â‹©", scpolint: "â¨“", scsim: "â‰¿", Scy: "Ð¡", scy: "Ñ", sdotb: "âŠ¡", sdot: "â‹…", sdote: "â©¦", searhk: "â¤¥", searr: "â†˜", seArr: "â‡˜", searrow: "â†˜", sect: "Â§", semi: ";", seswar: "â¤©", setminus: "âˆ–", setmn: "âˆ–", sext: "âœ¶", Sfr: "ð”–", sfr: "ð”°", sfrown: "âŒ¢", sharp: "â™¯", SHCHcy: "Ð©", shchcy: "Ñ‰", SHcy: "Ð¨", shcy: "Ñˆ", ShortDownArrow: "â†“", ShortLeftArrow: "â†", shortmid: "âˆ£", shortparallel: "âˆ¥", ShortRightArrow: "â†’", ShortUpArrow: "â†‘", shy: "Â­", Sigma: "Î£", sigma: "Ïƒ", sigmaf: "Ï‚", sigmav: "Ï‚", sim: "âˆ¼", simdot: "â©ª", sime: "â‰ƒ", simeq: "â‰ƒ", simg: "âªž", simgE: "âª ", siml: "âª", simlE: "âªŸ", simne: "â‰†", simplus: "â¨¤", simrarr: "â¥²", slarr: "â†", SmallCircle: "âˆ˜", smallsetminus: "âˆ–", smashp: "â¨³", smeparsl: "â§¤", smid: "âˆ£", smile: "âŒ£", smt: "âªª", smte: "âª¬", smtes: "âª¬ï¸€", SOFTcy: "Ð¬", softcy: "ÑŒ", solbar: "âŒ¿", solb: "â§„", sol: "/", Sopf: "ð•Š", sopf: "ð•¤", spades: "â™ ", spadesuit: "â™ ", spar: "âˆ¥", sqcap: "âŠ“", sqcaps: "âŠ“ï¸€", sqcup: "âŠ”", sqcups: "âŠ”ï¸€", Sqrt: "âˆš", sqsub: "âŠ", sqsube: "âŠ‘", sqsubset: "âŠ", sqsubseteq: "âŠ‘", sqsup: "âŠ", sqsupe: "âŠ’", sqsupset: "âŠ", sqsupseteq: "âŠ’", square: "â–¡", Square: "â–¡", SquareIntersection: "âŠ“", SquareSubset: "âŠ", SquareSubsetEqual: "âŠ‘", SquareSuperset: "âŠ", SquareSupersetEqual: "âŠ’", SquareUnion: "âŠ”", squarf: "â–ª", squ: "â–¡", squf: "â–ª", srarr: "â†’", Sscr: "ð’®", sscr: "ð“ˆ", ssetmn: "âˆ–", ssmile: "âŒ£", sstarf: "â‹†", Star: "â‹†", star: "â˜†", starf: "â˜…", straightepsilon: "Ïµ", straightphi: "Ï•", strns: "Â¯", sub: "âŠ‚", Sub: "â‹", subdot: "âª½", subE: "â«…", sube: "âŠ†", subedot: "â«ƒ", submult: "â«", subnE: "â«‹", subne: "âŠŠ", subplus: "âª¿", subrarr: "â¥¹", subset: "âŠ‚", Subset: "â‹", subseteq: "âŠ†", subseteqq: "â«…", SubsetEqual: "âŠ†", subsetneq: "âŠŠ", subsetneqq: "â«‹", subsim: "â«‡", subsub: "â«•", subsup: "â«“", succapprox: "âª¸", succ: "â‰»", succcurlyeq: "â‰½", Succeeds: "â‰»", SucceedsEqual: "âª°", SucceedsSlantEqual: "â‰½", SucceedsTilde: "â‰¿", succeq: "âª°", succnapprox: "âªº", succneqq: "âª¶", succnsim: "â‹©", succsim: "â‰¿", SuchThat: "âˆ‹", sum: "âˆ‘", Sum: "âˆ‘", sung: "â™ª", sup1: "Â¹", sup2: "Â²", sup3: "Â³", sup: "âŠƒ", Sup: "â‹‘", supdot: "âª¾", supdsub: "â«˜", supE: "â«†", supe: "âŠ‡", supedot: "â«„", Superset: "âŠƒ", SupersetEqual: "âŠ‡", suphsol: "âŸ‰", suphsub: "â«—", suplarr: "â¥»", supmult: "â«‚", supnE: "â«Œ", supne: "âŠ‹", supplus: "â«€", supset: "âŠƒ", Supset: "â‹‘", supseteq: "âŠ‡", supseteqq: "â«†", supsetneq: "âŠ‹", supsetneqq: "â«Œ", supsim: "â«ˆ", supsub: "â«”", supsup: "â«–", swarhk: "â¤¦", swarr: "â†™", swArr: "â‡™", swarrow: "â†™", swnwar: "â¤ª", szlig: "ÃŸ", Tab: "	", target: "âŒ–", Tau: "Î¤", tau: "Ï„", tbrk: "âŽ´", Tcaron: "Å¤", tcaron: "Å¥", Tcedil: "Å¢", tcedil: "Å£", Tcy: "Ð¢", tcy: "Ñ‚", tdot: "âƒ›", telrec: "âŒ•", Tfr: "ð”—", tfr: "ð”±", there4: "âˆ´", therefore: "âˆ´", Therefore: "âˆ´", Theta: "Î˜", theta: "Î¸", thetasym: "Ï‘", thetav: "Ï‘", thickapprox: "â‰ˆ", thicksim: "âˆ¼", ThickSpace: "âŸâ€Š", ThinSpace: "â€‰", thinsp: "â€‰", thkap: "â‰ˆ", thksim: "âˆ¼", THORN: "Ãž", thorn: "Ã¾", tilde: "Ëœ", Tilde: "âˆ¼", TildeEqual: "â‰ƒ", TildeFullEqual: "â‰…", TildeTilde: "â‰ˆ", timesbar: "â¨±", timesb: "âŠ ", times: "Ã—", timesd: "â¨°", tint: "âˆ­", toea: "â¤¨", topbot: "âŒ¶", topcir: "â«±", top: "âŠ¤", Topf: "ð•‹", topf: "ð•¥", topfork: "â«š", tosa: "â¤©", tprime: "â€´", trade: "â„¢", TRADE: "â„¢", triangle: "â–µ", triangledown: "â–¿", triangleleft: "â—ƒ", trianglelefteq: "âŠ´", triangleq: "â‰œ", triangleright: "â–¹", trianglerighteq: "âŠµ", tridot: "â—¬", trie: "â‰œ", triminus: "â¨º", TripleDot: "âƒ›", triplus: "â¨¹", trisb: "â§", tritime: "â¨»", trpezium: "â¢", Tscr: "ð’¯", tscr: "ð“‰", TScy: "Ð¦", tscy: "Ñ†", TSHcy: "Ð‹", tshcy: "Ñ›", Tstrok: "Å¦", tstrok: "Å§", twixt: "â‰¬", twoheadleftarrow: "â†ž", twoheadrightarrow: "â† ", Uacute: "Ãš", uacute: "Ãº", uarr: "â†‘", Uarr: "â†Ÿ", uArr: "â‡‘", Uarrocir: "â¥‰", Ubrcy: "ÐŽ", ubrcy: "Ñž", Ubreve: "Å¬", ubreve: "Å­", Ucirc: "Ã›", ucirc: "Ã»", Ucy: "Ð£", ucy: "Ñƒ", udarr: "â‡…", Udblac: "Å°", udblac: "Å±", udhar: "â¥®", ufisht: "â¥¾", Ufr: "ð”˜", ufr: "ð”²", Ugrave: "Ã™", ugrave: "Ã¹", uHar: "â¥£", uharl: "â†¿", uharr: "â†¾", uhblk: "â–€", ulcorn: "âŒœ", ulcorner: "âŒœ", ulcrop: "âŒ", ultri: "â—¸", Umacr: "Åª", umacr: "Å«", uml: "Â¨", UnderBar: "_", UnderBrace: "âŸ", UnderBracket: "âŽµ", UnderParenthesis: "â", Union: "â‹ƒ", UnionPlus: "âŠŽ", Uogon: "Å²", uogon: "Å³", Uopf: "ð•Œ", uopf: "ð•¦", UpArrowBar: "â¤’", uparrow: "â†‘", UpArrow: "â†‘", Uparrow: "â‡‘", UpArrowDownArrow: "â‡…", updownarrow: "â†•", UpDownArrow: "â†•", Updownarrow: "â‡•", UpEquilibrium: "â¥®", upharpoonleft: "â†¿", upharpoonright: "â†¾", uplus: "âŠŽ", UpperLeftArrow: "â†–", UpperRightArrow: "â†—", upsi: "Ï…", Upsi: "Ï’", upsih: "Ï’", Upsilon: "Î¥", upsilon: "Ï…", UpTeeArrow: "â†¥", UpTee: "âŠ¥", upuparrows: "â‡ˆ", urcorn: "âŒ", urcorner: "âŒ", urcrop: "âŒŽ", Uring: "Å®", uring: "Å¯", urtri: "â—¹", Uscr: "ð’°", uscr: "ð“Š", utdot: "â‹°", Utilde: "Å¨", utilde: "Å©", utri: "â–µ", utrif: "â–´", uuarr: "â‡ˆ", Uuml: "Ãœ", uuml: "Ã¼", uwangle: "â¦§", vangrt: "â¦œ", varepsilon: "Ïµ", varkappa: "Ï°", varnothing: "âˆ…", varphi: "Ï•", varpi: "Ï–", varpropto: "âˆ", varr: "â†•", vArr: "â‡•", varrho: "Ï±", varsigma: "Ï‚", varsubsetneq: "âŠŠï¸€", varsubsetneqq: "â«‹ï¸€", varsupsetneq: "âŠ‹ï¸€", varsupsetneqq: "â«Œï¸€", vartheta: "Ï‘", vartriangleleft: "âŠ²", vartriangleright: "âŠ³", vBar: "â«¨", Vbar: "â««", vBarv: "â«©", Vcy: "Ð’", vcy: "Ð²", vdash: "âŠ¢", vDash: "âŠ¨", Vdash: "âŠ©", VDash: "âŠ«", Vdashl: "â«¦", veebar: "âŠ»", vee: "âˆ¨", Vee: "â‹", veeeq: "â‰š", vellip: "â‹®", verbar: "|", Verbar: "â€–", vert: "|", Vert: "â€–", VerticalBar: "âˆ£", VerticalLine: "|", VerticalSeparator: "â˜", VerticalTilde: "â‰€", VeryThinSpace: "â€Š", Vfr: "ð”™", vfr: "ð”³", vltri: "âŠ²", vnsub: "âŠ‚âƒ’", vnsup: "âŠƒâƒ’", Vopf: "ð•", vopf: "ð•§", vprop: "âˆ", vrtri: "âŠ³", Vscr: "ð’±", vscr: "ð“‹", vsubnE: "â«‹ï¸€", vsubne: "âŠŠï¸€", vsupnE: "â«Œï¸€", vsupne: "âŠ‹ï¸€", Vvdash: "âŠª", vzigzag: "â¦š", Wcirc: "Å´", wcirc: "Åµ", wedbar: "â©Ÿ", wedge: "âˆ§", Wedge: "â‹€", wedgeq: "â‰™", weierp: "â„˜", Wfr: "ð”š", wfr: "ð”´", Wopf: "ð•Ž", wopf: "ð•¨", wp: "â„˜", wr: "â‰€", wreath: "â‰€", Wscr: "ð’²", wscr: "ð“Œ", xcap: "â‹‚", xcirc: "â—¯", xcup: "â‹ƒ", xdtri: "â–½", Xfr: "ð”›", xfr: "ð”µ", xharr: "âŸ·", xhArr: "âŸº", Xi: "Îž", xi: "Î¾", xlarr: "âŸµ", xlArr: "âŸ¸", xmap: "âŸ¼", xnis: "â‹»", xodot: "â¨€", Xopf: "ð•", xopf: "ð•©", xoplus: "â¨", xotime: "â¨‚", xrarr: "âŸ¶", xrArr: "âŸ¹", Xscr: "ð’³", xscr: "ð“", xsqcup: "â¨†", xuplus: "â¨„", xutri: "â–³", xvee: "â‹", xwedge: "â‹€", Yacute: "Ã", yacute: "Ã½", YAcy: "Ð¯", yacy: "Ñ", Ycirc: "Å¶", ycirc: "Å·", Ycy: "Ð«", ycy: "Ñ‹", yen: "Â¥", Yfr: "ð”œ", yfr: "ð”¶", YIcy: "Ð‡", yicy: "Ñ—", Yopf: "ð•", yopf: "ð•ª", Yscr: "ð’´", yscr: "ð“Ž", YUcy: "Ð®", yucy: "ÑŽ", yuml: "Ã¿", Yuml: "Å¸", Zacute: "Å¹", zacute: "Åº", Zcaron: "Å½", zcaron: "Å¾", Zcy: "Ð—", zcy: "Ð·", Zdot: "Å»", zdot: "Å¼", zeetrf: "â„¨", ZeroWidthSpace: "â€‹", Zeta: "Î–", zeta: "Î¶", zfr: "ð”·", Zfr: "â„¨", ZHcy: "Ð–", zhcy: "Ð¶", zigrarr: "â‡", zopf: "ð•«", Zopf: "â„¤", Zscr: "ð’µ", zscr: "ð“", zwj: "â€", zwnj: "â€Œ" };
  }
}), Gve = G({
  "../node_modules/entities/lib/maps/legacy.json"(e, t) {
    t.exports = { Aacute: "Ã", aacute: "Ã¡", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", AElig: "Ã†", aelig: "Ã¦", Agrave: "Ã€", agrave: "Ã ", amp: "&", AMP: "&", Aring: "Ã…", aring: "Ã¥", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", brvbar: "Â¦", Ccedil: "Ã‡", ccedil: "Ã§", cedil: "Â¸", cent: "Â¢", copy: "Â©", COPY: "Â©", curren: "Â¤", deg: "Â°", divide: "Ã·", Eacute: "Ã‰", eacute: "Ã©", Ecirc: "ÃŠ", ecirc: "Ãª", Egrave: "Ãˆ", egrave: "Ã¨", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", frac12: "Â½", frac14: "Â¼", frac34: "Â¾", gt: ">", GT: ">", Iacute: "Ã", iacute: "Ã­", Icirc: "ÃŽ", icirc: "Ã®", iexcl: "Â¡", Igrave: "ÃŒ", igrave: "Ã¬", iquest: "Â¿", Iuml: "Ã", iuml: "Ã¯", laquo: "Â«", lt: "<", LT: "<", macr: "Â¯", micro: "Âµ", middot: "Â·", nbsp: "Â ", not: "Â¬", Ntilde: "Ã‘", ntilde: "Ã±", Oacute: "Ã“", oacute: "Ã³", Ocirc: "Ã”", ocirc: "Ã´", Ograve: "Ã’", ograve: "Ã²", ordf: "Âª", ordm: "Âº", Oslash: "Ã˜", oslash: "Ã¸", Otilde: "Ã•", otilde: "Ãµ", Ouml: "Ã–", ouml: "Ã¶", para: "Â¶", plusmn: "Â±", pound: "Â£", quot: '"', QUOT: '"', raquo: "Â»", reg: "Â®", REG: "Â®", sect: "Â§", shy: "Â­", sup1: "Â¹", sup2: "Â²", sup3: "Â³", szlig: "ÃŸ", THORN: "Ãž", thorn: "Ã¾", times: "Ã—", Uacute: "Ãš", uacute: "Ãº", Ucirc: "Ã›", ucirc: "Ã»", Ugrave: "Ã™", ugrave: "Ã¹", uml: "Â¨", Uuml: "Ãœ", uuml: "Ã¼", Yacute: "Ã", yacute: "Ã½", yen: "Â¥", yuml: "Ã¿" };
  }
}), h6 = G({
  "../node_modules/entities/lib/maps/xml.json"(e, t) {
    t.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
}), Kve = G({
  "../node_modules/entities/lib/maps/decode.json"(e, t) {
    t.exports = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
  }
}), Yve = G({
  "../node_modules/entities/lib/decode_codepoint.js"(e) {
    var t = e && e.__importDefault || function(a) {
      return a && a.__esModule ? a : { default: a };
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    var r = t(Kve()), n = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(a) {
        var i = "";
        return a > 65535 && (a -= 65536, i += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), i += String.fromCharCode(a), i;
      }
    );
    function o(a) {
      return a >= 55296 && a <= 57343 || a > 1114111 ? "ï¿½" : (a in r.default && (a = r.default[a]), n(a));
    }
    u(o, "decodeCodePoint"), e.default = o;
  }
}), VR = G({
  "../node_modules/entities/lib/decode.js"(e) {
    var t = e && e.__importDefault || function(p) {
      return p && p.__esModule ? p : { default: p };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0;
    var r = t(f6()), n = t(Gve()), o = t(h6()), a = t(Yve()), i = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    e.decodeXML = s(o.default), e.decodeHTMLStrict = s(r.default);
    function s(p) {
      var f = l(p);
      return function(h) {
        return String(h).replace(i, f);
      };
    }
    u(s, "getStrictDecoder");
    var d = /* @__PURE__ */ u(function(p, f) {
      return p < f ? 1 : -1;
    }, "sorter");
    e.decodeHTML = (function() {
      for (var p = Object.keys(n.default).sort(d), f = Object.keys(r.default).sort(d), h = 0, m = 0; h < f.length; h++)
        p[m] === f[h] ? (f[h] += ";?", m++) : f[h] += ";";
      var g = new RegExp("&(?:" + f.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), w = l(r.default);
      function _(b) {
        return b.substr(-1) !== ";" && (b += ";"), w(b);
      }
      return u(_, "replacer"), function(b) {
        return String(b).replace(g, _);
      };
    })();
    function l(p) {
      return /* @__PURE__ */ u(function(f) {
        if (f.charAt(1) === "#") {
          var h = f.charAt(2);
          return h === "X" || h === "x" ? a.default(parseInt(f.substr(3), 16)) : a.default(parseInt(f.substr(2), 10));
        }
        return p[f.slice(1, -1)] || f;
      }, "replace");
    }
    u(l, "getReplacer");
  }
}), zR = G({
  "../node_modules/entities/lib/encode.js"(e) {
    var t = e && e.__importDefault || function(x) {
      return x && x.__esModule ? x : { default: x };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0;
    var r = t(h6()), n = d(r.default), o = l(n);
    e.encodeXML = b(n);
    var a = t(f6()), i = d(a.default), s = l(i);
    e.encodeHTML = m(i, s), e.encodeNonAsciiHTML = b(i);
    function d(x) {
      return Object.keys(x).sort().reduce(function(P, R) {
        return P[x[R]] = "&" + R + ";", P;
      }, {});
    }
    u(d, "getInverseObj");
    function l(x) {
      for (var P = [], R = [], N = 0, C = Object.keys(x); N < C.length; N++) {
        var A = C[N];
        A.length === 1 ? P.push("\\" + A) : R.push(A);
      }
      P.sort();
      for (var E = 0; E < P.length - 1; E++) {
        for (var T = E; T < P.length - 1 && P[T].charCodeAt(1) + 1 === P[T + 1].charCodeAt(1); )
          T += 1;
        var O = 1 + T - E;
        O < 3 || P.splice(E, O, P[E] + "-" + P[T]);
      }
      return R.unshift("[" + P.join("") + "]"), new RegExp(R.join("|"), "g");
    }
    u(l, "getInverseReplacer");
    var p = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, f = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (function(x) {
          return x.codePointAt(0);
        })
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (function(x) {
          return (x.charCodeAt(0) - 55296) * 1024 + x.charCodeAt(1) - 56320 + 65536;
        })
      )
    );
    function h(x) {
      return "&#x" + (x.length > 1 ? f(x) : x.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    u(h, "singleCharReplacer");
    function m(x, P) {
      return function(R) {
        return R.replace(P, function(N) {
          return x[N];
        }).replace(p, h);
      };
    }
    u(m, "getInverse");
    var g = new RegExp(o.source + "|" + p.source, "g");
    function w(x) {
      return x.replace(g, h);
    }
    u(w, "escape"), e.escape = w;
    function _(x) {
      return x.replace(o, h);
    }
    u(_, "escapeUTF8"), e.escapeUTF8 = _;
    function b(x) {
      return function(P) {
        return P.replace(g, function(R) {
          return x[R] || h(R);
        });
      };
    }
    u(b, "getASCIIEncoder");
  }
}), Xve = G({
  "../node_modules/entities/lib/index.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeXMLStrict = e.decodeHTML5Strict = e.decodeHTML4Strict = e.decodeHTML5 = e.decodeHTML4 = e.decodeHTMLStrict = e.decodeHTML = e.decodeXML = e.encodeHTML5 = e.encodeHTML4 = e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = e.encode = e.decodeStrict = e.decode = void 0;
    var t = VR(), r = zR();
    function n(d, l) {
      return (!l || l <= 0 ? t.decodeXML : t.decodeHTML)(d);
    }
    u(n, "decode"), e.decode = n;
    function o(d, l) {
      return (!l || l <= 0 ? t.decodeXML : t.decodeHTMLStrict)(d);
    }
    u(o, "decodeStrict"), e.decodeStrict = o;
    function a(d, l) {
      return (!l || l <= 0 ? r.encodeXML : r.encodeHTML)(d);
    }
    u(a, "encode"), e.encode = a;
    var i = zR();
    Object.defineProperty(e, "encodeXML", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.encodeXML;
    }, "get") }), Object.defineProperty(e, "encodeHTML", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.encodeHTML;
    }, "get") }), Object.defineProperty(e, "encodeNonAsciiHTML", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.encodeNonAsciiHTML;
    }, "get") }), Object.defineProperty(e, "escape", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.escape;
    }, "get") }), Object.defineProperty(e, "escapeUTF8", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.escapeUTF8;
    }, "get") }), Object.defineProperty(e, "encodeHTML4", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.encodeHTML;
    }, "get") }), Object.defineProperty(e, "encodeHTML5", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return i.encodeHTML;
    }, "get") });
    var s = VR();
    Object.defineProperty(e, "decodeXML", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeXML;
    }, "get") }), Object.defineProperty(e, "decodeHTML", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTMLStrict", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeHTML4", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTML5", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTML4Strict", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeHTML5Strict", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeXMLStrict", { enumerable: !0, get: /* @__PURE__ */ u(function() {
      return s.decodeXML;
    }, "get") });
  }
}), Qve = G({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(e, t) {
    function r($, I) {
      if (!($ instanceof I))
        throw new TypeError("Cannot call a class as a function");
    }
    u(r, "_classCallCheck");
    function n($, I) {
      for (var D = 0; D < I.length; D++) {
        var F = I[D];
        F.enumerable = F.enumerable || !1, F.configurable = !0, "value" in F && (F.writable = !0), Object.defineProperty($, F.key, F);
      }
    }
    u(n, "_defineProperties");
    function o($, I, D) {
      return I && n($.prototype, I), D && n($, D), $;
    }
    u(o, "_createClass");
    function a($, I) {
      var D = typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
      if (!D) {
        if (Array.isArray($) || (D = i($)) || I && $ && typeof $.length == "number") {
          D && ($ = D);
          var F = 0, J = /* @__PURE__ */ u(function() {
          }, "F");
          return { s: J, n: /* @__PURE__ */ u(function() {
            return F >= $.length ? { done: !0 } : { done: !1, value: $[F++] };
          }, "n"), e: /* @__PURE__ */ u(function(re) {
            throw re;
          }, "e"), f: J };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var oe = !0, ce = !1, le;
      return { s: /* @__PURE__ */ u(function() {
        D = D.call($);
      }, "s"), n: /* @__PURE__ */ u(function() {
        var re = D.next();
        return oe = re.done, re;
      }, "n"), e: /* @__PURE__ */ u(function(re) {
        ce = !0, le = re;
      }, "e"), f: /* @__PURE__ */ u(function() {
        try {
          !oe && D.return != null && D.return();
        } finally {
          if (ce) throw le;
        }
      }, "f") };
    }
    u(a, "_createForOfIteratorHelper");
    function i($, I) {
      if ($) {
        if (typeof $ == "string") return s($, I);
        var D = Object.prototype.toString.call($).slice(8, -1);
        if (D === "Object" && $.constructor && (D = $.constructor.name), D === "Map" || D === "Set") return Array.from($);
        if (D === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D)) return s($, I);
      }
    }
    u(i, "_unsupportedIterableToArray");
    function s($, I) {
      (I == null || I > $.length) && (I = $.length);
      for (var D = 0, F = new Array(I); D < I; D++)
        F[D] = $[D];
      return F;
    }
    u(s, "_arrayLikeToArray");
    var d = Xve(), l = {
      fg: "#FFF",
      bg: "#000",
      newline: !1,
      escapeXML: !1,
      stream: !1,
      colors: p()
    };
    function p() {
      var $ = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      return x(0, 5).forEach(function(I) {
        x(0, 5).forEach(function(D) {
          x(0, 5).forEach(function(F) {
            return f(I, D, F, $);
          });
        });
      }), x(0, 23).forEach(function(I) {
        var D = I + 232, F = h(I * 10 + 8);
        $[D] = "#" + F + F + F;
      }), $;
    }
    u(p, "getDefaultColors");
    function f($, I, D, F) {
      var J = 16 + $ * 36 + I * 6 + D, oe = $ > 0 ? $ * 40 + 55 : 0, ce = I > 0 ? I * 40 + 55 : 0, le = D > 0 ? D * 40 + 55 : 0;
      F[J] = m([oe, ce, le]);
    }
    u(f, "setStyleColor");
    function h($) {
      for (var I = $.toString(16); I.length < 2; )
        I = "0" + I;
      return I;
    }
    u(h, "toHexString");
    function m($) {
      var I = [], D = a($), F;
      try {
        for (D.s(); !(F = D.n()).done; ) {
          var J = F.value;
          I.push(h(J));
        }
      } catch (oe) {
        D.e(oe);
      } finally {
        D.f();
      }
      return "#" + I.join("");
    }
    u(m, "toColorHexString");
    function g($, I, D, F) {
      var J;
      return I === "text" ? J = N(D, F) : I === "display" ? J = _($, D, F) : I === "xterm256Foreground" ? J = E($, F.colors[D]) : I === "xterm256Background" ? J = T($, F.colors[D]) : I === "rgb" && (J = w($, D)), J;
    }
    u(g, "generateOutput");
    function w($, I) {
      I = I.substring(2).slice(0, -1);
      var D = +I.substr(0, 2), F = I.substring(5).split(";"), J = F.map(function(oe) {
        return ("0" + Number(oe).toString(16)).substr(-2);
      }).join("");
      return A($, (D === 38 ? "color:#" : "background-color:#") + J);
    }
    u(w, "handleRgb");
    function _($, I, D) {
      I = parseInt(I, 10);
      var F = {
        "-1": /* @__PURE__ */ u(function() {
          return "<br/>";
        }, "_"),
        0: /* @__PURE__ */ u(function() {
          return $.length && b($);
        }, "_"),
        1: /* @__PURE__ */ u(function() {
          return C($, "b");
        }, "_"),
        3: /* @__PURE__ */ u(function() {
          return C($, "i");
        }, "_"),
        4: /* @__PURE__ */ u(function() {
          return C($, "u");
        }, "_"),
        8: /* @__PURE__ */ u(function() {
          return A($, "display:none");
        }, "_"),
        9: /* @__PURE__ */ u(function() {
          return C($, "strike");
        }, "_"),
        22: /* @__PURE__ */ u(function() {
          return A($, "font-weight:normal;text-decoration:none;font-style:normal");
        }, "_"),
        23: /* @__PURE__ */ u(function() {
          return O($, "i");
        }, "_"),
        24: /* @__PURE__ */ u(function() {
          return O($, "u");
        }, "_"),
        39: /* @__PURE__ */ u(function() {
          return E($, D.fg);
        }, "_"),
        49: /* @__PURE__ */ u(function() {
          return T($, D.bg);
        }, "_"),
        53: /* @__PURE__ */ u(function() {
          return A($, "text-decoration:overline");
        }, "_")
      }, J;
      return F[I] ? J = F[I]() : 4 < I && I < 7 ? J = C($, "blink") : 29 < I && I < 38 ? J = E($, D.colors[I - 30]) : 39 < I && I < 48 ? J = T($, D.colors[I - 40]) : 89 < I && I < 98 ? J = E($, D.colors[8 + (I - 90)]) : 99 < I && I < 108 && (J = T($, D.colors[8 + (I - 100)])), J;
    }
    u(_, "handleDisplay");
    function b($) {
      var I = $.slice(0);
      return $.length = 0, I.reverse().map(function(D) {
        return "</" + D + ">";
      }).join("");
    }
    u(b, "resetStyles");
    function x($, I) {
      for (var D = [], F = $; F <= I; F++)
        D.push(F);
      return D;
    }
    u(x, "range");
    function P($) {
      return function(I) {
        return ($ === null || I.category !== $) && $ !== "all";
      };
    }
    u(P, "notCategory");
    function R($) {
      $ = parseInt($, 10);
      var I = null;
      return $ === 0 ? I = "all" : $ === 1 ? I = "bold" : 2 < $ && $ < 5 ? I = "underline" : 4 < $ && $ < 7 ? I = "blink" : $ === 8 ? I = "hide" : $ === 9 ? I = "strike" : 29 < $ && $ < 38 || $ === 39 || 89 < $ && $ < 98 ? I = "foreground-color" : (39 < $ && $ < 48 || $ === 49 || 99 < $ && $ < 108) && (I = "background-color"), I;
    }
    u(R, "categoryForCode");
    function N($, I) {
      return I.escapeXML ? d.encodeXML($) : $;
    }
    u(N, "pushText");
    function C($, I, D) {
      return D || (D = ""), $.push(I), "<".concat(I).concat(D ? ' style="'.concat(D, '"') : "", ">");
    }
    u(C, "pushTag");
    function A($, I) {
      return C($, "span", I);
    }
    u(A, "pushStyle");
    function E($, I) {
      return C($, "span", "color:" + I);
    }
    u(E, "pushForegroundColor");
    function T($, I) {
      return C($, "span", "background-color:" + I);
    }
    u(T, "pushBackgroundColor");
    function O($, I) {
      var D;
      if ($.slice(-1)[0] === I && (D = $.pop()), D)
        return "</" + I + ">";
    }
    u(O, "closeTag");
    function k($, I, D) {
      var F = !1, J = 3;
      function oe() {
        return "";
      }
      u(oe, "remove");
      function ce(se, ye) {
        return D("xterm256Foreground", ye), "";
      }
      u(ce, "removeXterm256Foreground");
      function le(se, ye) {
        return D("xterm256Background", ye), "";
      }
      u(le, "removeXterm256Background");
      function re(se) {
        return I.newline ? D("display", -1) : D("text", se), "";
      }
      u(re, "newline");
      function we(se, ye) {
        F = !0, ye.trim().length === 0 && (ye = "0"), ye = ye.trimRight(";").split(";");
        var fe = a(ye), Ae;
        try {
          for (fe.s(); !(Ae = fe.n()).done; ) {
            var Fe = Ae.value;
            D("display", Fe);
          }
        } catch (dt) {
          fe.e(dt);
        } finally {
          fe.f();
        }
        return "";
      }
      u(we, "ansiMess");
      function _e(se) {
        return D("text", se), "";
      }
      u(_e, "realText");
      function de(se) {
        return D("rgb", se), "";
      }
      u(de, "rgb");
      var ne = [{
        pattern: /^\x08+/,
        sub: oe
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: oe
      }, {
        pattern: /^\x1b\[\(B/,
        sub: oe
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: de
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: ce
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: le
      }, {
        pattern: /^\n/,
        sub: re
      }, {
        pattern: /^\r+\n/,
        sub: re
      }, {
        pattern: /^\r/,
        sub: re
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: we
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: oe
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: oe
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: oe
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: _e
      }];
      function $e(se, ye) {
        ye > J && F || (F = !1, $ = $.replace(se.pattern, se.sub));
      }
      u($e, "process");
      var Se = [], nt = $, We = nt.length;
      e: for (; We > 0; ) {
        for (var q = 0, te = 0, ae = ne.length; te < ae; q = ++te) {
          var ue = ne[q];
          if ($e(ue, q), $.length !== We) {
            We = $.length;
            continue e;
          }
        }
        if ($.length === We)
          break;
        Se.push(0), We = $.length;
      }
      return Se;
    }
    u(k, "tokenize");
    function M($, I, D) {
      return I !== "text" && ($ = $.filter(P(R(D))), $.push({
        token: I,
        data: D,
        category: R(D)
      })), $;
    }
    u(M, "updateStickyStack");
    var L = (function() {
      function $(I) {
        r(this, $), I = I || {}, I.colors && (I.colors = Object.assign({}, l.colors, I.colors)), this.options = Object.assign({}, l, I), this.stack = [], this.stickyStack = [];
      }
      return u($, "Filter"), o($, [{
        key: "toHtml",
        value: /* @__PURE__ */ u(function(I) {
          var D = this;
          I = typeof I == "string" ? [I] : I;
          var F = this.stack, J = this.options, oe = [];
          return this.stickyStack.forEach(function(ce) {
            var le = g(F, ce.token, ce.data, J);
            le && oe.push(le);
          }), k(I.join(""), J, function(ce, le) {
            var re = g(F, ce, le, J);
            re && oe.push(re), J.stream && (D.stickyStack = M(D.stickyStack, ce, le));
          }), F.length && oe.push(b(F)), oe.join("");
        }, "toHtml")
      }]), $;
    })();
    t.exports = L;
  }
}), m6 = G({
  "../node_modules/memoizerific/memoizerific.js"(e, t) {
    (function(r) {
      if (typeof e == "object" && typeof t < "u")
        t.exports = r();
      else if (typeof define == "function" && define.amd)
        define([], r);
      else {
        var n;
        typeof window < "u" ? n = window : typeof globalThis < "u" ? n = globalThis : typeof self < "u" ? n = self : n = this, n.memoizerific = r();
      }
    })(function() {
      return (/* @__PURE__ */ u(function r(n, o, a) {
        function i(l, p) {
          if (!o[l]) {
            if (!n[l]) {
              var f = typeof Gp == "function" && Gp;
              if (!p && f) return f(l, !0);
              if (s) return s(l, !0);
              var h = new Error("Cannot find module '" + l + "'");
              throw h.code = "MODULE_NOT_FOUND", h;
            }
            var m = o[l] = { exports: {} };
            n[l][0].call(m.exports, function(g) {
              var w = n[l][1][g];
              return i(w || g);
            }, m, m.exports, r, n, o, a);
          }
          return o[l].exports;
        }
        u(i, "s");
        for (var s = typeof Gp == "function" && Gp, d = 0; d < a.length; d++) i(a[d]);
        return i;
      }, "e"))({ 1: [function(r, n, o) {
        n.exports = function(a) {
          if (typeof Map != "function" || a) {
            var i = r("./similar");
            return new i();
          } else
            return /* @__PURE__ */ new Map();
        };
      }, { "./similar": 2 }], 2: [function(r, n, o) {
        function a() {
          return this.list = [], this.lastItem = void 0, this.size = 0, this;
        }
        u(a, "Similar"), a.prototype.get = function(i) {
          var s;
          if (this.lastItem && this.isEqual(this.lastItem.key, i))
            return this.lastItem.val;
          if (s = this.indexOf(i), s >= 0)
            return this.lastItem = this.list[s], this.list[s].val;
        }, a.prototype.set = function(i, s) {
          var d;
          return this.lastItem && this.isEqual(this.lastItem.key, i) ? (this.lastItem.val = s, this) : (d = this.indexOf(i), d >= 0 ? (this.lastItem = this.list[d], this.list[d].val = s, this) : (this.lastItem = { key: i, val: s }, this.list.push(this.lastItem), this.size++, this));
        }, a.prototype.delete = function(i) {
          var s;
          if (this.lastItem && this.isEqual(this.lastItem.key, i) && (this.lastItem = void 0), s = this.indexOf(i), s >= 0)
            return this.size--, this.list.splice(s, 1)[0];
        }, a.prototype.has = function(i) {
          var s;
          return this.lastItem && this.isEqual(this.lastItem.key, i) ? !0 : (s = this.indexOf(i), s >= 0 ? (this.lastItem = this.list[s], !0) : !1);
        }, a.prototype.forEach = function(i, s) {
          var d;
          for (d = 0; d < this.size; d++)
            i.call(s || this, this.list[d].val, this.list[d].key, this);
        }, a.prototype.indexOf = function(i) {
          var s;
          for (s = 0; s < this.size; s++)
            if (this.isEqual(this.list[s].key, i))
              return s;
          return -1;
        }, a.prototype.isEqual = function(i, s) {
          return i === s || i !== i && s !== s;
        }, n.exports = a;
      }, {}], 3: [function(r, n, o) {
        var a = r("map-or-similar");
        n.exports = function(l) {
          var p = new a(!1), f = [];
          return function(h) {
            var m = /* @__PURE__ */ u(function() {
              var g = p, w, _, b = arguments.length - 1, x = Array(b + 1), P = !0, R;
              if ((m.numArgs || m.numArgs === 0) && m.numArgs !== b + 1)
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              for (R = 0; R < b; R++) {
                if (x[R] = {
                  cacheItem: g,
                  arg: arguments[R]
                }, g.has(arguments[R])) {
                  g = g.get(arguments[R]);
                  continue;
                }
                P = !1, w = new a(!1), g.set(arguments[R], w), g = w;
              }
              return P && (g.has(arguments[b]) ? _ = g.get(arguments[b]) : P = !1), P || (_ = h.apply(null, arguments), g.set(arguments[b], _)), l > 0 && (x[b] = {
                cacheItem: g,
                arg: arguments[b]
              }, P ? i(f, x) : f.push(x), f.length > l && s(f.shift())), m.wasMemoized = P, m.numArgs = b + 1, _;
            }, "memoizerific");
            return m.limit = l, m.wasMemoized = !1, m.cache = p, m.lru = f, m;
          };
        };
        function i(l, p) {
          var f = l.length, h = p.length, m, g, w;
          for (g = 0; g < f; g++) {
            for (m = !0, w = 0; w < h; w++)
              if (!d(l[g][w].arg, p[w].arg)) {
                m = !1;
                break;
              }
            if (m)
              break;
          }
          l.push(l.splice(g, 1)[0]);
        }
        u(i, "moveToMostRecentLru");
        function s(l) {
          var p = l.length, f = l[p - 1], h, m;
          for (f.cacheItem.delete(f.arg), m = p - 2; m >= 0 && (f = l[m], h = f.cacheItem.get(f.arg), !h || !h.size); m--)
            f.cacheItem.delete(f.arg);
        }
        u(s, "removeCachedResult");
        function d(l, p) {
          return l === p || l !== l && p !== p;
        }
        u(d, "isEqual");
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
}), xe = (() => {
  let e;
  return typeof window < "u" ? e = window : typeof globalThis < "u" || typeof globalThis < "u" ? e = globalThis : typeof self < "u" ? e = self : e = {}, e;
})(), JR = /* @__PURE__ */ new Map(), Zve = "UNIVERSAL_STORE:", nn = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, si = class je {
  constructor(t, r) {
    if (this.debugging = !1, this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]), this.getState = /* @__PURE__ */ u(() => (this.debug("getState", { state: this.state }), this.state), "getState"), this.subscribe = /* @__PURE__ */ u((n, o) => {
      const a = typeof n == "function", i = a ? "*" : n, s = a ? n : o;
      if (this.debug("subscribe", { eventType: i, listener: s }), !s)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(i) || this.listeners.set(i, /* @__PURE__ */ new Set()), this.listeners.get(i).add(s), () => {
        this.debug("unsubscribe", { eventType: i, listener: s }), this.listeners.has(i) && (this.listeners.get(i).delete(s), this.listeners.get(i)?.size === 0 && this.listeners.delete(i));
      };
    }, "subscribe"), this.send = /* @__PURE__ */ u((n) => {
      if (this.debug("send", { event: n }), this.status !== je.Status.READY)
        throw new TypeError(
          Be`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event: n,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(n, { actor: this.actor }), this.emitToChannel(n, { actor: this.actor });
    }, "send"), this.debugging = t.debug ?? !1, !je.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (je.isInternalConstructing = !1, this.id = t.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = t.leader ? je.ActorType.LEADER : je.ActorType.FOLLOWER, this.state = t.initialState, this.channelEventName = `${Zve}${this.id}`, this.debug("constructor", {
      options: t,
      environmentOverrides: r,
      channelEventName: this.channelEventName
    }), this.actor.type === je.ActorType.LEADER)
      this.syncing = {
        state: nn.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let n, o;
      const a = new Promise((i, s) => {
        n = /* @__PURE__ */ u(() => {
          this.syncing.state === nn.PENDING && (this.syncing.state = nn.RESOLVED, i());
        }, "syncingResolve"), o = /* @__PURE__ */ u((d) => {
          this.syncing.state === nn.PENDING && (this.syncing.state = nn.REJECTED, s(d));
        }, "syncingReject");
      });
      this.syncing = {
        state: nn.PENDING,
        promise: a,
        resolve: n,
        reject: o
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(this), this.debug = this.debug.bind(this), this.channel = r?.channel ?? je.preparation.channel, this.environment = r?.environment ?? je.preparation.environment, this.channel && this.environment ? (je.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis({ channel: this.channel, environment: this.environment })) : je.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let t, r;
    const n = new Promise(
      (o, a) => {
        t = /* @__PURE__ */ u((i) => {
          o(i);
        }, "resolveRef"), r = /* @__PURE__ */ u((...i) => {
          a(i);
        }, "rejectRef");
      }
    );
    je.preparation = {
      resolve: t,
      reject: r,
      promise: n
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? je.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return je.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case nn.PENDING:
      case void 0:
        return je.Status.SYNCING;
      case nn.REJECTED:
        return je.Status.ERROR;
      case nn.RESOLVED:
      default:
        return je.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([je.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(t) {
    if (!t || typeof t?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    t.debug && console.debug(
      Be`[UniversalStore]
        create`,
      { options: t }
    );
    const r = JR.get(t.id);
    if (r)
      return console.warn(Be`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), r;
    je.isInternalConstructing = !0;
    const n = new je(t);
    return JR.set(t.id, n), n;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(t, r) {
    je.preparation.channel = t, je.preparation.environment = r, je.preparation.resolve({ channel: t, environment: r });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(t) {
    const r = this.state, n = typeof t == "function" ? t(r) : t;
    if (this.debug("setState", { newState: n, previousState: r, updater: t }), this.status !== je.Status.READY)
      throw new TypeError(
        Be`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState: n,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = n;
    const o = {
      type: je.InternalEventType.SET_STATE,
      payload: {
        state: n,
        previousState: r
      }
    };
    this.emitToChannel(o, { actor: this.actor }), this.emitToListeners(o, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(t) {
    return this.debug("onStateChange", { listener: t }), this.subscribe(
      je.InternalEventType.SET_STATE,
      ({ payload: r }, n) => {
        t(r.state, r.previousState, n);
      }
    );
  }
  emitToChannel(t, r) {
    this.debug("emitToChannel", { event: t, eventInfo: r, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event: t,
      eventInfo: r
    });
  }
  prepareThis({
    channel: t,
    environment: r
  }) {
    this.channel = t, this.environment = r, this.debug("prepared", { channel: !!t, environment: r }), this.channel.on(this.channelEventName, this.handleChannelEvents), this.actor.type === je.ActorType.LEADER ? this.emitToChannel(
      { type: je.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: je.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: je.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(t, r) {
    const n = this.listeners.get(t.type), o = this.listeners.get("*");
    this.debug("emitToListeners", {
      event: t,
      eventInfo: r,
      eventTypeListeners: n,
      everythingListeners: o
    }), [...n ?? [], ...o ?? []].forEach(
      (a) => a(t, r)
    );
  }
  handleChannelEvents(t) {
    const { event: r, eventInfo: n } = t;
    if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent: t });
      return;
    } else if (this.syncing?.state === nn.PENDING && r.type !== je.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent: t });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent: t }), this.actor.type === je.ActorType.LEADER) {
      let o = !0;
      switch (r.type) {
        case je.InternalEventType.EXISTING_STATE_REQUEST:
          o = !1;
          const a = {
            type: je.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent: a
          }), this.emitToChannel(a, { actor: this.actor }), this.emitToListeners(a, { actor: this.actor });
          break;
        case je.InternalEventType.LEADER_CREATED:
          o = !1, this.syncing.state = nn.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event: r
          }), console.error(
            Be`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`
          );
          break;
      }
      o && (this.debug("handleChannelEvents: forwarding event", { channelEvent: t }), this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === je.ActorType.FOLLOWER)
      switch (r.type) {
        case je.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event: r
          }), this.syncing?.state !== nn.PENDING)
            break;
          this.syncing.resolve?.();
          const o = {
            type: je.InternalEventType.SET_STATE,
            payload: {
              state: r.payload,
              previousState: this.state
            }
          };
          this.state = r.payload, this.emitToListeners(o, n);
          break;
      }
    switch (r.type) {
      case je.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event: r }), this.state = r.payload.state;
        break;
    }
    this.emitToListeners(r, { actor: n.actor });
  }
  debug(t, r) {
    this.debugging && console.debug(
      Be`[UniversalStore::${this.id}::${this.environment ?? je.Environment.UNKNOWN}]
        ${t}`,
      JSON.stringify(
        {
          data: r,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    je.preparation.reject(new Error("reset")), je.setupPreparationPromise(), je.isInternalConstructing = !1;
  }
};
u(si, "UniversalStore");
si.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
};
si.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
};
si.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
};
si.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
};
si.isInternalConstructing = !1;
si.setupPreparationPromise();
var Ev = si, ewe = Object.create, y6 = Object.defineProperty, twe = Object.getOwnPropertyDescriptor, g6 = Object.getOwnPropertyNames, rwe = Object.getPrototypeOf, nwe = Object.prototype.hasOwnProperty, Le = /* @__PURE__ */ u((e, t) => /* @__PURE__ */ u(function() {
  return t || (0, e[g6(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, "__require"), "__commonJS"), owe = /* @__PURE__ */ u((e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of g6(t))
      !nwe.call(e, o) && o !== r && y6(e, o, { get: /* @__PURE__ */ u(() => t[o], "get"), enumerable: !(n = twe(t, o)) || n.enumerable });
  return e;
}, "__copyProps"), IA = /* @__PURE__ */ u((e, t, r) => (r = e != null ? ewe(rwe(e)) : {}, owe(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? y6(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), "__toESM"), awe = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
], iwe = ["detail"];
function b6(e) {
  const t = awe.filter((r) => e[r] !== void 0).reduce((r, n) => (r[n] = e[n], r), {});
  if (e instanceof CustomEvent)
    for (const r of iwe.filter(
      (n) => e[n] !== void 0
    ))
      t[r] = e[r];
  return t;
}
u(b6, "extractEventHiddenProperties");
var v6 = Le({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(e, t) {
    t.exports = Object;
  }
}), swe = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(e, t) {
    t.exports = Error;
  }
}), lwe = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(e, t) {
    t.exports = EvalError;
  }
}), cwe = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(e, t) {
    t.exports = RangeError;
  }
}), uwe = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(e, t) {
    t.exports = ReferenceError;
  }
}), dwe = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(e, t) {
    t.exports = SyntaxError;
  }
}), NA = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(e, t) {
    t.exports = TypeError;
  }
}), pwe = Le({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(e, t) {
    t.exports = URIError;
  }
}), fwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(e, t) {
    t.exports = Math.abs;
  }
}), hwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(e, t) {
    t.exports = Math.floor;
  }
}), mwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(e, t) {
    t.exports = Math.max;
  }
}), ywe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(e, t) {
    t.exports = Math.min;
  }
}), gwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(e, t) {
    t.exports = Math.pow;
  }
}), bwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(e, t) {
    t.exports = Math.round;
  }
}), vwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(e, t) {
    t.exports = Number.isNaN || /* @__PURE__ */ u(function(r) {
      return r !== r;
    }, "isNaN2");
  }
}), wwe = Le({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(e, t) {
    var r = vwe();
    t.exports = /* @__PURE__ */ u(function(n) {
      return r(n) || n === 0 ? n : n < 0 ? -1 : 1;
    }, "sign");
  }
}), _we = Le({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(e, t) {
    t.exports = Object.getOwnPropertyDescriptor;
  }
}), MA = Le({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(e, t) {
    var r = _we();
    if (r)
      try {
        r([], "length");
      } catch {
        r = null;
      }
    t.exports = r;
  }
}), Ewe = Le({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(e, t) {
    var r = Object.defineProperty || !1;
    if (r)
      try {
        r({}, "a", { value: 1 });
      } catch {
        r = !1;
      }
    t.exports = r;
  }
}), w6 = Le({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(e, t) {
    t.exports = /* @__PURE__ */ u(function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
      if (typeof Symbol.iterator == "symbol")
        return !0;
      var r = {}, n = Symbol("test"), o = Object(n);
      if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]")
        return !1;
      var a = 42;
      r[n] = a;
      for (var i in r)
        return !1;
      if (typeof Object.keys == "function" && Object.keys(r).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r).length !== 0)
        return !1;
      var s = Object.getOwnPropertySymbols(r);
      if (s.length !== 1 || s[0] !== n || !Object.prototype.propertyIsEnumerable.call(r, n))
        return !1;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var d = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(r, n)
        );
        if (d.value !== a || d.enumerable !== !0)
          return !1;
      }
      return !0;
    }, "hasSymbols");
  }
}), _6 = Le({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(e, t) {
    var r = typeof Symbol < "u" && Symbol, n = w6();
    t.exports = /* @__PURE__ */ u(function() {
      return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : n();
    }, "hasNativeSymbols");
  }
}), E6 = Le({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
  }
}), x6 = Le({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(e, t) {
    var r = v6();
    t.exports = r.getPrototypeOf || null;
  }
}), xwe = Le({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(e, t) {
    var r = "Function.prototype.bind called on incompatible ", n = Object.prototype.toString, o = Math.max, a = "[object Function]", i = /* @__PURE__ */ u(function(l, p) {
      for (var f = [], h = 0; h < l.length; h += 1)
        f[h] = l[h];
      for (var m = 0; m < p.length; m += 1)
        f[m + l.length] = p[m];
      return f;
    }, "concatty2"), s = /* @__PURE__ */ u(function(l, p) {
      for (var f = [], h = p || 0, m = 0; h < l.length; h += 1, m += 1)
        f[m] = l[h];
      return f;
    }, "slicy2"), d = /* @__PURE__ */ u(function(l, p) {
      for (var f = "", h = 0; h < l.length; h += 1)
        f += l[h], h + 1 < l.length && (f += p);
      return f;
    }, "joiny");
    t.exports = /* @__PURE__ */ u(function(l) {
      var p = this;
      if (typeof p != "function" || n.apply(p) !== a)
        throw new TypeError(r + p);
      for (var f = s(arguments, 1), h, m = /* @__PURE__ */ u(function() {
        if (this instanceof h) {
          var x = p.apply(
            this,
            i(f, arguments)
          );
          return Object(x) === x ? x : this;
        }
        return p.apply(
          l,
          i(f, arguments)
        );
      }, "binder"), g = o(0, p.length - f.length), w = [], _ = 0; _ < g; _++)
        w[_] = "$" + _;
      if (h = Function("binder", "return function (" + d(w, ",") + "){ return binder.apply(this,arguments); }")(m), p.prototype) {
        var b = /* @__PURE__ */ u(function() {
        }, "Empty2");
        b.prototype = p.prototype, h.prototype = new b(), b.prototype = null;
      }
      return h;
    }, "bind");
  }
}), gg = Le({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(e, t) {
    var r = xwe();
    t.exports = Function.prototype.bind || r;
  }
}), DA = Le({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(e, t) {
    t.exports = Function.prototype.call;
  }
}), S6 = Le({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(e, t) {
    t.exports = Function.prototype.apply;
  }
}), Swe = Le({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
  }
}), Twe = Le({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(e, t) {
    var r = gg(), n = S6(), o = DA(), a = Swe();
    t.exports = a || r.call(o, n);
  }
}), T6 = Le({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(e, t) {
    var r = gg(), n = NA(), o = DA(), a = Twe();
    t.exports = /* @__PURE__ */ u(function(i) {
      if (i.length < 1 || typeof i[0] != "function")
        throw new n("a function is required");
      return a(r, o, i);
    }, "callBindBasic");
  }
}), Awe = Le({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(e, t) {
    var r = T6(), n = MA(), o;
    try {
      o = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (d) {
      if (!d || typeof d != "object" || !("code" in d) || d.code !== "ERR_PROTO_ACCESS")
        throw d;
    }
    var a = !!o && n && n(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), i = Object, s = i.getPrototypeOf;
    t.exports = a && typeof a.get == "function" ? r([a.get]) : typeof s == "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ u(function(d) {
        return s(d == null ? d : i(d));
      }, "getDunder")
    ) : !1;
  }
}), $we = Le({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(e, t) {
    var r = E6(), n = x6(), o = Awe();
    t.exports = r ? /* @__PURE__ */ u(function(a) {
      return r(a);
    }, "getProto") : n ? /* @__PURE__ */ u(function(a) {
      if (!a || typeof a != "object" && typeof a != "function")
        throw new TypeError("getProto: not an object");
      return n(a);
    }, "getProto") : o ? /* @__PURE__ */ u(function(a) {
      return o(a);
    }, "getProto") : null;
  }
}), A6 = Le({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(e, t) {
    var r = Function.prototype.call, n = Object.prototype.hasOwnProperty, o = gg();
    t.exports = o.call(r, n);
  }
}), Cwe = Le({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(e, t) {
    var r, n = v6(), o = swe(), a = lwe(), i = cwe(), s = uwe(), d = dwe(), l = NA(), p = pwe(), f = fwe(), h = hwe(), m = mwe(), g = ywe(), w = gwe(), _ = bwe(), b = wwe(), x = Function, P = /* @__PURE__ */ u(function(q) {
      try {
        return x('"use strict"; return (' + q + ").constructor;")();
      } catch {
      }
    }, "getEvalledConstructor"), R = MA(), N = Ewe(), C = /* @__PURE__ */ u(function() {
      throw new l();
    }, "throwTypeError"), A = R ? (function() {
      try {
        return arguments.callee, C;
      } catch {
        try {
          return R(arguments, "callee").get;
        } catch {
          return C;
        }
      }
    })() : C, E = _6()(), T = $we(), O = x6(), k = E6(), M = S6(), L = DA(), $ = {}, I = typeof Uint8Array > "u" || !T ? r : T(Uint8Array), D = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
      "%ArrayIteratorPrototype%": E && T ? T([][Symbol.iterator]()) : r,
      "%AsyncFromSyncIteratorPrototype%": r,
      "%AsyncFunction%": $,
      "%AsyncGenerator%": $,
      "%AsyncGeneratorFunction%": $,
      "%AsyncIteratorPrototype%": $,
      "%Atomics%": typeof Atomics > "u" ? r : Atomics,
      "%BigInt%": typeof BigInt > "u" ? r : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? r : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": o,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": a,
      "%Float16Array%": typeof Float16Array > "u" ? r : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
      "%Function%": x,
      "%GeneratorFunction%": $,
      "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": E && T ? T(T([][Symbol.iterator]())) : r,
      "%JSON%": typeof JSON == "object" ? JSON : r,
      "%Map%": typeof Map > "u" ? r : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !E || !T ? r : T((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": n,
      "%Object.getOwnPropertyDescriptor%": R,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? r : Promise,
      "%Proxy%": typeof Proxy > "u" ? r : Proxy,
      "%RangeError%": i,
      "%ReferenceError%": s,
      "%Reflect%": typeof Reflect > "u" ? r : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? r : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !E || !T ? r : T((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": E && T ? T(""[Symbol.iterator]()) : r,
      "%Symbol%": E ? Symbol : r,
      "%SyntaxError%": d,
      "%ThrowTypeError%": A,
      "%TypedArray%": I,
      "%TypeError%": l,
      "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
      "%URIError%": p,
      "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet,
      "%Function.prototype.call%": L,
      "%Function.prototype.apply%": M,
      "%Object.defineProperty%": N,
      "%Object.getPrototypeOf%": O,
      "%Math.abs%": f,
      "%Math.floor%": h,
      "%Math.max%": m,
      "%Math.min%": g,
      "%Math.pow%": w,
      "%Math.round%": _,
      "%Math.sign%": b,
      "%Reflect.getPrototypeOf%": k
    };
    if (T)
      try {
        null.error;
      } catch (q) {
        F = T(T(q)), D["%Error.prototype%"] = F;
      }
    var F, J = /* @__PURE__ */ u(function q(te) {
      var ae;
      if (te === "%AsyncFunction%")
        ae = P("async function () {}");
      else if (te === "%GeneratorFunction%")
        ae = P("function* () {}");
      else if (te === "%AsyncGeneratorFunction%")
        ae = P("async function* () {}");
      else if (te === "%AsyncGenerator%") {
        var ue = q("%AsyncGeneratorFunction%");
        ue && (ae = ue.prototype);
      } else if (te === "%AsyncIteratorPrototype%") {
        var se = q("%AsyncGenerator%");
        se && T && (ae = T(se.prototype));
      }
      return D[te] = ae, ae;
    }, "doEval2"), oe = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, ce = gg(), le = A6(), re = ce.call(L, Array.prototype.concat), we = ce.call(M, Array.prototype.splice), _e = ce.call(L, String.prototype.replace), de = ce.call(L, String.prototype.slice), ne = ce.call(L, RegExp.prototype.exec), $e = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Se = /\\(\\)?/g, nt = /* @__PURE__ */ u(function(q) {
      var te = de(q, 0, 1), ae = de(q, -1);
      if (te === "%" && ae !== "%")
        throw new d("invalid intrinsic syntax, expected closing `%`");
      if (ae === "%" && te !== "%")
        throw new d("invalid intrinsic syntax, expected opening `%`");
      var ue = [];
      return _e(q, $e, function(se, ye, fe, Ae) {
        ue[ue.length] = fe ? _e(Ae, Se, "$1") : ye || se;
      }), ue;
    }, "stringToPath3"), We = /* @__PURE__ */ u(function(q, te) {
      var ae = q, ue;
      if (le(oe, ae) && (ue = oe[ae], ae = "%" + ue[0] + "%"), le(D, ae)) {
        var se = D[ae];
        if (se === $ && (se = J(ae)), typeof se > "u" && !te)
          throw new l("intrinsic " + q + " exists, but is not available. Please file an issue!");
        return {
          alias: ue,
          name: ae,
          value: se
        };
      }
      throw new d("intrinsic " + q + " does not exist!");
    }, "getBaseIntrinsic2");
    t.exports = /* @__PURE__ */ u(function(q, te) {
      if (typeof q != "string" || q.length === 0)
        throw new l("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof te != "boolean")
        throw new l('"allowMissing" argument must be a boolean');
      if (ne(/^%?[^%]*%?$/, q) === null)
        throw new d("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var ae = nt(q), ue = ae.length > 0 ? ae[0] : "", se = We("%" + ue + "%", te), ye = se.name, fe = se.value, Ae = !1, Fe = se.alias;
      Fe && (ue = Fe[0], we(ae, re([0, 1], Fe)));
      for (var dt = 1, pt = !0; dt < ae.length; dt += 1) {
        var it = ae[dt], Ht = de(it, 0, 1), _t = de(it, -1);
        if ((Ht === '"' || Ht === "'" || Ht === "`" || _t === '"' || _t === "'" || _t === "`") && Ht !== _t)
          throw new d("property names with quotes must have matching quotes");
        if ((it === "constructor" || !pt) && (Ae = !0), ue += "." + it, ye = "%" + ue + "%", le(D, ye))
          fe = D[ye];
        else if (fe != null) {
          if (!(it in fe)) {
            if (!te)
              throw new l("base intrinsic for " + q + " exists, but the property is not available.");
            return;
          }
          if (R && dt + 1 >= ae.length) {
            var Et = R(fe, it);
            pt = !!Et, pt && "get" in Et && !("originalValue" in Et.get) ? fe = Et.get : fe = fe[it];
          } else
            pt = le(fe, it), fe = fe[it];
          pt && !Ae && (D[ye] = fe);
        }
      }
      return fe;
    }, "GetIntrinsic");
  }
}), qA = Le({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(e, t) {
    var r = Cwe(), n = T6(), o = n([r("%String.prototype.indexOf%")]);
    t.exports = /* @__PURE__ */ u(function(a, i) {
      var s = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        r(a, !!i)
      );
      return typeof s == "function" && o(a, ".prototype.") > -1 ? n(
        /** @type {const} */
        [s]
      ) : s;
    }, "callBoundIntrinsic");
  }
}), kwe = Le({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(e, t) {
    var r = w6();
    t.exports = /* @__PURE__ */ u(function() {
      return r() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
}), $6 = Le({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(e, t) {
    var r = qA(), n = kwe()(), o = A6(), a = MA(), i;
    n ? (s = r("RegExp.prototype.exec"), d = {}, l = /* @__PURE__ */ u(function() {
      throw d;
    }, "throwRegexMarker"), p = {
      toString: l,
      valueOf: l
    }, typeof Symbol.toPrimitive == "symbol" && (p[Symbol.toPrimitive] = l), i = /* @__PURE__ */ u(function(m) {
      if (!m || typeof m != "object")
        return !1;
      var g = (
        /** @type {NonNullable<typeof gOPD>} */
        a(
          /** @type {{ lastIndex?: unknown }} */
          m,
          "lastIndex"
        )
      ), w = g && o(g, "value");
      if (!w)
        return !1;
      try {
        s(
          m,
          /** @type {string} */
          /** @type {unknown} */
          p
        );
      } catch (_) {
        return _ === d;
      }
    }, "isRegex")) : (f = r("Object.prototype.toString"), h = "[object RegExp]", i = /* @__PURE__ */ u(function(m) {
      return !m || typeof m != "object" && typeof m != "function" ? !1 : f(m) === h;
    }, "isRegex"));
    var s, d, l, p, f, h;
    t.exports = i;
  }
}), Pwe = Le({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(e, t) {
    t.exports = n;
    var r = Object.prototype.toString;
    function n(o) {
      if (!o)
        return !1;
      var a = r.call(o);
      return a === "[object Function]" || typeof o == "function" && a !== "[object RegExp]" || typeof window < "u" && // IE8 and below
      (o === window.setTimeout || o === window.alert || o === window.confirm || o === window.prompt);
    }
    u(n, "isFunction3");
  }
}), Owe = Le({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(e, t) {
    var r = qA(), n = $6(), o = r("RegExp.prototype.exec"), a = NA();
    t.exports = /* @__PURE__ */ u(function(i) {
      if (!n(i))
        throw new a("`regex` must be a RegExp");
      return /* @__PURE__ */ u(function(s) {
        return o(i, s) !== null;
      }, "test");
    }, "regexTester");
  }
}), Rwe = Le({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(e, t) {
    var r = qA(), n = r("Object.prototype.toString"), o = _6()(), a = Owe();
    o ? (i = r("Symbol.prototype.toString"), s = a(/^Symbol\(.*\)$/), d = /* @__PURE__ */ u(function(l) {
      return typeof l.valueOf() != "symbol" ? !1 : s(i(l));
    }, "isRealSymbolObject"), t.exports = /* @__PURE__ */ u(function(l) {
      if (typeof l == "symbol")
        return !0;
      if (!l || typeof l != "object" || n(l) !== "[object Symbol]")
        return !1;
      try {
        return d(l);
      } catch {
        return !1;
      }
    }, "isSymbol3")) : t.exports = /* @__PURE__ */ u(function(l) {
      return !1;
    }, "isSymbol3");
    var i, s, d;
  }
}), jwe = IA($6()), Iwe = IA(Pwe()), Nwe = IA(Rwe());
function C6(e) {
  return e != null && typeof e == "object" && Array.isArray(e) === !1;
}
u(C6, "isObject");
var Mwe = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, Dwe = Mwe, qwe = typeof self == "object" && self && self.Object === Object && self, Lwe = Dwe || qwe || Function("return this")(), LA = Lwe, Fwe = LA.Symbol, tc = Fwe, k6 = Object.prototype, Uwe = k6.hasOwnProperty, Bwe = k6.toString, su = tc ? tc.toStringTag : void 0;
function P6(e) {
  var t = Uwe.call(e, su), r = e[su];
  try {
    e[su] = void 0;
    var n = !0;
  } catch {
  }
  var o = Bwe.call(e);
  return n && (t ? e[su] = r : delete e[su]), o;
}
u(P6, "getRawTag");
var Hwe = P6, Vwe = Object.prototype, zwe = Vwe.toString;
function O6(e) {
  return zwe.call(e);
}
u(O6, "objectToString");
var Jwe = O6, Wwe = "[object Null]", Gwe = "[object Undefined]", WR = tc ? tc.toStringTag : void 0;
function R6(e) {
  return e == null ? e === void 0 ? Gwe : Wwe : WR && WR in Object(e) ? Hwe(e) : Jwe(e);
}
u(R6, "baseGetTag");
var j6 = R6;
function I6(e) {
  return e != null && typeof e == "object";
}
u(I6, "isObjectLike");
var Kwe = I6, Ywe = "[object Symbol]";
function N6(e) {
  return typeof e == "symbol" || Kwe(e) && j6(e) == Ywe;
}
u(N6, "isSymbol");
var FA = N6;
function M6(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, o = Array(n); ++r < n; )
    o[r] = t(e[r], r, e);
  return o;
}
u(M6, "arrayMap");
var Xwe = M6, Qwe = Array.isArray, UA = Qwe, GR = tc ? tc.prototype : void 0, KR = GR ? GR.toString : void 0;
function BA(e) {
  if (typeof e == "string")
    return e;
  if (UA(e))
    return Xwe(e, BA) + "";
  if (FA(e))
    return KR ? KR.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
u(BA, "baseToString");
var Zwe = BA;
function D6(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
u(D6, "isObject2");
var q6 = D6, e_e = "[object AsyncFunction]", t_e = "[object Function]", r_e = "[object GeneratorFunction]", n_e = "[object Proxy]";
function L6(e) {
  if (!q6(e))
    return !1;
  var t = j6(e);
  return t == t_e || t == r_e || t == e_e || t == n_e;
}
u(L6, "isFunction");
var o_e = L6, a_e = LA["__core-js_shared__"], xv = a_e, YR = (function() {
  var e = /[^.]+$/.exec(xv && xv.keys && xv.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function F6(e) {
  return !!YR && YR in e;
}
u(F6, "isMasked");
var i_e = F6, s_e = Function.prototype, l_e = s_e.toString;
function U6(e) {
  if (e != null) {
    try {
      return l_e.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
u(U6, "toSource");
var c_e = U6, u_e = /[\\^$.*+?()[\]{}|]/g, d_e = /^\[object .+?Constructor\]$/, p_e = Function.prototype, f_e = Object.prototype, h_e = p_e.toString, m_e = f_e.hasOwnProperty, y_e = RegExp(
  "^" + h_e.call(m_e).replace(u_e, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function B6(e) {
  if (!q6(e) || i_e(e))
    return !1;
  var t = o_e(e) ? y_e : d_e;
  return t.test(c_e(e));
}
u(B6, "baseIsNative");
var g_e = B6;
function H6(e, t) {
  return e?.[t];
}
u(H6, "getValue");
var b_e = H6;
function V6(e, t) {
  var r = b_e(e, t);
  return g_e(r) ? r : void 0;
}
u(V6, "getNative");
var z6 = V6;
function J6(e, t) {
  return e === t || e !== e && t !== t;
}
u(J6, "eq");
var v_e = J6, w_e = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, __e = /^\w*$/;
function W6(e, t) {
  if (UA(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || FA(e) ? !0 : __e.test(e) || !w_e.test(e) || t != null && e in Object(t);
}
u(W6, "isKey");
var E_e = W6, x_e = z6(Object, "create"), Pd = x_e;
function G6() {
  this.__data__ = Pd ? Pd(null) : {}, this.size = 0;
}
u(G6, "hashClear");
var S_e = G6;
function K6(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
u(K6, "hashDelete");
var T_e = K6, A_e = "__lodash_hash_undefined__", $_e = Object.prototype, C_e = $_e.hasOwnProperty;
function Y6(e) {
  var t = this.__data__;
  if (Pd) {
    var r = t[e];
    return r === A_e ? void 0 : r;
  }
  return C_e.call(t, e) ? t[e] : void 0;
}
u(Y6, "hashGet");
var k_e = Y6, P_e = Object.prototype, O_e = P_e.hasOwnProperty;
function X6(e) {
  var t = this.__data__;
  return Pd ? t[e] !== void 0 : O_e.call(t, e);
}
u(X6, "hashHas");
var R_e = X6, j_e = "__lodash_hash_undefined__";
function Q6(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = Pd && t === void 0 ? j_e : t, this;
}
u(Q6, "hashSet");
var I_e = Q6;
function Is(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
u(Is, "Hash");
Is.prototype.clear = S_e;
Is.prototype.delete = T_e;
Is.prototype.get = k_e;
Is.prototype.has = R_e;
Is.prototype.set = I_e;
var XR = Is;
function Z6() {
  this.__data__ = [], this.size = 0;
}
u(Z6, "listCacheClear");
var N_e = Z6;
function eW(e, t) {
  for (var r = e.length; r--; )
    if (v_e(e[r][0], t))
      return r;
  return -1;
}
u(eW, "assocIndexOf");
var bg = eW, M_e = Array.prototype, D_e = M_e.splice;
function tW(e) {
  var t = this.__data__, r = bg(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : D_e.call(t, r, 1), --this.size, !0;
}
u(tW, "listCacheDelete");
var q_e = tW;
function rW(e) {
  var t = this.__data__, r = bg(t, e);
  return r < 0 ? void 0 : t[r][1];
}
u(rW, "listCacheGet");
var L_e = rW;
function nW(e) {
  return bg(this.__data__, e) > -1;
}
u(nW, "listCacheHas");
var F_e = nW;
function oW(e, t) {
  var r = this.__data__, n = bg(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
u(oW, "listCacheSet");
var U_e = oW;
function Ns(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
u(Ns, "ListCache");
Ns.prototype.clear = N_e;
Ns.prototype.delete = q_e;
Ns.prototype.get = L_e;
Ns.prototype.has = F_e;
Ns.prototype.set = U_e;
var B_e = Ns, H_e = z6(LA, "Map"), V_e = H_e;
function aW() {
  this.size = 0, this.__data__ = {
    hash: new XR(),
    map: new (V_e || B_e)(),
    string: new XR()
  };
}
u(aW, "mapCacheClear");
var z_e = aW;
function iW(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
u(iW, "isKeyable");
var J_e = iW;
function sW(e, t) {
  var r = e.__data__;
  return J_e(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
u(sW, "getMapData");
var vg = sW;
function lW(e) {
  var t = vg(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
u(lW, "mapCacheDelete");
var W_e = lW;
function cW(e) {
  return vg(this, e).get(e);
}
u(cW, "mapCacheGet");
var G_e = cW;
function uW(e) {
  return vg(this, e).has(e);
}
u(uW, "mapCacheHas");
var K_e = uW;
function dW(e, t) {
  var r = vg(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
u(dW, "mapCacheSet");
var Y_e = dW;
function Ms(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
u(Ms, "MapCache");
Ms.prototype.clear = z_e;
Ms.prototype.delete = W_e;
Ms.prototype.get = G_e;
Ms.prototype.has = K_e;
Ms.prototype.set = Y_e;
var pW = Ms, X_e = "Expected a function";
function wg(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(X_e);
  var r = /* @__PURE__ */ u(function() {
    var n = arguments, o = t ? t.apply(this, n) : n[0], a = r.cache;
    if (a.has(o))
      return a.get(o);
    var i = e.apply(this, n);
    return r.cache = a.set(o, i) || a, i;
  }, "memoized");
  return r.cache = new (wg.Cache || pW)(), r;
}
u(wg, "memoize");
wg.Cache = pW;
var Q_e = wg, Z_e = 500;
function fW(e) {
  var t = Q_e(e, function(n) {
    return r.size === Z_e && r.clear(), n;
  }), r = t.cache;
  return t;
}
u(fW, "memoizeCapped");
var e0e = fW, t0e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r0e = /\\(\\)?/g, n0e = e0e(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(t0e, function(r, n, o, a) {
    t.push(o ? a.replace(r0e, "$1") : n || r);
  }), t;
}), o0e = n0e;
function hW(e) {
  return e == null ? "" : Zwe(e);
}
u(hW, "toString");
var a0e = hW;
function mW(e, t) {
  return UA(e) ? e : E_e(e, t) ? [e] : o0e(a0e(e));
}
u(mW, "castPath");
var i0e = mW;
function yW(e) {
  if (typeof e == "string" || FA(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
u(yW, "toKey");
var s0e = yW;
function gW(e, t) {
  t = i0e(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[s0e(t[r++])];
  return r && r == n ? e : void 0;
}
u(gW, "baseGet");
var l0e = gW;
function bW(e, t, r) {
  var n = e == null ? void 0 : l0e(e, t);
  return n === void 0 ? r : n;
}
u(bW, "get");
var c0e = bW, HA = C6, u0e = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, VA = /* @__PURE__ */ u((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), "isJSON");
function zA(e) {
  if (!HA(e))
    return e;
  let t = e, r = !1;
  return typeof Event < "u" && e instanceof Event && (t = b6(t), r = !0), t = Object.keys(t).reduce((n, o) => {
    try {
      t[o] && t[o].toJSON, n[o] = t[o];
    } catch {
      r = !0;
    }
    return n;
  }, {}), r ? t : e;
}
u(zA, "convertUnconventionalData");
var d0e = /* @__PURE__ */ u(function(e) {
  let t, r, n, o;
  return /* @__PURE__ */ u(function(a, i) {
    try {
      if (a === "")
        return o = [], t = /* @__PURE__ */ new Map([[i, "[]"]]), r = /* @__PURE__ */ new Map(), n = [], i;
      const s = r.get(this) || this;
      for (; n.length && s !== n[0]; )
        n.shift(), o.pop();
      if (typeof i == "boolean")
        return i;
      if (i === void 0)
        return e.allowUndefined ? "_undefined_" : void 0;
      if (i === null)
        return null;
      if (typeof i == "number")
        return i === Number.NEGATIVE_INFINITY ? "_-Infinity_" : i === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(i) ? "_NaN_" : i;
      if (typeof i == "bigint")
        return `_bigint_${i.toString()}`;
      if (typeof i == "string")
        return u0e.test(i) ? e.allowDate ? `_date_${i}` : void 0 : i;
      if ((0, jwe.default)(i))
        return e.allowRegExp ? `_regexp_${i.flags}|${i.source}` : void 0;
      if ((0, Iwe.default)(i))
        return;
      if ((0, Nwe.default)(i)) {
        if (!e.allowSymbol)
          return;
        const l = Symbol.keyFor(i);
        return l !== void 0 ? `_gsymbol_${l}` : `_symbol_${i.toString().slice(7, -1)}`;
      }
      if (n.length >= e.maxDepth)
        return Array.isArray(i) ? `[Array(${i.length})]` : "[Object]";
      if (i === this)
        return `_duplicate_${JSON.stringify(o)}`;
      if (i instanceof Error && e.allowError)
        return {
          __isConvertedError__: !0,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...i.cause ? { cause: i.cause } : {},
            ...i,
            name: i.name,
            message: i.message,
            stack: i.stack,
            "_constructor-name_": i.constructor.name
          }
        };
      if (i?.constructor?.name && i.constructor.name !== "Object" && !Array.isArray(i)) {
        const l = t.get(i);
        if (!l) {
          const p = {
            __isClassInstance__: !0,
            __className__: i.constructor.name,
            ...Object.getOwnPropertyNames(i).reduce(
              (f, h) => {
                try {
                  f[h] = i[h];
                } catch {
                }
                return f;
              },
              {}
            )
          };
          return o.push(a), n.unshift(p), t.set(i, JSON.stringify(o)), i !== p && r.set(i, p), p;
        }
        return `_duplicate_${l}`;
      }
      const d = t.get(i);
      if (!d) {
        const l = Array.isArray(i) ? i : zA(i);
        return o.push(a), n.unshift(l), t.set(i, JSON.stringify(o)), i !== l && r.set(i, l), l;
      }
      return `_duplicate_${d}`;
    } catch {
      return;
    }
  }, "replace");
}, "replacer2"), p0e = /* @__PURE__ */ u(function(e) {
  const t = [];
  let r;
  return /* @__PURE__ */ u(function(n, o) {
    if (n === "" && (r = o, t.forEach(({ target: a, container: i, replacement: s }) => {
      const d = VA(s) ? JSON.parse(s) : s.split(".");
      d.length === 0 ? i[a] = r : i[a] = c0e(r, d);
    })), n === "_constructor-name_")
      return o;
    if (HA(o) && o.__isConvertedError__) {
      const { message: a, ...i } = o.errorProperties, s = new Error(a);
      return Object.assign(s, i), s;
    }
    if (typeof o == "string" && o.startsWith("_regexp_") && e.allowRegExp) {
      const [, a, i] = o.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(i, a);
    }
    return typeof o == "string" && o.startsWith("_date_") && e.allowDate ? new Date(o.replace("_date_", "")) : typeof o == "string" && o.startsWith("_duplicate_") ? (t.push({ target: n, container: this, replacement: o.replace(/^_duplicate_/, "") }), null) : typeof o == "string" && o.startsWith("_symbol_") && e.allowSymbol ? Symbol(o.replace("_symbol_", "")) : typeof o == "string" && o.startsWith("_gsymbol_") && e.allowSymbol ? Symbol.for(o.replace("_gsymbol_", "")) : typeof o == "string" && o === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof o == "string" && o === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof o == "string" && o === "_NaN_" ? Number.NaN : typeof o == "string" && o.startsWith("_bigint_") && typeof BigInt == "function" ? BigInt(o.replace("_bigint_", "")) : o;
  }, "revive");
}, "reviver2"), vW = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: !0,
  allowDate: !0,
  allowError: !0,
  allowUndefined: !0,
  allowSymbol: !0
}, wW = /* @__PURE__ */ u((e, t = {}) => {
  const r = { ...vW, ...t };
  return JSON.stringify(zA(e), d0e(r), t.space);
}, "stringify"), f0e = /* @__PURE__ */ u(() => {
  const e = /* @__PURE__ */ new Map();
  return /* @__PURE__ */ u(function t(r) {
    HA(r) && Object.entries(r).forEach(([n, o]) => {
      o === "_undefined_" ? r[n] = void 0 : e.get(o) || (e.set(o, !0), t(o));
    }), Array.isArray(r) && r.forEach((n, o) => {
      n === "_undefined_" ? (e.set(n, !0), r[o] = void 0) : e.get(n) || (e.set(n, !0), t(n));
    });
  }, "mutateUndefined");
}, "mutator"), _W = /* @__PURE__ */ u((e, t = {}) => {
  const r = { ...vW, ...t }, n = JSON.parse(e, p0e(r));
  return f0e()(n), n;
}, "parse"), { LOGLEVEL: h0e } = xe, Sa = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
}, m0e = h0e, zs = Sa[m0e] || Sa.info, wt = {
  trace: /* @__PURE__ */ u((e, ...t) => {
    zs <= Sa.trace && console.trace(e, ...t);
  }, "trace"),
  debug: /* @__PURE__ */ u((e, ...t) => {
    zs <= Sa.debug && console.debug(e, ...t);
  }, "debug"),
  info: /* @__PURE__ */ u((e, ...t) => {
    zs <= Sa.info && console.info(e, ...t);
  }, "info"),
  warn: /* @__PURE__ */ u((e, ...t) => {
    zs <= Sa.warn && console.warn(e, ...t);
  }, "warn"),
  error: /* @__PURE__ */ u((e, ...t) => {
    zs <= Sa.error && console.error(e, ...t);
  }, "error"),
  log: /* @__PURE__ */ u((e, ...t) => {
    zs < Sa.silent && console.log(e, ...t);
  }, "log")
}, c0 = /* @__PURE__ */ new Set(), qt = /* @__PURE__ */ u((e) => (t, ...r) => {
  if (!c0.has(t))
    return c0.add(t), wt[e](t, ...r);
}, "once");
qt.clear = () => c0.clear();
qt.trace = qt("trace");
qt.debug = qt("debug");
qt.info = qt("info");
qt.warn = qt("warn");
qt.error = qt("error");
qt.log = qt("log");
var EW = qt("warn"), _n = /* @__PURE__ */ u((e) => (...t) => {
  const r = [];
  if (t.length) {
    const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, o = /<\/span>/gi;
    let a;
    for (r.push(t[0].replace(n, "%c").replace(o, "%c")); a = n.exec(t[0]); )
      r.push(a[2]), r.push("");
    for (let i = 1; i < t.length; i++)
      r.push(t[i]);
  }
  wt[e].apply(wt, r);
}, "pretty");
_n.trace = _n("trace");
_n.debug = _n("debug");
_n.info = _n("info");
_n.warn = _n("warn");
_n.error = _n("error");
var JA = /* @__PURE__ */ ((e) => (e.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", e.CHANNEL_CREATED = "channelCreated", e.CONFIG_ERROR = "configError", e.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", e.STORY_SPECIFIED = "storySpecified", e.SET_CONFIG = "setConfig", e.SET_STORIES = "setStories", e.SET_INDEX = "setIndex", e.SET_CURRENT_STORY = "setCurrentStory", e.CURRENT_STORY_WAS_SET = "currentStoryWasSet", e.FORCE_RE_RENDER = "forceReRender", e.FORCE_REMOUNT = "forceRemount", e.PRELOAD_ENTRIES = "preloadStories", e.STORY_PREPARED = "storyPrepared", e.DOCS_PREPARED = "docsPrepared", e.STORY_CHANGED = "storyChanged", e.STORY_UNCHANGED = "storyUnchanged", e.STORY_RENDERED = "storyRendered", e.STORY_FINISHED = "storyFinished", e.STORY_MISSING = "storyMissing", e.STORY_ERRORED = "storyErrored", e.STORY_THREW_EXCEPTION = "storyThrewException", e.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", e.STORY_HOT_UPDATED = "storyHotUpdated", e.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", e.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", e.UPDATE_STORY_ARGS = "updateStoryArgs", e.STORY_ARGS_UPDATED = "storyArgsUpdated", e.RESET_STORY_ARGS = "resetStoryArgs", e.SET_FILTER = "setFilter", e.SET_GLOBALS = "setGlobals", e.UPDATE_GLOBALS = "updateGlobals", e.GLOBALS_UPDATED = "globalsUpdated", e.REGISTER_SUBSCRIPTION = "registerSubscription", e.PREVIEW_INITIALIZED = "previewInitialized", e.PREVIEW_KEYDOWN = "previewKeydown", e.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", e.SELECT_STORY = "selectStory", e.STORIES_COLLAPSE_ALL = "storiesCollapseAll", e.STORIES_EXPAND_ALL = "storiesExpandAll", e.DOCS_RENDERED = "docsRendered", e.SHARED_STATE_CHANGED = "sharedStateChanged", e.SHARED_STATE_SET = "sharedStateSet", e.NAVIGATE_URL = "navigateUrl", e.UPDATE_QUERY_PARAMS = "updateQueryParams", e.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", e.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", e.SET_WHATS_NEW_CACHE = "setWhatsNewCache", e.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", e.TELEMETRY_ERROR = "telemetryError", e.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", e.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", e.SAVE_STORY_REQUEST = "saveStoryRequest", e.SAVE_STORY_RESPONSE = "saveStoryResponse", e.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", e.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", e.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", e.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", e.OPEN_IN_EDITOR_REQUEST = "openInEditorRequest", e.OPEN_IN_EDITOR_RESPONSE = "openInEditorResponse", e))(JA || {}), y0e = JA, {
  CHANNEL_WS_DISCONNECT: xW,
  CHANNEL_CREATED: g0e,
  CONFIG_ERROR: SW,
  CREATE_NEW_STORYFILE_REQUEST: b0e,
  CREATE_NEW_STORYFILE_RESPONSE: v0e,
  CURRENT_STORY_WAS_SET: u0,
  DOCS_PREPARED: TW,
  DOCS_RENDERED: WA,
  FILE_COMPONENT_SEARCH_REQUEST: w0e,
  FILE_COMPONENT_SEARCH_RESPONSE: _0e,
  FORCE_RE_RENDER: GA,
  FORCE_REMOUNT: Hh,
  GLOBALS_UPDATED: Od,
  NAVIGATE_URL: E0e,
  PLAY_FUNCTION_THREW_EXCEPTION: AW,
  UNHANDLED_ERRORS_WHILE_PLAYING: $W,
  PRELOAD_ENTRIES: CW,
  PREVIEW_INITIALIZED: kW,
  PREVIEW_BUILDER_PROGRESS: x0e,
  PREVIEW_KEYDOWN: PW,
  REGISTER_SUBSCRIPTION: S0e,
  RESET_STORY_ARGS: KA,
  SELECT_STORY: T0e,
  SET_CONFIG: A0e,
  SET_CURRENT_STORY: YA,
  SET_FILTER: $0e,
  SET_GLOBALS: OW,
  SET_INDEX: C0e,
  SET_STORIES: k0e,
  SHARED_STATE_CHANGED: P0e,
  SHARED_STATE_SET: O0e,
  STORIES_COLLAPSE_ALL: R0e,
  STORIES_EXPAND_ALL: j0e,
  STORY_ARGS_UPDATED: RW,
  STORY_CHANGED: jW,
  STORY_ERRORED: IW,
  STORY_INDEX_INVALIDATED: NW,
  STORY_MISSING: d0,
  STORY_PREPARED: MW,
  STORY_RENDER_PHASE_CHANGED: ys,
  STORY_RENDERED: Vh,
  STORY_FINISHED: p0,
  STORY_SPECIFIED: DW,
  STORY_THREW_EXCEPTION: qW,
  STORY_UNCHANGED: LW,
  STORY_HOT_UPDATED: FW,
  UPDATE_GLOBALS: XA,
  UPDATE_QUERY_PARAMS: UW,
  UPDATE_STORY_ARGS: QA,
  REQUEST_WHATS_NEW_DATA: I0e,
  RESULT_WHATS_NEW_DATA: N0e,
  SET_WHATS_NEW_CACHE: M0e,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: D0e,
  TELEMETRY_ERROR: q0e,
  SAVE_STORY_REQUEST: L0e,
  SAVE_STORY_RESPONSE: F0e,
  ARGTYPES_INFO_REQUEST: BW,
  ARGTYPES_INFO_RESPONSE: f0,
  OPEN_IN_EDITOR_REQUEST: U0e,
  OPEN_IN_EDITOR_RESPONSE: B0e
} = JA;
const H0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ARGTYPES_INFO_REQUEST: BW,
  ARGTYPES_INFO_RESPONSE: f0,
  CHANNEL_CREATED: g0e,
  CHANNEL_WS_DISCONNECT: xW,
  CONFIG_ERROR: SW,
  CREATE_NEW_STORYFILE_REQUEST: b0e,
  CREATE_NEW_STORYFILE_RESPONSE: v0e,
  CURRENT_STORY_WAS_SET: u0,
  DOCS_PREPARED: TW,
  DOCS_RENDERED: WA,
  FILE_COMPONENT_SEARCH_REQUEST: w0e,
  FILE_COMPONENT_SEARCH_RESPONSE: _0e,
  FORCE_REMOUNT: Hh,
  FORCE_RE_RENDER: GA,
  GLOBALS_UPDATED: Od,
  NAVIGATE_URL: E0e,
  OPEN_IN_EDITOR_REQUEST: U0e,
  OPEN_IN_EDITOR_RESPONSE: B0e,
  PLAY_FUNCTION_THREW_EXCEPTION: AW,
  PRELOAD_ENTRIES: CW,
  PREVIEW_BUILDER_PROGRESS: x0e,
  PREVIEW_INITIALIZED: kW,
  PREVIEW_KEYDOWN: PW,
  REGISTER_SUBSCRIPTION: S0e,
  REQUEST_WHATS_NEW_DATA: I0e,
  RESET_STORY_ARGS: KA,
  RESULT_WHATS_NEW_DATA: N0e,
  SAVE_STORY_REQUEST: L0e,
  SAVE_STORY_RESPONSE: F0e,
  SELECT_STORY: T0e,
  SET_CONFIG: A0e,
  SET_CURRENT_STORY: YA,
  SET_FILTER: $0e,
  SET_GLOBALS: OW,
  SET_INDEX: C0e,
  SET_STORIES: k0e,
  SET_WHATS_NEW_CACHE: M0e,
  SHARED_STATE_CHANGED: P0e,
  SHARED_STATE_SET: O0e,
  STORIES_COLLAPSE_ALL: R0e,
  STORIES_EXPAND_ALL: j0e,
  STORY_ARGS_UPDATED: RW,
  STORY_CHANGED: jW,
  STORY_ERRORED: IW,
  STORY_FINISHED: p0,
  STORY_HOT_UPDATED: FW,
  STORY_INDEX_INVALIDATED: NW,
  STORY_MISSING: d0,
  STORY_PREPARED: MW,
  STORY_RENDERED: Vh,
  STORY_RENDER_PHASE_CHANGED: ys,
  STORY_SPECIFIED: DW,
  STORY_THREW_EXCEPTION: qW,
  STORY_UNCHANGED: LW,
  TELEMETRY_ERROR: q0e,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: D0e,
  UNHANDLED_ERRORS_WHILE_PLAYING: $W,
  UPDATE_GLOBALS: XA,
  UPDATE_QUERY_PARAMS: UW,
  UPDATE_STORY_ARGS: QA,
  default: y0e
}, Symbol.toStringTag, { value: "Module" }));
var V0e = /* @__PURE__ */ u((e) => e.transports !== void 0, "isMulti"), z0e = /* @__PURE__ */ u(() => Math.random().toString(16).slice(2), "generateRandomId"), HW = class {
  constructor(e = {}) {
    this.sender = z0e(), this.events = {}, this.data = {}, this.transports = [], this.isAsync = e.async || !1, V0e(e) ? (this.transports = e.transports || [], this.transports.forEach((t) => {
      t.setHandler((r) => this.handleEvent(r));
    })) : this.transports = e.transport ? [e.transport] : [], this.transports.forEach((t) => {
      t.setHandler((r) => this.handleEvent(r));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(e, t) {
    this.events[e] = this.events[e] || [], this.events[e].push(t);
  }
  emit(e, ...t) {
    const r = { type: e, args: t, from: this.sender };
    let n = {};
    t.length >= 1 && t[0] && t[0].options && (n = t[0].options);
    const o = /* @__PURE__ */ u(() => {
      this.transports.forEach((a) => {
        a.send(r, n);
      }), this.handleEvent(r);
    }, "handler");
    this.isAsync ? setImmediate(o) : o();
  }
  last(e) {
    return this.data[e];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(e) {
    const t = this.listeners(e);
    return t ? t.length : 0;
  }
  listeners(e) {
    return this.events[e] || void 0;
  }
  once(e, t) {
    const r = this.onceListener(e, t);
    this.addListener(e, r);
  }
  removeAllListeners(e) {
    e ? this.events[e] && delete this.events[e] : this.events = {};
  }
  removeListener(e, t) {
    const r = this.listeners(e);
    r && (this.events[e] = r.filter((n) => n !== t));
  }
  on(e, t) {
    this.addListener(e, t);
  }
  off(e, t) {
    this.removeListener(e, t);
  }
  handleEvent(e) {
    const t = this.listeners(e.type);
    t && t.length && t.forEach((r) => {
      r.apply(e, e.args);
    }), this.data[e.type] = e.args;
  }
  onceListener(e, t) {
    const r = /* @__PURE__ */ u((...n) => (this.removeListener(e, r), t(...n)), "onceListener");
    return r;
  }
};
u(HW, "Channel");
var VW = HW, J0e = /* @__PURE__ */ u((e) => {
  const t = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [r, ...n] = t.filter((a) => {
    try {
      return a.contentWindow?.location.origin === e.source.location.origin && a.contentWindow?.location.pathname === e.source.location.pathname;
    } catch {
    }
    try {
      return a.contentWindow === e.source;
    } catch {
    }
    const i = a.getAttribute("src");
    let s;
    try {
      if (!i)
        return !1;
      ({ origin: s } = new URL(i, document.location.toString()));
    } catch {
      return !1;
    }
    return s === e.origin;
  }), o = r?.getAttribute("src");
  if (o && n.length === 0) {
    const { protocol: a, host: i, pathname: s } = new URL(o, document.location.toString());
    return `${a}//${i}${s}`;
  }
  return n.length > 0 && wt.error("found multiple candidates for event source"), null;
}, "getEventSourceUrl"), { document: Sv, location: Tv } = xe, QR = "storybook-channel", W0e = { maxDepth: 25 }, zW = class {
  constructor(e) {
    if (this.config = e, this.connected = !1, this.buffer = [], typeof xe?.addEventListener == "function" && xe.addEventListener("message", this.handleEvent.bind(this), !1), e.page !== "manager" && e.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${e.page}"`);
  }
  setHandler(e) {
    this.handler = (...t) => {
      e.apply(this, t), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = !0);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(e, t) {
    const {
      target: r,
      // telejson options
      allowRegExp: n,
      allowSymbol: o,
      allowDate: a,
      allowError: i,
      allowUndefined: s,
      maxDepth: d,
      space: l
    } = t || {}, p = Object.fromEntries(
      Object.entries({
        allowRegExp: n,
        allowSymbol: o,
        allowDate: a,
        allowError: i,
        allowUndefined: s,
        maxDepth: d,
        space: l
      }).filter(([w, _]) => typeof _ < "u")
    ), f = {
      ...W0e,
      ...xe.CHANNEL_OPTIONS || {},
      ...p
    }, h = this.getFrames(r), m = new URLSearchParams(Tv?.search || ""), g = wW(
      {
        key: QR,
        event: e,
        refId: m.get("refId")
      },
      f
    );
    return h.length ? (this.buffer.length && this.flush(), h.forEach((w) => {
      try {
        w.postMessage(g, "*");
      } catch {
        wt.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((w, _) => {
      this.buffer.push({ event: e, resolve: w, reject: _ });
    });
  }
  flush() {
    const { buffer: e } = this;
    this.buffer = [], e.forEach((t) => {
      this.send(t.event).then(t.resolve).catch(t.reject);
    });
  }
  getFrames(e) {
    if (this.config.page === "manager") {
      const t = Array.from(
        Sv.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((r) => {
        try {
          return r.contentWindow && r.dataset.isStorybook !== void 0 && r.id === e ? [r.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return t?.length ? t : this.getCurrentFrames();
    }
    return xe && xe.parent && xe.parent !== xe.self ? [xe.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      Sv.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((e) => e.contentWindow ? [e.contentWindow] : []) : xe && xe.parent ? [xe.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      Sv.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((e) => e.contentWindow ? [e.contentWindow] : []) : xe && xe.parent ? [xe.parent] : [];
  }
  handleEvent(e) {
    try {
      const { data: t } = e, { key: r, event: n, refId: o } = typeof t == "string" && VA(t) ? _W(t, xe.CHANNEL_OPTIONS || {}) : t;
      if (r === QR) {
        const a = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', i = Object.values(H0e).includes(n.type) ? `<span style="color: #FF4785">${n.type}</span>` : `<span style="color: #FFAE00">${n.type}</span>`;
        if (o && (n.refId = o), n.source = this.config.page === "preview" ? e.origin : J0e(e), !n.source) {
          _n.error(
            `${a} received ${i} but was unable to determine the source of the event`
          );
          return;
        }
        const s = `${a} received ${i} (${t.length})`;
        _n.debug(
          Tv.origin !== n.source ? s : `${s} <span style="color: gray">(on ${Tv.origin} from ${n.source})</span>`,
          ...n.args
        ), uo(this.handler, "ChannelHandler should be set"), this.handler(n);
      }
    } catch (t) {
      wt.error(t);
    }
  }
};
u(zW, "PostMessageTransport");
var G0e = zW, { WebSocket: K0e } = xe, Y0e = 15e3, X0e = 5e3, JW = class {
  constructor({ url: e, onError: t, page: r }) {
    this.buffer = [], this.isReady = !1, this.isClosed = !1, this.pingTimeout = 0, this.socket = new K0e(e), this.socket.onopen = () => {
      this.isReady = !0, this.heartbeat(), this.flush();
    }, this.socket.onmessage = ({ data: n }) => {
      const o = typeof n == "string" && VA(n) ? _W(n) : n;
      uo(this.handler), this.handler(o), o.type === "ping" && (this.heartbeat(), this.send({ type: "pong" }));
    }, this.socket.onerror = (n) => {
      t && t(n);
    }, this.socket.onclose = (n) => {
      uo(this.handler), this.handler({
        type: xW,
        args: [{ reason: n.reason, code: n.code }],
        from: r || "preview"
      }), this.isClosed = !0, clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, Y0e + X0e);
  }
  setHandler(e) {
    this.handler = e;
  }
  send(e) {
    this.isClosed || (this.isReady ? this.sendNow(e) : this.sendLater(e));
  }
  sendLater(e) {
    this.buffer.push(e);
  }
  sendNow(e) {
    const t = wW(e, {
      maxDepth: 15,
      ...xe.CHANNEL_OPTIONS
    });
    this.socket.send(t);
  }
  flush() {
    const { buffer: e } = this;
    this.buffer = [], e.forEach((t) => this.send(t));
  }
};
u(JW, "WebsocketTransport");
var Q0e = JW, { CONFIG_TYPE: Z0e } = xe;
function e1e({ page: e, extraTransports: t = [] }) {
  const r = [new G0e({ page: e }), ...t];
  if (Z0e === "DEVELOPMENT") {
    const o = window.location.protocol === "http:" ? "ws" : "wss", { hostname: a, port: i } = window.location, s = `${o}://${a}:${i}/storybook-server-channel`;
    r.push(new Q0e({ url: s, onError: /* @__PURE__ */ u(() => {
    }, "onError"), page: e }));
  }
  const n = new VW({ transports: r });
  return Ev.__prepare(
    n,
    e === "manager" ? Ev.Environment.MANAGER : Ev.Environment.PREVIEW
  ), n;
}
u(e1e, "createBrowserChannel");
var zh = "backgrounds", t1e = "measureEnabled", WW = "outline", r1e = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
}, _g = "storybook/highlight", n1e = `${_g}/add`, o1e = `${_g}/remove`, a1e = `${_g}/reset`, i1e = `${_g}/scroll-into-view`, ZR = 2147483647, Ta = 28, s1e = "storybook/actions", l1e = `${s1e}/action-event`, c1e = {
  depth: 10,
  clearOnStoryChange: !0,
  limit: 50
}, GW = /* @__PURE__ */ u((e, t) => {
  const r = Object.getPrototypeOf(e);
  return !r || t(r) ? r : GW(r, t);
}, "findProto"), u1e = /* @__PURE__ */ u((e) => !!(typeof e == "object" && e && GW(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) && typeof e.persist == "function"), "isReactSyntheticEvent"), d1e = /* @__PURE__ */ u((e) => {
  if (u1e(e)) {
    const t = Object.create(
      e.constructor.prototype,
      Object.getOwnPropertyDescriptors(e)
    );
    t.persist();
    const r = Object.getOwnPropertyDescriptor(t, "view"), n = r?.value;
    return typeof n == "object" && n?.constructor.name === "Window" && Object.defineProperty(t, "view", {
      ...r,
      value: Object.create(n.constructor.prototype)
    }), t;
  }
  return e;
}, "serializeArg");
function Eg(e, t = {}) {
  const r = {
    ...c1e,
    ...t
  }, n = /* @__PURE__ */ u(function(...o) {
    if (t.implicit) {
      const f = ("__STORYBOOK_PREVIEW__" in xe ? xe.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (h) => h.phase === "playing" || h.phase === "rendering"
      );
      if (f) {
        const h = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, m = new ove({
          phase: f.phase,
          name: e,
          deprecated: h
        });
        if (h)
          console.warn(m);
        else
          throw m;
      }
    }
    const a = Bn.getChannel(), i = Date.now().toString(36) + Math.random().toString(36).substring(2), s = 5, d = o.map(d1e), l = o.length > 1 ? d : d[0], p = {
      id: i,
      count: 0,
      data: { name: e, args: l },
      options: {
        ...r,
        maxDepth: s + (r.depth || 3)
      }
    };
    a.emit(l1e, p);
  }, "actionHandler");
  return n.isAction = !0, n.implicit = t.implicit, n;
}
u(Eg, "action");
var p1e = "viewport", KW = G({
  "../node_modules/picocolors/picocolors.browser.js"(e, t) {
    var r = String, n = /* @__PURE__ */ u(function() {
      return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
    }, "create");
    t.exports = n(), t.exports.createColors = n;
  }
}), f1e = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, YW = Object.entries(f1e);
function wp(e) {
  return String(e);
}
u(wp, "a");
wp.open = "";
wp.close = "";
YW.reduce(
  (e, [t]) => (e[t] = wp, e),
  { isColorSupported: !1 }
);
function XW(e = !1) {
  let t = typeof process < "u" ? process : void 0, r = t?.env || {}, n = t?.argv || [];
  return !("NO_COLOR" in r || n.includes("--no-color")) && ("FORCE_COLOR" in r || n.includes("--color") || t?.platform === "win32" || e && r.TERM !== "dumb" || "CI" in r) || typeof window < "u" && !!window.chrome;
}
u(XW, "C");
function QW(e = !1) {
  let t = XW(e), r = /* @__PURE__ */ u((i, s, d, l) => {
    let p = "", f = 0;
    do
      p += i.substring(f, l) + d, f = l + s.length, l = i.indexOf(s, f);
    while (~l);
    return p + i.substring(f);
  }, "i"), n = /* @__PURE__ */ u((i, s, d = i) => {
    let l = /* @__PURE__ */ u((p) => {
      let f = String(p), h = f.indexOf(s, i.length);
      return ~h ? i + r(f, s, d, h) + s : i + f + s;
    }, "o");
    return l.open = i, l.close = s, l;
  }, "g"), o = {
    isColorSupported: t
  }, a = /* @__PURE__ */ u((i) => `\x1B[${i}m`, "d");
  for (let [i, s] of YW)
    o[i] = t ? n(
      a(s[0]),
      a(s[1]),
      s[2]
    ) : wp;
  return o;
}
u(QW, "p");
var Ot = QW();
function ZA(e, t) {
  return t.forEach(function(r) {
    r && typeof r != "string" && !Array.isArray(r) && Object.keys(r).forEach(function(n) {
      if (n !== "default" && !(n in e)) {
        var o = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(e, n, o.get ? o : {
          enumerable: !0,
          get: /* @__PURE__ */ u(function() {
            return r[n];
          }, "get")
        });
      }
    });
  }), Object.freeze(e);
}
u(ZA, "_mergeNamespaces");
function ZW(e, t) {
  const r = Object.keys(e), n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (const o of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, o).enumerable && n.push(o);
  return n;
}
u(ZW, "getKeysOfEnumerableProperties");
function Rc(e, t, r, n, o, a, i = ": ") {
  let s = "", d = 0, l = e.next();
  if (!l.done) {
    s += t.spacingOuter;
    const p = r + t.indent;
    for (; !l.done; ) {
      if (s += p, d++ === t.maxWidth) {
        s += "â€¦";
        break;
      }
      const f = a(l.value[0], t, p, n, o), h = a(l.value[1], t, p, n, o);
      s += f + i + h, l = e.next(), l.done ? t.min || (s += ",") : s += `,${t.spacingInner}`;
    }
    s += t.spacingOuter + r;
  }
  return s;
}
u(Rc, "printIteratorEntries");
function xg(e, t, r, n, o, a) {
  let i = "", s = 0, d = e.next();
  if (!d.done) {
    i += t.spacingOuter;
    const l = r + t.indent;
    for (; !d.done; ) {
      if (i += l, s++ === t.maxWidth) {
        i += "â€¦";
        break;
      }
      i += a(d.value, t, l, n, o), d = e.next(), d.done ? t.min || (i += ",") : i += `,${t.spacingInner}`;
    }
    i += t.spacingOuter + r;
  }
  return i;
}
u(xg, "printIteratorValues");
function Rd(e, t, r, n, o, a) {
  let i = "";
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  const s = /* @__PURE__ */ u((l) => l instanceof DataView, "isDataView"), d = s(e) ? e.byteLength : e.length;
  if (d > 0) {
    i += t.spacingOuter;
    const l = r + t.indent;
    for (let p = 0; p < d; p++) {
      if (i += l, p === t.maxWidth) {
        i += "â€¦";
        break;
      }
      (s(e) || p in e) && (i += a(s(e) ? e.getInt8(p) : e[p], t, l, n, o)), p < d - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + r;
  }
  return i;
}
u(Rd, "printListItems");
function Sg(e, t, r, n, o, a) {
  let i = "";
  const s = ZW(e, t.compareKeys);
  if (s.length > 0) {
    i += t.spacingOuter;
    const d = r + t.indent;
    for (let l = 0; l < s.length; l++) {
      const p = s[l], f = a(p, t, d, n, o), h = a(e[p], t, d, n, o);
      i += `${d + f}: ${h}`, l < s.length - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + r;
  }
  return i;
}
u(Sg, "printObjectProperties");
var h1e = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, Av = " ", m1e = /* @__PURE__ */ u((e, t, r, n, o, a) => {
  const i = e.toString();
  if (i === "ArrayContaining" || i === "ArrayNotContaining")
    return ++n > t.maxDepth ? `[${i}]` : `${i + Av}[${Rd(e.sample, t, r, n, o, a)}]`;
  if (i === "ObjectContaining" || i === "ObjectNotContaining")
    return ++n > t.maxDepth ? `[${i}]` : `${i + Av}{${Sg(e.sample, t, r, n, o, a)}}`;
  if (i === "StringMatching" || i === "StringNotMatching" || i === "StringContaining" || i === "StringNotContaining")
    return i + Av + a(e.sample, t, r, n, o);
  if (typeof e.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`);
  return e.toAsymmetricMatcher();
}, "serialize$5"), y1e = /* @__PURE__ */ u((e) => e && e.$$typeof === h1e, "test$5"), g1e = {
  serialize: m1e,
  test: y1e
}, b1e = " ", e9 = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), v1e = /^(?:HTML\w*Collection|NodeList)$/;
function t9(e) {
  return e9.has(e) || v1e.test(e);
}
u(t9, "testName");
var w1e = /* @__PURE__ */ u((e) => e && e.constructor && !!e.constructor.name && t9(e.constructor.name), "test$4");
function r9(e) {
  return e.constructor.name === "NamedNodeMap";
}
u(r9, "isNamedNodeMap");
var _1e = /* @__PURE__ */ u((e, t, r, n, o, a) => {
  const i = e.constructor.name;
  return ++n > t.maxDepth ? `[${i}]` : (t.min ? "" : i + b1e) + (e9.has(i) ? `{${Sg(r9(e) ? [...e].reduce((s, d) => (s[d.name] = d.value, s), {}) : { ...e }, t, r, n, o, a)}}` : `[${Rd([...e], t, r, n, o, a)}]`);
}, "serialize$4"), E1e = {
  serialize: _1e,
  test: w1e
};
function e$(e) {
  return e.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
u(e$, "escapeHTML");
function Tg(e, t, r, n, o, a, i) {
  const s = n + r.indent, d = r.colors;
  return e.map((l) => {
    const p = t[l];
    let f = i(p, r, s, o, a);
    return typeof p != "string" && (f.includes(`
`) && (f = r.spacingOuter + s + f + r.spacingOuter + n), f = `{${f}}`), `${r.spacingInner + n + d.prop.open + l + d.prop.close}=${d.value.open}${f}${d.value.close}`;
  }).join("");
}
u(Tg, "printProps");
function Ag(e, t, r, n, o, a) {
  return e.map((i) => t.spacingOuter + r + (typeof i == "string" ? t$(i, t) : a(i, t, r, n, o))).join("");
}
u(Ag, "printChildren");
function t$(e, t) {
  const r = t.colors.content;
  return r.open + e$(e) + r.close;
}
u(t$, "printText");
function n9(e, t) {
  const r = t.colors.comment;
  return `${r.open}<!--${e$(e)}-->${r.close}`;
}
u(n9, "printComment");
function $g(e, t, r, n, o) {
  const a = n.colors.tag;
  return `${a.open}<${e}${t && a.close + t + n.spacingOuter + o + a.open}${r ? `>${a.close}${r}${n.spacingOuter}${o}${a.open}</${e}` : `${t && !n.min ? "" : " "}/`}>${a.close}`;
}
u($g, "printElement");
function Cg(e, t) {
  const r = t.colors.tag;
  return `${r.open}<${e}${r.close} â€¦${r.open} />${r.close}`;
}
u(Cg, "printElementAsLeaf");
var x1e = 1, o9 = 3, a9 = 8, i9 = 11, S1e = /^(?:(?:HTML|SVG)\w*)?Element$/;
function s9(e) {
  try {
    return typeof e.hasAttribute == "function" && e.hasAttribute("is");
  } catch {
    return !1;
  }
}
u(s9, "testHasAttribute");
function l9(e) {
  const t = e.constructor.name, { nodeType: r, tagName: n } = e, o = typeof n == "string" && n.includes("-") || s9(e);
  return r === x1e && (S1e.test(t) || o) || r === o9 && t === "Text" || r === a9 && t === "Comment" || r === i9 && t === "DocumentFragment";
}
u(l9, "testNode");
var T1e = /* @__PURE__ */ u((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && l9(e);
}, "test$3");
function c9(e) {
  return e.nodeType === o9;
}
u(c9, "nodeIsText");
function u9(e) {
  return e.nodeType === a9;
}
u(u9, "nodeIsComment");
function _f(e) {
  return e.nodeType === i9;
}
u(_f, "nodeIsFragment");
var A1e = /* @__PURE__ */ u((e, t, r, n, o, a) => {
  if (c9(e))
    return t$(e.data, t);
  if (u9(e))
    return n9(e.data, t);
  const i = _f(e) ? "DocumentFragment" : e.tagName.toLowerCase();
  return ++n > t.maxDepth ? Cg(i, t) : $g(i, Tg(_f(e) ? [] : Array.from(e.attributes, (s) => s.name).sort(), _f(e) ? {} : [...e.attributes].reduce((s, d) => (s[d.name] = d.value, s), {}), t, r + t.indent, n, o, a), Ag(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, o, a), t, r);
}, "serialize$3"), $1e = {
  serialize: A1e,
  test: T1e
}, C1e = "@@__IMMUTABLE_ITERABLE__@@", k1e = "@@__IMMUTABLE_LIST__@@", P1e = "@@__IMMUTABLE_KEYED__@@", O1e = "@@__IMMUTABLE_MAP__@@", ej = "@@__IMMUTABLE_ORDERED__@@", R1e = "@@__IMMUTABLE_RECORD__@@", j1e = "@@__IMMUTABLE_SEQ__@@", I1e = "@@__IMMUTABLE_SET__@@", N1e = "@@__IMMUTABLE_STACK__@@", rc = /* @__PURE__ */ u((e) => `Immutable.${e}`, "getImmutableName"), kg = /* @__PURE__ */ u((e) => `[${e}]`, "printAsLeaf"), jd = " ", tj = "â€¦";
function d9(e, t, r, n, o, a, i) {
  return ++n > t.maxDepth ? kg(rc(i)) : `${rc(i) + jd}{${Rc(e.entries(), t, r, n, o, a)}}`;
}
u(d9, "printImmutableEntries");
function p9(e) {
  let t = 0;
  return { next() {
    if (t < e._keys.length) {
      const r = e._keys[t++];
      return {
        done: !1,
        value: [r, e.get(r)]
      };
    }
    return {
      done: !0,
      value: void 0
    };
  } };
}
u(p9, "getRecordEntries");
function f9(e, t, r, n, o, a) {
  const i = rc(e._name || "Record");
  return ++n > t.maxDepth ? kg(i) : `${i + jd}{${Rc(p9(e), t, r, n, o, a)}}`;
}
u(f9, "printImmutableRecord");
function h9(e, t, r, n, o, a) {
  const i = rc("Seq");
  return ++n > t.maxDepth ? kg(i) : e[P1e] ? `${i + jd}{${e._iter || e._object ? Rc(e.entries(), t, r, n, o, a) : tj}}` : `${i + jd}[${e._iter || e._array || e._collection || e._iterable ? xg(e.values(), t, r, n, o, a) : tj}]`;
}
u(h9, "printImmutableSeq");
function Ef(e, t, r, n, o, a, i) {
  return ++n > t.maxDepth ? kg(rc(i)) : `${rc(i) + jd}[${xg(e.values(), t, r, n, o, a)}]`;
}
u(Ef, "printImmutableValues");
var M1e = /* @__PURE__ */ u((e, t, r, n, o, a) => e[O1e] ? d9(e, t, r, n, o, a, e[ej] ? "OrderedMap" : "Map") : e[k1e] ? Ef(e, t, r, n, o, a, "List") : e[I1e] ? Ef(e, t, r, n, o, a, e[ej] ? "OrderedSet" : "Set") : e[N1e] ? Ef(e, t, r, n, o, a, "Stack") : e[j1e] ? h9(e, t, r, n, o, a) : f9(e, t, r, n, o, a), "serialize$2"), D1e = /* @__PURE__ */ u((e) => e && (e[C1e] === !0 || e[R1e] === !0), "test$2"), q1e = {
  serialize: M1e,
  test: D1e
};
function r$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
u(r$, "getDefaultExportFromCjs");
var rj = { exports: {} }, ut = {}, nj;
function m9() {
  if (nj) return ut;
  nj = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), i = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.view_transition"), m = Symbol.for("react.client.reference");
  function g(w) {
    if (typeof w == "object" && w !== null) {
      var _ = w.$$typeof;
      switch (_) {
        case e:
          switch (w = w.type, w) {
            case r:
            case o:
            case n:
            case d:
            case l:
            case h:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case i:
                case s:
                case f:
                case p:
                  return w;
                case a:
                  return w;
                default:
                  return _;
              }
          }
        case t:
          return _;
      }
    }
  }
  return u(g, "typeOf"), ut.ContextConsumer = a, ut.ContextProvider = i, ut.Element = e, ut.ForwardRef = s, ut.Fragment = r, ut.Lazy = f, ut.Memo = p, ut.Portal = t, ut.Profiler = o, ut.StrictMode = n, ut.Suspense = d, ut.SuspenseList = l, ut.isContextConsumer = function(w) {
    return g(w) === a;
  }, ut.isContextProvider = function(w) {
    return g(w) === i;
  }, ut.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === e;
  }, ut.isForwardRef = function(w) {
    return g(w) === s;
  }, ut.isFragment = function(w) {
    return g(w) === r;
  }, ut.isLazy = function(w) {
    return g(w) === f;
  }, ut.isMemo = function(w) {
    return g(w) === p;
  }, ut.isPortal = function(w) {
    return g(w) === t;
  }, ut.isProfiler = function(w) {
    return g(w) === o;
  }, ut.isStrictMode = function(w) {
    return g(w) === n;
  }, ut.isSuspense = function(w) {
    return g(w) === d;
  }, ut.isSuspenseList = function(w) {
    return g(w) === l;
  }, ut.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === o || w === n || w === d || w === l || typeof w == "object" && w !== null && (w.$$typeof === f || w.$$typeof === p || w.$$typeof === i || w.$$typeof === a || w.$$typeof === s || w.$$typeof === m || w.getModuleId !== void 0);
  }, ut.typeOf = g, ut;
}
u(m9, "requireReactIs_production");
var L1e = {};
function F1e() {
  return L1e;
}
u(F1e, "requireReactIs_development$1");
var oj;
function y9() {
  return oj || (oj = 1, rj.exports = m9()), rj.exports;
}
u(y9, "requireReactIs$1");
var g9 = y9(), U1e = r$(g9), B1e = ZA({
  __proto__: null,
  default: U1e
}, [g9]), aj = { exports: {} }, at = {}, ij;
function b9() {
  if (ij) return at;
  ij = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), s = Symbol.for("react.server_context"), d = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), g;
  g = Symbol.for("react.module.reference");
  function w(_) {
    if (typeof _ == "object" && _ !== null) {
      var b = _.$$typeof;
      switch (b) {
        case e:
          switch (_ = _.type, _) {
            case r:
            case o:
            case n:
            case l:
            case p:
              return _;
            default:
              switch (_ = _ && _.$$typeof, _) {
                case s:
                case i:
                case d:
                case h:
                case f:
                case a:
                  return _;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return u(w, "v"), at.ContextConsumer = i, at.ContextProvider = a, at.Element = e, at.ForwardRef = d, at.Fragment = r, at.Lazy = h, at.Memo = f, at.Portal = t, at.Profiler = o, at.StrictMode = n, at.Suspense = l, at.SuspenseList = p, at.isAsyncMode = function() {
    return !1;
  }, at.isConcurrentMode = function() {
    return !1;
  }, at.isContextConsumer = function(_) {
    return w(_) === i;
  }, at.isContextProvider = function(_) {
    return w(_) === a;
  }, at.isElement = function(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === e;
  }, at.isForwardRef = function(_) {
    return w(_) === d;
  }, at.isFragment = function(_) {
    return w(_) === r;
  }, at.isLazy = function(_) {
    return w(_) === h;
  }, at.isMemo = function(_) {
    return w(_) === f;
  }, at.isPortal = function(_) {
    return w(_) === t;
  }, at.isProfiler = function(_) {
    return w(_) === o;
  }, at.isStrictMode = function(_) {
    return w(_) === n;
  }, at.isSuspense = function(_) {
    return w(_) === l;
  }, at.isSuspenseList = function(_) {
    return w(_) === p;
  }, at.isValidElementType = function(_) {
    return typeof _ == "string" || typeof _ == "function" || _ === r || _ === o || _ === n || _ === l || _ === p || _ === m || typeof _ == "object" && _ !== null && (_.$$typeof === h || _.$$typeof === f || _.$$typeof === a || _.$$typeof === i || _.$$typeof === d || _.$$typeof === g || _.getModuleId !== void 0);
  }, at.typeOf = w, at;
}
u(b9, "requireReactIs_production_min");
var H1e = {};
function V1e() {
  return H1e;
}
u(V1e, "requireReactIs_development");
var sj;
function v9() {
  return sj || (sj = 1, aj.exports = b9()), aj.exports;
}
u(v9, "requireReactIs");
var w9 = v9(), z1e = r$(w9), J1e = ZA({
  __proto__: null,
  default: z1e
}, [w9]), W1e = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], ji = Object.fromEntries(W1e.map((e) => [e, (t) => J1e[e](t) || B1e[e](t)]));
function n$(e, t = []) {
  if (Array.isArray(e))
    for (const r of e)
      n$(r, t);
  else e != null && e !== !1 && e !== "" && t.push(e);
  return t;
}
u(n$, "getChildren");
function h0(e) {
  const t = e.type;
  if (typeof t == "string")
    return t;
  if (typeof t == "function")
    return t.displayName || t.name || "Unknown";
  if (ji.isFragment(e))
    return "React.Fragment";
  if (ji.isSuspense(e))
    return "React.Suspense";
  if (typeof t == "object" && t !== null) {
    if (ji.isContextProvider(e))
      return "Context.Provider";
    if (ji.isContextConsumer(e))
      return "Context.Consumer";
    if (ji.isForwardRef(e)) {
      if (t.displayName)
        return t.displayName;
      const r = t.render.displayName || t.render.name || "";
      return r === "" ? "ForwardRef" : `ForwardRef(${r})`;
    }
    if (ji.isMemo(e)) {
      const r = t.displayName || t.type.displayName || t.type.name || "";
      return r === "" ? "Memo" : `Memo(${r})`;
    }
  }
  return "UNDEFINED";
}
u(h0, "getType");
function _9(e) {
  const { props: t } = e;
  return Object.keys(t).filter((r) => r !== "children" && t[r] !== void 0).sort();
}
u(_9, "getPropKeys$1");
var G1e = /* @__PURE__ */ u((e, t, r, n, o, a) => ++n > t.maxDepth ? Cg(h0(e), t) : $g(h0(e), Tg(_9(e), e.props, t, r + t.indent, n, o, a), Ag(n$(e.props.children), t, r + t.indent, n, o, a), t, r), "serialize$1"), K1e = /* @__PURE__ */ u((e) => e != null && ji.isElement(e), "test$1"), Y1e = {
  serialize: G1e,
  test: K1e
}, X1e = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function E9(e) {
  const { props: t } = e;
  return t ? Object.keys(t).filter((r) => t[r] !== void 0).sort() : [];
}
u(E9, "getPropKeys");
var Q1e = /* @__PURE__ */ u((e, t, r, n, o, a) => ++n > t.maxDepth ? Cg(e.type, t) : $g(e.type, e.props ? Tg(E9(e), e.props, t, r + t.indent, n, o, a) : "", e.children ? Ag(e.children, t, r + t.indent, n, o, a) : "", t, r), "serialize"), Z1e = /* @__PURE__ */ u((e) => e && e.$$typeof === X1e, "test"), eEe = {
  serialize: Q1e,
  test: Z1e
}, x9 = Object.prototype.toString, tEe = Date.prototype.toISOString, rEe = Error.prototype.toString, lj = RegExp.prototype.toString;
function Ju(e) {
  return typeof e.constructor == "function" && e.constructor.name || "Object";
}
u(Ju, "getConstructorName");
function S9(e) {
  return typeof window < "u" && e === window;
}
u(S9, "isWindow");
var nEe = /^Symbol\((.*)\)(.*)$/, oEe = /\n/g, T9 = class extends Error {
  constructor(e, t) {
    super(e), this.stack = t, this.name = this.constructor.name;
  }
};
u(T9, "PrettyFormatPluginError");
var A9 = T9;
function $9(e) {
  return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
}
u($9, "isToStringedArrayType");
function C9(e) {
  return Object.is(e, -0) ? "-0" : String(e);
}
u(C9, "printNumber");
function k9(e) {
  return `${e}n`;
}
u(k9, "printBigInt");
function m0(e, t) {
  return t ? `[Function ${e.name || "anonymous"}]` : "[Function]";
}
u(m0, "printFunction");
function y0(e) {
  return String(e).replace(nEe, "Symbol($1)");
}
u(y0, "printSymbol");
function g0(e) {
  return `[${rEe.call(e)}]`;
}
u(g0, "printError");
function o$(e, t, r, n) {
  if (e === !0 || e === !1)
    return `${e}`;
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const o = typeof e;
  if (o === "number")
    return C9(e);
  if (o === "bigint")
    return k9(e);
  if (o === "string")
    return n ? `"${e.replaceAll(/"|\\/g, "\\$&")}"` : `"${e}"`;
  if (o === "function")
    return m0(e, t);
  if (o === "symbol")
    return y0(e);
  const a = x9.call(e);
  return a === "[object WeakMap]" ? "WeakMap {}" : a === "[object WeakSet]" ? "WeakSet {}" : a === "[object Function]" || a === "[object GeneratorFunction]" ? m0(e, t) : a === "[object Symbol]" ? y0(e) : a === "[object Date]" ? Number.isNaN(+e) ? "Date { NaN }" : tEe.call(e) : a === "[object Error]" ? g0(e) : a === "[object RegExp]" ? r ? lj.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : lj.call(e) : e instanceof Error ? g0(e) : null;
}
u(o$, "printBasicValue");
function a$(e, t, r, n, o, a) {
  if (o.includes(e))
    return "[Circular]";
  o = [...o], o.push(e);
  const i = ++n > t.maxDepth, s = t.min;
  if (t.callToJSON && !i && e.toJSON && typeof e.toJSON == "function" && !a)
    return Jo(e.toJSON(), t, r, n, o, !0);
  const d = x9.call(e);
  return d === "[object Arguments]" ? i ? "[Arguments]" : `${s ? "" : "Arguments "}[${Rd(e, t, r, n, o, Jo)}]` : $9(d) ? i ? `[${e.constructor.name}]` : `${s || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : `${e.constructor.name} `}[${Rd(e, t, r, n, o, Jo)}]` : d === "[object Map]" ? i ? "[Map]" : `Map {${Rc(e.entries(), t, r, n, o, Jo, " => ")}}` : d === "[object Set]" ? i ? "[Set]" : `Set {${xg(e.values(), t, r, n, o, Jo)}}` : i || S9(e) ? `[${Ju(e)}]` : `${s || !t.printBasicPrototype && Ju(e) === "Object" ? "" : `${Ju(e)} `}{${Sg(e, t, r, n, o, Jo)}}`;
}
u(a$, "printComplexValue");
var aEe = {
  test: /* @__PURE__ */ u((e) => e && e instanceof Error, "test"),
  serialize(e, t, r, n, o, a) {
    if (o.includes(e))
      return "[Circular]";
    o = [...o, e];
    const i = ++n > t.maxDepth, { message: s, cause: d, ...l } = e, p = {
      message: s,
      ...typeof d < "u" ? { cause: d } : {},
      ...e instanceof AggregateError ? { errors: e.errors } : {},
      ...l
    }, f = e.name !== "Error" ? e.name : Ju(e);
    return i ? `[${f}]` : `${f} {${Rc(Object.entries(p).values(), t, r, n, o, a)}}`;
  }
};
function P9(e) {
  return e.serialize != null;
}
u(P9, "isNewPlugin");
function i$(e, t, r, n, o, a) {
  let i;
  try {
    i = P9(e) ? e.serialize(t, r, n, o, a, Jo) : e.print(t, (s) => Jo(s, r, n, o, a), (s) => {
      const d = n + r.indent;
      return d + s.replaceAll(oEe, `
${d}`);
    }, {
      edgeSpacing: r.spacingOuter,
      min: r.min,
      spacing: r.spacingInner
    }, r.colors);
  } catch (s) {
    throw new A9(s.message, s.stack);
  }
  if (typeof i != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof i}".`);
  return i;
}
u(i$, "printPlugin");
function s$(e, t) {
  for (const r of e)
    try {
      if (r.test(t))
        return r;
    } catch (n) {
      throw new A9(n.message, n.stack);
    }
  return null;
}
u(s$, "findPlugin");
function Jo(e, t, r, n, o, a) {
  const i = s$(t.plugins, e);
  if (i !== null)
    return i$(i, e, t, r, n, o);
  const s = o$(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return s !== null ? s : a$(e, t, r, n, o, a);
}
u(Jo, "printer");
var l$ = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, O9 = Object.keys(l$), In = {
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: l$
};
function R9(e) {
  for (const t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(In, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
u(R9, "validateOptions");
function j9() {
  return O9.reduce((e, t) => {
    const r = l$[t], n = r && Ot[r];
    if (n && typeof n.close == "string" && typeof n.open == "string")
      e[t] = n;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`);
    return e;
  }, /* @__PURE__ */ Object.create(null));
}
u(j9, "getColorsHighlight");
function I9() {
  return O9.reduce((e, t) => (e[t] = {
    close: "",
    open: ""
  }, e), /* @__PURE__ */ Object.create(null));
}
u(I9, "getColorsEmpty");
function c$(e) {
  return e?.printFunctionName ?? In.printFunctionName;
}
u(c$, "getPrintFunctionName");
function u$(e) {
  return e?.escapeRegex ?? In.escapeRegex;
}
u(u$, "getEscapeRegex");
function d$(e) {
  return e?.escapeString ?? In.escapeString;
}
u(d$, "getEscapeString");
function b0(e) {
  return {
    callToJSON: e?.callToJSON ?? In.callToJSON,
    colors: e?.highlight ? j9() : I9(),
    compareKeys: typeof e?.compareKeys == "function" || e?.compareKeys === null ? e.compareKeys : In.compareKeys,
    escapeRegex: u$(e),
    escapeString: d$(e),
    indent: e?.min ? "" : N9(e?.indent ?? In.indent),
    maxDepth: e?.maxDepth ?? In.maxDepth,
    maxWidth: e?.maxWidth ?? In.maxWidth,
    min: e?.min ?? In.min,
    plugins: e?.plugins ?? In.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? !0,
    printFunctionName: c$(e),
    spacingInner: e?.min ? " " : `
`,
    spacingOuter: e?.min ? "" : `
`
  };
}
u(b0, "getConfig");
function N9(e) {
  return Array.from({ length: e + 1 }).join(" ");
}
u(N9, "createIndent");
function qn(e, t) {
  if (t && (R9(t), t.plugins)) {
    const n = s$(t.plugins, e);
    if (n !== null)
      return i$(n, e, b0(t), "", 0, []);
  }
  const r = o$(e, c$(t), u$(t), d$(t));
  return r !== null ? r : a$(e, b0(t), "", 0, []);
}
u(qn, "format");
var p$ = {
  AsymmetricMatcher: g1e,
  DOMCollection: E1e,
  DOMElement: $1e,
  Immutable: q1e,
  ReactElement: Y1e,
  ReactTestComponent: eEe,
  Error: aEe
}, cj = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, iEe = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, nc = "â€¦";
function M9(e, t) {
  const r = cj[iEe[t]] || cj[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
u(M9, "colorise");
function D9({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: n = !0,
  showProxy: o = !1,
  maxArrayLength: a = 1 / 0,
  breakLength: i = 1 / 0,
  seen: s = [],
  // eslint-disable-next-line no-shadow
  truncate: d = 1 / 0,
  stylize: l = String
} = {}, p) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(a),
    breakLength: Number(i),
    truncate: Number(d),
    seen: s,
    inspect: p,
    stylize: l
  };
  return f.colors && (f.stylize = M9), f;
}
u(D9, "normaliseOptions");
function q9(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
u(q9, "isHighSurrogate");
function pa(e, t, r = nc) {
  e = String(e);
  const n = r.length, o = e.length;
  if (n > t && o > n)
    return r;
  if (o > t && o > n) {
    let a = t - n;
    return a > 0 && q9(e[a - 1]) && (a = a - 1), `${e.slice(0, a)}${r}`;
  }
  return e;
}
u(pa, "truncate");
function En(e, t, r, n = ", ") {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0)
    return "";
  const a = t.truncate;
  let i = "", s = "", d = "";
  for (let l = 0; l < o; l += 1) {
    const p = l + 1 === e.length, f = l + 2 === e.length;
    d = `${nc}(${e.length - l})`;
    const h = e[l];
    t.truncate = a - i.length - (p ? 0 : n.length);
    const m = s || r(h, t) + (p ? "" : n), g = i.length + m.length, w = g + d.length;
    if (p && g > a && i.length + d.length <= a || !p && !f && w > a || (s = p ? "" : r(e[l + 1], t) + (f ? "" : n), !p && f && w > a && g + s.length > a))
      break;
    if (i += m, !p && !f && g + s.length >= a) {
      d = `${nc}(${e.length - l - 1})`;
      break;
    }
    d = "";
  }
  return `${i}${d}`;
}
u(En, "inspectList");
function L9(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
u(L9, "quoteComplexKey");
function oc([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = L9(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
u(oc, "inspectProperty");
function F9(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const n = En(e, t);
  t.truncate -= n.length;
  let o = "";
  return r.length && (o = En(r.map((a) => [a, e[a]]), t, oc)), `[ ${n}${o ? `, ${o}` : ""} ]`;
}
u(F9, "inspectArray");
var sEe = /* @__PURE__ */ u((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function Qn(e, t) {
  const r = sEe(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let o = "";
  for (let i = 0; i < e.length; i++) {
    const s = `${t.stylize(pa(e[i], t.truncate), "number")}${i === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= s.length, e[i] !== e.length && t.truncate <= 3) {
      o += `${nc}(${e.length - e[i] + 1})`;
      break;
    }
    o += s;
  }
  let a = "";
  return n.length && (a = En(n.map((i) => [i, e[i]]), t, oc)), `${r}[ ${o}${a ? `, ${a}` : ""} ]`;
}
u(Qn, "inspectTypedArray");
function U9(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const n = r.split("T"), o = n[0];
  return t.stylize(`${o}T${pa(n[1], t.truncate - o.length - 1)}`, "date");
}
u(U9, "inspectDate");
function v0(e, t) {
  const r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${pa(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
u(v0, "inspectFunction");
function B9([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
u(B9, "inspectMapEntry");
function H9(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
u(H9, "mapToEntries");
function V9(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${En(H9(e), t, B9)} }`);
}
u(V9, "inspectMap");
var lEe = Number.isNaN || ((e) => e !== e);
function w0(e, t) {
  return lEe(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(pa(String(e), t.truncate), "number");
}
u(w0, "inspectNumber");
function _0(e, t) {
  let r = pa(e.toString(), t.truncate - 1);
  return r !== nc && (r += "n"), t.stylize(r, "bigint");
}
u(_0, "inspectBigInt");
function z9(e, t) {
  const r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), o = e.source;
  return t.stylize(`/${pa(o, n)}/${r}`, "regexp");
}
u(z9, "inspectRegExp");
function J9(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
u(J9, "arrayFromSet");
function W9(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${En(J9(e), t)} }`);
}
u(W9, "inspectSet");
var uj = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), cEe = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, uEe = 16;
function G9(e) {
  return cEe[e] || `\\u${`0000${e.charCodeAt(0).toString(uEe)}`.slice(-4)}`;
}
u(G9, "escape");
function E0(e, t) {
  return uj.test(e) && (e = e.replace(uj, G9)), t.stylize(`'${pa(e, t.truncate - 2)}'`, "string");
}
u(E0, "inspectString");
function x0(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
u(x0, "inspectSymbol");
var dEe = /* @__PURE__ */ u(() => "Promise{â€¦}", "getPromiseValue"), pEe = dEe;
function Wu(e, t) {
  const r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const o = En(r.map((s) => [s, e[s]]), t, oc), a = En(n.map((s) => [s, e[s]]), t, oc);
  t.seen.pop();
  let i = "";
  return o && a && (i = ", "), `{ ${o}${i}${a} }`;
}
u(Wu, "inspectObject");
var $v = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function K9(e, t) {
  let r = "";
  return $v && $v in e && (r = e[$v]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${Wu(e, t)}`;
}
u(K9, "inspectClass");
function Y9(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${En(e, t)} ]`);
}
u(Y9, "inspectArguments");
var fEe = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function X9(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((i) => fEe.indexOf(i) === -1), n = e.name;
  t.truncate -= n.length;
  let o = "";
  if (typeof e.message == "string" ? o = pa(e.message, t.truncate) : r.unshift("message"), o = o ? `: ${o}` : "", t.truncate -= o.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = En(r.map((i) => [i, e[i]]), t, oc);
  return `${n}${o}${a ? ` { ${a} }` : ""}`;
}
u(X9, "inspectObject");
function Q9([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
u(Q9, "inspectAttribute");
function Jh(e, t) {
  return En(e, t, Z9, `
`);
}
u(Jh, "inspectNodeCollection");
function Z9(e, t) {
  switch (e.nodeType) {
    case 1:
      return f$(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
u(Z9, "inspectNode");
function f$(e, t) {
  const r = e.getAttributeNames(), n = e.tagName.toLowerCase(), o = t.stylize(`<${n}`, "special"), a = t.stylize(">", "special"), i = t.stylize(`</${n}>`, "special");
  t.truncate -= n.length * 2 + 5;
  let s = "";
  r.length > 0 && (s += " ", s += En(r.map((p) => [p, e.getAttribute(p)]), t, Q9, " ")), t.truncate -= s.length;
  const d = t.truncate;
  let l = Jh(e.children, t);
  return l && l.length > d && (l = `${nc}(${e.children.length})`), `${o}${s}${a}${l}${i}`;
}
u(f$, "inspectHTML");
var hEe = typeof Symbol == "function" && typeof Symbol.for == "function", Cv = hEe ? Symbol.for("chai/inspect") : "@@chai/inspect", kv = Symbol.for("nodejs.util.inspect.custom"), dj = /* @__PURE__ */ new WeakMap(), pj = {}, fj = {
  undefined: /* @__PURE__ */ u((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ u((e, t) => t.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ u((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ u((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: w0,
  Number: w0,
  bigint: _0,
  BigInt: _0,
  string: E0,
  String: E0,
  function: v0,
  Function: v0,
  symbol: x0,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: x0,
  Array: F9,
  Date: U9,
  Map: V9,
  Set: W9,
  RegExp: z9,
  Promise: pEe,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ u((e, t) => t.stylize("WeakSet{â€¦}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ u((e, t) => t.stylize("WeakMap{â€¦}", "special"), "WeakMap"),
  Arguments: Y9,
  Int8Array: Qn,
  Uint8Array: Qn,
  Uint8ClampedArray: Qn,
  Int16Array: Qn,
  Uint16Array: Qn,
  Int32Array: Qn,
  Uint32Array: Qn,
  Float32Array: Qn,
  Float64Array: Qn,
  Generator: /* @__PURE__ */ u(() => "", "Generator"),
  DataView: /* @__PURE__ */ u(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ u(() => "", "ArrayBuffer"),
  Error: X9,
  HTMLCollection: Jh,
  NodeList: Jh
}, mEe = /* @__PURE__ */ u((e, t, r, n) => Cv in e && typeof e[Cv] == "function" ? e[Cv](t) : kv in e && typeof e[kv] == "function" ? e[kv](t.depth, t, n) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && dj.has(e.constructor) ? dj.get(e.constructor)(e, t) : pj[r] ? pj[r](e, t) : "", "inspectCustom"), yEe = Object.prototype.toString;
function Gu(e, t = {}) {
  const r = D9(t, Gu), { customInspect: n } = r;
  let o = e === null ? "null" : typeof e;
  if (o === "object" && (o = yEe.call(e).slice(8, -1)), o in fj)
    return fj[o](e, r);
  if (n && e) {
    const i = mEe(e, r, o, Gu);
    if (i)
      return typeof i == "string" ? i : Gu(i, r);
  }
  const a = e ? Object.getPrototypeOf(e) : !1;
  return a === Object.prototype || a === null ? Wu(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? f$(e, r) : "constructor" in e ? e.constructor !== Object ? K9(e, r) : Wu(e, r) : e === Object(e) ? Wu(e, r) : r.stylize(String(e), o);
}
u(Gu, "inspect");
var { AsymmetricMatcher: gEe, DOMCollection: bEe, DOMElement: vEe, Immutable: wEe, ReactElement: _Ee, ReactTestComponent: EEe } = p$, hj = [
  EEe,
  _Ee,
  vEe,
  bEe,
  wEe,
  gEe
];
function jr(e, t = 10, { maxLength: r, ...n } = {}) {
  const o = r ?? 1e4;
  let a;
  try {
    a = qn(e, {
      maxDepth: t,
      escapeString: !1,
      plugins: hj,
      ...n
    });
  } catch {
    a = qn(e, {
      callToJSON: !1,
      maxDepth: t,
      escapeString: !1,
      plugins: hj,
      ...n
    });
  }
  return a.length >= o && t > 1 ? jr(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength: r,
    ...n
  }) : a;
}
u(jr, "stringify");
var xEe = /%[sdjifoOc%]/g;
function eG(...e) {
  if (typeof e[0] != "string") {
    const a = [];
    for (let i = 0; i < e.length; i++)
      a.push(tl(e[i], {
        depth: 0,
        colors: !1
      }));
    return a.join(" ");
  }
  const t = e.length;
  let r = 1;
  const n = e[0];
  let o = String(n).replace(xEe, (a) => {
    if (a === "%%")
      return "%";
    if (r >= t)
      return a;
    switch (a) {
      case "%s": {
        const i = e[r++];
        return typeof i == "bigint" ? `${i.toString()}n` : typeof i == "number" && i === 0 && 1 / i < 0 ? "-0" : typeof i == "object" && i !== null ? typeof i.toString == "function" && i.toString !== Object.prototype.toString ? i.toString() : tl(i, {
          depth: 0,
          colors: !1
        }) : String(i);
      }
      case "%d": {
        const i = e[r++];
        return typeof i == "bigint" ? `${i.toString()}n` : Number(i).toString();
      }
      case "%i": {
        const i = e[r++];
        return typeof i == "bigint" ? `${i.toString()}n` : Number.parseInt(String(i)).toString();
      }
      case "%f":
        return Number.parseFloat(String(e[r++])).toString();
      case "%o":
        return tl(e[r++], {
          showHidden: !0,
          showProxy: !0
        });
      case "%O":
        return tl(e[r++]);
      case "%c":
        return r++, "";
      case "%j":
        try {
          return JSON.stringify(e[r++]);
        } catch (i) {
          const s = i.message;
          if (s.includes("circular structure") || s.includes("cyclic structures") || s.includes("cyclic object"))
            return "[Circular]";
          throw i;
        }
      default:
        return a;
    }
  });
  for (let a = e[r]; r < t; a = e[++r])
    a === null || typeof a != "object" ? o += ` ${a}` : o += ` ${tl(a)}`;
  return o;
}
u(eG, "format");
function tl(e, t = {}) {
  return t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), Gu(e, t);
}
u(tl, "inspect");
function h$(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
u(h$, "getDefaultExportFromCjs");
function Zn(e, t, r) {
  const n = typeof e;
  if (!r.includes(n))
    throw new TypeError(`${t} value must be ${r.join(" or ")}, received "${n}"`);
}
u(Zn, "assertTypes");
function Ku(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
u(Ku, "isObject");
function tG(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
u(tG, "isFinalObj");
function Id(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
u(Id, "getType");
function rG(e, t) {
  const r = typeof t == "function" ? t : (n) => t.add(n);
  Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r);
}
u(rG, "collectOwnProperties");
function m$(e) {
  const t = /* @__PURE__ */ new Set();
  return tG(e) ? [] : (rG(e, t), Array.from(t));
}
u(m$, "getOwnProperties");
var nG = { forceWritable: !1 };
function S0(e, t = nG) {
  return Wh(e, /* @__PURE__ */ new WeakMap(), t);
}
u(S0, "deepClone");
function Wh(e, t, r = nG) {
  let n, o;
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    for (o = Array.from({ length: n = e.length }), t.set(e, o); n--; )
      o[n] = Wh(e[n], t, r);
    return o;
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
    o = Object.create(Object.getPrototypeOf(e)), t.set(e, o);
    const a = m$(e);
    for (const i of a) {
      const s = Object.getOwnPropertyDescriptor(e, i);
      if (!s)
        continue;
      const d = Wh(e[i], t, r);
      r.forceWritable ? Object.defineProperty(o, i, {
        enumerable: s.enumerable,
        configurable: !0,
        writable: !0,
        value: d
      }) : "get" in s ? Object.defineProperty(o, i, {
        ...s,
        get() {
          return d;
        }
      }) : Object.defineProperty(o, i, {
        ...s,
        value: d
      });
    }
    return o;
  }
  return e;
}
u(Wh, "clone");
function oG() {
}
u(oG, "noop");
var Er = -1, ur = 1, kt = 0, aG = class {
  0;
  1;
  constructor(e, t) {
    this[0] = e, this[1] = t;
  }
};
u(aG, "Diff");
var $t = aG;
function iG(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), o = n, a = 0;
  for (; r < o; )
    e.substring(a, o) === t.substring(a, o) ? (r = o, a = r) : n = o, o = Math.floor((n - r) / 2 + r);
  return o;
}
u(iG, "diff_commonPrefix");
function y$(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), o = n, a = 0;
  for (; r < o; )
    e.substring(e.length - o, e.length - a) === t.substring(t.length - o, t.length - a) ? (r = o, a = r) : n = o, o = Math.floor((n - r) / 2 + r);
  return o;
}
u(y$, "diff_commonSuffix");
function T0(e, t) {
  const r = e.length, n = t.length;
  if (r === 0 || n === 0)
    return 0;
  r > n ? e = e.substring(r - n) : r < n && (t = t.substring(0, r));
  const o = Math.min(r, n);
  if (e === t)
    return o;
  let a = 0, i = 1;
  for (; ; ) {
    const s = e.substring(o - i), d = t.indexOf(s);
    if (d === -1)
      return a;
    i += d, (d === 0 || e.substring(o - i) === t.substring(0, i)) && (a = i, i++);
  }
}
u(T0, "diff_commonOverlap_");
function sG(e) {
  let t = !1;
  const r = [];
  let n = 0, o = null, a = 0, i = 0, s = 0, d = 0, l = 0;
  for (; a < e.length; )
    e[a][0] === kt ? (r[n++] = a, i = d, s = l, d = 0, l = 0, o = e[a][1]) : (e[a][0] === ur ? d += e[a][1].length : l += e[a][1].length, o && o.length <= Math.max(i, s) && o.length <= Math.max(d, l) && (e.splice(r[n - 1], 0, new $t(Er, o)), e[r[n - 1] + 1][0] = ur, n--, n--, a = n > 0 ? r[n - 1] : -1, i = 0, s = 0, d = 0, l = 0, o = null, t = !0)), a++;
  for (t && g$(e), lG(e), a = 1; a < e.length; ) {
    if (e[a - 1][0] === Er && e[a][0] === ur) {
      const p = e[a - 1][1], f = e[a][1], h = T0(p, f), m = T0(f, p);
      h >= m ? (h >= p.length / 2 || h >= f.length / 2) && (e.splice(a, 0, new $t(kt, f.substring(0, h))), e[a - 1][1] = p.substring(0, p.length - h), e[a + 1][1] = f.substring(h), a++) : (m >= p.length / 2 || m >= f.length / 2) && (e.splice(a, 0, new $t(kt, p.substring(0, m))), e[a - 1][0] = ur, e[a - 1][1] = f.substring(0, f.length - m), e[a + 1][0] = Er, e[a + 1][1] = p.substring(m), a++), a++;
    }
    a++;
  }
}
u(sG, "diff_cleanupSemantic");
var mj = /[^a-z0-9]/i, yj = /\s/, gj = /[\r\n]/, SEe = /\n\r?\n$/, TEe = /^\r?\n\r?\n/;
function lG(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === kt && e[t + 1][0] === kt) {
      let r = e[t - 1][1], n = e[t][1], o = e[t + 1][1];
      const a = y$(r, n);
      if (a) {
        const p = n.substring(n.length - a);
        r = r.substring(0, r.length - a), n = p + n.substring(0, n.length - a), o = p + o;
      }
      let i = r, s = n, d = o, l = _u(r, n) + _u(n, o);
      for (; n.charAt(0) === o.charAt(0); ) {
        r += n.charAt(0), n = n.substring(1) + o.charAt(0), o = o.substring(1);
        const p = _u(r, n) + _u(n, o);
        p >= l && (l = p, i = r, s = n, d = o);
      }
      e[t - 1][1] !== i && (i ? e[t - 1][1] = i : (e.splice(t - 1, 1), t--), e[t][1] = s, d ? e[t + 1][1] = d : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
u(lG, "diff_cleanupSemanticLossless");
function g$(e) {
  e.push(new $t(kt, ""));
  let t = 0, r = 0, n = 0, o = "", a = "", i;
  for (; t < e.length; )
    switch (e[t][0]) {
      case ur:
        n++, a += e[t][1], t++;
        break;
      case Er:
        r++, o += e[t][1], t++;
        break;
      case kt:
        r + n > 1 ? (r !== 0 && n !== 0 && (i = iG(a, o), i !== 0 && (t - r - n > 0 && e[t - r - n - 1][0] === kt ? e[t - r - n - 1][1] += a.substring(0, i) : (e.splice(0, 0, new $t(kt, a.substring(0, i))), t++), a = a.substring(i), o = o.substring(i)), i = y$(a, o), i !== 0 && (e[t][1] = a.substring(a.length - i) + e[t][1], a = a.substring(0, a.length - i), o = o.substring(0, o.length - i))), t -= r + n, e.splice(t, r + n), o.length && (e.splice(t, 0, new $t(Er, o)), t++), a.length && (e.splice(t, 0, new $t(ur, a)), t++), t++) : t !== 0 && e[t - 1][0] === kt ? (e[t - 1][1] += e[t][1], e.splice(t, 1)) : t++, n = 0, r = 0, o = "", a = "";
        break;
    }
  e[e.length - 1][1] === "" && e.pop();
  let s = !1;
  for (t = 1; t < e.length - 1; )
    e[t - 1][0] === kt && e[t + 1][0] === kt && (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1] ? (e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length), e[t + 1][1] = e[t - 1][1] + e[t + 1][1], e.splice(t - 1, 1), s = !0) : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] && (e[t - 1][1] += e[t + 1][1], e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1], e.splice(t + 1, 1), s = !0)), t++;
  s && g$(e);
}
u(g$, "diff_cleanupMerge");
function _u(e, t) {
  if (!e || !t)
    return 6;
  const r = e.charAt(e.length - 1), n = t.charAt(0), o = r.match(mj), a = n.match(mj), i = o && r.match(yj), s = a && n.match(yj), d = i && r.match(gj), l = s && n.match(gj), p = d && e.match(SEe), f = l && t.match(TEe);
  return p || f ? 5 : d || l ? 4 : o && !i && s ? 3 : i || s ? 2 : o || a ? 1 : 0;
}
u(_u, "diff_cleanupSemanticScore_");
var cG = "Compared values have no visual difference.", AEe = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", Kp = {}, bj;
function uG() {
  if (bj) return Kp;
  bj = 1, Object.defineProperty(Kp, "__esModule", {
    value: !0
  }), Kp.default = h;
  const e = "diff-sequences", t = 0, r = /* @__PURE__ */ u((m, g, w, _, b) => {
    let x = 0;
    for (; m < g && w < _ && b(m, w); )
      m += 1, w += 1, x += 1;
    return x;
  }, "countCommonItemsF"), n = /* @__PURE__ */ u((m, g, w, _, b) => {
    let x = 0;
    for (; m <= g && w <= _ && b(g, _); )
      g -= 1, _ -= 1, x += 1;
    return x;
  }, "countCommonItemsR"), o = /* @__PURE__ */ u((m, g, w, _, b, x, P) => {
    let R = 0, N = -m, C = x[R], A = C;
    x[R] += r(
      C + 1,
      g,
      _ + C - N + 1,
      w,
      b
    );
    const E = m < P ? m : P;
    for (R += 1, N += 2; R <= E; R += 1, N += 2) {
      if (R !== m && A < x[R])
        C = x[R];
      else if (C = A + 1, g <= C)
        return R - 1;
      A = x[R], x[R] = C + r(C + 1, g, _ + C - N + 1, w, b);
    }
    return P;
  }, "extendPathsF"), a = /* @__PURE__ */ u((m, g, w, _, b, x, P) => {
    let R = 0, N = m, C = x[R], A = C;
    x[R] -= n(
      g,
      C - 1,
      w,
      _ + C - N - 1,
      b
    );
    const E = m < P ? m : P;
    for (R += 1, N -= 2; R <= E; R += 1, N -= 2) {
      if (R !== m && x[R] < A)
        C = x[R];
      else if (C = A - 1, C < g)
        return R - 1;
      A = x[R], x[R] = C - n(
        g,
        C - 1,
        w,
        _ + C - N - 1,
        b
      );
    }
    return P;
  }, "extendPathsR"), i = /* @__PURE__ */ u((m, g, w, _, b, x, P, R, N, C, A) => {
    const E = _ - g, T = w - g, O = b - _ - T, k = -O - (m - 1), M = -O + (m - 1);
    let L = t;
    const $ = m < R ? m : R;
    for (let I = 0, D = -m; I <= $; I += 1, D += 2) {
      const F = I === 0 || I !== m && L < P[I], J = F ? P[I] : L, oe = F ? J : J + 1, ce = E + oe - D, le = r(
        oe + 1,
        w,
        ce + 1,
        b,
        x
      ), re = oe + le;
      if (L = P[I], P[I] = re, k <= D && D <= M) {
        const we = (m - 1 - (D + O)) / 2;
        if (we <= C && N[we] - 1 <= re) {
          const _e = E + J - (F ? D + 1 : D - 1), de = n(
            g,
            J,
            _,
            _e,
            x
          ), ne = J - de, $e = _e - de, Se = ne + 1, nt = $e + 1;
          A.nChangePreceding = m - 1, m - 1 === Se + nt - g - _ ? (A.aEndPreceding = g, A.bEndPreceding = _) : (A.aEndPreceding = Se, A.bEndPreceding = nt), A.nCommonPreceding = de, de !== 0 && (A.aCommonPreceding = Se, A.bCommonPreceding = nt), A.nCommonFollowing = le, le !== 0 && (A.aCommonFollowing = oe + 1, A.bCommonFollowing = ce + 1);
          const We = re + 1, q = ce + le + 1;
          return A.nChangeFollowing = m - 1, m - 1 === w + b - We - q ? (A.aStartFollowing = w, A.bStartFollowing = b) : (A.aStartFollowing = We, A.bStartFollowing = q), !0;
        }
      }
    }
    return !1;
  }, "extendOverlappablePathsF"), s = /* @__PURE__ */ u((m, g, w, _, b, x, P, R, N, C, A) => {
    const E = b - w, T = w - g, O = b - _ - T, k = O - m, M = O + m;
    let L = t;
    const $ = m < C ? m : C;
    for (let I = 0, D = m; I <= $; I += 1, D -= 2) {
      const F = I === 0 || I !== m && N[I] < L, J = F ? N[I] : L, oe = F ? J : J - 1, ce = E + oe - D, le = n(
        g,
        oe - 1,
        _,
        ce - 1,
        x
      ), re = oe - le;
      if (L = N[I], N[I] = re, k <= D && D <= M) {
        const we = (m + (D - O)) / 2;
        if (we <= R && re - 1 <= P[we]) {
          const _e = ce - le;
          if (A.nChangePreceding = m, m === re + _e - g - _ ? (A.aEndPreceding = g, A.bEndPreceding = _) : (A.aEndPreceding = re, A.bEndPreceding = _e), A.nCommonPreceding = le, le !== 0 && (A.aCommonPreceding = re, A.bCommonPreceding = _e), A.nChangeFollowing = m - 1, m === 1)
            A.nCommonFollowing = 0, A.aStartFollowing = w, A.bStartFollowing = b;
          else {
            const de = E + J - (F ? D - 1 : D + 1), ne = r(
              J,
              w,
              de,
              b,
              x
            );
            A.nCommonFollowing = ne, ne !== 0 && (A.aCommonFollowing = J, A.bCommonFollowing = de);
            const $e = J + ne, Se = de + ne;
            m - 1 === w + b - $e - Se ? (A.aStartFollowing = w, A.bStartFollowing = b) : (A.aStartFollowing = $e, A.bStartFollowing = Se);
          }
          return !0;
        }
      }
    }
    return !1;
  }, "extendOverlappablePathsR"), d = /* @__PURE__ */ u((m, g, w, _, b, x, P, R, N) => {
    const C = _ - g, A = b - w, E = w - g, T = b - _, O = T - E;
    let k = E, M = E;
    if (P[0] = g - 1, R[0] = w, O % 2 === 0) {
      const L = (m || O) / 2, $ = (E + T) / 2;
      for (let I = 1; I <= $; I += 1)
        if (k = o(I, w, b, C, x, P, k), I < L)
          M = a(I, g, _, A, x, R, M);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          s(
            I,
            g,
            w,
            _,
            b,
            x,
            P,
            k,
            R,
            M,
            N
          )
        )
          return;
    } else {
      const L = ((m || O) + 1) / 2, $ = (E + T + 1) / 2;
      let I = 1;
      for (k = o(I, w, b, C, x, P, k), I += 1; I <= $; I += 1)
        if (M = a(
          I - 1,
          g,
          _,
          A,
          x,
          R,
          M
        ), I < L)
          k = o(I, w, b, C, x, P, k);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          i(
            I,
            g,
            w,
            _,
            b,
            x,
            P,
            k,
            R,
            M,
            N
          )
        )
          return;
    }
    throw new Error(
      `${e}: no overlap aStart=${g} aEnd=${w} bStart=${_} bEnd=${b}`
    );
  }, "divide"), l = /* @__PURE__ */ u((m, g, w, _, b, x, P, R, N, C) => {
    if (b - _ < w - g) {
      if (x = !x, x && P.length === 1) {
        const { foundSubsequence: we, isCommon: _e } = P[0];
        P[1] = {
          foundSubsequence: /* @__PURE__ */ u((de, ne, $e) => {
            we(de, $e, ne);
          }, "foundSubsequence"),
          isCommon: /* @__PURE__ */ u((de, ne) => _e(ne, de), "isCommon")
        };
      }
      const le = g, re = w;
      g = _, w = b, _ = le, b = re;
    }
    const { foundSubsequence: A, isCommon: E } = P[x ? 1 : 0];
    d(
      m,
      g,
      w,
      _,
      b,
      E,
      R,
      N,
      C
    );
    const {
      nChangePreceding: T,
      aEndPreceding: O,
      bEndPreceding: k,
      nCommonPreceding: M,
      aCommonPreceding: L,
      bCommonPreceding: $,
      nCommonFollowing: I,
      aCommonFollowing: D,
      bCommonFollowing: F,
      nChangeFollowing: J,
      aStartFollowing: oe,
      bStartFollowing: ce
    } = C;
    g < O && _ < k && l(
      T,
      g,
      O,
      _,
      k,
      x,
      P,
      R,
      N,
      C
    ), M !== 0 && A(M, L, $), I !== 0 && A(I, D, F), oe < w && ce < b && l(
      J,
      oe,
      w,
      ce,
      b,
      x,
      P,
      R,
      N,
      C
    );
  }, "findSubsequences"), p = /* @__PURE__ */ u((m, g) => {
    if (typeof g != "number")
      throw new TypeError(`${e}: ${m} typeof ${typeof g} is not a number`);
    if (!Number.isSafeInteger(g))
      throw new RangeError(`${e}: ${m} value ${g} is not a safe integer`);
    if (g < 0)
      throw new RangeError(`${e}: ${m} value ${g} is a negative integer`);
  }, "validateLength"), f = /* @__PURE__ */ u((m, g) => {
    const w = typeof g;
    if (w !== "function")
      throw new TypeError(`${e}: ${m} typeof ${w} is not a function`);
  }, "validateCallback");
  function h(m, g, w, _) {
    p("aLength", m), p("bLength", g), f("isCommon", w), f("foundSubsequence", _);
    const b = r(0, m, 0, g, w);
    if (b !== 0 && _(b, 0, 0), m !== b || g !== b) {
      const x = b, P = b, R = n(
        x,
        m - 1,
        P,
        g - 1,
        w
      ), N = m - R, C = g - R, A = b + R;
      m !== A && g !== A && l(
        0,
        x,
        N,
        P,
        C,
        !1,
        [
          {
            foundSubsequence: _,
            isCommon: w
          }
        ],
        [t],
        [t],
        {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t
        }
      ), R !== 0 && _(R, N, C);
    }
  }
  return u(h, "diffSequence"), Kp;
}
u(uG, "requireBuild");
var $Ee = uG(), dG = h$($Ee);
function pG(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
u(pG, "formatTrailingSpaces");
function Pg(e, t, r, n, o, a) {
  return e.length !== 0 ? r(`${n} ${pG(e, o)}`) : n !== " " ? r(n) : t && a.length !== 0 ? r(`${n} ${a}`) : "";
}
u(Pg, "printDiffLine");
function b$(e, t, { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: a }) {
  return Pg(e, t, r, n, o, a);
}
u(b$, "printDeleteLine");
function v$(e, t, { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: a }) {
  return Pg(e, t, r, n, o, a);
}
u(v$, "printInsertLine");
function w$(e, t, { commonColor: r, commonIndicator: n, commonLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: a }) {
  return Pg(e, t, r, n, o, a);
}
u(w$, "printCommonLine");
function A0(e, t, r, n, { patchColor: o }) {
  return o(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
u(A0, "createPatchMark");
function fG(e, t) {
  const r = e.length, n = t.contextLines, o = n + n;
  let a = r, i = !1, s = 0, d = 0;
  for (; d !== r; ) {
    const R = d;
    for (; d !== r && e[d][0] === kt; )
      d += 1;
    if (R !== d)
      if (R === 0)
        d > n && (a -= d - n, i = !0);
      else if (d === r) {
        const N = d - R;
        N > n && (a -= N - n, i = !0);
      } else {
        const N = d - R;
        N > o && (a -= N - o, s += 1);
      }
    for (; d !== r && e[d][0] !== kt; )
      d += 1;
  }
  const l = s !== 0 || i;
  s !== 0 ? a += s + 1 : i && (a += 1);
  const p = a - 1, f = [];
  let h = 0;
  l && f.push("");
  let m = 0, g = 0, w = 0, _ = 0;
  const b = /* @__PURE__ */ u((R) => {
    const N = f.length;
    f.push(w$(R, N === 0 || N === p, t)), w += 1, _ += 1;
  }, "pushCommonLine"), x = /* @__PURE__ */ u((R) => {
    const N = f.length;
    f.push(b$(R, N === 0 || N === p, t)), w += 1;
  }, "pushDeleteLine"), P = /* @__PURE__ */ u((R) => {
    const N = f.length;
    f.push(v$(R, N === 0 || N === p, t)), _ += 1;
  }, "pushInsertLine");
  for (d = 0; d !== r; ) {
    let R = d;
    for (; d !== r && e[d][0] === kt; )
      d += 1;
    if (R !== d)
      if (R === 0) {
        d > n && (R = d - n, m = R, g = R, w = m, _ = g);
        for (let N = R; N !== d; N += 1)
          b(e[N][1]);
      } else if (d === r) {
        const N = d - R > n ? R + n : d;
        for (let C = R; C !== N; C += 1)
          b(e[C][1]);
      } else {
        const N = d - R;
        if (N > o) {
          const C = R + n;
          for (let E = R; E !== C; E += 1)
            b(e[E][1]);
          f[h] = A0(m, w, g, _, t), h = f.length, f.push("");
          const A = N - o;
          m = w + A, g = _ + A, w = m, _ = g;
          for (let E = d - n; E !== d; E += 1)
            b(e[E][1]);
        } else
          for (let C = R; C !== d; C += 1)
            b(e[C][1]);
      }
    for (; d !== r && e[d][0] === Er; )
      x(e[d][1]), d += 1;
    for (; d !== r && e[d][0] === ur; )
      P(e[d][1]), d += 1;
  }
  return l && (f[h] = A0(m, w, g, _, t)), f.join(`
`);
}
u(fG, "joinAlignedDiffsNoExpand");
function hG(e, t) {
  return e.map((r, n, o) => {
    const a = r[1], i = n === 0 || n === o.length - 1;
    switch (r[0]) {
      case Er:
        return b$(a, i, t);
      case ur:
        return v$(a, i, t);
      default:
        return w$(a, i, t);
    }
  }).join(`
`);
}
u(hG, "joinAlignedDiffsExpand");
var Pv = /* @__PURE__ */ u((e) => e, "noColor"), mG = 5, CEe = 0;
function yG() {
  return {
    aAnnotation: "Expected",
    aColor: Ot.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: Ot.red,
    bIndicator: "+",
    changeColor: Ot.inverse,
    changeLineTrailingSpaceColor: Pv,
    commonColor: Ot.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: Pv,
    compareKeys: void 0,
    contextLines: mG,
    emptyFirstOrLastLinePlaceholder: "",
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: Ot.yellow,
    printBasicPrototype: !1,
    truncateThreshold: CEe,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: Pv
  };
}
u(yG, "getDefaultOptions");
function gG(e) {
  return e && typeof e == "function" ? e : void 0;
}
u(gG, "getCompareKeys");
function bG(e) {
  return typeof e == "number" && Number.isSafeInteger(e) && e >= 0 ? e : mG;
}
u(bG, "getContextLines");
function li(e = {}) {
  return {
    ...yG(),
    ...e,
    compareKeys: gG(e.compareKeys),
    contextLines: bG(e.contextLines)
  };
}
u(li, "normalizeDiffOptions");
function Hi(e) {
  return e.length === 1 && e[0].length === 0;
}
u(Hi, "isEmptyString");
function vG(e) {
  let t = 0, r = 0;
  return e.forEach((n) => {
    switch (n[0]) {
      case Er:
        t += 1;
        break;
      case ur:
        r += 1;
        break;
    }
  }), {
    a: t,
    b: r
  };
}
u(vG, "countChanges");
function wG({ aAnnotation: e, aColor: t, aIndicator: r, bAnnotation: n, bColor: o, bIndicator: a, includeChangeCounts: i, omitAnnotationLines: s }, d) {
  if (s)
    return "";
  let l = "", p = "";
  if (i) {
    const m = String(d.a), g = String(d.b), w = n.length - e.length, _ = " ".repeat(Math.max(0, w)), b = " ".repeat(Math.max(0, -w)), x = g.length - m.length, P = " ".repeat(Math.max(0, x)), R = " ".repeat(Math.max(0, -x));
    l = `${_}  ${r} ${P}${m}`, p = `${b}  ${a} ${R}${g}`;
  }
  const f = `${r} ${e}${l}`, h = `${a} ${n}${p}`;
  return `${t(f)}
${o(h)}

`;
}
u(wG, "printAnnotation");
function Og(e, t, r) {
  return wG(r, vG(e)) + (r.expand ? hG(e, r) : fG(e, r)) + (t ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`) : "");
}
u(Og, "printDiffLines");
function _p(e, t, r) {
  const n = li(r), [o, a] = _$(Hi(e) ? [] : e, Hi(t) ? [] : t, n);
  return Og(o, a, n);
}
u(_p, "diffLinesUnified");
function _G(e, t, r, n, o) {
  if (Hi(e) && Hi(r) && (e = [], r = []), Hi(t) && Hi(n) && (t = [], n = []), e.length !== r.length || t.length !== n.length)
    return _p(e, t, o);
  const [a, i] = _$(r, n, o);
  let s = 0, d = 0;
  return a.forEach((l) => {
    switch (l[0]) {
      case Er:
        l[1] = e[s], s += 1;
        break;
      case ur:
        l[1] = t[d], d += 1;
        break;
      default:
        l[1] = t[d], s += 1, d += 1;
    }
  }), Og(a, i, li(o));
}
u(_G, "diffLinesUnified2");
function _$(e, t, r) {
  const n = r?.truncateThreshold ?? !1, o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0), a = n ? Math.min(e.length, o) : e.length, i = n ? Math.min(t.length, o) : t.length, s = a !== e.length || i !== t.length, d = /* @__PURE__ */ u((h, m) => e[h] === t[m], "isCommon"), l = [];
  let p = 0, f = 0;
  for (dG(a, i, d, /* @__PURE__ */ u((h, m, g) => {
    for (; p !== m; p += 1)
      l.push(new $t(Er, e[p]));
    for (; f !== g; f += 1)
      l.push(new $t(ur, t[f]));
    for (; h !== 0; h -= 1, p += 1, f += 1)
      l.push(new $t(kt, t[f]));
  }, "foundSubsequence")); p !== a; p += 1)
    l.push(new $t(Er, e[p]));
  for (; f !== i; f += 1)
    l.push(new $t(ur, t[f]));
  return [l, s];
}
u(_$, "diffLinesRaw");
function $0(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  if (Array.isArray(e))
    return "array";
  if (typeof e == "boolean")
    return "boolean";
  if (typeof e == "function")
    return "function";
  if (typeof e == "number")
    return "number";
  if (typeof e == "string")
    return "string";
  if (typeof e == "bigint")
    return "bigint";
  if (typeof e == "object") {
    if (e != null) {
      if (e.constructor === RegExp)
        return "regexp";
      if (e.constructor === Map)
        return "map";
      if (e.constructor === Set)
        return "set";
      if (e.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof e == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${e}`);
}
u($0, "getType");
function C0(e) {
  return e.includes(`\r
`) ? `\r
` : `
`;
}
u(C0, "getNewLineSymbol");
function EG(e, t, r) {
  const n = r?.truncateThreshold ?? !1, o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
  let a = e.length, i = t.length;
  if (n) {
    const h = e.includes(`
`), m = t.includes(`
`), g = C0(e), w = C0(t), _ = h ? `${e.split(g, o).join(g)}
` : e, b = m ? `${t.split(w, o).join(w)}
` : t;
    a = _.length, i = b.length;
  }
  const s = a !== e.length || i !== t.length, d = /* @__PURE__ */ u((h, m) => e[h] === t[m], "isCommon");
  let l = 0, p = 0;
  const f = [];
  return dG(a, i, d, /* @__PURE__ */ u((h, m, g) => {
    l !== m && f.push(new $t(Er, e.slice(l, m))), p !== g && f.push(new $t(ur, t.slice(p, g))), l = m + h, p = g + h, f.push(new $t(kt, t.slice(g, p)));
  }, "foundSubsequence")), l !== a && f.push(new $t(Er, e.slice(l))), p !== i && f.push(new $t(ur, t.slice(p))), [f, s];
}
u(EG, "diffStrings");
function xG(e, t, r) {
  return t.reduce((n, o) => n + (o[0] === kt ? o[1] : o[0] === e && o[1].length !== 0 ? r(o[1]) : ""), "");
}
u(xG, "concatenateRelevantDiffs");
var SG = class {
  op;
  line;
  lines;
  changeColor;
  constructor(e, t) {
    this.op = e, this.line = [], this.lines = [], this.changeColor = t;
  }
  pushSubstring(e) {
    this.pushDiff(new $t(this.op, e));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new $t(this.op, xG(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new $t(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(e) {
    this.line.push(e);
  }
  // Main input to buffer.
  align(e) {
    const t = e[1];
    if (t.includes(`
`)) {
      const r = t.split(`
`), n = r.length - 1;
      r.forEach((o, a) => {
        a < n ? (this.pushSubstring(o), this.pushLine()) : o.length !== 0 && this.pushSubstring(o);
      });
    } else
      this.pushDiff(e);
  }
  // Output from buffer.
  moveLinesTo(e) {
    this.isLineEmpty() || this.pushLine(), e.push(...this.lines), this.lines.length = 0;
  }
};
u(SG, "ChangeBuffer");
var vj = SG, TG = class {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(e, t) {
    this.deleteBuffer = e, this.insertBuffer = t, this.lines = [];
  }
  pushDiffCommonLine(e) {
    this.lines.push(e);
  }
  pushDiffChangeLines(e) {
    const t = e[1].length === 0;
    (!t || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(e), (!t || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(e);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(e) {
    const t = e[0], r = e[1];
    if (r.includes(`
`)) {
      const n = r.split(`
`), o = n.length - 1;
      n.forEach((a, i) => {
        if (i === 0) {
          const s = new $t(t, a);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(s)) : (this.pushDiffChangeLines(s), this.flushChangeLines());
        } else i < o ? this.pushDiffCommonLine(new $t(t, a)) : a.length !== 0 && this.pushDiffChangeLines(new $t(t, a));
      });
    } else
      this.pushDiffChangeLines(e);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
u(TG, "CommonBuffer");
var kEe = TG;
function AG(e, t) {
  const r = new vj(Er, t), n = new vj(ur, t), o = new kEe(r, n);
  return e.forEach((a) => {
    switch (a[0]) {
      case Er:
        r.align(a);
        break;
      case ur:
        n.align(a);
        break;
      default:
        o.align(a);
    }
  }), o.getLines();
}
u(AG, "getAlignedDiffs");
function $G(e, t) {
  if (t) {
    const r = e.length - 1;
    return e.some((n, o) => n[0] === kt && (o !== r || n[1] !== `
`));
  }
  return e.some((r) => r[0] === kt);
}
u($G, "hasCommonDiff");
function CG(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    const n = e.includes(`
`) || t.includes(`
`), [o, a] = E$(n ? `${e}
` : e, n ? `${t}
` : t, !0, r);
    if ($G(o, n)) {
      const i = li(r), s = AG(o, i.changeColor);
      return Og(s, a, i);
    }
  }
  return _p(e.split(`
`), t.split(`
`), r);
}
u(CG, "diffStringsUnified");
function E$(e, t, r, n) {
  const [o, a] = EG(e, t, n);
  return r && sG(o), [o, a];
}
u(E$, "diffStringsRaw");
function Gh(e, t) {
  const { commonColor: r } = li(t);
  return r(e);
}
u(Gh, "getCommonMessage");
var { AsymmetricMatcher: PEe, DOMCollection: OEe, DOMElement: REe, Immutable: jEe, ReactElement: IEe, ReactTestComponent: NEe } = p$, kG = [
  NEe,
  IEe,
  REe,
  OEe,
  jEe,
  PEe,
  p$.Error
], k0 = {
  maxDepth: 20,
  plugins: kG
}, PG = {
  callToJSON: !1,
  maxDepth: 8,
  plugins: kG
};
function Ds(e, t, r) {
  if (Object.is(e, t))
    return "";
  const n = $0(e);
  let o = n, a = !1;
  if (n === "object" && typeof e.asymmetricMatch == "function") {
    if (e.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof e.getExpectedType != "function")
      return;
    o = e.getExpectedType(), a = o === "string";
  }
  if (o !== $0(t)) {
    let i = function(P) {
      return P.length <= _ ? P : `${P.slice(0, _)}...`;
    };
    u(i, "truncate");
    const { aAnnotation: s, aColor: d, aIndicator: l, bAnnotation: p, bColor: f, bIndicator: h } = li(r), m = Kh(PG, r);
    let g = qn(e, m), w = qn(t, m);
    const _ = 1e5;
    g = i(g), w = i(w);
    const b = `${d(`${l} ${s}:`)} 
${g}`, x = `${f(`${h} ${p}:`)} 
${w}`;
    return `${b}

${x}`;
  }
  if (!a)
    switch (n) {
      case "string":
        return _p(e.split(`
`), t.split(`
`), r);
      case "boolean":
      case "number":
        return OG(e, t, r);
      case "map":
        return xf(P0(e), P0(t), r);
      case "set":
        return xf(O0(e), O0(t), r);
      default:
        return xf(e, t, r);
    }
}
u(Ds, "diff");
function OG(e, t, r) {
  const n = qn(e, k0), o = qn(t, k0);
  return n === o ? "" : _p(n.split(`
`), o.split(`
`), r);
}
u(OG, "comparePrimitive");
function P0(e) {
  return new Map(Array.from(e.entries()).sort());
}
u(P0, "sortMap");
function O0(e) {
  return new Set(Array.from(e.values()).sort());
}
u(O0, "sortSet");
function xf(e, t, r) {
  let n, o = !1;
  try {
    const i = Kh(k0, r);
    n = R0(e, t, i, r);
  } catch {
    o = !0;
  }
  const a = Gh(cG, r);
  if (n === void 0 || n === a) {
    const i = Kh(PG, r);
    n = R0(e, t, i, r), n !== a && !o && (n = `${Gh(AEe, r)}

${n}`);
  }
  return n;
}
u(xf, "compareObjects");
function Kh(e, t) {
  const { compareKeys: r, printBasicPrototype: n, maxDepth: o } = li(t);
  return {
    ...e,
    compareKeys: r,
    printBasicPrototype: n,
    maxDepth: o ?? e.maxDepth
  };
}
u(Kh, "getFormatOptions");
function R0(e, t, r, n) {
  const o = {
    ...r,
    indent: 0
  }, a = qn(e, o), i = qn(t, o);
  if (a === i)
    return Gh(cG, n);
  {
    const s = qn(e, r), d = qn(t, r);
    return _G(s.split(`
`), d.split(`
`), a.split(`
`), i.split(`
`), n);
  }
}
u(R0, "getObjectsDifference");
var wj = 2e4;
function j0(e) {
  return Id(e) === "Object" && typeof e.asymmetricMatch == "function";
}
u(j0, "isAsymmetricMatcher");
function I0(e, t) {
  const r = Id(e), n = Id(t);
  return r === n && (r === "Object" || r === "Array");
}
u(I0, "isReplaceable");
function x$(e, t, r) {
  const { aAnnotation: n, bAnnotation: o } = li(r);
  if (typeof t == "string" && typeof e == "string" && t.length > 0 && e.length > 0 && t.length <= wj && e.length <= wj && t !== e) {
    if (t.includes(`
`) || e.includes(`
`))
      return CG(t, e, r);
    const [l] = E$(t, e, !0), p = l.some((g) => g[0] === kt), f = RG(n, o), h = f(n) + IG(N0(l, Er, p)), m = f(o) + jG(N0(l, ur, p));
    return `${h}
${m}`;
  }
  const a = S0(t, { forceWritable: !0 }), i = S0(e, { forceWritable: !0 }), { replacedExpected: s, replacedActual: d } = S$(i, a);
  return Ds(s, d, r);
}
u(x$, "printDiffOrStringify");
function S$(e, t, r = /* @__PURE__ */ new WeakSet(), n = /* @__PURE__ */ new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < "u" && typeof t.cause > "u" ? (delete e.cause, {
    replacedActual: e,
    replacedExpected: t
  }) : I0(e, t) ? r.has(e) || n.has(t) ? {
    replacedActual: e,
    replacedExpected: t
  } : (r.add(e), n.add(t), m$(t).forEach((o) => {
    const a = t[o], i = e[o];
    if (j0(a))
      a.asymmetricMatch(i) && (e[o] = a);
    else if (j0(i))
      i.asymmetricMatch(a) && (t[o] = i);
    else if (I0(i, a)) {
      const s = S$(i, a, r, n);
      e[o] = s.replacedActual, t[o] = s.replacedExpected;
    }
  }), {
    replacedActual: e,
    replacedExpected: t
  }) : {
    replacedActual: e,
    replacedExpected: t
  };
}
u(S$, "replaceAsymmetricMatcher");
function RG(...e) {
  const t = e.reduce((r, n) => n.length > r ? n.length : r, 0);
  return (r) => `${r}: ${" ".repeat(t - r.length)}`;
}
u(RG, "getLabelPrinter");
var MEe = "Â·";
function T$(e) {
  return e.replace(/\s+$/gm, (t) => MEe.repeat(t.length));
}
u(T$, "replaceTrailingSpaces");
function jG(e) {
  return Ot.red(T$(jr(e)));
}
u(jG, "printReceived");
function IG(e) {
  return Ot.green(T$(jr(e)));
}
u(IG, "printExpected");
function N0(e, t, r) {
  return e.reduce((n, o) => n + (o[0] === kt ? o[1] : o[0] === t ? r ? Ot.inverse(o[1]) : o[1] : ""), "");
}
u(N0, "getCommonAndChangedSubstrings");
var DEe = "@@__IMMUTABLE_RECORD__@@", qEe = "@@__IMMUTABLE_ITERABLE__@@";
function NG(e) {
  return e && (e[qEe] || e[DEe]);
}
u(NG, "isImmutable");
var LEe = Object.getPrototypeOf({});
function M0(e) {
  return e instanceof Error ? `<unserializable>: ${e.message}` : typeof e == "string" ? `<unserializable>: ${e}` : "<unserializable>";
}
u(M0, "getUnserializableMessage");
function Wo(e, t = /* @__PURE__ */ new WeakMap()) {
  if (!e || typeof e == "string")
    return e;
  if (e instanceof Error && "toJSON" in e && typeof e.toJSON == "function") {
    const r = e.toJSON();
    return r && r !== e && typeof r == "object" && (typeof e.message == "string" && Eu(() => r.message ?? (r.message = e.message)), typeof e.stack == "string" && Eu(() => r.stack ?? (r.stack = e.stack)), typeof e.name == "string" && Eu(() => r.name ?? (r.name = e.name)), e.cause != null && Eu(() => r.cause ?? (r.cause = Wo(e.cause, t)))), Wo(r, t);
  }
  if (typeof e == "function")
    return `Function<${e.name || "anonymous"}>`;
  if (typeof e == "symbol")
    return e.toString();
  if (typeof e != "object")
    return e;
  if (typeof Buffer < "u" && e instanceof Buffer)
    return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < "u" && e instanceof Uint8Array)
    return `<Uint8Array(${e.length}) ...>`;
  if (NG(e))
    return Wo(e.toJSON(), t);
  if (e instanceof Promise || e.constructor && e.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && e instanceof Element)
    return e.tagName;
  if (typeof e.asymmetricMatch == "function")
    return `${e.toString()} ${eG(e.sample)}`;
  if (typeof e.toJSON == "function")
    return Wo(e.toJSON(), t);
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    const r = new Array(e.length);
    return t.set(e, r), e.forEach((n, o) => {
      try {
        r[o] = Wo(n, t);
      } catch (a) {
        r[o] = M0(a);
      }
    }), r;
  } else {
    const r = /* @__PURE__ */ Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== LEe; )
      Object.getOwnPropertyNames(n).forEach((o) => {
        if (!(o in r))
          try {
            r[o] = Wo(e[o], t);
          } catch (a) {
            delete r[o], r[o] = M0(a);
          }
      }), n = Object.getPrototypeOf(n);
    return r;
  }
}
u(Wo, "serializeValue");
function Eu(e) {
  try {
    return e();
  } catch {
  }
}
u(Eu, "safe");
function MG(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
u(MG, "normalizeErrorMessage");
function Rg(e, t, r = /* @__PURE__ */ new WeakSet()) {
  if (!e || typeof e != "object")
    return { message: String(e) };
  const n = e;
  (n.showDiff || n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0) && (n.diff = x$(n.actual, n.expected, {
    ...t,
    ...n.diffOptions
  })), "expected" in n && typeof n.expected != "string" && (n.expected = jr(n.expected, 10)), "actual" in n && typeof n.actual != "string" && (n.actual = jr(n.actual, 10));
  try {
    typeof n.message == "string" && (n.message = MG(n.message));
  } catch {
  }
  try {
    !r.has(n) && typeof n.cause == "object" && (r.add(n), n.cause = Rg(n.cause, t, r));
  } catch {
  }
  try {
    return Wo(n);
  } catch (o) {
    return Wo(new Error(`Failed to fully serialize error: ${o?.message}
Inner error message: ${n?.message}`));
  }
}
u(Rg, "processError");
var Io = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
}, Ov = globalThis.__STORYBOOK_ADDONS_PREVIEW, FEe = new Error(
  "This function ran after the play function completed. Did you forget to `await` it?"
), _j = /* @__PURE__ */ u((e) => Object.prototype.toString.call(e) === "[object Object]", "isObject"), UEe = /* @__PURE__ */ u((e) => Object.prototype.toString.call(e) === "[object Module]", "isModule"), BEe = /* @__PURE__ */ u((e) => {
  if (!_j(e) && !UEe(e))
    return !1;
  if (e.constructor === void 0)
    return !0;
  const t = e.constructor.prototype;
  return !!_j(t);
}, "isInstrumentable"), HEe = /* @__PURE__ */ u((e) => {
  try {
    return new e.constructor();
  } catch {
    return {};
  }
}, "construct"), Rv = /* @__PURE__ */ u(() => ({
  renderPhase: "preparing",
  isDebugging: !1,
  isPlaying: !1,
  isLocked: !1,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), "getInitialState"), Ej = /* @__PURE__ */ u((e, t = !1) => {
  const r = (t ? e.shadowCalls : e.calls).filter((o) => o.retain);
  if (!r.length)
    return;
  const n = new Map(
    Array.from(e.callRefsByResult.entries()).filter(([, o]) => o.retain)
  );
  return { cursor: r.length, calls: r, callRefsByResult: n };
}, "getRetainedState"), DG = class {
  constructor() {
    this.detached = !1, this.initialized = !1, this.state = {}, this.loadParentWindowState = /* @__PURE__ */ u(() => {
      try {
        this.state = xe.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = !0;
      }
    }, "loadParentWindowState"), this.updateParentWindowState = /* @__PURE__ */ u(() => {
      try {
        xe.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = !0;
      }
    }, "updateParentWindowState"), this.loadParentWindowState();
    const e = /* @__PURE__ */ u(({
      storyId: s,
      renderPhase: d,
      isPlaying: l = !0,
      isDebugging: p = !1
    }) => {
      const f = this.getState(s);
      this.setState(s, {
        ...Rv(),
        ...Ej(f, p),
        renderPhase: d || f.renderPhase,
        shadowCalls: p ? f.shadowCalls : [],
        chainedCallIds: p ? f.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: p ? f.playUntil : void 0,
        isPlaying: l,
        isDebugging: p
      }), this.sync(s);
    }, "resetState"), t = /* @__PURE__ */ u((s) => ({ storyId: d, playUntil: l }) => {
      this.getState(d).isDebugging || this.setState(d, ({ calls: f }) => ({
        calls: [],
        shadowCalls: f.map((h) => ({
          ...h,
          status: "waiting"
          /* WAITING */
        })),
        isDebugging: !0
      }));
      const p = this.getLog(d);
      this.setState(d, ({ shadowCalls: f }) => {
        if (l || !p.length)
          return { playUntil: l };
        const h = f.findIndex((m) => m.id === p[0].callId);
        return {
          playUntil: f.slice(0, h).filter((m) => m.interceptable && !m.ancestors?.length).slice(-1)[0]?.id
        };
      }), s.emit(Hh, { storyId: d, isDebugging: !0 });
    }, "start"), r = /* @__PURE__ */ u((s) => ({ storyId: d }) => {
      const l = this.getLog(d).filter((f) => !f.ancestors?.length), p = l.reduceRight((f, h, m) => f >= 0 || h.status === "waiting" ? f : m, -1);
      t(s)({ storyId: d, playUntil: l[p - 1]?.callId });
    }, "back"), n = /* @__PURE__ */ u((s) => ({ storyId: d, callId: l }) => {
      const { calls: p, shadowCalls: f, resolvers: h } = this.getState(d), m = p.find(({ id: w }) => w === l), g = f.find(({ id: w }) => w === l);
      if (!m && g && Object.values(h).length > 0) {
        const w = this.getLog(d).find(
          (_) => _.status === "waiting"
          /* WAITING */
        )?.callId;
        g.id !== w && this.setState(d, { playUntil: g.id }), Object.values(h).forEach((_) => _());
      } else
        t(s)({ storyId: d, playUntil: l });
    }, "goto"), o = /* @__PURE__ */ u((s) => ({ storyId: d }) => {
      const { resolvers: l } = this.getState(d);
      if (Object.values(l).length > 0)
        Object.values(l).forEach((p) => p());
      else {
        const p = this.getLog(d).find(
          (f) => f.status === "waiting"
          /* WAITING */
        )?.callId;
        p ? t(s)({ storyId: d, playUntil: p }) : a({ storyId: d });
      }
    }, "next"), a = /* @__PURE__ */ u(({ storyId: s }) => {
      this.setState(s, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(s).resolvers).forEach((d) => d());
    }, "end"), i = /* @__PURE__ */ u(({
      storyId: s,
      newPhase: d
    }) => {
      const { isDebugging: l } = this.getState(s);
      if (d === "preparing" && l)
        return e({ storyId: s, renderPhase: d, isDebugging: l });
      if (d === "playing")
        return e({ storyId: s, renderPhase: d, isDebugging: l });
      d === "played" ? this.setState(s, {
        renderPhase: d,
        isLocked: !1,
        isPlaying: !1,
        isDebugging: !1
      }) : d === "errored" ? this.setState(s, {
        renderPhase: d,
        isLocked: !1,
        isPlaying: !1
      }) : d === "aborted" ? this.setState(s, {
        renderPhase: d,
        isLocked: !0,
        isPlaying: !1
      }) : this.setState(s, {
        renderPhase: d
      }), this.sync(s);
    }, "renderPhaseChanged");
    Ov && Ov.ready().then(() => {
      this.channel = Ov.getChannel(), this.channel.on(Hh, e), this.channel.on(ys, i), this.channel.on(YA, () => {
        this.initialized ? this.cleanup() : this.initialized = !0;
      }), this.channel.on(Io.START, t(this.channel)), this.channel.on(Io.BACK, r(this.channel)), this.channel.on(Io.GOTO, n(this.channel)), this.channel.on(Io.NEXT, o(this.channel)), this.channel.on(Io.END, a);
    });
  }
  getState(e) {
    return this.state[e] || Rv();
  }
  setState(e, t) {
    if (e) {
      const r = this.getState(e), n = typeof t == "function" ? t(r) : t;
      this.state = { ...this.state, [e]: { ...r, ...n } }, this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (t, [r, n]) => {
        const o = Ej(n);
        return o && (t[r] = Object.assign(Rv(), o)), t;
      },
      {}
    );
    const e = { controlStates: {
      detached: this.detached,
      start: !1,
      back: !1,
      goto: !1,
      next: !1,
      end: !1
    }, logItems: [] };
    this.channel?.emit(Io.SYNC, e), this.updateParentWindowState();
  }
  getLog(e) {
    const { calls: t, shadowCalls: r } = this.getState(e), n = [...r];
    t.forEach((a, i) => {
      n[i] = a;
    });
    const o = /* @__PURE__ */ new Set();
    return n.reduceRight((a, i) => (i.args.forEach((s) => {
      s?.__callId__ && o.add(s.__callId__);
    }), i.path.forEach((s) => {
      s.__callId__ && o.add(s.__callId__);
    }), (i.interceptable || i.exception) && !o.has(i.id) && (a.unshift({ callId: i.id, status: i.status, ancestors: i.ancestors }), o.add(i.id)), a), []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(e, t, r = 0) {
    if (!BEe(e))
      return e;
    const { mutate: n = !1, path: o = [] } = t, a = t.getKeys ? t.getKeys(e, r) : Object.keys(e);
    return r += 1, a.reduce(
      (i, s) => {
        const d = qG(e, s);
        if (typeof d?.get == "function") {
          if (d.configurable) {
            const p = /* @__PURE__ */ u(() => d?.get?.bind(e)?.(), "getter");
            Object.defineProperty(i, s, {
              get: /* @__PURE__ */ u(() => this.instrument(p(), { ...t, path: o.concat(s) }, r), "get")
            });
          }
          return i;
        }
        const l = e[s];
        return typeof l != "function" ? (i[s] = this.instrument(l, { ...t, path: o.concat(s) }, r), i) : "__originalFn__" in l && typeof l.__originalFn__ == "function" ? (i[s] = l, i) : (i[s] = (...p) => this.track(s, l, e, p, t), i[s].__originalFn__ = l, Object.defineProperty(i[s], "name", { value: s, writable: !1 }), Object.keys(l).length > 0 && Object.assign(
          i[s],
          this.instrument({ ...l }, { ...t, path: o.concat(s) }, r)
        ), i);
      },
      n ? e : HEe(e)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(e, t, r, n, o) {
    const a = n?.[0]?.__storyId__ || xe.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor: i, ancestors: s } = this.getState(a);
    this.setState(a, { cursor: i + 1 });
    const d = `${s.slice(-1)[0] || a} [${i}] ${e}`, { path: l = [], intercept: p = !1, retain: f = !1 } = o, h = typeof p == "function" ? p(e, l) : p, m = { id: d, cursor: i, storyId: a, ancestors: s, path: l, method: e, args: n, interceptable: h, retain: f }, g = (h && !s.length ? this.intercept : this.invoke).call(this, t, r, m, o);
    return this.instrument(g, { ...o, mutate: !0, path: [{ __callId__: m.id }] });
  }
  intercept(e, t, r, n) {
    const { chainedCallIds: o, isDebugging: a, playUntil: i } = this.getState(r.storyId), s = o.has(r.id);
    return !a || s || i ? (i === r.id && this.setState(r.storyId, { playUntil: void 0 }), this.invoke(e, t, r, n)) : new Promise((d) => {
      this.setState(r.storyId, ({ resolvers: l }) => ({
        isLocked: !1,
        resolvers: { ...l, [r.id]: d }
      }));
    }).then(() => (this.setState(r.storyId, (d) => {
      const { [r.id]: l, ...p } = d.resolvers;
      return { isLocked: !0, resolvers: p };
    }), this.invoke(e, t, r, n)));
  }
  invoke(e, t, r, n) {
    const { callRefsByResult: o, renderPhase: a } = this.getState(r.storyId), i = 25, s = /* @__PURE__ */ u((p, f, h) => {
      if (h.includes(p))
        return "[Circular]";
      if (h = [...h, p], f > i)
        return "...";
      if (o.has(p))
        return o.get(p);
      if (p instanceof Array)
        return p.map((m) => s(m, ++f, h));
      if (p instanceof Date)
        return { __date__: { value: p.toISOString() } };
      if (p instanceof Error) {
        const { name: m, message: g, stack: w } = p;
        return { __error__: { name: m, message: g, stack: w } };
      }
      if (p instanceof RegExp) {
        const { flags: m, source: g } = p;
        return { __regexp__: { flags: m, source: g } };
      }
      if (p instanceof xe.window?.HTMLElement) {
        const { prefix: m, localName: g, id: w, classList: _, innerText: b } = p, x = Array.from(_);
        return { __element__: { prefix: m, localName: g, id: w, classNames: x, innerText: b } };
      }
      return typeof p == "function" ? {
        __function__: { name: "getMockName" in p ? p.getMockName() : p.name }
      } : typeof p == "symbol" ? { __symbol__: { description: p.description } } : typeof p == "object" && p?.constructor?.name && p?.constructor?.name !== "Object" ? { __class__: { name: p.constructor.name } } : Object.prototype.toString.call(p) === "[object Object]" ? Object.fromEntries(
        Object.entries(p).map(([m, g]) => [m, s(g, ++f, h)])
      ) : p;
    }, "serializeValues"), d = {
      ...r,
      args: r.args.map((p) => s(p, 0, []))
    };
    r.path.forEach((p) => {
      p?.__callId__ && this.setState(r.storyId, ({ chainedCallIds: f }) => ({
        chainedCallIds: new Set(Array.from(f).concat(p.__callId__))
      }));
    });
    const l = /* @__PURE__ */ u((p) => {
      if (p instanceof Error) {
        const { name: f, message: h, stack: m, callId: g = r.id } = p, {
          showDiff: w = void 0,
          diff: _ = void 0,
          actual: b = void 0,
          expected: x = void 0
        } = p.name === "AssertionError" ? Rg(p) : p, P = { name: f, message: h, stack: m, callId: g, showDiff: w, diff: _, actual: b, expected: x };
        if (this.update({ ...d, status: "error", exception: P }), this.setState(r.storyId, (R) => ({
          callRefsByResult: new Map([
            ...Array.from(R.callRefsByResult.entries()),
            [p, { __callId__: r.id, retain: r.retain }]
          ])
        })), r.ancestors?.length)
          throw Object.prototype.hasOwnProperty.call(p, "callId") || Object.defineProperty(p, "callId", { value: r.id }), p;
      }
      throw p;
    }, "handleException");
    try {
      if (a === "played" && !r.retain)
        throw FEe;
      const p = (n.getArgs ? n.getArgs(r, this.getState(r.storyId)) : r.args).map((h) => typeof h != "function" || LG(h) || Object.keys(h).length ? h : (...m) => {
        const { cursor: g, ancestors: w } = this.getState(r.storyId);
        this.setState(r.storyId, { cursor: 0, ancestors: [...w, r.id] });
        const _ = /* @__PURE__ */ u(() => this.setState(r.storyId, { cursor: g, ancestors: w }), "restore");
        let b = !1;
        try {
          const x = h(...m);
          return x instanceof Promise ? (b = !0, x.finally(_)) : x;
        } finally {
          b || _();
        }
      }), f = e.apply(t, p);
      return f && ["object", "function", "symbol"].includes(typeof f) && this.setState(r.storyId, (h) => ({
        callRefsByResult: new Map([
          ...Array.from(h.callRefsByResult.entries()),
          [f, { __callId__: r.id, retain: r.retain }]
        ])
      })), this.update({
        ...d,
        status: f instanceof Promise ? "active" : "done"
        /* DONE */
      }), f instanceof Promise ? f.then((h) => (this.update({
        ...d,
        status: "done"
        /* DONE */
      }), h), l) : f;
    } catch (p) {
      return l(p);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(e) {
    this.channel?.emit(Io.CALL, e), this.setState(e.storyId, ({ calls: t }) => {
      const r = t.concat(e).reduce((n, o) => Object.assign(n, { [o.id]: o }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(r).sort(
          (n, o) => n.id.localeCompare(o.id, void 0, { numeric: !0 })
        )
      };
    }), this.sync(e.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(e) {
    const t = /* @__PURE__ */ u(() => {
      const { isLocked: r, isPlaying: n } = this.getState(e), o = this.getLog(e), a = o.filter(({ ancestors: l }) => !l.length).find(
        (l) => l.status === "waiting"
        /* WAITING */
      )?.callId, i = o.some(
        (l) => l.status === "active"
        /* ACTIVE */
      );
      if (this.detached || r || i || o.length === 0) {
        const l = { controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1
        }, logItems: o };
        this.channel?.emit(Io.SYNC, l);
        return;
      }
      const s = o.some(
        (l) => l.status === "done" || l.status === "error"
        /* ERROR */
      ), d = { controlStates: {
        detached: this.detached,
        start: s,
        back: s,
        goto: !0,
        next: n,
        end: n
      }, logItems: o, pausedAt: a };
      this.channel?.emit(Io.SYNC, d);
    }, "synchronize");
    this.setState(e, ({ syncTimeout: r }) => (clearTimeout(r), { syncTimeout: setTimeout(t, 0) }));
  }
};
u(DG, "Instrumenter");
var VEe = DG;
function jc(e, t = {}) {
  try {
    let r = !1, n = !1;
    return xe.window?.location?.search?.includes("instrument=true") ? r = !0 : xe.window?.location?.search?.includes("instrument=false") && (n = !0), xe.window?.parent === xe.window && !r || n ? e : (xe.window && !xe.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (xe.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new VEe()), (xe.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t));
  } catch (r) {
    return qt.warn(r), e;
  }
}
u(jc, "instrument");
function qG(e, t) {
  let r = e;
  for (; r != null; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n)
      return n;
    r = Object.getPrototypeOf(r);
  }
}
u(qG, "getPropertyDescriptor");
function LG(e) {
  if (typeof e != "function")
    return !1;
  const t = Object.getOwnPropertyDescriptor(e, "prototype");
  return t ? !t.writable : !1;
}
u(LG, "isClass");
var zEe = G({
  "../node_modules/min-indent/index.js"(e, t) {
    t.exports = (r) => {
      const n = r.match(/^[ \t]*(?=\S)/gm);
      return n ? n.reduce((o, a) => Math.min(o, a.length), 1 / 0) : 0;
    };
  }
}), JEe = G({
  "../node_modules/strip-indent/index.js"(e, t) {
    var r = zEe();
    t.exports = (n) => {
      const o = r(n);
      if (o === 0)
        return n;
      const a = new RegExp(`^[ \\t]{${o}}`, "gm");
      return n.replace(a, "");
    };
  }
}), WEe = G({
  "../node_modules/indent-string/index.js"(e, t) {
    t.exports = (r, n = 1, o) => {
      if (o = {
        indent: " ",
        includeEmptyLines: !1,
        ...o
      }, typeof r != "string")
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof r}\``
        );
      if (typeof n != "number")
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof n}\``
        );
      if (typeof o.indent != "string")
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof o.indent}\``
        );
      if (n === 0)
        return r;
      const a = o.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return r.replace(a, o.indent.repeat(n));
    };
  }
}), FG = G({
  "../node_modules/redent/index.js"(e, t) {
    var r = JEe(), n = WEe();
    t.exports = (o, a = 0, i) => n(r(o), a, i);
  }
}), GEe = G({
  "../node_modules/aria-query/lib/util/iteratorProxy.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    function t() {
      var r = this, n = 0, o = {
        "@@iterator": /* @__PURE__ */ u(function() {
          return o;
        }, "iterator"),
        next: /* @__PURE__ */ u(function() {
          if (n < r.length) {
            var a = r[n];
            return n = n + 1, {
              done: !1,
              value: a
            };
          } else
            return {
              done: !0
            };
        }, "next")
      };
      return o;
    }
    u(t, "iteratorProxy"), e.default = t;
  }
}), Ep = G({
  "../node_modules/aria-query/lib/util/iterationDecorator.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = o;
    var t = r(GEe());
    function r(a) {
      return a && a.__esModule ? a : { default: a };
    }
    u(r, "_interopRequireDefault");
    function n(a) {
      "@babel/helpers - typeof";
      return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
        return typeof i;
      } : function(i) {
        return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
      }, n(a);
    }
    u(n, "_typeof");
    function o(a, i) {
      return typeof Symbol == "function" && n(Symbol.iterator) === "symbol" && Object.defineProperty(a, Symbol.iterator, {
        value: t.default.bind(i)
      }), a;
    }
    u(o, "iterationDecorator");
  }
}), KEe = G({
  "../node_modules/aria-query/lib/ariaPropsMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = r(Ep());
    function r(f) {
      return f && f.__esModule ? f : { default: f };
    }
    u(r, "_interopRequireDefault");
    function n(f, h) {
      return d(f) || s(f, h) || a(f, h) || o();
    }
    u(n, "_slicedToArray");
    function o() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    u(o, "_nonIterableRest");
    function a(f, h) {
      if (f) {
        if (typeof f == "string") return i(f, h);
        var m = {}.toString.call(f).slice(8, -1);
        return m === "Object" && f.constructor && (m = f.constructor.name), m === "Map" || m === "Set" ? Array.from(f) : m === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(m) ? i(f, h) : void 0;
      }
    }
    u(a, "_unsupportedIterableToArray");
    function i(f, h) {
      (h == null || h > f.length) && (h = f.length);
      for (var m = 0, g = Array(h); m < h; m++) g[m] = f[m];
      return g;
    }
    u(i, "_arrayLikeToArray");
    function s(f, h) {
      var m = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (m != null) {
        var g, w, _, b, x = [], P = !0, R = !1;
        try {
          if (_ = (m = m.call(f)).next, h === 0) {
            if (Object(m) !== m) return;
            P = !1;
          } else for (; !(P = (g = _.call(m)).done) && (x.push(g.value), x.length !== h); P = !0) ;
        } catch (N) {
          R = !0, w = N;
        } finally {
          try {
            if (!P && m.return != null && (b = m.return(), Object(b) !== b)) return;
          } finally {
            if (R) throw w;
          }
        }
        return x;
      }
    }
    u(s, "_iterableToArrayLimit");
    function d(f) {
      if (Array.isArray(f)) return f;
    }
    u(d, "_arrayWithHoles");
    var l = [["aria-activedescendant", {
      type: "id"
    }], ["aria-atomic", {
      type: "boolean"
    }], ["aria-autocomplete", {
      type: "token",
      values: ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      type: "string"
    }], ["aria-brailleroledescription", {
      type: "string"
    }], ["aria-busy", {
      type: "boolean"
    }], ["aria-checked", {
      type: "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      type: "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", !0, !1]
    }], ["aria-describedby", {
      type: "idlist"
    }], ["aria-description", {
      type: "string"
    }], ["aria-details", {
      type: "id"
    }], ["aria-disabled", {
      type: "boolean"
    }], ["aria-dropeffect", {
      type: "tokenlist",
      values: ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      type: "id"
    }], ["aria-expanded", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-flowto", {
      type: "idlist"
    }], ["aria-grabbed", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-haspopup", {
      type: "token",
      values: [!1, !0, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-invalid", {
      type: "token",
      values: ["grammar", !1, "spelling", !0]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      type: "string"
    }], ["aria-labelledby", {
      type: "idlist"
    }], ["aria-level", {
      type: "integer"
    }], ["aria-live", {
      type: "token",
      values: ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      type: "boolean"
    }], ["aria-multiselectable", {
      type: "boolean"
    }], ["aria-orientation", {
      type: "token",
      values: ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      type: "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      type: "integer"
    }], ["aria-pressed", {
      type: "tristate"
    }], ["aria-readonly", {
      type: "boolean"
    }], ["aria-relevant", {
      type: "tokenlist",
      values: ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      type: "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-setsize", {
      type: "integer"
    }], ["aria-sort", {
      type: "token",
      values: ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      type: "number"
    }], ["aria-valuemin", {
      type: "number"
    }], ["aria-valuenow", {
      type: "number"
    }], ["aria-valuetext", {
      type: "string"
    }]], p = {
      entries: /* @__PURE__ */ u(function() {
        return l;
      }, "entries"),
      forEach: /* @__PURE__ */ u(function(f) {
        for (var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, m = 0, g = l; m < g.length; m++) {
          var w = n(g[m], 2), _ = w[0], b = w[1];
          f.call(h, b, _, l);
        }
      }, "forEach"),
      get: /* @__PURE__ */ u(function(f) {
        var h = l.filter(function(m) {
          return m[0] === f;
        })[0];
        return h && h[1];
      }, "get"),
      has: /* @__PURE__ */ u(function(f) {
        return !!p.get(f);
      }, "has"),
      keys: /* @__PURE__ */ u(function() {
        return l.map(function(f) {
          var h = n(f, 1), m = h[0];
          return m;
        });
      }, "keys"),
      values: /* @__PURE__ */ u(function() {
        return l.map(function(f) {
          var h = n(f, 2), m = h[1];
          return m;
        });
      }, "values")
    };
    e.default = (0, t.default)(p, p.entries());
  }
}), YEe = G({
  "../node_modules/aria-query/lib/domMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = r(Ep());
    function r(f) {
      return f && f.__esModule ? f : { default: f };
    }
    u(r, "_interopRequireDefault");
    function n(f, h) {
      return d(f) || s(f, h) || a(f, h) || o();
    }
    u(n, "_slicedToArray");
    function o() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    u(o, "_nonIterableRest");
    function a(f, h) {
      if (f) {
        if (typeof f == "string") return i(f, h);
        var m = {}.toString.call(f).slice(8, -1);
        return m === "Object" && f.constructor && (m = f.constructor.name), m === "Map" || m === "Set" ? Array.from(f) : m === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(m) ? i(f, h) : void 0;
      }
    }
    u(a, "_unsupportedIterableToArray");
    function i(f, h) {
      (h == null || h > f.length) && (h = f.length);
      for (var m = 0, g = Array(h); m < h; m++) g[m] = f[m];
      return g;
    }
    u(i, "_arrayLikeToArray");
    function s(f, h) {
      var m = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (m != null) {
        var g, w, _, b, x = [], P = !0, R = !1;
        try {
          if (_ = (m = m.call(f)).next, h === 0) {
            if (Object(m) !== m) return;
            P = !1;
          } else for (; !(P = (g = _.call(m)).done) && (x.push(g.value), x.length !== h); P = !0) ;
        } catch (N) {
          R = !0, w = N;
        } finally {
          try {
            if (!P && m.return != null && (b = m.return(), Object(b) !== b)) return;
          } finally {
            if (R) throw w;
          }
        }
        return x;
      }
    }
    u(s, "_iterableToArrayLimit");
    function d(f) {
      if (Array.isArray(f)) return f;
    }
    u(d, "_arrayWithHoles");
    var l = [["a", {
      reserved: !1
    }], ["abbr", {
      reserved: !1
    }], ["acronym", {
      reserved: !1
    }], ["address", {
      reserved: !1
    }], ["applet", {
      reserved: !1
    }], ["area", {
      reserved: !1
    }], ["article", {
      reserved: !1
    }], ["aside", {
      reserved: !1
    }], ["audio", {
      reserved: !1
    }], ["b", {
      reserved: !1
    }], ["base", {
      reserved: !0
    }], ["bdi", {
      reserved: !1
    }], ["bdo", {
      reserved: !1
    }], ["big", {
      reserved: !1
    }], ["blink", {
      reserved: !1
    }], ["blockquote", {
      reserved: !1
    }], ["body", {
      reserved: !1
    }], ["br", {
      reserved: !1
    }], ["button", {
      reserved: !1
    }], ["canvas", {
      reserved: !1
    }], ["caption", {
      reserved: !1
    }], ["center", {
      reserved: !1
    }], ["cite", {
      reserved: !1
    }], ["code", {
      reserved: !1
    }], ["col", {
      reserved: !0
    }], ["colgroup", {
      reserved: !0
    }], ["content", {
      reserved: !1
    }], ["data", {
      reserved: !1
    }], ["datalist", {
      reserved: !1
    }], ["dd", {
      reserved: !1
    }], ["del", {
      reserved: !1
    }], ["details", {
      reserved: !1
    }], ["dfn", {
      reserved: !1
    }], ["dialog", {
      reserved: !1
    }], ["dir", {
      reserved: !1
    }], ["div", {
      reserved: !1
    }], ["dl", {
      reserved: !1
    }], ["dt", {
      reserved: !1
    }], ["em", {
      reserved: !1
    }], ["embed", {
      reserved: !1
    }], ["fieldset", {
      reserved: !1
    }], ["figcaption", {
      reserved: !1
    }], ["figure", {
      reserved: !1
    }], ["font", {
      reserved: !1
    }], ["footer", {
      reserved: !1
    }], ["form", {
      reserved: !1
    }], ["frame", {
      reserved: !1
    }], ["frameset", {
      reserved: !1
    }], ["h1", {
      reserved: !1
    }], ["h2", {
      reserved: !1
    }], ["h3", {
      reserved: !1
    }], ["h4", {
      reserved: !1
    }], ["h5", {
      reserved: !1
    }], ["h6", {
      reserved: !1
    }], ["head", {
      reserved: !0
    }], ["header", {
      reserved: !1
    }], ["hgroup", {
      reserved: !1
    }], ["hr", {
      reserved: !1
    }], ["html", {
      reserved: !0
    }], ["i", {
      reserved: !1
    }], ["iframe", {
      reserved: !1
    }], ["img", {
      reserved: !1
    }], ["input", {
      reserved: !1
    }], ["ins", {
      reserved: !1
    }], ["kbd", {
      reserved: !1
    }], ["keygen", {
      reserved: !1
    }], ["label", {
      reserved: !1
    }], ["legend", {
      reserved: !1
    }], ["li", {
      reserved: !1
    }], ["link", {
      reserved: !0
    }], ["main", {
      reserved: !1
    }], ["map", {
      reserved: !1
    }], ["mark", {
      reserved: !1
    }], ["marquee", {
      reserved: !1
    }], ["menu", {
      reserved: !1
    }], ["menuitem", {
      reserved: !1
    }], ["meta", {
      reserved: !0
    }], ["meter", {
      reserved: !1
    }], ["nav", {
      reserved: !1
    }], ["noembed", {
      reserved: !0
    }], ["noscript", {
      reserved: !0
    }], ["object", {
      reserved: !1
    }], ["ol", {
      reserved: !1
    }], ["optgroup", {
      reserved: !1
    }], ["option", {
      reserved: !1
    }], ["output", {
      reserved: !1
    }], ["p", {
      reserved: !1
    }], ["param", {
      reserved: !0
    }], ["picture", {
      reserved: !0
    }], ["pre", {
      reserved: !1
    }], ["progress", {
      reserved: !1
    }], ["q", {
      reserved: !1
    }], ["rp", {
      reserved: !1
    }], ["rt", {
      reserved: !1
    }], ["rtc", {
      reserved: !1
    }], ["ruby", {
      reserved: !1
    }], ["s", {
      reserved: !1
    }], ["samp", {
      reserved: !1
    }], ["script", {
      reserved: !0
    }], ["section", {
      reserved: !1
    }], ["select", {
      reserved: !1
    }], ["small", {
      reserved: !1
    }], ["source", {
      reserved: !0
    }], ["spacer", {
      reserved: !1
    }], ["span", {
      reserved: !1
    }], ["strike", {
      reserved: !1
    }], ["strong", {
      reserved: !1
    }], ["style", {
      reserved: !0
    }], ["sub", {
      reserved: !1
    }], ["summary", {
      reserved: !1
    }], ["sup", {
      reserved: !1
    }], ["table", {
      reserved: !1
    }], ["tbody", {
      reserved: !1
    }], ["td", {
      reserved: !1
    }], ["textarea", {
      reserved: !1
    }], ["tfoot", {
      reserved: !1
    }], ["th", {
      reserved: !1
    }], ["thead", {
      reserved: !1
    }], ["time", {
      reserved: !1
    }], ["title", {
      reserved: !0
    }], ["tr", {
      reserved: !1
    }], ["track", {
      reserved: !0
    }], ["tt", {
      reserved: !1
    }], ["u", {
      reserved: !1
    }], ["ul", {
      reserved: !1
    }], ["var", {
      reserved: !1
    }], ["video", {
      reserved: !1
    }], ["wbr", {
      reserved: !1
    }], ["xmp", {
      reserved: !1
    }]], p = {
      entries: /* @__PURE__ */ u(function() {
        return l;
      }, "entries"),
      forEach: /* @__PURE__ */ u(function(f) {
        for (var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, m = 0, g = l; m < g.length; m++) {
          var w = n(g[m], 2), _ = w[0], b = w[1];
          f.call(h, b, _, l);
        }
      }, "forEach"),
      get: /* @__PURE__ */ u(function(f) {
        var h = l.filter(function(m) {
          return m[0] === f;
        })[0];
        return h && h[1];
      }, "get"),
      has: /* @__PURE__ */ u(function(f) {
        return !!p.get(f);
      }, "has"),
      keys: /* @__PURE__ */ u(function() {
        return l.map(function(f) {
          var h = n(f, 1), m = h[0];
          return m;
        });
      }, "keys"),
      values: /* @__PURE__ */ u(function() {
        return l.map(function(f) {
          var h = n(f, 2), m = h[1];
          return m;
        });
      }, "values")
    };
    e.default = (0, t.default)(p, p.entries());
  }
}), XEe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), QEe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), ZEe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), exe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), txe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), rxe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    e.default = t;
  }
}), nxe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), oxe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), axe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), ixe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), sxe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), lxe = G({
  "../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), cxe = G({
  "../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = m(XEe()), r = m(QEe()), n = m(ZEe()), o = m(exe()), a = m(txe()), i = m(rxe()), s = m(nxe()), d = m(oxe()), l = m(axe()), p = m(ixe()), f = m(sxe()), h = m(lxe());
    function m(w) {
      return w && w.__esModule ? w : { default: w };
    }
    u(m, "_interopRequireDefault");
    var g = [["command", t.default], ["composite", r.default], ["input", n.default], ["landmark", o.default], ["range", a.default], ["roletype", i.default], ["section", s.default], ["sectionhead", d.default], ["select", l.default], ["structure", p.default], ["widget", f.default], ["window", h.default]];
    e.default = g;
  }
}), uxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), dxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    e.default = t;
  }
}), pxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), fxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    e.default = t;
  }
}), hxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), mxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), yxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), gxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), bxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), vxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), wxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), _xe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), Exe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), xxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Sxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Txe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Axe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), $xe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    e.default = t;
  }
}), Cxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    e.default = t;
  }
}), kxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), Pxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Oxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    e.default = t;
  }
}), Rxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), jxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Ixe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), Nxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    e.default = t;
  }
}), Mxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), Dxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), qxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), Lxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Fxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Uxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), Bxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Hxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), Vxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), zxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Jxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), Wxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Gxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Kxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), Yxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), Xxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    e.default = t;
  }
}), Qxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), Zxe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    e.default = t;
  }
}), eSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    e.default = t;
  }
}), tSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), rSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), nSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    e.default = t;
  }
}), oSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), aSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), iSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), sSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), lSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), cSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), uSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), dSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), pSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), fSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), hSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), mSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), ySe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), gSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    e.default = t;
  }
}), bSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), vSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), wSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), _Se = G({
  "../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), ESe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), xSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), SSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), TSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    e.default = t;
  }
}), ASe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), $Se = G({
  "../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), CSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    e.default = t;
  }
}), kSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), PSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), OSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), RSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), jSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    e.default = t;
  }
}), ISe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), NSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), MSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), DSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    e.default = t;
  }
}), qSe = G({
  "../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    e.default = t;
  }
}), LSe = G({
  "../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = K(uxe()), r = K(dxe()), n = K(pxe()), o = K(fxe()), a = K(hxe()), i = K(mxe()), s = K(yxe()), d = K(gxe()), l = K(bxe()), p = K(vxe()), f = K(wxe()), h = K(_xe()), m = K(Exe()), g = K(xxe()), w = K(Sxe()), _ = K(Txe()), b = K(Axe()), x = K($xe()), P = K(Cxe()), R = K(kxe()), N = K(Pxe()), C = K(Oxe()), A = K(Rxe()), E = K(jxe()), T = K(Ixe()), O = K(Nxe()), k = K(Mxe()), M = K(Dxe()), L = K(qxe()), $ = K(Lxe()), I = K(Fxe()), D = K(Uxe()), F = K(Bxe()), J = K(Hxe()), oe = K(Vxe()), ce = K(zxe()), le = K(Jxe()), re = K(Wxe()), we = K(Gxe()), _e = K(Kxe()), de = K(Yxe()), ne = K(Xxe()), $e = K(Qxe()), Se = K(Zxe()), nt = K(eSe()), We = K(tSe()), q = K(rSe()), te = K(nSe()), ae = K(oSe()), ue = K(aSe()), se = K(iSe()), ye = K(sSe()), fe = K(lSe()), Ae = K(cSe()), Fe = K(uSe()), dt = K(dSe()), pt = K(pSe()), it = K(fSe()), Ht = K(hSe()), _t = K(mSe()), Et = K(ySe()), Nr = K(gSe()), To = K(bSe()), di = K(vSe()), Ao = K(wSe()), pi = K(_Se()), fi = K(ESe()), hi = K(xSe()), $o = K(SSe()), mi = K(TSe()), yi = K(ASe()), gi = K($Se()), bi = K(CSe()), vi = K(kSe()), wi = K(PSe()), _i = K(OSe()), Ei = K(RSe()), xi = K(jSe()), Si = K(ISe()), Ti = K(NSe()), Ai = K(MSe()), $n = K(DSe()), Co = K(qSe());
    function K(sr) {
      return sr && sr.__esModule ? sr : { default: sr };
    }
    u(K, "_interopRequireDefault");
    var Ce = [["alert", t.default], ["alertdialog", r.default], ["application", n.default], ["article", o.default], ["banner", a.default], ["blockquote", i.default], ["button", s.default], ["caption", d.default], ["cell", l.default], ["checkbox", p.default], ["code", f.default], ["columnheader", h.default], ["combobox", m.default], ["complementary", g.default], ["contentinfo", w.default], ["definition", _.default], ["deletion", b.default], ["dialog", x.default], ["directory", P.default], ["document", R.default], ["emphasis", N.default], ["feed", C.default], ["figure", A.default], ["form", E.default], ["generic", T.default], ["grid", O.default], ["gridcell", k.default], ["group", M.default], ["heading", L.default], ["img", $.default], ["insertion", I.default], ["link", D.default], ["list", F.default], ["listbox", J.default], ["listitem", oe.default], ["log", ce.default], ["main", le.default], ["mark", re.default], ["marquee", we.default], ["math", _e.default], ["menu", de.default], ["menubar", ne.default], ["menuitem", $e.default], ["menuitemcheckbox", Se.default], ["menuitemradio", nt.default], ["meter", We.default], ["navigation", q.default], ["none", te.default], ["note", ae.default], ["option", ue.default], ["paragraph", se.default], ["presentation", ye.default], ["progressbar", fe.default], ["radio", Ae.default], ["radiogroup", Fe.default], ["region", dt.default], ["row", pt.default], ["rowgroup", it.default], ["rowheader", Ht.default], ["scrollbar", _t.default], ["search", Et.default], ["searchbox", Nr.default], ["separator", To.default], ["slider", di.default], ["spinbutton", Ao.default], ["status", pi.default], ["strong", fi.default], ["subscript", hi.default], ["superscript", $o.default], ["switch", mi.default], ["tab", yi.default], ["table", gi.default], ["tablist", bi.default], ["tabpanel", vi.default], ["term", wi.default], ["textbox", _i.default], ["time", Ei.default], ["timer", xi.default], ["toolbar", Si.default], ["tooltip", Ti.default], ["tree", Ai.default], ["treegrid", $n.default], ["treeitem", Co.default]];
    e.default = Ce;
  }
}), FSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), USe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), BSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), HSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), VSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), zSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    e.default = t;
  }
}), JSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), WSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), GSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), KSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), YSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), XSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    e.default = t;
  }
}), QSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), ZSe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), eTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), tTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    e.default = t;
  }
}), rTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), nTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), oTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), aTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), iTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), sTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), lTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), cTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), uTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), dTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), pTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), fTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), hTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    e.default = t;
  }
}), mTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    e.default = t;
  }
}), yTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), gTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), bTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), vTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), wTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), _Te = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), ETe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    e.default = t;
  }
}), xTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), STe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), TTe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    e.default = t;
  }
}), ATe = G({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), $Te = G({
  "../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = ne(FSe()), r = ne(USe()), n = ne(BSe()), o = ne(HSe()), a = ne(VSe()), i = ne(zSe()), s = ne(JSe()), d = ne(WSe()), l = ne(GSe()), p = ne(KSe()), f = ne(YSe()), h = ne(XSe()), m = ne(QSe()), g = ne(ZSe()), w = ne(eTe()), _ = ne(tTe()), b = ne(rTe()), x = ne(nTe()), P = ne(oTe()), R = ne(aTe()), N = ne(iTe()), C = ne(sTe()), A = ne(lTe()), E = ne(cTe()), T = ne(uTe()), O = ne(dTe()), k = ne(pTe()), M = ne(fTe()), L = ne(hTe()), $ = ne(mTe()), I = ne(yTe()), D = ne(gTe()), F = ne(bTe()), J = ne(vTe()), oe = ne(wTe()), ce = ne(_Te()), le = ne(ETe()), re = ne(xTe()), we = ne(STe()), _e = ne(TTe()), de = ne(ATe());
    function ne(Se) {
      return Se && Se.__esModule ? Se : { default: Se };
    }
    u(ne, "_interopRequireDefault");
    var $e = [["doc-abstract", t.default], ["doc-acknowledgments", r.default], ["doc-afterword", n.default], ["doc-appendix", o.default], ["doc-backlink", a.default], ["doc-biblioentry", i.default], ["doc-bibliography", s.default], ["doc-biblioref", d.default], ["doc-chapter", l.default], ["doc-colophon", p.default], ["doc-conclusion", f.default], ["doc-cover", h.default], ["doc-credit", m.default], ["doc-credits", g.default], ["doc-dedication", w.default], ["doc-endnote", _.default], ["doc-endnotes", b.default], ["doc-epigraph", x.default], ["doc-epilogue", P.default], ["doc-errata", R.default], ["doc-example", N.default], ["doc-footnote", C.default], ["doc-foreword", A.default], ["doc-glossary", E.default], ["doc-glossref", T.default], ["doc-index", O.default], ["doc-introduction", k.default], ["doc-noteref", M.default], ["doc-notice", L.default], ["doc-pagebreak", $.default], ["doc-pagefooter", I.default], ["doc-pageheader", D.default], ["doc-pagelist", F.default], ["doc-part", J.default], ["doc-preface", oe.default], ["doc-prologue", ce.default], ["doc-pullquote", le.default], ["doc-qna", re.default], ["doc-subtitle", we.default], ["doc-tip", _e.default], ["doc-toc", de.default]];
    e.default = $e;
  }
}), CTe = G({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    e.default = t;
  }
}), kTe = G({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), PTe = G({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    e.default = t;
  }
}), OTe = G({
  "../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = o(CTe()), r = o(kTe()), n = o(PTe());
    function o(i) {
      return i && i.__esModule ? i : { default: i };
    }
    u(o, "_interopRequireDefault");
    var a = [["graphics-document", t.default], ["graphics-object", r.default], ["graphics-symbol", n.default]];
    e.default = a;
  }
}), A$ = G({
  "../node_modules/aria-query/lib/rolesMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = i(cxe()), r = i(LSe()), n = i($Te()), o = i(OTe()), a = i(Ep());
    function i(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    u(i, "_interopRequireDefault");
    function s(_, b) {
      var x = typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
      if (!x) {
        if (Array.isArray(_) || (x = p(_)) || b && _ && typeof _.length == "number") {
          x && (_ = x);
          var P = 0, R = /* @__PURE__ */ u(function() {
          }, "F");
          return { s: R, n: /* @__PURE__ */ u(function() {
            return P >= _.length ? { done: !0 } : { done: !1, value: _[P++] };
          }, "n"), e: /* @__PURE__ */ u(function(E) {
            throw E;
          }, "e"), f: R };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var N, C = !0, A = !1;
      return { s: /* @__PURE__ */ u(function() {
        x = x.call(_);
      }, "s"), n: /* @__PURE__ */ u(function() {
        var E = x.next();
        return C = E.done, E;
      }, "n"), e: /* @__PURE__ */ u(function(E) {
        A = !0, N = E;
      }, "e"), f: /* @__PURE__ */ u(function() {
        try {
          C || x.return == null || x.return();
        } finally {
          if (A) throw N;
        }
      }, "f") };
    }
    u(s, "_createForOfIteratorHelper");
    function d(_, b) {
      return m(_) || h(_, b) || p(_, b) || l();
    }
    u(d, "_slicedToArray");
    function l() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    u(l, "_nonIterableRest");
    function p(_, b) {
      if (_) {
        if (typeof _ == "string") return f(_, b);
        var x = {}.toString.call(_).slice(8, -1);
        return x === "Object" && _.constructor && (x = _.constructor.name), x === "Map" || x === "Set" ? Array.from(_) : x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x) ? f(_, b) : void 0;
      }
    }
    u(p, "_unsupportedIterableToArray");
    function f(_, b) {
      (b == null || b > _.length) && (b = _.length);
      for (var x = 0, P = Array(b); x < b; x++) P[x] = _[x];
      return P;
    }
    u(f, "_arrayLikeToArray");
    function h(_, b) {
      var x = _ == null ? null : typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
      if (x != null) {
        var P, R, N, C, A = [], E = !0, T = !1;
        try {
          if (N = (x = x.call(_)).next, b === 0) {
            if (Object(x) !== x) return;
            E = !1;
          } else for (; !(E = (P = N.call(x)).done) && (A.push(P.value), A.length !== b); E = !0) ;
        } catch (O) {
          T = !0, R = O;
        } finally {
          try {
            if (!E && x.return != null && (C = x.return(), Object(C) !== C)) return;
          } finally {
            if (T) throw R;
          }
        }
        return A;
      }
    }
    u(h, "_iterableToArrayLimit");
    function m(_) {
      if (Array.isArray(_)) return _;
    }
    u(m, "_arrayWithHoles");
    var g = [].concat(t.default, r.default, n.default, o.default);
    g.forEach(function(_) {
      var b = d(_, 2), x = b[1], P = s(x.superClass), R;
      try {
        for (P.s(); !(R = P.n()).done; ) {
          var N = R.value, C = s(N), A;
          try {
            var E = /* @__PURE__ */ u(function() {
              var T = A.value, O = g.filter(function(I) {
                var D = d(I, 1), F = D[0];
                return F === T;
              })[0];
              if (O)
                for (var k = O[1], M = 0, L = Object.keys(k.props); M < L.length; M++) {
                  var $ = L[M];
                  Object.prototype.hasOwnProperty.call(x.props, $) || (x.props[$] = k.props[$]);
                }
            }, "_loop");
            for (C.s(); !(A = C.n()).done; )
              E();
          } catch (T) {
            C.e(T);
          } finally {
            C.f();
          }
        }
      } catch (T) {
        P.e(T);
      } finally {
        P.f();
      }
    });
    var w = {
      entries: /* @__PURE__ */ u(function() {
        return g;
      }, "entries"),
      forEach: /* @__PURE__ */ u(function(_) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, x = s(g), P;
        try {
          for (x.s(); !(P = x.n()).done; ) {
            var R = d(P.value, 2), N = R[0], C = R[1];
            _.call(b, C, N, g);
          }
        } catch (A) {
          x.e(A);
        } finally {
          x.f();
        }
      }, "forEach"),
      get: /* @__PURE__ */ u(function(_) {
        var b = g.filter(function(x) {
          return x[0] === _;
        })[0];
        return b && b[1];
      }, "get"),
      has: /* @__PURE__ */ u(function(_) {
        return !!w.get(_);
      }, "has"),
      keys: /* @__PURE__ */ u(function() {
        return g.map(function(_) {
          var b = d(_, 1), x = b[0];
          return x;
        });
      }, "keys"),
      values: /* @__PURE__ */ u(function() {
        return g.map(function(_) {
          var b = d(_, 2), x = b[1];
          return x;
        });
      }, "values")
    };
    e.default = (0, a.default)(w, w.entries());
  }
}), RTe = G({
  "../node_modules/aria-query/lib/elementRoleMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = n(Ep()), r = n(A$());
    function n(C) {
      return C && C.__esModule ? C : { default: C };
    }
    u(n, "_interopRequireDefault");
    function o(C, A) {
      return l(C) || d(C, A) || i(C, A) || a();
    }
    u(o, "_slicedToArray");
    function a() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    u(a, "_nonIterableRest");
    function i(C, A) {
      if (C) {
        if (typeof C == "string") return s(C, A);
        var E = {}.toString.call(C).slice(8, -1);
        return E === "Object" && C.constructor && (E = C.constructor.name), E === "Map" || E === "Set" ? Array.from(C) : E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E) ? s(C, A) : void 0;
      }
    }
    u(i, "_unsupportedIterableToArray");
    function s(C, A) {
      (A == null || A > C.length) && (A = C.length);
      for (var E = 0, T = Array(A); E < A; E++) T[E] = C[E];
      return T;
    }
    u(s, "_arrayLikeToArray");
    function d(C, A) {
      var E = C == null ? null : typeof Symbol < "u" && C[Symbol.iterator] || C["@@iterator"];
      if (E != null) {
        var T, O, k, M, L = [], $ = !0, I = !1;
        try {
          if (k = (E = E.call(C)).next, A === 0) {
            if (Object(E) !== E) return;
            $ = !1;
          } else for (; !($ = (T = k.call(E)).done) && (L.push(T.value), L.length !== A); $ = !0) ;
        } catch (D) {
          I = !0, O = D;
        } finally {
          try {
            if (!$ && E.return != null && (M = E.return(), Object(M) !== M)) return;
          } finally {
            if (I) throw O;
          }
        }
        return L;
      }
    }
    u(d, "_iterableToArrayLimit");
    function l(C) {
      if (Array.isArray(C)) return C;
    }
    u(l, "_arrayWithHoles");
    var p = [], f = r.default.keys();
    for (b = 0; b < f.length; b++)
      if (h = f[b], m = r.default.get(h), m)
        for (g = [].concat(m.baseConcepts, m.relatedConcepts), w = /* @__PURE__ */ u(function() {
          var C = g[_];
          if (C.module === "HTML") {
            var A = C.concept;
            if (A) {
              var E = p.filter(function(M) {
                return P(M[0], A);
              })[0], T;
              E ? T = E[1] : T = [];
              for (var O = !0, k = 0; k < T.length; k++)
                if (T[k] === h) {
                  O = !1;
                  break;
                }
              O && T.push(h), E || p.push([A, T]);
            }
          }
        }, "_loop"), _ = 0; _ < g.length; _++)
          w();
    var h, m, g, w, _, b, x = {
      entries: /* @__PURE__ */ u(function() {
        return p;
      }, "entries"),
      forEach: /* @__PURE__ */ u(function(C) {
        for (var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, E = 0, T = p; E < T.length; E++) {
          var O = o(T[E], 2), k = O[0], M = O[1];
          C.call(A, M, k, p);
        }
      }, "forEach"),
      get: /* @__PURE__ */ u(function(C) {
        var A = p.filter(function(E) {
          return C.name === E[0].name && N(C.attributes, E[0].attributes);
        })[0];
        return A && A[1];
      }, "get"),
      has: /* @__PURE__ */ u(function(C) {
        return !!x.get(C);
      }, "has"),
      keys: /* @__PURE__ */ u(function() {
        return p.map(function(C) {
          var A = o(C, 1), E = A[0];
          return E;
        });
      }, "keys"),
      values: /* @__PURE__ */ u(function() {
        return p.map(function(C) {
          var A = o(C, 2), E = A[1];
          return E;
        });
      }, "values")
    };
    function P(C, A) {
      return C.name === A.name && R(C.constraints, A.constraints) && N(C.attributes, A.attributes);
    }
    u(P, "ariaRoleRelationConceptEquals");
    function R(C, A) {
      if (C === void 0 && A !== void 0 || C !== void 0 && A === void 0)
        return !1;
      if (C !== void 0 && A !== void 0) {
        if (C.length !== A.length)
          return !1;
        for (var E = 0; E < C.length; E++)
          if (C[E] !== A[E])
            return !1;
      }
      return !0;
    }
    u(R, "ariaRoleRelationConstraintsEquals");
    function N(C, A) {
      if (C === void 0 && A !== void 0 || C !== void 0 && A === void 0)
        return !1;
      if (C !== void 0 && A !== void 0) {
        if (C.length !== A.length)
          return !1;
        for (var E = 0; E < C.length; E++) {
          if (C[E].name !== A[E].name || C[E].value !== A[E].value || C[E].constraints === void 0 && A[E].constraints !== void 0 || C[E].constraints !== void 0 && A[E].constraints === void 0)
            return !1;
          if (C[E].constraints !== void 0 && A[E].constraints !== void 0) {
            if (C[E].constraints.length !== A[E].constraints.length)
              return !1;
            for (var T = 0; T < C[E].constraints.length; T++)
              if (C[E].constraints[T] !== A[E].constraints[T])
                return !1;
          }
        }
      }
      return !0;
    }
    u(N, "ariaRoleRelationConceptAttributeEquals"), e.default = (0, t.default)(x, x.entries());
  }
}), jTe = G({
  "../node_modules/aria-query/lib/roleElementMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = n(Ep()), r = n(A$());
    function n(N) {
      return N && N.__esModule ? N : { default: N };
    }
    u(n, "_interopRequireDefault");
    function o(N, C) {
      return l(N) || d(N, C) || i(N, C) || a();
    }
    u(o, "_slicedToArray");
    function a() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    u(a, "_nonIterableRest");
    function i(N, C) {
      if (N) {
        if (typeof N == "string") return s(N, C);
        var A = {}.toString.call(N).slice(8, -1);
        return A === "Object" && N.constructor && (A = N.constructor.name), A === "Map" || A === "Set" ? Array.from(N) : A === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A) ? s(N, C) : void 0;
      }
    }
    u(i, "_unsupportedIterableToArray");
    function s(N, C) {
      (C == null || C > N.length) && (C = N.length);
      for (var A = 0, E = Array(C); A < C; A++) E[A] = N[A];
      return E;
    }
    u(s, "_arrayLikeToArray");
    function d(N, C) {
      var A = N == null ? null : typeof Symbol < "u" && N[Symbol.iterator] || N["@@iterator"];
      if (A != null) {
        var E, T, O, k, M = [], L = !0, $ = !1;
        try {
          if (O = (A = A.call(N)).next, C === 0) {
            if (Object(A) !== A) return;
            L = !1;
          } else for (; !(L = (E = O.call(A)).done) && (M.push(E.value), M.length !== C); L = !0) ;
        } catch (I) {
          $ = !0, T = I;
        } finally {
          try {
            if (!L && A.return != null && (k = A.return(), Object(k) !== k)) return;
          } finally {
            if ($) throw T;
          }
        }
        return M;
      }
    }
    u(d, "_iterableToArrayLimit");
    function l(N) {
      if (Array.isArray(N)) return N;
    }
    u(l, "_arrayWithHoles");
    var p = [], f = r.default.keys();
    for (P = 0; P < f.length; P++)
      if (h = f[P], m = r.default.get(h), g = [], m) {
        for (w = [].concat(m.baseConcepts, m.relatedConcepts), x = 0; x < w.length; x++)
          _ = w[x], _.module === "HTML" && (b = _.concept, b != null && g.push(b));
        g.length > 0 && p.push([h, g]);
      }
    var h, m, g, w, _, b, x, P, R = {
      entries: /* @__PURE__ */ u(function() {
        return p;
      }, "entries"),
      forEach: /* @__PURE__ */ u(function(N) {
        for (var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, A = 0, E = p; A < E.length; A++) {
          var T = o(E[A], 2), O = T[0], k = T[1];
          N.call(C, k, O, p);
        }
      }, "forEach"),
      get: /* @__PURE__ */ u(function(N) {
        var C = p.filter(function(A) {
          return A[0] === N;
        })[0];
        return C && C[1];
      }, "get"),
      has: /* @__PURE__ */ u(function(N) {
        return !!R.get(N);
      }, "has"),
      keys: /* @__PURE__ */ u(function() {
        return p.map(function(N) {
          var C = o(N, 1), A = C[0];
          return A;
        });
      }, "keys"),
      values: /* @__PURE__ */ u(function() {
        return p.map(function(N) {
          var C = o(N, 2), A = C[1];
          return A;
        });
      }, "values")
    };
    e.default = (0, t.default)(R, R.entries());
  }
}), $$ = G({
  "../node_modules/aria-query/lib/index.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0;
    var t = i(KEe()), r = i(YEe()), n = i(A$()), o = i(RTe()), a = i(jTe());
    function i(s) {
      return s && s.__esModule ? s : { default: s };
    }
    u(i, "_interopRequireDefault"), e.aria = t.default, e.dom = r.default, e.roles = n.default, e.elementRoles = o.default, e.roleElements = a.default;
  }
}), UG = G({
  "../node_modules/css.escape/css.escape.js"(e, t) {
    (function(r, n) {
      typeof e == "object" ? t.exports = n(r) : typeof define == "function" && define.amd ? define([], n.bind(r, r)) : n(r);
    })(typeof globalThis < "u" ? globalThis : e, function(r) {
      if (r.CSS && r.CSS.escape)
        return r.CSS.escape;
      var n = /* @__PURE__ */ u(function(o) {
        if (arguments.length == 0)
          throw new TypeError("`CSS.escape` requires an argument.");
        for (var a = String(o), i = a.length, s = -1, d, l = "", p = a.charCodeAt(0); ++s < i; ) {
          if (d = a.charCodeAt(s), d == 0) {
            l += "ï¿½";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, [â€¦]
            d >= 1 && d <= 31 || d == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), [â€¦]
            s == 0 && d >= 48 && d <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), [â€¦]
            s == 1 && d >= 48 && d <= 57 && p == 45
          ) {
            l += "\\" + d.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, [â€¦]
            s == 0 && i == 1 && d == 45
          ) {
            l += "\\" + a.charAt(s);
            continue;
          }
          if (d >= 128 || d == 45 || d == 95 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122) {
            l += a.charAt(s);
            continue;
          }
          l += "\\" + a.charAt(s);
        }
        return l;
      }, "cssEscape");
      return r.CSS || (r.CSS = {}), r.CSS.escape = n, n;
    });
  }
}), BG = G({
  "../node_modules/pretty-format/node_modules/ansi-styles/index.js"(e, t) {
    var r = 10, n = /* @__PURE__ */ u((i = 0) => (s) => `\x1B[${38 + i};5;${s}m`, "wrapAnsi256"), o = /* @__PURE__ */ u((i = 0) => (s, d, l) => `\x1B[${38 + i};2;${s};${d};${l}m`, "wrapAnsi16m");
    function a() {
      const i = /* @__PURE__ */ new Map(), s = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      s.color.gray = s.color.blackBright, s.bgColor.bgGray = s.bgColor.bgBlackBright, s.color.grey = s.color.blackBright, s.bgColor.bgGrey = s.bgColor.bgBlackBright;
      for (const [d, l] of Object.entries(s)) {
        for (const [p, f] of Object.entries(l))
          s[p] = {
            open: `\x1B[${f[0]}m`,
            close: `\x1B[${f[1]}m`
          }, l[p] = s[p], i.set(f[0], f[1]);
        Object.defineProperty(s, d, {
          value: l,
          enumerable: !1
        });
      }
      return Object.defineProperty(s, "codes", {
        value: i,
        enumerable: !1
      }), s.color.close = "\x1B[39m", s.bgColor.close = "\x1B[49m", s.color.ansi256 = n(), s.color.ansi16m = o(), s.bgColor.ansi256 = n(r), s.bgColor.ansi16m = o(r), Object.defineProperties(s, {
        rgbToAnsi256: {
          value: /* @__PURE__ */ u((d, l, p) => d === l && l === p ? d < 8 ? 16 : d > 248 ? 231 : Math.round((d - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(d / 255 * 5) + 6 * Math.round(l / 255 * 5) + Math.round(p / 255 * 5), "value"),
          enumerable: !1
        },
        hexToRgb: {
          value: /* @__PURE__ */ u((d) => {
            const l = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(d.toString(16));
            if (!l)
              return [0, 0, 0];
            let { colorString: p } = l.groups;
            p.length === 3 && (p = p.split("").map((h) => h + h).join(""));
            const f = Number.parseInt(p, 16);
            return [
              f >> 16 & 255,
              f >> 8 & 255,
              f & 255
            ];
          }, "value"),
          enumerable: !1
        },
        hexToAnsi256: {
          value: /* @__PURE__ */ u((d) => s.rgbToAnsi256(...s.hexToRgb(d)), "value"),
          enumerable: !1
        }
      }), s;
    }
    u(a, "assembleStyles"), Object.defineProperty(t, "exports", {
      enumerable: !0,
      get: a
    });
  }
}), jg = G({
  "../node_modules/pretty-format/build/collections.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.printIteratorEntries = r, e.printIteratorValues = n, e.printListItems = o, e.printObjectProperties = a;
    var t = /* @__PURE__ */ u((i, s) => {
      const d = Object.keys(i).sort(s);
      return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(i).forEach((l) => {
        Object.getOwnPropertyDescriptor(i, l).enumerable && d.push(l);
      }), d;
    }, "getKeysOfEnumerableProperties");
    function r(i, s, d, l, p, f, h = ": ") {
      let m = "", g = i.next();
      if (!g.done) {
        m += s.spacingOuter;
        const w = d + s.indent;
        for (; !g.done; ) {
          const _ = f(
            g.value[0],
            s,
            w,
            l,
            p
          ), b = f(
            g.value[1],
            s,
            w,
            l,
            p
          );
          m += w + _ + h + b, g = i.next(), g.done ? s.min || (m += ",") : m += "," + s.spacingInner;
        }
        m += s.spacingOuter + d;
      }
      return m;
    }
    u(r, "printIteratorEntries");
    function n(i, s, d, l, p, f) {
      let h = "", m = i.next();
      if (!m.done) {
        h += s.spacingOuter;
        const g = d + s.indent;
        for (; !m.done; )
          h += g + f(m.value, s, g, l, p), m = i.next(), m.done ? s.min || (h += ",") : h += "," + s.spacingInner;
        h += s.spacingOuter + d;
      }
      return h;
    }
    u(n, "printIteratorValues");
    function o(i, s, d, l, p, f) {
      let h = "";
      if (i.length) {
        h += s.spacingOuter;
        const m = d + s.indent;
        for (let g = 0; g < i.length; g++)
          h += m, g in i && (h += f(i[g], s, m, l, p)), g < i.length - 1 ? h += "," + s.spacingInner : s.min || (h += ",");
        h += s.spacingOuter + d;
      }
      return h;
    }
    u(o, "printListItems");
    function a(i, s, d, l, p, f) {
      let h = "";
      const m = t(i, s.compareKeys);
      if (m.length) {
        h += s.spacingOuter;
        const g = d + s.indent;
        for (let w = 0; w < m.length; w++) {
          const _ = m[w], b = f(_, s, g, l, p), x = f(i[_], s, g, l, p);
          h += g + b + ": " + x, w < m.length - 1 ? h += "," + s.spacingInner : s.min || (h += ",");
        }
        h += s.spacingOuter + d;
      }
      return h;
    }
    u(a, "printObjectProperties");
  }
}), ITe = G({
  "../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = jg(), r = (function() {
      return typeof globalThis < "u" ? globalThis : typeof r < "u" ? r : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), n = r["jest-symbol-do-not-touch"] || r.Symbol, o = typeof n == "function" && n.for ? n.for("jest.asymmetricMatcher") : 1267621, a = " ", i = /* @__PURE__ */ u((p, f, h, m, g, w) => {
      const _ = p.toString();
      return _ === "ArrayContaining" || _ === "ArrayNotContaining" ? ++m > f.maxDepth ? "[" + _ + "]" : _ + a + "[" + (0, t.printListItems)(
        p.sample,
        f,
        h,
        m,
        g,
        w
      ) + "]" : _ === "ObjectContaining" || _ === "ObjectNotContaining" ? ++m > f.maxDepth ? "[" + _ + "]" : _ + a + "{" + (0, t.printObjectProperties)(
        p.sample,
        f,
        h,
        m,
        g,
        w
      ) + "}" : _ === "StringMatching" || _ === "StringNotMatching" || _ === "StringContaining" || _ === "StringNotContaining" ? _ + a + w(p.sample, f, h, m, g) : p.toAsymmetricMatcher();
    }, "serialize");
    e.serialize = i;
    var s = /* @__PURE__ */ u((p) => p && p.$$typeof === o, "test");
    e.test = s;
    var d = {
      serialize: i,
      test: s
    }, l = d;
    e.default = l;
  }
}), NTe = G({
  "../node_modules/pretty-format/node_modules/ansi-regex/index.js"(e, t) {
    t.exports = ({ onlyFirst: r = !1 } = {}) => {
      const n = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(n, r ? void 0 : "g");
    };
  }
}), MTe = G({
  "../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = n(NTe()), r = n(BG());
    function n(l) {
      return l && l.__esModule ? l : { default: l };
    }
    u(n, "_interopRequireDefault");
    var o = /* @__PURE__ */ u((l) => l.replace((0, t.default)(), (p) => {
      switch (p) {
        case r.default.red.close:
        case r.default.green.close:
        case r.default.cyan.close:
        case r.default.gray.close:
        case r.default.white.close:
        case r.default.yellow.close:
        case r.default.bgRed.close:
        case r.default.bgGreen.close:
        case r.default.bgYellow.close:
        case r.default.inverse.close:
        case r.default.dim.close:
        case r.default.bold.close:
        case r.default.reset.open:
        case r.default.reset.close:
          return "</>";
        case r.default.red.open:
          return "<red>";
        case r.default.green.open:
          return "<green>";
        case r.default.cyan.open:
          return "<cyan>";
        case r.default.gray.open:
          return "<gray>";
        case r.default.white.open:
          return "<white>";
        case r.default.yellow.open:
          return "<yellow>";
        case r.default.bgRed.open:
          return "<bgRed>";
        case r.default.bgGreen.open:
          return "<bgGreen>";
        case r.default.bgYellow.open:
          return "<bgYellow>";
        case r.default.inverse.open:
          return "<inverse>";
        case r.default.dim.open:
          return "<dim>";
        case r.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    }), "toHumanReadableAnsi"), a = /* @__PURE__ */ u((l) => typeof l == "string" && !!l.match((0, t.default)()), "test");
    e.test = a;
    var i = /* @__PURE__ */ u((l, p, f, h, m, g) => g(o(l), p, f, h, m), "serialize");
    e.serialize = i;
    var s = {
      serialize: i,
      test: a
    }, d = s;
    e.default = d;
  }
}), DTe = G({
  "../node_modules/pretty-format/build/plugins/DOMCollection.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = jg(), r = " ", n = ["DOMStringMap", "NamedNodeMap"], o = /^(HTML\w*Collection|NodeList)$/, a = /* @__PURE__ */ u((f) => n.indexOf(f) !== -1 || o.test(f), "testName"), i = /* @__PURE__ */ u((f) => f && f.constructor && !!f.constructor.name && a(f.constructor.name), "test");
    e.test = i;
    var s = /* @__PURE__ */ u((f) => f.constructor.name === "NamedNodeMap", "isNamedNodeMap"), d = /* @__PURE__ */ u((f, h, m, g, w, _) => {
      const b = f.constructor.name;
      return ++g > h.maxDepth ? "[" + b + "]" : (h.min ? "" : b + r) + (n.indexOf(b) !== -1 ? "{" + (0, t.printObjectProperties)(
        s(f) ? Array.from(f).reduce((x, P) => (x[P.name] = P.value, x), {}) : { ...f },
        h,
        m,
        g,
        w,
        _
      ) + "}" : "[" + (0, t.printListItems)(
        Array.from(f),
        h,
        m,
        g,
        w,
        _
      ) + "]");
    }, "serialize");
    e.serialize = d;
    var l = {
      serialize: d,
      test: i
    }, p = l;
    e.default = p;
  }
}), qTe = G({
  "../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = t;
    function t(r) {
      return r.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    u(t, "escapeHTML");
  }
}), C$ = G({
  "../node_modules/pretty-format/build/plugins/lib/markup.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.printText = e.printProps = e.printElementAsLeaf = e.printElement = e.printComment = e.printChildren = void 0;
    var t = r(qTe());
    function r(l) {
      return l && l.__esModule ? l : { default: l };
    }
    u(r, "_interopRequireDefault");
    var n = /* @__PURE__ */ u((l, p, f, h, m, g, w) => {
      const _ = h + f.indent, b = f.colors;
      return l.map((x) => {
        const P = p[x];
        let R = w(P, f, _, m, g);
        return typeof P != "string" && (R.indexOf(`
`) !== -1 && (R = f.spacingOuter + _ + R + f.spacingOuter + h), R = "{" + R + "}"), f.spacingInner + h + b.prop.open + x + b.prop.close + "=" + b.value.open + R + b.value.close;
      }).join("");
    }, "printProps");
    e.printProps = n;
    var o = /* @__PURE__ */ u((l, p, f, h, m, g) => l.map(
      (w) => p.spacingOuter + f + (typeof w == "string" ? a(w, p) : g(w, p, f, h, m))
    ).join(""), "printChildren");
    e.printChildren = o;
    var a = /* @__PURE__ */ u((l, p) => {
      const f = p.colors.content;
      return f.open + (0, t.default)(l) + f.close;
    }, "printText");
    e.printText = a;
    var i = /* @__PURE__ */ u((l, p) => {
      const f = p.colors.comment;
      return f.open + "<!--" + (0, t.default)(l) + "-->" + f.close;
    }, "printComment");
    e.printComment = i;
    var s = /* @__PURE__ */ u((l, p, f, h, m) => {
      const g = h.colors.tag;
      return g.open + "<" + l + (p && g.close + p + h.spacingOuter + m + g.open) + (f ? ">" + g.close + f + h.spacingOuter + m + g.open + "</" + l : (p && !h.min ? "" : " ") + "/") + ">" + g.close;
    }, "printElement");
    e.printElement = s;
    var d = /* @__PURE__ */ u((l, p) => {
      const f = p.colors.tag;
      return f.open + "<" + l + f.close + " â€¦" + f.open + " />" + f.close;
    }, "printElementAsLeaf");
    e.printElementAsLeaf = d;
  }
}), LTe = G({
  "../node_modules/pretty-format/build/plugins/DOMElement.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = C$(), r = 1, n = 3, o = 8, a = 11, i = /^((HTML|SVG)\w*)?Element$/, s = /* @__PURE__ */ u((_) => {
      try {
        return typeof _.hasAttribute == "function" && _.hasAttribute("is");
      } catch {
        return !1;
      }
    }, "testHasAttribute"), d = /* @__PURE__ */ u((_) => {
      const b = _.constructor.name, { nodeType: x, tagName: P } = _, R = typeof P == "string" && P.includes("-") || s(_);
      return x === r && (i.test(b) || R) || x === n && b === "Text" || x === o && b === "Comment" || x === a && b === "DocumentFragment";
    }, "testNode"), l = /* @__PURE__ */ u((_) => {
      var b;
      return (_ == null || (b = _.constructor) === null || b === void 0 ? void 0 : b.name) && d(_);
    }, "test");
    e.test = l;
    function p(_) {
      return _.nodeType === n;
    }
    u(p, "nodeIsText");
    function f(_) {
      return _.nodeType === o;
    }
    u(f, "nodeIsComment");
    function h(_) {
      return _.nodeType === a;
    }
    u(h, "nodeIsFragment");
    var m = /* @__PURE__ */ u((_, b, x, P, R, N) => {
      if (p(_))
        return (0, t.printText)(_.data, b);
      if (f(_))
        return (0, t.printComment)(_.data, b);
      const C = h(_) ? "DocumentFragment" : _.tagName.toLowerCase();
      return ++P > b.maxDepth ? (0, t.printElementAsLeaf)(C, b) : (0, t.printElement)(
        C,
        (0, t.printProps)(
          h(_) ? [] : Array.from(_.attributes).map((A) => A.name).sort(),
          h(_) ? {} : Array.from(_.attributes).reduce((A, E) => (A[E.name] = E.value, A), {}),
          b,
          x + b.indent,
          P,
          R,
          N
        ),
        (0, t.printChildren)(
          Array.prototype.slice.call(_.childNodes || _.children),
          b,
          x + b.indent,
          P,
          R,
          N
        ),
        b,
        x
      );
    }, "serialize");
    e.serialize = m;
    var g = {
      serialize: m,
      test: l
    }, w = g;
    e.default = w;
  }
}), FTe = G({
  "../node_modules/pretty-format/build/plugins/Immutable.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = jg(), r = "@@__IMMUTABLE_ITERABLE__@@", n = "@@__IMMUTABLE_LIST__@@", o = "@@__IMMUTABLE_KEYED__@@", a = "@@__IMMUTABLE_MAP__@@", i = "@@__IMMUTABLE_ORDERED__@@", s = "@@__IMMUTABLE_RECORD__@@", d = "@@__IMMUTABLE_SEQ__@@", l = "@@__IMMUTABLE_SET__@@", p = "@@__IMMUTABLE_STACK__@@", f = /* @__PURE__ */ u((E) => "Immutable." + E, "getImmutableName"), h = /* @__PURE__ */ u((E) => "[" + E + "]", "printAsLeaf"), m = " ", g = "â€¦", w = /* @__PURE__ */ u((E, T, O, k, M, L, $) => ++k > T.maxDepth ? h(f($)) : f($) + m + "{" + (0, t.printIteratorEntries)(
      E.entries(),
      T,
      O,
      k,
      M,
      L
    ) + "}", "printImmutableEntries");
    function _(E) {
      let T = 0;
      return {
        next() {
          if (T < E._keys.length) {
            const O = E._keys[T++];
            return {
              done: !1,
              value: [O, E.get(O)]
            };
          }
          return {
            done: !0,
            value: void 0
          };
        }
      };
    }
    u(_, "getRecordEntries");
    var b = /* @__PURE__ */ u((E, T, O, k, M, L) => {
      const $ = f(E._name || "Record");
      return ++k > T.maxDepth ? h($) : $ + m + "{" + (0, t.printIteratorEntries)(
        _(E),
        T,
        O,
        k,
        M,
        L
      ) + "}";
    }, "printImmutableRecord"), x = /* @__PURE__ */ u((E, T, O, k, M, L) => {
      const $ = f("Seq");
      return ++k > T.maxDepth ? h($) : E[o] ? $ + m + "{" + // from Immutable collection of entries or from ECMAScript object
      (E._iter || E._object ? (0, t.printIteratorEntries)(
        E.entries(),
        T,
        O,
        k,
        M,
        L
      ) : g) + "}" : $ + m + "[" + (E._iter || // from Immutable collection of values
      E._array || // from ECMAScript array
      E._collection || // from ECMAScript collection in immutable v4
      E._iterable ? (0, t.printIteratorValues)(
        E.values(),
        T,
        O,
        k,
        M,
        L
      ) : g) + "]";
    }, "printImmutableSeq"), P = /* @__PURE__ */ u((E, T, O, k, M, L, $) => ++k > T.maxDepth ? h(f($)) : f($) + m + "[" + (0, t.printIteratorValues)(
      E.values(),
      T,
      O,
      k,
      M,
      L
    ) + "]", "printImmutableValues"), R = /* @__PURE__ */ u((E, T, O, k, M, L) => E[a] ? w(
      E,
      T,
      O,
      k,
      M,
      L,
      E[i] ? "OrderedMap" : "Map"
    ) : E[n] ? P(
      E,
      T,
      O,
      k,
      M,
      L,
      "List"
    ) : E[l] ? P(
      E,
      T,
      O,
      k,
      M,
      L,
      E[i] ? "OrderedSet" : "Set"
    ) : E[p] ? P(
      E,
      T,
      O,
      k,
      M,
      L,
      "Stack"
    ) : E[d] ? x(E, T, O, k, M, L) : b(E, T, O, k, M, L), "serialize");
    e.serialize = R;
    var N = /* @__PURE__ */ u((E) => E && (E[r] === !0 || E[s] === !0), "test");
    e.test = N;
    var C = {
      serialize: R,
      test: N
    }, A = C;
    e.default = A;
  }
}), UTe = G({
  "../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js"(e) {
    var t = 60103, r = 60106, n = 60107, o = 60108, a = 60114, i = 60109, s = 60110, d = 60112, l = 60113, p = 60120, f = 60115, h = 60116, m = 60121, g = 60122, w = 60117, _ = 60129, b = 60131;
    typeof Symbol == "function" && Symbol.for && (x = Symbol.for, t = x("react.element"), r = x("react.portal"), n = x("react.fragment"), o = x("react.strict_mode"), a = x("react.profiler"), i = x("react.provider"), s = x("react.context"), d = x("react.forward_ref"), l = x("react.suspense"), p = x("react.suspense_list"), f = x("react.memo"), h = x("react.lazy"), m = x("react.block"), g = x("react.server.block"), w = x("react.fundamental"), _ = x("react.debug_trace_mode"), b = x("react.legacy_hidden"));
    var x;
    function P($) {
      if (typeof $ == "object" && $ !== null) {
        var I = $.$$typeof;
        switch (I) {
          case t:
            switch ($ = $.type, $) {
              case n:
              case a:
              case o:
              case l:
              case p:
                return $;
              default:
                switch ($ = $ && $.$$typeof, $) {
                  case s:
                  case d:
                  case h:
                  case f:
                  case i:
                    return $;
                  default:
                    return I;
                }
            }
          case r:
            return I;
        }
      }
    }
    u(P, "y");
    var R = i, N = t, C = d, A = n, E = h, T = f, O = r, k = a, M = o, L = l;
    e.ContextConsumer = s, e.ContextProvider = R, e.Element = N, e.ForwardRef = C, e.Fragment = A, e.Lazy = E, e.Memo = T, e.Portal = O, e.Profiler = k, e.StrictMode = M, e.Suspense = L, e.isAsyncMode = function() {
      return !1;
    }, e.isConcurrentMode = function() {
      return !1;
    }, e.isContextConsumer = function($) {
      return P($) === s;
    }, e.isContextProvider = function($) {
      return P($) === i;
    }, e.isElement = function($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === t;
    }, e.isForwardRef = function($) {
      return P($) === d;
    }, e.isFragment = function($) {
      return P($) === n;
    }, e.isLazy = function($) {
      return P($) === h;
    }, e.isMemo = function($) {
      return P($) === f;
    }, e.isPortal = function($) {
      return P($) === r;
    }, e.isProfiler = function($) {
      return P($) === a;
    }, e.isStrictMode = function($) {
      return P($) === o;
    }, e.isSuspense = function($) {
      return P($) === l;
    }, e.isValidElementType = function($) {
      return typeof $ == "string" || typeof $ == "function" || $ === n || $ === a || $ === _ || $ === o || $ === l || $ === p || $ === b || typeof $ == "object" && $ !== null && ($.$$typeof === h || $.$$typeof === f || $.$$typeof === i || $.$$typeof === s || $.$$typeof === d || $.$$typeof === w || $.$$typeof === m || $[0] === g);
    }, e.typeOf = P;
  }
}), BTe = G({
  "../node_modules/pretty-format/node_modules/react-is/index.js"(e, t) {
    t.exports = UTe();
  }
}), HTe = G({
  "../node_modules/pretty-format/build/plugins/ReactElement.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = o(BTe()), r = C$();
    function n(h) {
      if (typeof WeakMap != "function") return null;
      var m = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
      return (n = /* @__PURE__ */ u(function(w) {
        return w ? g : m;
      }, "_getRequireWildcardCache"))(h);
    }
    u(n, "_getRequireWildcardCache");
    function o(h, m) {
      if (!m && h && h.__esModule)
        return h;
      if (h === null || typeof h != "object" && typeof h != "function")
        return { default: h };
      var g = n(m);
      if (g && g.has(h))
        return g.get(h);
      var w = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b in h)
        if (b !== "default" && Object.prototype.hasOwnProperty.call(h, b)) {
          var x = _ ? Object.getOwnPropertyDescriptor(h, b) : null;
          x && (x.get || x.set) ? Object.defineProperty(w, b, x) : w[b] = h[b];
        }
      return w.default = h, g && g.set(h, w), w;
    }
    u(o, "_interopRequireWildcard");
    var a = /* @__PURE__ */ u((h, m = []) => (Array.isArray(h) ? h.forEach((g) => {
      a(g, m);
    }) : h != null && h !== !1 && m.push(h), m), "getChildren"), i = /* @__PURE__ */ u((h) => {
      const m = h.type;
      if (typeof m == "string")
        return m;
      if (typeof m == "function")
        return m.displayName || m.name || "Unknown";
      if (t.isFragment(h))
        return "React.Fragment";
      if (t.isSuspense(h))
        return "React.Suspense";
      if (typeof m == "object" && m !== null) {
        if (t.isContextProvider(h))
          return "Context.Provider";
        if (t.isContextConsumer(h))
          return "Context.Consumer";
        if (t.isForwardRef(h)) {
          if (m.displayName)
            return m.displayName;
          const g = m.render.displayName || m.render.name || "";
          return g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef";
        }
        if (t.isMemo(h)) {
          const g = m.displayName || m.type.displayName || m.type.name || "";
          return g !== "" ? "Memo(" + g + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    }, "getType"), s = /* @__PURE__ */ u((h) => {
      const { props: m } = h;
      return Object.keys(m).filter((g) => g !== "children" && m[g] !== void 0).sort();
    }, "getPropKeys"), d = /* @__PURE__ */ u((h, m, g, w, _, b) => ++w > m.maxDepth ? (0, r.printElementAsLeaf)(i(h), m) : (0, r.printElement)(
      i(h),
      (0, r.printProps)(
        s(h),
        h.props,
        m,
        g + m.indent,
        w,
        _,
        b
      ),
      (0, r.printChildren)(
        a(h.props.children),
        m,
        g + m.indent,
        w,
        _,
        b
      ),
      m,
      g
    ), "serialize");
    e.serialize = d;
    var l = /* @__PURE__ */ u((h) => h != null && t.isElement(h), "test");
    e.test = l;
    var p = {
      serialize: d,
      test: l
    }, f = p;
    e.default = f;
  }
}), VTe = G({
  "../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = C$(), r = (function() {
      return typeof globalThis < "u" ? globalThis : typeof r < "u" ? r : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), n = r["jest-symbol-do-not-touch"] || r.Symbol, o = typeof n == "function" && n.for ? n.for("react.test.json") : 245830487, a = /* @__PURE__ */ u((p) => {
      const { props: f } = p;
      return f ? Object.keys(f).filter((h) => f[h] !== void 0).sort() : [];
    }, "getPropKeys"), i = /* @__PURE__ */ u((p, f, h, m, g, w) => ++m > f.maxDepth ? (0, t.printElementAsLeaf)(p.type, f) : (0, t.printElement)(
      p.type,
      p.props ? (0, t.printProps)(
        a(p),
        p.props,
        f,
        h + f.indent,
        m,
        g,
        w
      ) : "",
      p.children ? (0, t.printChildren)(
        p.children,
        f,
        h + f.indent,
        m,
        g,
        w
      ) : "",
      f,
      h
    ), "serialize");
    e.serialize = i;
    var s = /* @__PURE__ */ u((p) => p && p.$$typeof === o, "test");
    e.test = s;
    var d = {
      serialize: i,
      test: s
    }, l = d;
    e.default = l;
  }
}), zTe = G({
  "../node_modules/pretty-format/build/index.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = e.DEFAULT_OPTIONS = void 0, e.format = Se, e.plugins = void 0;
    var t = p(BG()), r = jg(), n = p(
      ITe()
    ), o = p(MTe()), a = p(DTe()), i = p(LTe()), s = p(FTe()), d = p(HTe()), l = p(
      VTe()
    );
    function p(q) {
      return q && q.__esModule ? q : { default: q };
    }
    u(p, "_interopRequireDefault");
    var f = Object.prototype.toString, h = Date.prototype.toISOString, m = Error.prototype.toString, g = RegExp.prototype.toString, w = /* @__PURE__ */ u((q) => typeof q.constructor == "function" && q.constructor.name || "Object", "getConstructorName"), _ = /* @__PURE__ */ u((q) => typeof window < "u" && q === window, "isWindow"), b = /^Symbol\((.*)\)(.*)$/, x = /\n/gi, P = class extends Error {
      constructor(q, te) {
        super(q), this.stack = te, this.name = this.constructor.name;
      }
    };
    u(P, "PrettyFormatPluginError");
    var R = P;
    function N(q) {
      return q === "[object Array]" || q === "[object ArrayBuffer]" || q === "[object DataView]" || q === "[object Float32Array]" || q === "[object Float64Array]" || q === "[object Int8Array]" || q === "[object Int16Array]" || q === "[object Int32Array]" || q === "[object Uint8Array]" || q === "[object Uint8ClampedArray]" || q === "[object Uint16Array]" || q === "[object Uint32Array]";
    }
    u(N, "isToStringedArrayType");
    function C(q) {
      return Object.is(q, -0) ? "-0" : String(q);
    }
    u(C, "printNumber");
    function A(q) {
      return `${q}n`;
    }
    u(A, "printBigInt");
    function E(q, te) {
      return te ? "[Function " + (q.name || "anonymous") + "]" : "[Function]";
    }
    u(E, "printFunction");
    function T(q) {
      return String(q).replace(b, "Symbol($1)");
    }
    u(T, "printSymbol");
    function O(q) {
      return "[" + m.call(q) + "]";
    }
    u(O, "printError");
    function k(q, te, ae, ue) {
      if (q === !0 || q === !1)
        return "" + q;
      if (q === void 0)
        return "undefined";
      if (q === null)
        return "null";
      const se = typeof q;
      if (se === "number")
        return C(q);
      if (se === "bigint")
        return A(q);
      if (se === "string")
        return ue ? '"' + q.replace(/"|\\/g, "\\$&") + '"' : '"' + q + '"';
      if (se === "function")
        return E(q, te);
      if (se === "symbol")
        return T(q);
      const ye = f.call(q);
      return ye === "[object WeakMap]" ? "WeakMap {}" : ye === "[object WeakSet]" ? "WeakSet {}" : ye === "[object Function]" || ye === "[object GeneratorFunction]" ? E(q, te) : ye === "[object Symbol]" ? T(q) : ye === "[object Date]" ? isNaN(+q) ? "Date { NaN }" : h.call(q) : ye === "[object Error]" ? O(q) : ye === "[object RegExp]" ? ae ? g.call(q).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : g.call(q) : q instanceof Error ? O(q) : null;
    }
    u(k, "printBasicValue");
    function M(q, te, ae, ue, se, ye) {
      if (se.indexOf(q) !== -1)
        return "[Circular]";
      se = se.slice(), se.push(q);
      const fe = ++ue > te.maxDepth, Ae = te.min;
      if (te.callToJSON && !fe && q.toJSON && typeof q.toJSON == "function" && !ye)
        return D(q.toJSON(), te, ae, ue, se, !0);
      const Fe = f.call(q);
      return Fe === "[object Arguments]" ? fe ? "[Arguments]" : (Ae ? "" : "Arguments ") + "[" + (0, r.printListItems)(
        q,
        te,
        ae,
        ue,
        se,
        D
      ) + "]" : N(Fe) ? fe ? "[" + q.constructor.name + "]" : (Ae || !te.printBasicPrototype && q.constructor.name === "Array" ? "" : q.constructor.name + " ") + "[" + (0, r.printListItems)(
        q,
        te,
        ae,
        ue,
        se,
        D
      ) + "]" : Fe === "[object Map]" ? fe ? "[Map]" : "Map {" + (0, r.printIteratorEntries)(
        q.entries(),
        te,
        ae,
        ue,
        se,
        D,
        " => "
      ) + "}" : Fe === "[object Set]" ? fe ? "[Set]" : "Set {" + (0, r.printIteratorValues)(
        q.values(),
        te,
        ae,
        ue,
        se,
        D
      ) + "}" : fe || _(q) ? "[" + w(q) + "]" : (Ae || !te.printBasicPrototype && w(q) === "Object" ? "" : w(q) + " ") + "{" + (0, r.printObjectProperties)(
        q,
        te,
        ae,
        ue,
        se,
        D
      ) + "}";
    }
    u(M, "printComplexValue");
    function L(q) {
      return q.serialize != null;
    }
    u(L, "isNewPlugin");
    function $(q, te, ae, ue, se, ye) {
      let fe;
      try {
        fe = L(q) ? q.serialize(te, ae, ue, se, ye, D) : q.print(
          te,
          (Ae) => D(Ae, ae, ue, se, ye),
          (Ae) => {
            const Fe = ue + ae.indent;
            return Fe + Ae.replace(x, `
` + Fe);
          },
          {
            edgeSpacing: ae.spacingOuter,
            min: ae.min,
            spacing: ae.spacingInner
          },
          ae.colors
        );
      } catch (Ae) {
        throw new R(Ae.message, Ae.stack);
      }
      if (typeof fe != "string")
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof fe}".`
        );
      return fe;
    }
    u($, "printPlugin");
    function I(q, te) {
      for (let ae = 0; ae < q.length; ae++)
        try {
          if (q[ae].test(te))
            return q[ae];
        } catch (ue) {
          throw new R(ue.message, ue.stack);
        }
      return null;
    }
    u(I, "findPlugin");
    function D(q, te, ae, ue, se, ye) {
      const fe = I(te.plugins, q);
      if (fe !== null)
        return $(fe, q, te, ae, ue, se);
      const Ae = k(
        q,
        te.printFunctionName,
        te.escapeRegex,
        te.escapeString
      );
      return Ae !== null ? Ae : M(
        q,
        te,
        ae,
        ue,
        se,
        ye
      );
    }
    u(D, "printer");
    var F = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    }, J = Object.keys(F), oe = {
      callToJSON: !0,
      compareKeys: void 0,
      escapeRegex: !1,
      escapeString: !0,
      highlight: !1,
      indent: 2,
      maxDepth: 1 / 0,
      min: !1,
      plugins: [],
      printBasicPrototype: !0,
      printFunctionName: !0,
      theme: F
    };
    e.DEFAULT_OPTIONS = oe;
    function ce(q) {
      if (Object.keys(q).forEach((te) => {
        if (!oe.hasOwnProperty(te))
          throw new Error(`pretty-format: Unknown option "${te}".`);
      }), q.min && q.indent !== void 0 && q.indent !== 0)
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      if (q.theme !== void 0) {
        if (q.theme === null)
          throw new Error('pretty-format: Option "theme" must not be null.');
        if (typeof q.theme != "object")
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof q.theme}".`
          );
      }
    }
    u(ce, "validateOptions");
    var le = /* @__PURE__ */ u((q) => J.reduce((te, ae) => {
      const ue = q.theme && q.theme[ae] !== void 0 ? q.theme[ae] : F[ae], se = ue && t.default[ue];
      if (se && typeof se.close == "string" && typeof se.open == "string")
        te[ae] = se;
      else
        throw new Error(
          `pretty-format: Option "theme" has a key "${ae}" whose value "${ue}" is undefined in ansi-styles.`
        );
      return te;
    }, /* @__PURE__ */ Object.create(null)), "getColorsHighlight"), re = /* @__PURE__ */ u(() => J.reduce((q, te) => (q[te] = {
      close: "",
      open: ""
    }, q), /* @__PURE__ */ Object.create(null)), "getColorsEmpty"), we = /* @__PURE__ */ u((q) => q && q.printFunctionName !== void 0 ? q.printFunctionName : oe.printFunctionName, "getPrintFunctionName"), _e = /* @__PURE__ */ u((q) => q && q.escapeRegex !== void 0 ? q.escapeRegex : oe.escapeRegex, "getEscapeRegex"), de = /* @__PURE__ */ u((q) => q && q.escapeString !== void 0 ? q.escapeString : oe.escapeString, "getEscapeString"), ne = /* @__PURE__ */ u((q) => {
      var te;
      return {
        callToJSON: q && q.callToJSON !== void 0 ? q.callToJSON : oe.callToJSON,
        colors: q && q.highlight ? le(q) : re(),
        compareKeys: q && typeof q.compareKeys == "function" ? q.compareKeys : oe.compareKeys,
        escapeRegex: _e(q),
        escapeString: de(q),
        indent: q && q.min ? "" : $e(
          q && q.indent !== void 0 ? q.indent : oe.indent
        ),
        maxDepth: q && q.maxDepth !== void 0 ? q.maxDepth : oe.maxDepth,
        min: q && q.min !== void 0 ? q.min : oe.min,
        plugins: q && q.plugins !== void 0 ? q.plugins : oe.plugins,
        printBasicPrototype: (te = q?.printBasicPrototype) !== null && te !== void 0 ? te : !0,
        printFunctionName: we(q),
        spacingInner: q && q.min ? " " : `
`,
        spacingOuter: q && q.min ? "" : `
`
      };
    }, "getConfig");
    function $e(q) {
      return new Array(q + 1).join(" ");
    }
    u($e, "createIndent");
    function Se(q, te) {
      if (te && (ce(te), te.plugins)) {
        const ue = I(te.plugins, q);
        if (ue !== null)
          return $(ue, q, ne(te), "", 0, []);
      }
      const ae = k(
        q,
        we(te),
        _e(te),
        de(te)
      );
      return ae !== null ? ae : M(q, ne(te), "", 0, []);
    }
    u(Se, "format");
    var nt = {
      AsymmetricMatcher: n.default,
      ConvertAnsi: o.default,
      DOMCollection: a.default,
      DOMElement: i.default,
      Immutable: s.default,
      ReactElement: d.default,
      ReactTestComponent: l.default
    };
    e.plugins = nt;
    var We = Se;
    e.default = We;
  }
}), JTe = G({
  "../node_modules/lz-string/libs/lz-string.js"(e, t) {
    var r = (function() {
      var n = String.fromCharCode, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", i = {};
      function s(l, p) {
        if (!i[l]) {
          i[l] = {};
          for (var f = 0; f < l.length; f++)
            i[l][l.charAt(f)] = f;
        }
        return i[l][p];
      }
      u(s, "getBaseValue");
      var d = {
        compressToBase64: /* @__PURE__ */ u(function(l) {
          if (l == null) return "";
          var p = d._compress(l, 6, function(f) {
            return o.charAt(f);
          });
          switch (p.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return p;
            case 1:
              return p + "===";
            case 2:
              return p + "==";
            case 3:
              return p + "=";
          }
        }, "compressToBase64"),
        decompressFromBase64: /* @__PURE__ */ u(function(l) {
          return l == null ? "" : l == "" ? null : d._decompress(l.length, 32, function(p) {
            return s(o, l.charAt(p));
          });
        }, "decompressFromBase64"),
        compressToUTF16: /* @__PURE__ */ u(function(l) {
          return l == null ? "" : d._compress(l, 15, function(p) {
            return n(p + 32);
          }) + " ";
        }, "compressToUTF16"),
        decompressFromUTF16: /* @__PURE__ */ u(function(l) {
          return l == null ? "" : l == "" ? null : d._decompress(l.length, 16384, function(p) {
            return l.charCodeAt(p) - 32;
          });
        }, "decompressFromUTF16"),
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: /* @__PURE__ */ u(function(l) {
          for (var p = d.compress(l), f = new Uint8Array(p.length * 2), h = 0, m = p.length; h < m; h++) {
            var g = p.charCodeAt(h);
            f[h * 2] = g >>> 8, f[h * 2 + 1] = g % 256;
          }
          return f;
        }, "compressToUint8Array"),
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: /* @__PURE__ */ u(function(l) {
          if (l == null)
            return d.decompress(l);
          for (var p = new Array(l.length / 2), f = 0, h = p.length; f < h; f++)
            p[f] = l[f * 2] * 256 + l[f * 2 + 1];
          var m = [];
          return p.forEach(function(g) {
            m.push(n(g));
          }), d.decompress(m.join(""));
        }, "decompressFromUint8Array"),
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: /* @__PURE__ */ u(function(l) {
          return l == null ? "" : d._compress(l, 6, function(p) {
            return a.charAt(p);
          });
        }, "compressToEncodedURIComponent"),
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: /* @__PURE__ */ u(function(l) {
          return l == null ? "" : l == "" ? null : (l = l.replace(/ /g, "+"), d._decompress(l.length, 32, function(p) {
            return s(a, l.charAt(p));
          }));
        }, "decompressFromEncodedURIComponent"),
        compress: /* @__PURE__ */ u(function(l) {
          return d._compress(l, 16, function(p) {
            return n(p);
          });
        }, "compress"),
        _compress: /* @__PURE__ */ u(function(l, p, f) {
          if (l == null) return "";
          var h, m, g = {}, w = {}, _ = "", b = "", x = "", P = 2, R = 3, N = 2, C = [], A = 0, E = 0, T;
          for (T = 0; T < l.length; T += 1)
            if (_ = l.charAt(T), Object.prototype.hasOwnProperty.call(g, _) || (g[_] = R++, w[_] = !0), b = x + _, Object.prototype.hasOwnProperty.call(g, b))
              x = b;
            else {
              if (Object.prototype.hasOwnProperty.call(w, x)) {
                if (x.charCodeAt(0) < 256) {
                  for (h = 0; h < N; h++)
                    A = A << 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++;
                  for (m = x.charCodeAt(0), h = 0; h < 8; h++)
                    A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
                } else {
                  for (m = 1, h = 0; h < N; h++)
                    A = A << 1 | m, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = 0;
                  for (m = x.charCodeAt(0), h = 0; h < 16; h++)
                    A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
                }
                P--, P == 0 && (P = Math.pow(2, N), N++), delete w[x];
              } else
                for (m = g[x], h = 0; h < N; h++)
                  A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
              P--, P == 0 && (P = Math.pow(2, N), N++), g[b] = R++, x = String(_);
            }
          if (x !== "") {
            if (Object.prototype.hasOwnProperty.call(w, x)) {
              if (x.charCodeAt(0) < 256) {
                for (h = 0; h < N; h++)
                  A = A << 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++;
                for (m = x.charCodeAt(0), h = 0; h < 8; h++)
                  A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
              } else {
                for (m = 1, h = 0; h < N; h++)
                  A = A << 1 | m, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = 0;
                for (m = x.charCodeAt(0), h = 0; h < 16; h++)
                  A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
              }
              P--, P == 0 && (P = Math.pow(2, N), N++), delete w[x];
            } else
              for (m = g[x], h = 0; h < N; h++)
                A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
            P--, P == 0 && (P = Math.pow(2, N), N++);
          }
          for (m = 2, h = 0; h < N; h++)
            A = A << 1 | m & 1, E == p - 1 ? (E = 0, C.push(f(A)), A = 0) : E++, m = m >> 1;
          for (; ; )
            if (A = A << 1, E == p - 1) {
              C.push(f(A));
              break;
            } else E++;
          return C.join("");
        }, "_compress"),
        decompress: /* @__PURE__ */ u(function(l) {
          return l == null ? "" : l == "" ? null : d._decompress(l.length, 32768, function(p) {
            return l.charCodeAt(p);
          });
        }, "decompress"),
        _decompress: /* @__PURE__ */ u(function(l, p, f) {
          var h = [], m = 4, g = 4, w = 3, _ = "", b = [], x, P, R, N, C, A, E, T = { val: f(0), position: p, index: 1 };
          for (x = 0; x < 3; x += 1)
            h[x] = x;
          for (R = 0, C = Math.pow(2, 2), A = 1; A != C; )
            N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
          switch (R) {
            case 0:
              for (R = 0, C = Math.pow(2, 8), A = 1; A != C; )
                N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
              E = n(R);
              break;
            case 1:
              for (R = 0, C = Math.pow(2, 16), A = 1; A != C; )
                N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
              E = n(R);
              break;
            case 2:
              return "";
          }
          for (h[3] = E, P = E, b.push(E); ; ) {
            if (T.index > l)
              return "";
            for (R = 0, C = Math.pow(2, w), A = 1; A != C; )
              N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
            switch (E = R) {
              case 0:
                for (R = 0, C = Math.pow(2, 8), A = 1; A != C; )
                  N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
                h[g++] = n(R), E = g - 1, m--;
                break;
              case 1:
                for (R = 0, C = Math.pow(2, 16), A = 1; A != C; )
                  N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), R |= (N > 0 ? 1 : 0) * A, A <<= 1;
                h[g++] = n(R), E = g - 1, m--;
                break;
              case 2:
                return b.join("");
            }
            if (m == 0 && (m = Math.pow(2, w), w++), h[E])
              _ = h[E];
            else if (E === g)
              _ = P + P.charAt(0);
            else
              return null;
            b.push(_), h[g++] = P + _.charAt(0), m--, P = _, m == 0 && (m = Math.pow(2, w), w++);
          }
        }, "_decompress")
      };
      return d;
    })();
    typeof define == "function" && define.amd ? define(function() {
      return r;
    }) : typeof t < "u" && t != null ? t.exports = r : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
      return r;
    });
  }
}), HG = Object.defineProperty, ee = /* @__PURE__ */ u((e, t) => HG(e, "name", { value: t, configurable: !0 }), "__name"), k$ = /* @__PURE__ */ u((e, t) => {
  for (var r in t)
    HG(e, r, { get: t[r], enumerable: !0 });
}, "__export"), ao = {};
k$(ao, {
  addChainableMethod: /* @__PURE__ */ u(() => zg, "addChainableMethod"),
  addLengthGuard: /* @__PURE__ */ u(() => Mc, "addLengthGuard"),
  addMethod: /* @__PURE__ */ u(() => Bg, "addMethod"),
  addProperty: /* @__PURE__ */ u(() => Ug, "addProperty"),
  checkError: /* @__PURE__ */ u(() => Vr, "checkError"),
  compareByInspect: /* @__PURE__ */ u(() => qd, "compareByInspect"),
  eql: /* @__PURE__ */ u(() => zG, "eql"),
  expectTypes: /* @__PURE__ */ u(() => M$, "expectTypes"),
  flag: /* @__PURE__ */ u(() => Ne, "flag"),
  getActual: /* @__PURE__ */ u(() => Sp, "getActual"),
  getMessage: /* @__PURE__ */ u(() => Mg, "getMessage"),
  getName: /* @__PURE__ */ u(() => Ap, "getName"),
  getOperator: /* @__PURE__ */ u(() => Kg, "getOperator"),
  getOwnEnumerableProperties: /* @__PURE__ */ u(() => Gg, "getOwnEnumerableProperties"),
  getOwnEnumerablePropertySymbols: /* @__PURE__ */ u(() => Wg, "getOwnEnumerablePropertySymbols"),
  getPathInfo: /* @__PURE__ */ u(() => Fg, "getPathInfo"),
  hasProperty: /* @__PURE__ */ u(() => Tp, "hasProperty"),
  inspect: /* @__PURE__ */ u(() => Je, "inspect"),
  isNaN: /* @__PURE__ */ u(() => um, "isNaN"),
  isNumeric: /* @__PURE__ */ u(() => er, "isNumeric"),
  isProxyEnabled: /* @__PURE__ */ u(() => Nc, "isProxyEnabled"),
  isRegExp: /* @__PURE__ */ u(() => Ld, "isRegExp"),
  objDisplay: /* @__PURE__ */ u(() => Da, "objDisplay"),
  overwriteChainableMethod: /* @__PURE__ */ u(() => Jg, "overwriteChainableMethod"),
  overwriteMethod: /* @__PURE__ */ u(() => Vg, "overwriteMethod"),
  overwriteProperty: /* @__PURE__ */ u(() => Hg, "overwriteProperty"),
  proxify: /* @__PURE__ */ u(() => qs, "proxify"),
  test: /* @__PURE__ */ u(() => Ig, "test"),
  transferFlags: /* @__PURE__ */ u(() => xn, "transferFlags"),
  type: /* @__PURE__ */ u(() => lt, "type")
});
var Vr = {};
k$(Vr, {
  compatibleConstructor: /* @__PURE__ */ u(() => R$, "compatibleConstructor"),
  compatibleInstance: /* @__PURE__ */ u(() => O$, "compatibleInstance"),
  compatibleMessage: /* @__PURE__ */ u(() => j$, "compatibleMessage"),
  getConstructorName: /* @__PURE__ */ u(() => I$, "getConstructorName"),
  getMessage: /* @__PURE__ */ u(() => N$, "getMessage")
});
function xp(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
u(xp, "isErrorInstance");
ee(xp, "isErrorInstance");
function P$(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
u(P$, "isRegExp");
ee(P$, "isRegExp");
function O$(e, t) {
  return xp(t) && e === t;
}
u(O$, "compatibleInstance");
ee(O$, "compatibleInstance");
function R$(e, t) {
  return xp(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : !1;
}
u(R$, "compatibleConstructor");
ee(R$, "compatibleConstructor");
function j$(e, t) {
  const r = typeof e == "string" ? e : e.message;
  return P$(t) ? t.test(r) : typeof t == "string" ? r.indexOf(t) !== -1 : !1;
}
u(j$, "compatibleMessage");
ee(j$, "compatibleMessage");
function I$(e) {
  let t = e;
  return xp(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
u(I$, "getConstructorName");
ee(I$, "getConstructorName");
function N$(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
u(N$, "getMessage");
ee(N$, "getMessage");
function Ne(e, t, r) {
  let n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    n[t] = r;
  else
    return n[t];
}
u(Ne, "flag");
ee(Ne, "flag");
function Ig(e, t) {
  let r = Ne(e, "negate"), n = t[0];
  return r ? !n : n;
}
u(Ig, "test");
ee(Ig, "test");
function lt(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
u(lt, "type");
ee(lt, "type");
var WTe = "captureStackTrace" in Error, lu, rt = (lu = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(e = "Unspecified AssertionError", t, r) {
    super(e), this.message = e, WTe && Error.captureStackTrace(this, r || lu);
    for (const n in t)
      n in this || (this[n] = t[n]);
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, u(lu, "_AssertionError"), ee(lu, "AssertionError"), lu);
function M$(e, t) {
  let r = Ne(e, "message"), n = Ne(e, "ssfi");
  r = r ? r + ": " : "", e = Ne(e, "object"), t = t.map(function(i) {
    return i.toLowerCase();
  }), t.sort();
  let o = t.map(function(i, s) {
    let d = ~["a", "e", "i", "o", "u"].indexOf(i.charAt(0)) ? "an" : "a";
    return (t.length > 1 && s === t.length - 1 ? "or " : "") + d + " " + i;
  }).join(", "), a = lt(e).toLowerCase();
  if (!t.some(function(i) {
    return a === i;
  }))
    throw new rt(
      r + "object tested must be " + o + ", but " + a + " given",
      void 0,
      n
    );
}
u(M$, "expectTypes");
ee(M$, "expectTypes");
function Sp(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
u(Sp, "getActual");
ee(Sp, "getActual");
var xj = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, GTe = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, ac = "â€¦";
function D$(e, t) {
  const r = xj[GTe[t]] || xj[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
u(D$, "colorise");
ee(D$, "colorise");
function q$({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: n = !0,
  showProxy: o = !1,
  maxArrayLength: a = 1 / 0,
  breakLength: i = 1 / 0,
  seen: s = [],
  // eslint-disable-next-line no-shadow
  truncate: d = 1 / 0,
  stylize: l = String
} = {}, p) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!o,
    maxArrayLength: Number(a),
    breakLength: Number(i),
    truncate: Number(d),
    seen: s,
    inspect: p,
    stylize: l
  };
  return f.colors && (f.stylize = D$), f;
}
u(q$, "normaliseOptions");
ee(q$, "normaliseOptions");
function L$(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
u(L$, "isHighSurrogate");
ee(L$, "isHighSurrogate");
function _o(e, t, r = ac) {
  e = String(e);
  const n = r.length, o = e.length;
  if (n > t && o > n)
    return r;
  if (o > t && o > n) {
    let a = t - n;
    return a > 0 && L$(e[a - 1]) && (a = a - 1), `${e.slice(0, a)}${r}`;
  }
  return e;
}
u(_o, "truncate");
ee(_o, "truncate");
function Qr(e, t, r, n = ", ") {
  r = r || t.inspect;
  const o = e.length;
  if (o === 0)
    return "";
  const a = t.truncate;
  let i = "", s = "", d = "";
  for (let l = 0; l < o; l += 1) {
    const p = l + 1 === e.length, f = l + 2 === e.length;
    d = `${ac}(${e.length - l})`;
    const h = e[l];
    t.truncate = a - i.length - (p ? 0 : n.length);
    const m = s || r(h, t) + (p ? "" : n), g = i.length + m.length, w = g + d.length;
    if (p && g > a && i.length + d.length <= a || !p && !f && w > a || (s = p ? "" : r(e[l + 1], t) + (f ? "" : n), !p && f && w > a && g + s.length > a))
      break;
    if (i += m, !p && !f && g + s.length >= a) {
      d = `${ac}(${e.length - l - 1})`;
      break;
    }
    d = "";
  }
  return `${i}${d}`;
}
u(Qr, "inspectList");
ee(Qr, "inspectList");
function F$(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
u(F$, "quoteComplexKey");
ee(F$, "quoteComplexKey");
function gs([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = F$(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
u(gs, "inspectProperty");
ee(gs, "inspectProperty");
function U$(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const n = Qr(e, t);
  t.truncate -= n.length;
  let o = "";
  return r.length && (o = Qr(r.map((a) => [a, e[a]]), t, gs)), `[ ${n}${o ? `, ${o}` : ""} ]`;
}
u(U$, "inspectArray");
ee(U$, "inspectArray");
var KTe = ee((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function Rn(e, t) {
  const r = KTe(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let o = "";
  for (let i = 0; i < e.length; i++) {
    const s = `${t.stylize(_o(e[i], t.truncate), "number")}${i === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= s.length, e[i] !== e.length && t.truncate <= 3) {
      o += `${ac}(${e.length - e[i] + 1})`;
      break;
    }
    o += s;
  }
  let a = "";
  return n.length && (a = Qr(n.map((i) => [i, e[i]]), t, gs)), `${r}[ ${o}${a ? `, ${a}` : ""} ]`;
}
u(Rn, "inspectTypedArray");
ee(Rn, "inspectTypedArray");
function B$(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const n = r.split("T"), o = n[0];
  return t.stylize(`${o}T${_o(n[1], t.truncate - o.length - 1)}`, "date");
}
u(B$, "inspectDate");
ee(B$, "inspectDate");
function Yh(e, t) {
  const r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${_o(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
u(Yh, "inspectFunction");
ee(Yh, "inspectFunction");
function H$([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
u(H$, "inspectMapEntry");
ee(H$, "inspectMapEntry");
function V$(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
u(V$, "mapToEntries");
ee(V$, "mapToEntries");
function z$(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Qr(V$(e), t, H$)} }`);
}
u(z$, "inspectMap");
ee(z$, "inspectMap");
var YTe = Number.isNaN || ((e) => e !== e);
function Xh(e, t) {
  return YTe(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(_o(String(e), t.truncate), "number");
}
u(Xh, "inspectNumber");
ee(Xh, "inspectNumber");
function Qh(e, t) {
  let r = _o(e.toString(), t.truncate - 1);
  return r !== ac && (r += "n"), t.stylize(r, "bigint");
}
u(Qh, "inspectBigInt");
ee(Qh, "inspectBigInt");
function J$(e, t) {
  const r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), o = e.source;
  return t.stylize(`/${_o(o, n)}/${r}`, "regexp");
}
u(J$, "inspectRegExp");
ee(J$, "inspectRegExp");
function W$(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
u(W$, "arrayFromSet");
ee(W$, "arrayFromSet");
function G$(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Qr(W$(e), t)} }`);
}
u(G$, "inspectSet");
ee(G$, "inspectSet");
var Sj = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), XTe = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, QTe = 16;
function K$(e) {
  return XTe[e] || `\\u${`0000${e.charCodeAt(0).toString(QTe)}`.slice(-4)}`;
}
u(K$, "escape");
ee(K$, "escape");
function Zh(e, t) {
  return Sj.test(e) && (e = e.replace(Sj, K$)), t.stylize(`'${_o(e, t.truncate - 2)}'`, "string");
}
u(Zh, "inspectString");
ee(Zh, "inspectString");
function em(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
u(em, "inspectSymbol");
ee(em, "inspectSymbol");
var ZTe = ee(() => "Promise{â€¦}", "getPromiseValue"), eAe = ZTe;
function Tl(e, t) {
  const r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const o = Qr(r.map((s) => [s, e[s]]), t, gs), a = Qr(n.map((s) => [s, e[s]]), t, gs);
  t.seen.pop();
  let i = "";
  return o && a && (i = ", "), `{ ${o}${i}${a} }`;
}
u(Tl, "inspectObject");
ee(Tl, "inspectObject");
var jv = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function Y$(e, t) {
  let r = "";
  return jv && jv in e && (r = e[jv]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${Tl(e, t)}`;
}
u(Y$, "inspectClass");
ee(Y$, "inspectClass");
function X$(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Qr(e, t)} ]`);
}
u(X$, "inspectArguments");
ee(X$, "inspectArguments");
var tAe = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function Q$(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((i) => tAe.indexOf(i) === -1), n = e.name;
  t.truncate -= n.length;
  let o = "";
  if (typeof e.message == "string" ? o = _o(e.message, t.truncate) : r.unshift("message"), o = o ? `: ${o}` : "", t.truncate -= o.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = Qr(r.map((i) => [i, e[i]]), t, gs);
  return `${n}${o}${a ? ` { ${a} }` : ""}`;
}
u(Q$, "inspectObject2");
ee(Q$, "inspectObject");
function Z$([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
u(Z$, "inspectAttribute");
ee(Z$, "inspectAttribute");
function Nd(e, t) {
  return Qr(e, t, eC, `
`);
}
u(Nd, "inspectNodeCollection");
ee(Nd, "inspectNodeCollection");
function eC(e, t) {
  switch (e.nodeType) {
    case 1:
      return Ng(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
u(eC, "inspectNode");
ee(eC, "inspectNode");
function Ng(e, t) {
  const r = e.getAttributeNames(), n = e.tagName.toLowerCase(), o = t.stylize(`<${n}`, "special"), a = t.stylize(">", "special"), i = t.stylize(`</${n}>`, "special");
  t.truncate -= n.length * 2 + 5;
  let s = "";
  r.length > 0 && (s += " ", s += Qr(r.map((p) => [p, e.getAttribute(p)]), t, Z$, " ")), t.truncate -= s.length;
  const d = t.truncate;
  let l = Nd(e.children, t);
  return l && l.length > d && (l = `${ac}(${e.children.length})`), `${o}${s}${a}${l}${i}`;
}
u(Ng, "inspectHTML");
ee(Ng, "inspectHTML");
var rAe = typeof Symbol == "function" && typeof Symbol.for == "function", Iv = rAe ? Symbol.for("chai/inspect") : "@@chai/inspect", Nv = Symbol.for("nodejs.util.inspect.custom"), Tj = /* @__PURE__ */ new WeakMap(), Aj = {}, $j = {
  undefined: ee((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: ee((e, t) => t.stylize("null", "null"), "null"),
  boolean: ee((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: ee((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: Xh,
  Number: Xh,
  bigint: Qh,
  BigInt: Qh,
  string: Zh,
  String: Zh,
  function: Yh,
  Function: Yh,
  symbol: em,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: em,
  Array: U$,
  Date: B$,
  Map: z$,
  Set: G$,
  RegExp: J$,
  Promise: eAe,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: ee((e, t) => t.stylize("WeakSet{â€¦}", "special"), "WeakSet"),
  WeakMap: ee((e, t) => t.stylize("WeakMap{â€¦}", "special"), "WeakMap"),
  Arguments: X$,
  Int8Array: Rn,
  Uint8Array: Rn,
  Uint8ClampedArray: Rn,
  Int16Array: Rn,
  Uint16Array: Rn,
  Int32Array: Rn,
  Uint32Array: Rn,
  Float32Array: Rn,
  Float64Array: Rn,
  Generator: ee(() => "", "Generator"),
  DataView: ee(() => "", "DataView"),
  ArrayBuffer: ee(() => "", "ArrayBuffer"),
  Error: Q$,
  HTMLCollection: Nd,
  NodeList: Nd
}, nAe = ee((e, t, r) => Iv in e && typeof e[Iv] == "function" ? e[Iv](t) : Nv in e && typeof e[Nv] == "function" ? e[Nv](t.depth, t) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && Tj.has(e.constructor) ? Tj.get(e.constructor)(e, t) : Aj[r] ? Aj[r](e, t) : "", "inspectCustom"), oAe = Object.prototype.toString;
function Md(e, t = {}) {
  const r = q$(t, Md), { customInspect: n } = r;
  let o = e === null ? "null" : typeof e;
  if (o === "object" && (o = oAe.call(e).slice(8, -1)), o in $j)
    return $j[o](e, r);
  if (n && e) {
    const i = nAe(e, r, o);
    if (i)
      return typeof i == "string" ? i : Md(i, r);
  }
  const a = e ? Object.getPrototypeOf(e) : !1;
  return a === Object.prototype || a === null ? Tl(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? Ng(e, r) : "constructor" in e ? e.constructor !== Object ? Y$(e, r) : Tl(e, r) : e === Object(e) ? Tl(e, r) : r.stylize(String(e), o);
}
u(Md, "inspect");
ee(Md, "inspect");
var Tr = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function Je(e, t, r, n) {
  let o = {
    colors: n,
    depth: typeof r > "u" ? 2 : r,
    showHidden: t,
    truncate: Tr.truncateThreshold ? Tr.truncateThreshold : 1 / 0
  };
  return Md(e, o);
}
u(Je, "inspect2");
ee(Je, "inspect");
function Da(e) {
  let t = Je(e), r = Object.prototype.toString.call(e);
  if (Tr.truncateThreshold && t.length >= Tr.truncateThreshold) {
    if (r === "[object Function]")
      return !e.name || e.name === "" ? "[Function]" : "[Function: " + e.name + "]";
    if (r === "[object Array]")
      return "[ Array(" + e.length + ") ]";
    if (r === "[object Object]") {
      let n = Object.keys(e);
      return "{ Object (" + (n.length > 2 ? n.splice(0, 2).join(", ") + ", ..." : n.join(", ")) + ") }";
    } else
      return t;
  } else
    return t;
}
u(Da, "objDisplay");
ee(Da, "objDisplay");
function Mg(e, t) {
  let r = Ne(e, "negate"), n = Ne(e, "object"), o = t[3], a = Sp(e, t), i = r ? t[2] : t[1], s = Ne(e, "message");
  return typeof i == "function" && (i = i()), i = i || "", i = i.replace(/#\{this\}/g, function() {
    return Da(n);
  }).replace(/#\{act\}/g, function() {
    return Da(a);
  }).replace(/#\{exp\}/g, function() {
    return Da(o);
  }), s ? s + ": " + i : i;
}
u(Mg, "getMessage2");
ee(Mg, "getMessage");
function xn(e, t, r) {
  let n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), r = arguments.length === 3 ? r : !0;
  for (let o in n)
    (r || o !== "object" && o !== "ssfi" && o !== "lockSsfi" && o != "message") && (t.__flags[o] = n[o]);
}
u(xn, "transferFlags");
ee(xn, "transferFlags");
function tm(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
u(tm, "type2");
ee(tm, "type");
function Dg() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
u(Dg, "FakeMap");
ee(Dg, "FakeMap");
Dg.prototype = {
  get: ee(/* @__PURE__ */ u(function(e) {
    return e[this._key];
  }, "get"), "get"),
  set: ee(/* @__PURE__ */ u(function(e, t) {
    Object.isExtensible(e) && Object.defineProperty(e, this._key, {
      value: t,
      configurable: !0
    });
  }, "set"), "set")
};
var VG = typeof WeakMap == "function" ? WeakMap : Dg;
function rm(e, t, r) {
  if (!r || Ya(e) || Ya(t))
    return null;
  var n = r.get(e);
  if (n) {
    var o = n.get(t);
    if (typeof o == "boolean")
      return o;
  }
  return null;
}
u(rm, "memoizeCompare");
ee(rm, "memoizeCompare");
function fl(e, t, r, n) {
  if (!(!r || Ya(e) || Ya(t))) {
    var o = r.get(e);
    o ? o.set(t, n) : (o = new VG(), o.set(t, n), r.set(e, o));
  }
}
u(fl, "memoizeSet");
ee(fl, "memoizeSet");
var zG = Ic;
function Ic(e, t, r) {
  if (r && r.comparator)
    return nm(e, t, r);
  var n = qg(e, t);
  return n !== null ? n : nm(e, t, r);
}
u(Ic, "deepEqual");
ee(Ic, "deepEqual");
function qg(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? !0 : Ya(e) || Ya(t) ? !1 : null;
}
u(qg, "simpleEqual");
ee(qg, "simpleEqual");
function nm(e, t, r) {
  r = r || {}, r.memoize = r.memoize === !1 ? !1 : r.memoize || new VG();
  var n = r && r.comparator, o = rm(e, t, r.memoize);
  if (o !== null)
    return o;
  var a = rm(t, e, r.memoize);
  if (a !== null)
    return a;
  if (n) {
    var i = n(e, t);
    if (i === !1 || i === !0)
      return fl(e, t, r.memoize, i), i;
    var s = qg(e, t);
    if (s !== null)
      return s;
  }
  var d = tm(e);
  if (d !== tm(t))
    return fl(e, t, r.memoize, !1), !1;
  fl(e, t, r.memoize, !0);
  var l = tC(e, t, d, r);
  return fl(e, t, r.memoize, l), l;
}
u(nm, "extensiveDeepEqual");
ee(nm, "extensiveDeepEqual");
function tC(e, t, r, n) {
  switch (r) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Ic(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return Lg(e, t, ["name", "message", "code"], n);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return ra(e, t, n);
    case "RegExp":
      return rC(e, t);
    case "Generator":
      return nC(e, t, n);
    case "DataView":
      return ra(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case "ArrayBuffer":
      return ra(new Uint8Array(e), new Uint8Array(t), n);
    case "Set":
      return om(e, t, n);
    case "Map":
      return om(e, t, n);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return aC(e, t, n);
  }
}
u(tC, "extensiveDeepEqualByType");
ee(tC, "extensiveDeepEqualByType");
function rC(e, t) {
  return e.toString() === t.toString();
}
u(rC, "regexpEqual");
ee(rC, "regexpEqual");
function om(e, t, r) {
  try {
    if (e.size !== t.size)
      return !1;
    if (e.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var n = [], o = [];
  return e.forEach(ee(/* @__PURE__ */ u(function(a, i) {
    n.push([a, i]);
  }, "gatherEntries"), "gatherEntries")), t.forEach(ee(/* @__PURE__ */ u(function(a, i) {
    o.push([a, i]);
  }, "gatherEntries"), "gatherEntries")), ra(n.sort(), o.sort(), r);
}
u(om, "entriesEqual");
ee(om, "entriesEqual");
function ra(e, t, r) {
  var n = e.length;
  if (n !== t.length)
    return !1;
  if (n === 0)
    return !0;
  for (var o = -1; ++o < n; )
    if (Ic(e[o], t[o], r) === !1)
      return !1;
  return !0;
}
u(ra, "iterableEqual");
ee(ra, "iterableEqual");
function nC(e, t, r) {
  return ra(Dd(e), Dd(t), r);
}
u(nC, "generatorEqual");
ee(nC, "generatorEqual");
function oC(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
u(oC, "hasIteratorFunction");
ee(oC, "hasIteratorFunction");
function am(e) {
  if (oC(e))
    try {
      return Dd(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
u(am, "getIteratorEntries");
ee(am, "getIteratorEntries");
function Dd(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; )
    t = e.next(), r.push(t.value);
  return r;
}
u(Dd, "getGeneratorEntries");
ee(Dd, "getGeneratorEntries");
function im(e) {
  var t = [];
  for (var r in e)
    t.push(r);
  return t;
}
u(im, "getEnumerableKeys");
ee(im, "getEnumerableKeys");
function sm(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var o = r[n];
    Object.getOwnPropertyDescriptor(e, o).enumerable && t.push(o);
  }
  return t;
}
u(sm, "getEnumerableSymbols");
ee(sm, "getEnumerableSymbols");
function Lg(e, t, r, n) {
  var o = r.length;
  if (o === 0)
    return !0;
  for (var a = 0; a < o; a += 1)
    if (Ic(e[r[a]], t[r[a]], n) === !1)
      return !1;
  return !0;
}
u(Lg, "keysEqual");
ee(Lg, "keysEqual");
function aC(e, t, r) {
  var n = im(e), o = im(t), a = sm(e), i = sm(t);
  if (n = n.concat(a), o = o.concat(i), n.length && n.length === o.length)
    return ra(lm(n).sort(), lm(o).sort()) === !1 ? !1 : Lg(e, t, n, r);
  var s = am(e), d = am(t);
  return s.length && s.length === d.length ? (s.sort(), d.sort(), ra(s, d, r)) : n.length === 0 && s.length === 0 && o.length === 0 && d.length === 0;
}
u(aC, "objectEqual");
ee(aC, "objectEqual");
function Ya(e) {
  return e === null || typeof e != "object";
}
u(Ya, "isPrimitive");
ee(Ya, "isPrimitive");
function lm(e) {
  return e.map(ee(/* @__PURE__ */ u(function(t) {
    return typeof t == "symbol" ? t.toString() : t;
  }, "mapSymbol"), "mapSymbol"));
}
u(lm, "mapSymbols");
ee(lm, "mapSymbols");
function Tp(e, t) {
  return typeof e > "u" || e === null ? !1 : t in Object(e);
}
u(Tp, "hasProperty");
ee(Tp, "hasProperty");
function iC(e) {
  return e.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((t) => {
    if (t === "constructor" || t === "__proto__" || t === "prototype")
      return {};
    const r = /^\[(\d+)\]$/.exec(t);
    let n = null;
    return r ? n = { i: parseFloat(r[1]) } : n = { p: t.replace(/\\([.[\]])/g, "$1") }, n;
  });
}
u(iC, "parsePath");
ee(iC, "parsePath");
function cm(e, t, r) {
  let n = e, o = null;
  r = typeof r > "u" ? t.length : r;
  for (let a = 0; a < r; a++) {
    const i = t[a];
    n && (typeof i.p > "u" ? n = n[i.i] : n = n[i.p], a === r - 1 && (o = n));
  }
  return o;
}
u(cm, "internalGetPathValue");
ee(cm, "internalGetPathValue");
function Fg(e, t) {
  const r = iC(t), n = r[r.length - 1], o = {
    parent: r.length > 1 ? cm(e, r, r.length - 1) : e,
    name: n.p || n.i,
    value: cm(e, r)
  };
  return o.exists = Tp(o.parent, o.name), o;
}
u(Fg, "getPathInfo");
ee(Fg, "getPathInfo");
var cu, z = (cu = class {
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(e, t, r, n) {
    return Ne(this, "ssfi", r || cu), Ne(this, "lockSsfi", n), Ne(this, "object", e), Ne(this, "message", t), Ne(this, "eql", Tr.deepEqual || zG), qs(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), Tr.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(e) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), Tr.includeStack = e;
  }
  /** @returns {boolean} */
  static get showDiff() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), Tr.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(e) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), Tr.showDiff = e;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(e, t) {
    Ug(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(e, t) {
    Bg(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(e, t, r) {
    zg(this.prototype, e, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(e, t) {
    Hg(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(e, t) {
    Vg(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(e, t, r) {
    Jg(this.prototype, e, t, r);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(e, t, r, n, o, a) {
    const i = Ig(this, arguments);
    if (a !== !1 && (a = !0), n === void 0 && o === void 0 && (a = !1), Tr.showDiff !== !0 && (a = !1), !i) {
      t = Mg(this, arguments);
      const s = {
        actual: Sp(this, arguments),
        expected: n,
        showDiff: a
      }, d = Kg(this, arguments);
      throw d && (s.operator = d), new rt(
        t,
        s,
        // @ts-expect-error Not sure what to do about these types yet
        Tr.includeStack ? this.assert : Ne(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return Ne(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(e) {
    Ne(this, "object", e);
  }
}, u(cu, "_Assertion"), ee(cu, "Assertion"), cu);
function Nc() {
  return Tr.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
u(Nc, "isProxyEnabled");
ee(Nc, "isProxyEnabled");
function Ug(e, t, r) {
  r = r === void 0 ? function() {
  } : r, Object.defineProperty(e, t, {
    get: ee(/* @__PURE__ */ u(function n() {
      !Nc() && !Ne(this, "lockSsfi") && Ne(this, "ssfi", n);
      let o = r.call(this);
      if (o !== void 0) return o;
      let a = new z();
      return xn(this, a), a;
    }, "propertyGetter"), "propertyGetter"),
    configurable: !0
  });
}
u(Ug, "addProperty");
ee(Ug, "addProperty");
var aAe = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Mc(e, t, r) {
  return aAe.configurable && Object.defineProperty(e, "length", {
    get: ee(function() {
      throw Error(
        r ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".'
      );
    }, "get")
  }), e;
}
u(Mc, "addLengthGuard");
ee(Mc, "addLengthGuard");
function sC(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(o) {
    t.indexOf(o) === -1 && t.push(o);
  }
  u(r, "addProperty2"), ee(r, "addProperty");
  let n = Object.getPrototypeOf(e);
  for (; n !== null; )
    Object.getOwnPropertyNames(n).forEach(r), n = Object.getPrototypeOf(n);
  return t;
}
u(sC, "getProperties");
ee(sC, "getProperties");
var Cj = ["__flags", "__methods", "_obj", "assert"];
function qs(e, t) {
  return Nc() ? new Proxy(e, {
    get: ee(/* @__PURE__ */ u(function r(n, o) {
      if (typeof o == "string" && Tr.proxyExcludedKeys.indexOf(o) === -1 && !Reflect.has(n, o)) {
        if (t)
          throw Error(
            "Invalid Chai property: " + t + "." + o + '. See docs for proper usage of "' + t + '".'
          );
        let a = null, i = 4;
        throw sC(n).forEach(function(s) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(s) && Cj.indexOf(s) === -1
          ) {
            let d = lC(o, s, i);
            d < i && (a = s, i = d);
          }
        }), Error(
          a !== null ? "Invalid Chai property: " + o + '. Did you mean "' + a + '"?' : "Invalid Chai property: " + o
        );
      }
      return Cj.indexOf(o) === -1 && !Ne(n, "lockSsfi") && Ne(n, "ssfi", r), Reflect.get(n, o);
    }, "proxyGetter"), "proxyGetter")
  }) : e;
}
u(qs, "proxify");
ee(qs, "proxify");
function lC(e, t, r) {
  if (Math.abs(e.length - t.length) >= r)
    return r;
  let n = [];
  for (let o = 0; o <= e.length; o++)
    n[o] = Array(t.length + 1).fill(0), n[o][0] = o;
  for (let o = 0; o < t.length; o++)
    n[0][o] = o;
  for (let o = 1; o <= e.length; o++) {
    let a = e.charCodeAt(o - 1);
    for (let i = 1; i <= t.length; i++) {
      if (Math.abs(o - i) >= r) {
        n[o][i] = r;
        continue;
      }
      n[o][i] = Math.min(
        n[o - 1][i] + 1,
        n[o][i - 1] + 1,
        n[o - 1][i - 1] + (a === t.charCodeAt(i - 1) ? 0 : 1)
      );
    }
  }
  return n[e.length][t.length];
}
u(lC, "stringDistanceCapped");
ee(lC, "stringDistanceCapped");
function Bg(e, t, r) {
  let n = ee(function() {
    Ne(this, "lockSsfi") || Ne(this, "ssfi", n);
    let o = r.apply(this, arguments);
    if (o !== void 0) return o;
    let a = new z();
    return xn(this, a), a;
  }, "methodWrapper");
  Mc(n, t, !1), e[t] = qs(n, t);
}
u(Bg, "addMethod");
ee(Bg, "addMethod");
function Hg(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e, t), o = ee(function() {
  }, "_super");
  n && typeof n.get == "function" && (o = n.get), Object.defineProperty(e, t, {
    get: ee(/* @__PURE__ */ u(function a() {
      !Nc() && !Ne(this, "lockSsfi") && Ne(this, "ssfi", a);
      let i = Ne(this, "lockSsfi");
      Ne(this, "lockSsfi", !0);
      let s = r(o).call(this);
      if (Ne(this, "lockSsfi", i), s !== void 0)
        return s;
      let d = new z();
      return xn(this, d), d;
    }, "overwritingPropertyGetter"), "overwritingPropertyGetter"),
    configurable: !0
  });
}
u(Hg, "overwriteProperty");
ee(Hg, "overwriteProperty");
function Vg(e, t, r) {
  let n = e[t], o = ee(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  n && typeof n == "function" && (o = n);
  let a = ee(function() {
    Ne(this, "lockSsfi") || Ne(this, "ssfi", a);
    let i = Ne(this, "lockSsfi");
    Ne(this, "lockSsfi", !0);
    let s = r(o).apply(this, arguments);
    if (Ne(this, "lockSsfi", i), s !== void 0)
      return s;
    let d = new z();
    return xn(this, d), d;
  }, "overwritingMethodWrapper");
  Mc(a, t, !1), e[t] = qs(a, t);
}
u(Vg, "overwriteMethod");
ee(Vg, "overwriteMethod");
var iAe = typeof Object.setPrototypeOf == "function", kj = ee(function() {
}, "testFn"), sAe = Object.getOwnPropertyNames(kj).filter(function(e) {
  let t = Object.getOwnPropertyDescriptor(kj, e);
  return typeof t != "object" ? !0 : !t.configurable;
}), lAe = Function.prototype.call, cAe = Function.prototype.apply;
function zg(e, t, r, n) {
  typeof n != "function" && (n = ee(function() {
  }, "chainingBehavior"));
  let o = {
    method: r,
    chainingBehavior: n
  };
  e.__methods || (e.__methods = {}), e.__methods[t] = o, Object.defineProperty(e, t, {
    get: ee(/* @__PURE__ */ u(function() {
      o.chainingBehavior.call(this);
      let a = ee(function() {
        Ne(this, "lockSsfi") || Ne(this, "ssfi", a);
        let i = o.method.apply(this, arguments);
        if (i !== void 0)
          return i;
        let s = new z();
        return xn(this, s), s;
      }, "chainableMethodWrapper");
      if (Mc(a, t, !0), iAe) {
        let i = Object.create(this);
        i.call = lAe, i.apply = cAe, Object.setPrototypeOf(a, i);
      } else
        Object.getOwnPropertyNames(e).forEach(function(i) {
          if (sAe.indexOf(i) !== -1)
            return;
          let s = Object.getOwnPropertyDescriptor(e, i);
          Object.defineProperty(a, i, s);
        });
      return xn(this, a), qs(a);
    }, "chainableMethodGetter"), "chainableMethodGetter"),
    configurable: !0
  });
}
u(zg, "addChainableMethod");
ee(zg, "addChainableMethod");
function Jg(e, t, r, n) {
  let o = e.__methods[t], a = o.chainingBehavior;
  o.chainingBehavior = ee(/* @__PURE__ */ u(function() {
    let s = n(a).call(this);
    if (s !== void 0)
      return s;
    let d = new z();
    return xn(this, d), d;
  }, "overwritingChainableMethodGetter"), "overwritingChainableMethodGetter");
  let i = o.method;
  o.method = ee(/* @__PURE__ */ u(function() {
    let s = r(i).apply(this, arguments);
    if (s !== void 0)
      return s;
    let d = new z();
    return xn(this, d), d;
  }, "overwritingChainableMethodWrapper"), "overwritingChainableMethodWrapper");
}
u(Jg, "overwriteChainableMethod");
ee(Jg, "overwriteChainableMethod");
function qd(e, t) {
  return Je(e) < Je(t) ? -1 : 1;
}
u(qd, "compareByInspect");
ee(qd, "compareByInspect");
function Wg(e) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.getOwnPropertyDescriptor(e, t).enumerable;
  });
}
u(Wg, "getOwnEnumerablePropertySymbols");
ee(Wg, "getOwnEnumerablePropertySymbols");
function Gg(e) {
  return Object.keys(e).concat(Wg(e));
}
u(Gg, "getOwnEnumerableProperties");
ee(Gg, "getOwnEnumerableProperties");
var um = Number.isNaN;
function cC(e) {
  let t = lt(e);
  return ["Array", "Object", "Function"].indexOf(t) !== -1;
}
u(cC, "isObjectType");
ee(cC, "isObjectType");
function Kg(e, t) {
  let r = Ne(e, "operator"), n = Ne(e, "negate"), o = t[3], a = n ? t[2] : t[1];
  if (r)
    return r;
  if (typeof a == "function" && (a = a()), a = a || "", !a || /\shave\s/.test(a))
    return;
  let i = cC(o);
  return /\snot\s/.test(a) ? i ? "notDeepStrictEqual" : "notStrictEqual" : i ? "deepStrictEqual" : "strictEqual";
}
u(Kg, "getOperator");
ee(Kg, "getOperator");
function Ap(e) {
  return e.name;
}
u(Ap, "getName");
ee(Ap, "getName");
function Ld(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
u(Ld, "isRegExp2");
ee(Ld, "isRegExp");
function er(e) {
  return ["Number", "BigInt"].includes(lt(e));
}
u(er, "isNumeric");
ee(er, "isNumeric");
var { flag: X } = ao;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(e) {
  z.addProperty(e);
});
z.addProperty("not", function() {
  X(this, "negate", !0);
});
z.addProperty("deep", function() {
  X(this, "deep", !0);
});
z.addProperty("nested", function() {
  X(this, "nested", !0);
});
z.addProperty("own", function() {
  X(this, "own", !0);
});
z.addProperty("ordered", function() {
  X(this, "ordered", !0);
});
z.addProperty("any", function() {
  X(this, "any", !0), X(this, "all", !1);
});
z.addProperty("all", function() {
  X(this, "all", !0), X(this, "any", !1);
});
var Pj = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function Yg(e, t) {
  t && X(this, "message", t), e = e.toLowerCase();
  let r = X(this, "object"), n = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a ";
  const o = lt(r).toLowerCase();
  Pj.function.includes(e) ? this.assert(
    Pj[e].includes(o),
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  ) : this.assert(
    e === o,
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  );
}
u(Yg, "an");
ee(Yg, "an");
z.addChainableMethod("an", Yg);
z.addChainableMethod("a", Yg);
function uC(e, t) {
  return um(e) && um(t) || e === t;
}
u(uC, "SameValueZero");
ee(uC, "SameValueZero");
function Dc() {
  X(this, "contains", !0);
}
u(Dc, "includeChainingBehavior");
ee(Dc, "includeChainingBehavior");
function qc(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = lt(r).toLowerCase(), o = X(this, "message"), a = X(this, "negate"), i = X(this, "ssfi"), s = X(this, "deep"), d = s ? "deep " : "", l = s ? X(this, "eql") : uC;
  o = o ? o + ": " : "";
  let p = !1;
  switch (n) {
    case "string":
      p = r.indexOf(e) !== -1;
      break;
    case "weakset":
      if (s)
        throw new rt(
          o + "unable to use .deep.include with WeakSet",
          void 0,
          i
        );
      p = r.has(e);
      break;
    case "map":
      r.forEach(function(f) {
        p = p || l(f, e);
      });
      break;
    case "set":
      s ? r.forEach(function(f) {
        p = p || l(f, e);
      }) : p = r.has(e);
      break;
    case "array":
      s ? p = r.some(function(f) {
        return l(f, e);
      }) : p = r.indexOf(e) !== -1;
      break;
    default: {
      if (e !== Object(e))
        throw new rt(
          o + "the given combination of arguments (" + n + " and " + lt(e).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + lt(e).toLowerCase(),
          void 0,
          i
        );
      let f = Object.keys(e), h = null, m = 0;
      if (f.forEach(function(g) {
        let w = new z(r);
        if (xn(this, w, !0), X(w, "lockSsfi", !0), !a || f.length === 1) {
          w.property(g, e[g]);
          return;
        }
        try {
          w.property(g, e[g]);
        } catch (_) {
          if (!Vr.compatibleConstructor(_, rt))
            throw _;
          h === null && (h = _), m++;
        }
      }, this), a && f.length > 1 && m === f.length)
        throw h;
      return;
    }
  }
  this.assert(
    p,
    "expected #{this} to " + d + "include " + Je(e),
    "expected #{this} to not " + d + "include " + Je(e)
  );
}
u(qc, "include");
ee(qc, "include");
z.addChainableMethod("include", qc, Dc);
z.addChainableMethod("contain", qc, Dc);
z.addChainableMethod("contains", qc, Dc);
z.addChainableMethod("includes", qc, Dc);
z.addProperty("ok", function() {
  this.assert(
    X(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
z.addProperty("true", function() {
  this.assert(
    X(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !X(this, "negate")
  );
});
z.addProperty("numeric", function() {
  const e = X(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(lt(e)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !X(this, "negate")
  );
});
z.addProperty("callable", function() {
  const e = X(this, "object"), t = X(this, "ssfi"), r = X(this, "message"), n = r ? `${r}: ` : "", o = X(this, "negate"), a = o ? `${n}expected ${Je(e)} not to be a callable function` : `${n}expected ${Je(e)} to be a callable function`, i = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(lt(e));
  if (i && o || !i && !o)
    throw new rt(a, void 0, t);
});
z.addProperty("false", function() {
  this.assert(
    X(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!X(this, "negate")
  );
});
z.addProperty("null", function() {
  this.assert(
    X(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
z.addProperty("undefined", function() {
  this.assert(
    X(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
z.addProperty("NaN", function() {
  this.assert(
    um(X(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function Xg() {
  let e = X(this, "object");
  this.assert(
    e != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
u(Xg, "assertExist");
ee(Xg, "assertExist");
z.addProperty("exist", Xg);
z.addProperty("exists", Xg);
z.addProperty("empty", function() {
  let e = X(this, "object"), t = X(this, "ssfi"), r = X(this, "message"), n;
  switch (r = r ? r + ": " : "", lt(e).toLowerCase()) {
    case "array":
    case "string":
      n = e.length;
      break;
    case "map":
    case "set":
      n = e.size;
      break;
    case "weakmap":
    case "weakset":
      throw new rt(
        r + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function": {
      const o = r + ".empty was passed a function " + Ap(e);
      throw new rt(o.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new rt(
          r + ".empty was passed non-string primitive " + Je(e),
          void 0,
          t
        );
      n = Object.keys(e).length;
  }
  this.assert(
    n === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function Qg() {
  let e = X(this, "object"), t = lt(e);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
u(Qg, "checkArguments");
ee(Qg, "checkArguments");
z.addProperty("arguments", Qg);
z.addProperty("Arguments", Qg);
function $p(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object");
  if (X(this, "deep")) {
    let n = X(this, "lockSsfi");
    X(this, "lockSsfi", !0), this.eql(e), X(this, "lockSsfi", n);
  } else
    this.assert(
      e === r,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      e,
      this._obj,
      !0
    );
}
u($p, "assertEqual");
ee($p, "assertEqual");
z.addMethod("equal", $p);
z.addMethod("equals", $p);
z.addMethod("eq", $p);
function Zg(e, t) {
  t && X(this, "message", t);
  let r = X(this, "eql");
  this.assert(
    r(e, X(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    e,
    this._obj,
    !0
  );
}
u(Zg, "assertEql");
ee(Zg, "assertEql");
z.addMethod("eql", Zg);
z.addMethod("eqls", Zg);
function Cp(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "doLength"), o = X(this, "message"), a = o ? o + ": " : "", i = X(this, "ssfi"), s = lt(r).toLowerCase(), d = lt(e).toLowerCase();
  if (n && s !== "map" && s !== "set" && new z(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    throw new rt(
      a + "the argument to above must be a date",
      void 0,
      i
    );
  if (!er(e) && (n || er(r)))
    throw new rt(
      a + "the argument to above must be a number",
      void 0,
      i
    );
  if (!n && s !== "date" && !er(r)) {
    let l = s === "string" ? "'" + r + "'" : r;
    throw new rt(
      a + "expected " + l + " to be a number or a date",
      void 0,
      i
    );
  }
  if (n) {
    let l = "length", p;
    s === "map" || s === "set" ? (l = "size", p = r.size) : p = r.length, this.assert(
      p > e,
      "expected #{this} to have a " + l + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + l + " above #{exp}",
      e,
      p
    );
  } else
    this.assert(
      r > e,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      e
    );
}
u(Cp, "assertAbove");
ee(Cp, "assertAbove");
z.addMethod("above", Cp);
z.addMethod("gt", Cp);
z.addMethod("greaterThan", Cp);
function kp(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "doLength"), o = X(this, "message"), a = o ? o + ": " : "", i = X(this, "ssfi"), s = lt(r).toLowerCase(), d = lt(e).toLowerCase(), l, p = !0;
  if (n && s !== "map" && s !== "set" && new z(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    l = a + "the argument to least must be a date";
  else if (!er(e) && (n || er(r)))
    l = a + "the argument to least must be a number";
  else if (!n && s !== "date" && !er(r)) {
    let f = s === "string" ? "'" + r + "'" : r;
    l = a + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new rt(l, void 0, i);
  if (n) {
    let f = "length", h;
    s === "map" || s === "set" ? (f = "size", h = r.size) : h = r.length, this.assert(
      h >= e,
      "expected #{this} to have a " + f + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + f + " below #{exp}",
      e,
      h
    );
  } else
    this.assert(
      r >= e,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      e
    );
}
u(kp, "assertLeast");
ee(kp, "assertLeast");
z.addMethod("least", kp);
z.addMethod("gte", kp);
z.addMethod("greaterThanOrEqual", kp);
function Pp(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "doLength"), o = X(this, "message"), a = o ? o + ": " : "", i = X(this, "ssfi"), s = lt(r).toLowerCase(), d = lt(e).toLowerCase(), l, p = !0;
  if (n && s !== "map" && s !== "set" && new z(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    l = a + "the argument to below must be a date";
  else if (!er(e) && (n || er(r)))
    l = a + "the argument to below must be a number";
  else if (!n && s !== "date" && !er(r)) {
    let f = s === "string" ? "'" + r + "'" : r;
    l = a + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new rt(l, void 0, i);
  if (n) {
    let f = "length", h;
    s === "map" || s === "set" ? (f = "size", h = r.size) : h = r.length, this.assert(
      h < e,
      "expected #{this} to have a " + f + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + f + " below #{exp}",
      e,
      h
    );
  } else
    this.assert(
      r < e,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      e
    );
}
u(Pp, "assertBelow");
ee(Pp, "assertBelow");
z.addMethod("below", Pp);
z.addMethod("lt", Pp);
z.addMethod("lessThan", Pp);
function Op(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "doLength"), o = X(this, "message"), a = o ? o + ": " : "", i = X(this, "ssfi"), s = lt(r).toLowerCase(), d = lt(e).toLowerCase(), l, p = !0;
  if (n && s !== "map" && s !== "set" && new z(r, o, i, !0).to.have.property("length"), !n && s === "date" && d !== "date")
    l = a + "the argument to most must be a date";
  else if (!er(e) && (n || er(r)))
    l = a + "the argument to most must be a number";
  else if (!n && s !== "date" && !er(r)) {
    let f = s === "string" ? "'" + r + "'" : r;
    l = a + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new rt(l, void 0, i);
  if (n) {
    let f = "length", h;
    s === "map" || s === "set" ? (f = "size", h = r.size) : h = r.length, this.assert(
      h <= e,
      "expected #{this} to have a " + f + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + f + " above #{exp}",
      e,
      h
    );
  } else
    this.assert(
      r <= e,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      e
    );
}
u(Op, "assertMost");
ee(Op, "assertMost");
z.addMethod("most", Op);
z.addMethod("lte", Op);
z.addMethod("lessThanOrEqual", Op);
z.addMethod("within", function(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "object"), o = X(this, "doLength"), a = X(this, "message"), i = a ? a + ": " : "", s = X(this, "ssfi"), d = lt(n).toLowerCase(), l = lt(e).toLowerCase(), p = lt(t).toLowerCase(), f, h = !0, m = l === "date" && p === "date" ? e.toISOString() + ".." + t.toISOString() : e + ".." + t;
  if (o && d !== "map" && d !== "set" && new z(n, a, s, !0).to.have.property("length"), !o && d === "date" && (l !== "date" || p !== "date"))
    f = i + "the arguments to within must be dates";
  else if ((!er(e) || !er(t)) && (o || er(n)))
    f = i + "the arguments to within must be numbers";
  else if (!o && d !== "date" && !er(n)) {
    let g = d === "string" ? "'" + n + "'" : n;
    f = i + "expected " + g + " to be a number or a date";
  } else
    h = !1;
  if (h)
    throw new rt(f, void 0, s);
  if (o) {
    let g = "length", w;
    d === "map" || d === "set" ? (g = "size", w = n.size) : w = n.length, this.assert(
      w >= e && w <= t,
      "expected #{this} to have a " + g + " within " + m,
      "expected #{this} to not have a " + g + " within " + m
    );
  } else
    this.assert(
      n >= e && n <= t,
      "expected #{this} to be within " + m,
      "expected #{this} to not be within " + m
    );
});
function eb(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "ssfi"), o = X(this, "message"), a;
  try {
    a = r instanceof e;
  } catch (s) {
    throw s instanceof TypeError ? (o = o ? o + ": " : "", new rt(
      o + "The instanceof assertion needs a constructor but " + lt(e) + " was given.",
      void 0,
      n
    )) : s;
  }
  let i = Ap(e);
  i == null && (i = "an unnamed constructor"), this.assert(
    a,
    "expected #{this} to be an instance of " + i,
    "expected #{this} to not be an instance of " + i
  );
}
u(eb, "assertInstanceOf");
ee(eb, "assertInstanceOf");
z.addMethod("instanceof", eb);
z.addMethod("instanceOf", eb);
function tb(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "nested"), o = X(this, "own"), a = X(this, "message"), i = X(this, "object"), s = X(this, "ssfi"), d = typeof e;
  if (a = a ? a + ": " : "", n) {
    if (d !== "string")
      throw new rt(
        a + "the argument to property must be a string when using nested syntax",
        void 0,
        s
      );
  } else if (d !== "string" && d !== "number" && d !== "symbol")
    throw new rt(
      a + "the argument to property must be a string, number, or symbol",
      void 0,
      s
    );
  if (n && o)
    throw new rt(
      a + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      s
    );
  if (i == null)
    throw new rt(
      a + "Target cannot be null or undefined.",
      void 0,
      s
    );
  let l = X(this, "deep"), p = X(this, "negate"), f = n ? Fg(i, e) : null, h = n ? f.value : i[e], m = l ? X(this, "eql") : (_, b) => _ === b, g = "";
  l && (g += "deep "), o && (g += "own "), n && (g += "nested "), g += "property ";
  let w;
  o ? w = Object.prototype.hasOwnProperty.call(i, e) : n ? w = f.exists : w = Tp(i, e), (!p || arguments.length === 1) && this.assert(
    w,
    "expected #{this} to have " + g + Je(e),
    "expected #{this} to not have " + g + Je(e)
  ), arguments.length > 1 && this.assert(
    w && m(t, h),
    "expected #{this} to have " + g + Je(e) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + g + Je(e) + " of #{act}",
    t,
    h
  ), X(this, "object", h);
}
u(tb, "assertProperty");
ee(tb, "assertProperty");
z.addMethod("property", tb);
function rb(e, t, r) {
  X(this, "own", !0), tb.apply(this, arguments);
}
u(rb, "assertOwnProperty");
ee(rb, "assertOwnProperty");
z.addMethod("ownProperty", rb);
z.addMethod("haveOwnProperty", rb);
function nb(e, t, r) {
  typeof t == "string" && (r = t, t = null), r && X(this, "message", r);
  let n = X(this, "object"), o = Object.getOwnPropertyDescriptor(Object(n), e), a = X(this, "eql");
  o && t ? this.assert(
    a(t, o),
    "expected the own property descriptor for " + Je(e) + " on #{this} to match " + Je(t) + ", got " + Je(o),
    "expected the own property descriptor for " + Je(e) + " on #{this} to not match " + Je(t),
    t,
    o,
    !0
  ) : this.assert(
    o,
    "expected #{this} to have an own property descriptor for " + Je(e),
    "expected #{this} to not have an own property descriptor for " + Je(e)
  ), X(this, "object", o);
}
u(nb, "assertOwnPropertyDescriptor");
ee(nb, "assertOwnPropertyDescriptor");
z.addMethod("ownPropertyDescriptor", nb);
z.addMethod("haveOwnPropertyDescriptor", nb);
function ob() {
  X(this, "doLength", !0);
}
u(ob, "assertLengthChain");
ee(ob, "assertLengthChain");
function ab(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = lt(r).toLowerCase(), o = X(this, "message"), a = X(this, "ssfi"), i = "length", s;
  switch (n) {
    case "map":
    case "set":
      i = "size", s = r.size;
      break;
    default:
      new z(r, o, a, !0).to.have.property("length"), s = r.length;
  }
  this.assert(
    s == e,
    "expected #{this} to have a " + i + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + i + " of #{act}",
    e,
    s
  );
}
u(ab, "assertLength");
ee(ab, "assertLength");
z.addChainableMethod("length", ab, ob);
z.addChainableMethod("lengthOf", ab, ob);
function ib(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object");
  this.assert(
    e.exec(r),
    "expected #{this} to match " + e,
    "expected #{this} not to match " + e
  );
}
u(ib, "assertMatch");
ee(ib, "assertMatch");
z.addMethod("match", ib);
z.addMethod("matches", ib);
z.addMethod("string", function(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "message"), o = X(this, "ssfi");
  new z(r, n, o, !0).is.a("string"), this.assert(
    ~r.indexOf(e),
    "expected #{this} to contain " + Je(e),
    "expected #{this} to not contain " + Je(e)
  );
});
function sb(e) {
  let t = X(this, "object"), r = lt(t), n = lt(e), o = X(this, "ssfi"), a = X(this, "deep"), i, s = "", d, l = !0, p = X(this, "message");
  p = p ? p + ": " : "";
  let f = p + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (r === "Map" || r === "Set")
    s = a ? "deeply " : "", d = [], t.forEach(function(b, x) {
      d.push(x);
    }), n !== "Array" && (e = Array.prototype.slice.call(arguments));
  else {
    switch (d = Gg(t), n) {
      case "Array":
        if (arguments.length > 1)
          throw new rt(f, void 0, o);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new rt(f, void 0, o);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function(b) {
      return typeof b == "symbol" ? b : String(b);
    });
  }
  if (!e.length)
    throw new rt(p + "keys required", void 0, o);
  let h = e.length, m = X(this, "any"), g = X(this, "all"), w = e, _ = a ? X(this, "eql") : (b, x) => b === x;
  if (!m && !g && (g = !0), m && (l = w.some(function(b) {
    return d.some(function(x) {
      return _(b, x);
    });
  })), g && (l = w.every(function(b) {
    return d.some(function(x) {
      return _(b, x);
    });
  }), X(this, "contains") || (l = l && e.length == d.length)), h > 1) {
    e = e.map(function(x) {
      return Je(x);
    });
    let b = e.pop();
    g && (i = e.join(", ") + ", and " + b), m && (i = e.join(", ") + ", or " + b);
  } else
    i = Je(e[0]);
  i = (h > 1 ? "keys " : "key ") + i, i = (X(this, "contains") ? "contain " : "have ") + i, this.assert(
    l,
    "expected #{this} to " + s + i,
    "expected #{this} to not " + s + i,
    w.slice(0).sort(qd),
    d.sort(qd),
    !0
  );
}
u(sb, "assertKeys");
ee(sb, "assertKeys");
z.addMethod("keys", sb);
z.addMethod("key", sb);
function Rp(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "object"), o = X(this, "ssfi"), a = X(this, "message"), i = X(this, "negate") || !1;
  new z(n, a, o, !0).is.a("function"), (Ld(e) || typeof e == "string") && (t = e, e = null);
  let s, d = !1;
  try {
    n();
  } catch (m) {
    d = !0, s = m;
  }
  let l = e === void 0 && t === void 0, p = !!(e && t), f = !1, h = !1;
  if (l || !l && !i) {
    let m = "an error";
    e instanceof Error ? m = "#{exp}" : e && (m = Vr.getConstructorName(e));
    let g = s;
    if (s instanceof Error)
      g = s.toString();
    else if (typeof s == "string")
      g = s;
    else if (s && (typeof s == "object" || typeof s == "function"))
      try {
        g = Vr.getConstructorName(s);
      } catch {
      }
    this.assert(
      d,
      "expected #{this} to throw " + m,
      "expected #{this} to not throw an error but #{act} was thrown",
      e && e.toString(),
      g
    );
  }
  if (e && s && (e instanceof Error && Vr.compatibleInstance(
    s,
    e
  ) === i && (p && i ? f = !0 : this.assert(
    i,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (s && !i ? " but #{act} was thrown" : ""),
    e.toString(),
    s.toString()
  )), Vr.compatibleConstructor(
    s,
    e
  ) === i && (p && i ? f = !0 : this.assert(
    i,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (s ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && Vr.getConstructorName(e),
    s instanceof Error ? s.toString() : s && Vr.getConstructorName(s)
  ))), s && t !== void 0 && t !== null) {
    let m = "including";
    Ld(t) && (m = "matching"), Vr.compatibleMessage(
      s,
      t
    ) === i && (p && i ? h = !0 : this.assert(
      i,
      "expected #{this} to throw error " + m + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + m + " #{exp}",
      t,
      Vr.getMessage(s)
    ));
  }
  f && h && this.assert(
    i,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (s ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && Vr.getConstructorName(e),
    s instanceof Error ? s.toString() : s && Vr.getConstructorName(s)
  ), X(this, "object", s);
}
u(Rp, "assertThrows");
ee(Rp, "assertThrows");
z.addMethod("throw", Rp);
z.addMethod("throws", Rp);
z.addMethod("Throw", Rp);
function lb(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "itself"), o = typeof r == "function" && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof o == "function",
    "expected #{this} to respond to " + Je(e),
    "expected #{this} to not respond to " + Je(e)
  );
}
u(lb, "respondTo");
ee(lb, "respondTo");
z.addMethod("respondTo", lb);
z.addMethod("respondsTo", lb);
z.addProperty("itself", function() {
  X(this, "itself", !0);
});
function cb(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = e(r);
  this.assert(
    n,
    "expected #{this} to satisfy " + Da(e),
    "expected #{this} to not satisfy" + Da(e),
    !X(this, "negate"),
    n
  );
}
u(cb, "satisfy");
ee(cb, "satisfy");
z.addMethod("satisfy", cb);
z.addMethod("satisfies", cb);
function ub(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "object"), o = X(this, "message"), a = X(this, "ssfi");
  new z(n, o, a, !0).is.numeric;
  let i = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new rt(
      o ? `${o}: ${i}` : i,
      void 0,
      a
    );
  if (new z(t, o, a, !0).is.numeric, i = "A `expected` value is required for `closeTo`", e == null)
    throw new rt(
      o ? `${o}: ${i}` : i,
      void 0,
      a
    );
  new z(e, o, a, !0).is.numeric;
  const s = ee((l) => l < 0n ? -l : l, "abs"), d = ee((l) => parseFloat(parseFloat(l).toPrecision(12)), "strip");
  this.assert(
    d(s(n - e)) <= t,
    "expected #{this} to be close to " + e + " +/- " + t,
    "expected #{this} not to be close to " + e + " +/- " + t
  );
}
u(ub, "closeTo");
ee(ub, "closeTo");
z.addMethod("closeTo", ub);
z.addMethod("approximately", ub);
function dC(e, t, r, n, o) {
  let a = Array.from(t), i = Array.from(e);
  if (!n) {
    if (i.length !== a.length) return !1;
    a = a.slice();
  }
  return i.every(function(s, d) {
    if (o) return r ? r(s, a[d]) : s === a[d];
    if (!r) {
      let l = a.indexOf(s);
      return l === -1 ? !1 : (n || a.splice(l, 1), !0);
    }
    return a.some(function(l, p) {
      return r(s, l) ? (n || a.splice(p, 1), !0) : !1;
    });
  });
}
u(dC, "isSubsetOf");
ee(dC, "isSubsetOf");
z.addMethod("members", function(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "message"), o = X(this, "ssfi");
  new z(r, n, o, !0).to.be.iterable, new z(e, n, o, !0).to.be.iterable;
  let a = X(this, "contains"), i = X(this, "ordered"), s, d, l;
  a ? (s = i ? "an ordered superset" : "a superset", d = "expected #{this} to be " + s + " of #{exp}", l = "expected #{this} to not be " + s + " of #{exp}") : (s = i ? "ordered members" : "members", d = "expected #{this} to have the same " + s + " as #{exp}", l = "expected #{this} to not have the same " + s + " as #{exp}");
  let p = X(this, "deep") ? X(this, "eql") : void 0;
  this.assert(
    dC(e, r, p, a, i),
    d,
    l,
    e,
    r,
    !0
  );
});
z.addProperty("iterable", function(e) {
  e && X(this, "message", e);
  let t = X(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function pC(e, t) {
  t && X(this, "message", t);
  let r = X(this, "object"), n = X(this, "message"), o = X(this, "ssfi"), a = X(this, "contains"), i = X(this, "deep"), s = X(this, "eql");
  new z(e, n, o, !0).to.be.an("array"), a ? this.assert(
    e.some(function(d) {
      return r.indexOf(d) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    e,
    r
  ) : i ? this.assert(
    e.some(function(d) {
      return s(r, d);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    e,
    r
  ) : this.assert(
    e.indexOf(r) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    e,
    r
  );
}
u(pC, "oneOf");
ee(pC, "oneOf");
z.addMethod("oneOf", pC);
function db(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "object"), o = X(this, "message"), a = X(this, "ssfi");
  new z(n, o, a, !0).is.a("function");
  let i;
  t ? (new z(e, o, a, !0).to.have.property(t), i = e[t]) : (new z(e, o, a, !0).is.a("function"), i = e()), n();
  let s = t == null ? e() : e[t], d = t == null ? i : "." + t;
  X(this, "deltaMsgObj", d), X(this, "initialDeltaValue", i), X(this, "finalDeltaValue", s), X(this, "deltaBehavior", "change"), X(this, "realDelta", s !== i), this.assert(
    i !== s,
    "expected " + d + " to change",
    "expected " + d + " to not change"
  );
}
u(db, "assertChanges");
ee(db, "assertChanges");
z.addMethod("change", db);
z.addMethod("changes", db);
function pb(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "object"), o = X(this, "message"), a = X(this, "ssfi");
  new z(n, o, a, !0).is.a("function");
  let i;
  t ? (new z(e, o, a, !0).to.have.property(t), i = e[t]) : (new z(e, o, a, !0).is.a("function"), i = e()), new z(i, o, a, !0).is.a("number"), n();
  let s = t == null ? e() : e[t], d = t == null ? i : "." + t;
  X(this, "deltaMsgObj", d), X(this, "initialDeltaValue", i), X(this, "finalDeltaValue", s), X(this, "deltaBehavior", "increase"), X(this, "realDelta", s - i), this.assert(
    s - i > 0,
    "expected " + d + " to increase",
    "expected " + d + " to not increase"
  );
}
u(pb, "assertIncreases");
ee(pb, "assertIncreases");
z.addMethod("increase", pb);
z.addMethod("increases", pb);
function fb(e, t, r) {
  r && X(this, "message", r);
  let n = X(this, "object"), o = X(this, "message"), a = X(this, "ssfi");
  new z(n, o, a, !0).is.a("function");
  let i;
  t ? (new z(e, o, a, !0).to.have.property(t), i = e[t]) : (new z(e, o, a, !0).is.a("function"), i = e()), new z(i, o, a, !0).is.a("number"), n();
  let s = t == null ? e() : e[t], d = t == null ? i : "." + t;
  X(this, "deltaMsgObj", d), X(this, "initialDeltaValue", i), X(this, "finalDeltaValue", s), X(this, "deltaBehavior", "decrease"), X(this, "realDelta", i - s), this.assert(
    s - i < 0,
    "expected " + d + " to decrease",
    "expected " + d + " to not decrease"
  );
}
u(fb, "assertDecreases");
ee(fb, "assertDecreases");
z.addMethod("decrease", fb);
z.addMethod("decreases", fb);
function fC(e, t) {
  t && X(this, "message", t);
  let r = X(this, "deltaMsgObj"), n = X(this, "initialDeltaValue"), o = X(this, "finalDeltaValue"), a = X(this, "deltaBehavior"), i = X(this, "realDelta"), s;
  a === "change" ? s = Math.abs(o - n) === Math.abs(e) : s = i === Math.abs(e), this.assert(
    s,
    "expected " + r + " to " + a + " by " + e,
    "expected " + r + " to not " + a + " by " + e
  );
}
u(fC, "assertDelta");
ee(fC, "assertDelta");
z.addMethod("by", fC);
z.addProperty("extensible", function() {
  let e = X(this, "object"), t = e === Object(e) && Object.isExtensible(e);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
z.addProperty("sealed", function() {
  let e = X(this, "object"), t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
z.addProperty("frozen", function() {
  let e = X(this, "object"), t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
z.addProperty("finite", function(e) {
  let t = X(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Fd(e, t) {
  return e === t ? !0 : typeof t != typeof e ? !1 : typeof e != "object" || e === null ? e === t : t ? Array.isArray(e) ? Array.isArray(t) ? e.every(function(r) {
    return t.some(function(n) {
      return Fd(r, n);
    });
  }) : !1 : e instanceof Date ? t instanceof Date ? e.getTime() === t.getTime() : !1 : Object.keys(e).every(function(r) {
    let n = e[r], o = t[r];
    return typeof n == "object" && n !== null && o !== null ? Fd(n, o) : typeof n == "function" ? n(o) : o === n;
  }) : !1;
}
u(Fd, "compareSubset");
ee(Fd, "compareSubset");
z.addMethod("containSubset", function(e) {
  const t = Ne(this, "object"), r = Tr.showDiff;
  this.assert(
    Fd(e, t),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    e,
    t,
    r
  );
});
function qa(e, t) {
  return new z(e, t);
}
u(qa, "expect");
ee(qa, "expect");
qa.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "expect.fail()", new rt(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    qa.fail
  );
};
var JG = {};
k$(JG, {
  Should: /* @__PURE__ */ u(() => dAe, "Should"),
  should: /* @__PURE__ */ u(() => uAe, "should")
});
function hb() {
  function e() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new z(this.valueOf(), null, e) : new z(this, null, e);
  }
  u(e, "shouldGetter"), ee(e, "shouldGetter");
  function t(n) {
    Object.defineProperty(this, "should", {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  u(t, "shouldSetter"), ee(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: e,
    configurable: !0
  });
  let r = {};
  return r.fail = function(n, o, a, i) {
    throw arguments.length < 2 && (a = n, n = void 0), a = a || "should.fail()", new rt(
      a,
      {
        actual: n,
        expected: o,
        operator: i
      },
      r.fail
    );
  }, r.equal = function(n, o, a) {
    new z(n, a).to.equal(o);
  }, r.Throw = function(n, o, a, i) {
    new z(n, i).to.Throw(o, a);
  }, r.exist = function(n, o) {
    new z(n, o).to.exist;
  }, r.not = {}, r.not.equal = function(n, o, a) {
    new z(n, a).to.not.equal(o);
  }, r.not.Throw = function(n, o, a, i) {
    new z(n, i).to.not.Throw(o, a);
  }, r.not.exist = function(n, o) {
    new z(n, o).to.not.exist;
  }, r.throw = r.Throw, r.not.throw = r.not.Throw, r;
}
u(hb, "loadShould");
ee(hb, "loadShould");
var uAe = hb, dAe = hb;
function H(e, t) {
  new z(null, null, H, !0).assert(e, t, "[ negation message unavailable ]");
}
u(H, "assert");
ee(H, "assert");
H.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "assert.fail()", new rt(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    H.fail
  );
};
H.isOk = function(e, t) {
  new z(e, t, H.isOk, !0).is.ok;
};
H.isNotOk = function(e, t) {
  new z(e, t, H.isNotOk, !0).is.not.ok;
};
H.equal = function(e, t, r) {
  let n = new z(e, r, H.equal, !0);
  n.assert(
    t == Ne(n, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    e,
    !0
  );
};
H.notEqual = function(e, t, r) {
  let n = new z(e, r, H.notEqual, !0);
  n.assert(
    t != Ne(n, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    e,
    !0
  );
};
H.strictEqual = function(e, t, r) {
  new z(e, r, H.strictEqual, !0).to.equal(t);
};
H.notStrictEqual = function(e, t, r) {
  new z(e, r, H.notStrictEqual, !0).to.not.equal(t);
};
H.deepEqual = H.deepStrictEqual = function(e, t, r) {
  new z(e, r, H.deepEqual, !0).to.eql(t);
};
H.notDeepEqual = function(e, t, r) {
  new z(e, r, H.notDeepEqual, !0).to.not.eql(t);
};
H.isAbove = function(e, t, r) {
  new z(e, r, H.isAbove, !0).to.be.above(t);
};
H.isAtLeast = function(e, t, r) {
  new z(e, r, H.isAtLeast, !0).to.be.least(t);
};
H.isBelow = function(e, t, r) {
  new z(e, r, H.isBelow, !0).to.be.below(t);
};
H.isAtMost = function(e, t, r) {
  new z(e, r, H.isAtMost, !0).to.be.most(t);
};
H.isTrue = function(e, t) {
  new z(e, t, H.isTrue, !0).is.true;
};
H.isNotTrue = function(e, t) {
  new z(e, t, H.isNotTrue, !0).to.not.equal(!0);
};
H.isFalse = function(e, t) {
  new z(e, t, H.isFalse, !0).is.false;
};
H.isNotFalse = function(e, t) {
  new z(e, t, H.isNotFalse, !0).to.not.equal(!1);
};
H.isNull = function(e, t) {
  new z(e, t, H.isNull, !0).to.equal(null);
};
H.isNotNull = function(e, t) {
  new z(e, t, H.isNotNull, !0).to.not.equal(null);
};
H.isNaN = function(e, t) {
  new z(e, t, H.isNaN, !0).to.be.NaN;
};
H.isNotNaN = function(e, t) {
  new z(e, t, H.isNotNaN, !0).not.to.be.NaN;
};
H.exists = function(e, t) {
  new z(e, t, H.exists, !0).to.exist;
};
H.notExists = function(e, t) {
  new z(e, t, H.notExists, !0).to.not.exist;
};
H.isUndefined = function(e, t) {
  new z(e, t, H.isUndefined, !0).to.equal(void 0);
};
H.isDefined = function(e, t) {
  new z(e, t, H.isDefined, !0).to.not.equal(void 0);
};
H.isCallable = function(e, t) {
  new z(e, t, H.isCallable, !0).is.callable;
};
H.isNotCallable = function(e, t) {
  new z(e, t, H.isNotCallable, !0).is.not.callable;
};
H.isObject = function(e, t) {
  new z(e, t, H.isObject, !0).to.be.a("object");
};
H.isNotObject = function(e, t) {
  new z(e, t, H.isNotObject, !0).to.not.be.a("object");
};
H.isArray = function(e, t) {
  new z(e, t, H.isArray, !0).to.be.an("array");
};
H.isNotArray = function(e, t) {
  new z(e, t, H.isNotArray, !0).to.not.be.an("array");
};
H.isString = function(e, t) {
  new z(e, t, H.isString, !0).to.be.a("string");
};
H.isNotString = function(e, t) {
  new z(e, t, H.isNotString, !0).to.not.be.a("string");
};
H.isNumber = function(e, t) {
  new z(e, t, H.isNumber, !0).to.be.a("number");
};
H.isNotNumber = function(e, t) {
  new z(e, t, H.isNotNumber, !0).to.not.be.a("number");
};
H.isNumeric = function(e, t) {
  new z(e, t, H.isNumeric, !0).is.numeric;
};
H.isNotNumeric = function(e, t) {
  new z(e, t, H.isNotNumeric, !0).is.not.numeric;
};
H.isFinite = function(e, t) {
  new z(e, t, H.isFinite, !0).to.be.finite;
};
H.isBoolean = function(e, t) {
  new z(e, t, H.isBoolean, !0).to.be.a("boolean");
};
H.isNotBoolean = function(e, t) {
  new z(e, t, H.isNotBoolean, !0).to.not.be.a("boolean");
};
H.typeOf = function(e, t, r) {
  new z(e, r, H.typeOf, !0).to.be.a(t);
};
H.notTypeOf = function(e, t, r) {
  new z(e, r, H.notTypeOf, !0).to.not.be.a(t);
};
H.instanceOf = function(e, t, r) {
  new z(e, r, H.instanceOf, !0).to.be.instanceOf(t);
};
H.notInstanceOf = function(e, t, r) {
  new z(e, r, H.notInstanceOf, !0).to.not.be.instanceOf(
    t
  );
};
H.include = function(e, t, r) {
  new z(e, r, H.include, !0).include(t);
};
H.notInclude = function(e, t, r) {
  new z(e, r, H.notInclude, !0).not.include(t);
};
H.deepInclude = function(e, t, r) {
  new z(e, r, H.deepInclude, !0).deep.include(t);
};
H.notDeepInclude = function(e, t, r) {
  new z(e, r, H.notDeepInclude, !0).not.deep.include(t);
};
H.nestedInclude = function(e, t, r) {
  new z(e, r, H.nestedInclude, !0).nested.include(t);
};
H.notNestedInclude = function(e, t, r) {
  new z(e, r, H.notNestedInclude, !0).not.nested.include(
    t
  );
};
H.deepNestedInclude = function(e, t, r) {
  new z(e, r, H.deepNestedInclude, !0).deep.nested.include(
    t
  );
};
H.notDeepNestedInclude = function(e, t, r) {
  new z(
    e,
    r,
    H.notDeepNestedInclude,
    !0
  ).not.deep.nested.include(t);
};
H.ownInclude = function(e, t, r) {
  new z(e, r, H.ownInclude, !0).own.include(t);
};
H.notOwnInclude = function(e, t, r) {
  new z(e, r, H.notOwnInclude, !0).not.own.include(t);
};
H.deepOwnInclude = function(e, t, r) {
  new z(e, r, H.deepOwnInclude, !0).deep.own.include(t);
};
H.notDeepOwnInclude = function(e, t, r) {
  new z(e, r, H.notDeepOwnInclude, !0).not.deep.own.include(
    t
  );
};
H.match = function(e, t, r) {
  new z(e, r, H.match, !0).to.match(t);
};
H.notMatch = function(e, t, r) {
  new z(e, r, H.notMatch, !0).to.not.match(t);
};
H.property = function(e, t, r) {
  new z(e, r, H.property, !0).to.have.property(t);
};
H.notProperty = function(e, t, r) {
  new z(e, r, H.notProperty, !0).to.not.have.property(t);
};
H.propertyVal = function(e, t, r, n) {
  new z(e, n, H.propertyVal, !0).to.have.property(t, r);
};
H.notPropertyVal = function(e, t, r, n) {
  new z(e, n, H.notPropertyVal, !0).to.not.have.property(
    t,
    r
  );
};
H.deepPropertyVal = function(e, t, r, n) {
  new z(e, n, H.deepPropertyVal, !0).to.have.deep.property(
    t,
    r
  );
};
H.notDeepPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.notDeepPropertyVal,
    !0
  ).to.not.have.deep.property(t, r);
};
H.ownProperty = function(e, t, r) {
  new z(e, r, H.ownProperty, !0).to.have.own.property(t);
};
H.notOwnProperty = function(e, t, r) {
  new z(e, r, H.notOwnProperty, !0).to.not.have.own.property(
    t
  );
};
H.ownPropertyVal = function(e, t, r, n) {
  new z(e, n, H.ownPropertyVal, !0).to.have.own.property(
    t,
    r
  );
};
H.notOwnPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.notOwnPropertyVal,
    !0
  ).to.not.have.own.property(t, r);
};
H.deepOwnPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.deepOwnPropertyVal,
    !0
  ).to.have.deep.own.property(t, r);
};
H.notDeepOwnPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.notDeepOwnPropertyVal,
    !0
  ).to.not.have.deep.own.property(t, r);
};
H.nestedProperty = function(e, t, r) {
  new z(e, r, H.nestedProperty, !0).to.have.nested.property(
    t
  );
};
H.notNestedProperty = function(e, t, r) {
  new z(
    e,
    r,
    H.notNestedProperty,
    !0
  ).to.not.have.nested.property(t);
};
H.nestedPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.nestedPropertyVal,
    !0
  ).to.have.nested.property(t, r);
};
H.notNestedPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.notNestedPropertyVal,
    !0
  ).to.not.have.nested.property(t, r);
};
H.deepNestedPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.deepNestedPropertyVal,
    !0
  ).to.have.deep.nested.property(t, r);
};
H.notDeepNestedPropertyVal = function(e, t, r, n) {
  new z(
    e,
    n,
    H.notDeepNestedPropertyVal,
    !0
  ).to.not.have.deep.nested.property(t, r);
};
H.lengthOf = function(e, t, r) {
  new z(e, r, H.lengthOf, !0).to.have.lengthOf(t);
};
H.hasAnyKeys = function(e, t, r) {
  new z(e, r, H.hasAnyKeys, !0).to.have.any.keys(t);
};
H.hasAllKeys = function(e, t, r) {
  new z(e, r, H.hasAllKeys, !0).to.have.all.keys(t);
};
H.containsAllKeys = function(e, t, r) {
  new z(e, r, H.containsAllKeys, !0).to.contain.all.keys(
    t
  );
};
H.doesNotHaveAnyKeys = function(e, t, r) {
  new z(e, r, H.doesNotHaveAnyKeys, !0).to.not.have.any.keys(
    t
  );
};
H.doesNotHaveAllKeys = function(e, t, r) {
  new z(e, r, H.doesNotHaveAllKeys, !0).to.not.have.all.keys(
    t
  );
};
H.hasAnyDeepKeys = function(e, t, r) {
  new z(e, r, H.hasAnyDeepKeys, !0).to.have.any.deep.keys(
    t
  );
};
H.hasAllDeepKeys = function(e, t, r) {
  new z(e, r, H.hasAllDeepKeys, !0).to.have.all.deep.keys(
    t
  );
};
H.containsAllDeepKeys = function(e, t, r) {
  new z(
    e,
    r,
    H.containsAllDeepKeys,
    !0
  ).to.contain.all.deep.keys(t);
};
H.doesNotHaveAnyDeepKeys = function(e, t, r) {
  new z(
    e,
    r,
    H.doesNotHaveAnyDeepKeys,
    !0
  ).to.not.have.any.deep.keys(t);
};
H.doesNotHaveAllDeepKeys = function(e, t, r) {
  new z(
    e,
    r,
    H.doesNotHaveAllDeepKeys,
    !0
  ).to.not.have.all.deep.keys(t);
};
H.throws = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null);
  let o = new z(e, n, H.throws, !0).to.throw(
    t,
    r
  );
  return Ne(o, "object");
};
H.doesNotThrow = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null), new z(e, n, H.doesNotThrow, !0).to.not.throw(
    t,
    r
  );
};
H.operator = function(e, t, r, n) {
  let o;
  switch (t) {
    case "==":
      o = e == r;
      break;
    case "===":
      o = e === r;
      break;
    case ">":
      o = e > r;
      break;
    case ">=":
      o = e >= r;
      break;
    case "<":
      o = e < r;
      break;
    case "<=":
      o = e <= r;
      break;
    case "!=":
      o = e != r;
      break;
    case "!==":
      o = e !== r;
      break;
    default:
      throw n = n && n + ": ", new rt(
        n + 'Invalid operator "' + t + '"',
        void 0,
        H.operator
      );
  }
  let a = new z(o, n, H.operator, !0);
  a.assert(
    Ne(a, "object") === !0,
    "expected " + Je(e) + " to be " + t + " " + Je(r),
    "expected " + Je(e) + " to not be " + t + " " + Je(r)
  );
};
H.closeTo = function(e, t, r, n) {
  new z(e, n, H.closeTo, !0).to.be.closeTo(t, r);
};
H.approximately = function(e, t, r, n) {
  new z(e, n, H.approximately, !0).to.be.approximately(
    t,
    r
  );
};
H.sameMembers = function(e, t, r) {
  new z(e, r, H.sameMembers, !0).to.have.same.members(t);
};
H.notSameMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notSameMembers,
    !0
  ).to.not.have.same.members(t);
};
H.sameDeepMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.sameDeepMembers,
    !0
  ).to.have.same.deep.members(t);
};
H.notSameDeepMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notSameDeepMembers,
    !0
  ).to.not.have.same.deep.members(t);
};
H.sameOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.sameOrderedMembers,
    !0
  ).to.have.same.ordered.members(t);
};
H.notSameOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notSameOrderedMembers,
    !0
  ).to.not.have.same.ordered.members(t);
};
H.sameDeepOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.sameDeepOrderedMembers,
    !0
  ).to.have.same.deep.ordered.members(t);
};
H.notSameDeepOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notSameDeepOrderedMembers,
    !0
  ).to.not.have.same.deep.ordered.members(t);
};
H.includeMembers = function(e, t, r) {
  new z(e, r, H.includeMembers, !0).to.include.members(
    t
  );
};
H.notIncludeMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notIncludeMembers,
    !0
  ).to.not.include.members(t);
};
H.includeDeepMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.includeDeepMembers,
    !0
  ).to.include.deep.members(t);
};
H.notIncludeDeepMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notIncludeDeepMembers,
    !0
  ).to.not.include.deep.members(t);
};
H.includeOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.includeOrderedMembers,
    !0
  ).to.include.ordered.members(t);
};
H.notIncludeOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notIncludeOrderedMembers,
    !0
  ).to.not.include.ordered.members(t);
};
H.includeDeepOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.includeDeepOrderedMembers,
    !0
  ).to.include.deep.ordered.members(t);
};
H.notIncludeDeepOrderedMembers = function(e, t, r) {
  new z(
    e,
    r,
    H.notIncludeDeepOrderedMembers,
    !0
  ).to.not.include.deep.ordered.members(t);
};
H.oneOf = function(e, t, r) {
  new z(e, r, H.oneOf, !0).to.be.oneOf(t);
};
H.isIterable = function(e, t) {
  if (e == null || !e[Symbol.iterator])
    throw t = t ? `${t} expected ${Je(e)} to be an iterable` : `expected ${Je(e)} to be an iterable`, new rt(t, void 0, H.isIterable);
};
H.changes = function(e, t, r, n) {
  arguments.length === 3 && typeof t == "function" && (n = r, r = null), new z(e, n, H.changes, !0).to.change(t, r);
};
H.changesBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new z(e, o, H.changesBy, !0).to.change(t, r).by(n);
};
H.doesNotChange = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new z(e, n, H.doesNotChange, !0).to.not.change(
    t,
    r
  );
};
H.changesButNotBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new z(e, o, H.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
H.increases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new z(e, n, H.increases, !0).to.increase(t, r);
};
H.increasesBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new z(e, o, H.increasesBy, !0).to.increase(t, r).by(n);
};
H.doesNotIncrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new z(e, n, H.doesNotIncrease, !0).to.not.increase(
    t,
    r
  );
};
H.increasesButNotBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new z(e, o, H.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
H.decreases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new z(e, n, H.decreases, !0).to.decrease(t, r);
};
H.decreasesBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new z(e, o, H.decreasesBy, !0).to.decrease(t, r).by(n);
};
H.doesNotDecrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new z(e, n, H.doesNotDecrease, !0).to.not.decrease(
    t,
    r
  );
};
H.doesNotDecreaseBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  return new z(e, o, H.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
H.decreasesButNotBy = function(e, t, r, n, o) {
  if (arguments.length === 4 && typeof t == "function") {
    let a = n;
    n = r, o = a;
  } else arguments.length === 3 && (n = r, r = null);
  new z(e, o, H.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
H.ifError = function(e) {
  if (e)
    throw e;
};
H.isExtensible = function(e, t) {
  new z(e, t, H.isExtensible, !0).to.be.extensible;
};
H.isNotExtensible = function(e, t) {
  new z(e, t, H.isNotExtensible, !0).to.not.be.extensible;
};
H.isSealed = function(e, t) {
  new z(e, t, H.isSealed, !0).to.be.sealed;
};
H.isNotSealed = function(e, t) {
  new z(e, t, H.isNotSealed, !0).to.not.be.sealed;
};
H.isFrozen = function(e, t) {
  new z(e, t, H.isFrozen, !0).to.be.frozen;
};
H.isNotFrozen = function(e, t) {
  new z(e, t, H.isNotFrozen, !0).to.not.be.frozen;
};
H.isEmpty = function(e, t) {
  new z(e, t, H.isEmpty, !0).to.be.empty;
};
H.isNotEmpty = function(e, t) {
  new z(e, t, H.isNotEmpty, !0).to.not.be.empty;
};
H.containsSubset = function(e, t, r) {
  new z(e, r).to.containSubset(t);
};
H.doesNotContainSubset = function(e, t, r) {
  new z(e, r).to.not.containSubset(t);
};
var pAe = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (const [e, t] of pAe)
  H[t] = H[e];
var Oj = [];
function es(e) {
  const t = {
    use: es,
    AssertionError: rt,
    util: ao,
    config: Tr,
    expect: qa,
    assert: H,
    Assertion: z,
    ...JG
  };
  return ~Oj.indexOf(e) || (e(t, ao), Oj.push(e)), t;
}
u(es, "use");
ee(es, "use");
var WG = {};
vp(WG, {
  toBeChecked: () => GC,
  toBeDisabled: () => FC,
  toBeEmpty: () => TC,
  toBeEmptyDOMElement: () => AC,
  toBeEnabled: () => UC,
  toBeInTheDOM: () => pm,
  toBeInTheDocument: () => SC,
  toBeInvalid: () => VC,
  toBePartiallyChecked: () => YC,
  toBePartiallyPressed: () => tk,
  toBePressed: () => ek,
  toBeRequired: () => BC,
  toBeValid: () => zC,
  toBeVisible: () => NC,
  toContainElement: () => fm,
  toContainHTML: () => $C,
  toHaveAccessibleDescription: () => hm,
  toHaveAccessibleErrorMessage: () => kC,
  toHaveAccessibleName: () => ym,
  toHaveAttribute: () => PC,
  toHaveClass: () => OC,
  toHaveDescription: () => XC,
  toHaveDisplayValue: () => WC,
  toHaveErrorMessage: () => QC,
  toHaveFocus: () => RC,
  toHaveFormValues: () => jC,
  toHaveRole: () => mm,
  toHaveSelection: () => ZC,
  toHaveStyle: () => gm,
  toHaveTextContent: () => CC,
  toHaveValue: () => JC
});
var Rj = ar(FG(), 1), GG = class extends Error {
  reason;
  filename;
  line;
  column;
  source;
  constructor(e, t, r, n, o) {
    super(`${e}:${r}:${n}: ${t}`), this.reason = t, this.filename = e, this.line = r, this.column = n, this.source = o;
  }
};
u(GG, "t");
var fAe = GG, KG = class {
  start;
  end;
  source;
  constructor(e, t, r) {
    this.start = e, this.end = t, this.source = r;
  }
};
u(KG, "e");
var hAe = KG, Kt;
(function(e) {
  e.stylesheet = "stylesheet", e.rule = "rule", e.declaration = "declaration", e.comment = "comment", e.container = "container", e.charset = "charset", e.document = "document", e.customMedia = "custom-media", e.fontFace = "font-face", e.host = "host", e.import = "import", e.keyframes = "keyframes", e.keyframe = "keyframe", e.layer = "layer", e.media = "media", e.namespace = "namespace", e.page = "page", e.startingStyle = "starting-style", e.supports = "supports";
})(Kt || (Kt = {}));
var jj = /* @__PURE__ */ u((e, t, r) => {
  let n = r, o = 1e4;
  do {
    const a = t.map((d) => e.indexOf(d, n));
    a.push(e.indexOf("\\", n));
    const i = a.filter((d) => d !== -1);
    if (i.length === 0) return -1;
    const s = Math.min(...i);
    if (e[s] !== "\\") return s;
    n = s + 2, o--;
  } while (o > 0);
  throw new Error("Too many escaping");
}, "s"), D0 = /* @__PURE__ */ u((e, t, r) => {
  let n = r, o = 1e4;
  do {
    const a = t.map((d) => e.indexOf(d, n));
    a.push(e.indexOf("(", n)), a.push(e.indexOf('"', n)), a.push(e.indexOf("'", n)), a.push(e.indexOf("\\", n));
    const i = a.filter((d) => d !== -1);
    if (i.length === 0) return -1;
    const s = Math.min(...i);
    switch (e[s]) {
      case "\\":
        n = s + 2;
        break;
      case "(":
        {
          const d = D0(e, [")"], s + 1);
          if (d === -1) return -1;
          n = d + 1;
        }
        break;
      case '"':
        {
          const d = jj(e, ['"'], s + 1);
          if (d === -1) return -1;
          n = d + 1;
        }
        break;
      case "'":
        {
          const d = jj(e, ["'"], s + 1);
          if (d === -1) return -1;
          n = d + 1;
        }
        break;
      default:
        return s;
    }
    o--;
  } while (o > 0);
  throw new Error("Too many escaping");
}, "n"), Mv = /\/\*[^]*?(?:\*\/|$)/g;
function Fr(e) {
  return e ? e.trim() : "";
}
u(Fr, "o");
function dm(e, t) {
  const r = e && typeof e.type == "string", n = r ? e : t;
  for (const o in e) {
    const a = e[o];
    Array.isArray(a) ? a.forEach((i) => {
      dm(i, n);
    }) : a && typeof a == "object" && dm(a, n);
  }
  return r && Object.defineProperty(e, "parent", { configurable: !0, writable: !0, enumerable: !1, value: t || null }), e;
}
u(dm, "c");
var mAe = /* @__PURE__ */ u((e, t) => {
  t = t || {};
  let r = 1, n = 1;
  function o() {
    const E = { line: r, column: n };
    return (T) => (T.position = new hAe(E, { line: r, column: n }, t?.source || ""), f(), T);
  }
  u(o, "u");
  const a = [];
  function i(E) {
    const T = new fAe(t?.source || "", E, r, n, e);
    if (!t?.silent) throw T;
    a.push(T);
  }
  u(i, "l");
  function s() {
    const E = /^{\s*/.exec(e);
    return !!E && (p(E), !0);
  }
  u(s, "f");
  function d() {
    const E = /^}/.exec(e);
    return !!E && (p(E), !0);
  }
  u(d, "d");
  function l() {
    let E;
    const T = [];
    for (f(), h(T); e.length && e.charAt(0) !== "}" && (E = C() || A(), E); ) T.push(E), h(T);
    return T;
  }
  u(l, "y");
  function p(E) {
    const T = E[0];
    return (function(O) {
      const k = O.match(/\n/g);
      k && (r += k.length);
      const M = O.lastIndexOf(`
`);
      n = ~M ? O.length - M : n + O.length;
    })(T), e = e.slice(T.length), E;
  }
  u(p, "g");
  function f() {
    const E = /^\s*/.exec(e);
    E && p(E);
  }
  u(f, "$");
  function h(E) {
    E = E || [];
    let T = m();
    for (; T; ) E.push(T), T = m();
    return E;
  }
  u(h, "x");
  function m() {
    const E = o();
    if (e.charAt(0) !== "/" || e.charAt(1) !== "*") return;
    const T = /^\/\*[^]*?\*\//.exec(e);
    return T ? (p(T), E({ type: Kt.comment, comment: T[0].slice(2, -2) })) : i("End of comment missing");
  }
  u(m, "V");
  function g() {
    const E = /^([^{]+)/.exec(e);
    if (E)
      return p(E), ((T, O) => {
        const k = [];
        let M = 0;
        for (; M < T.length; ) {
          const L = D0(T, O, M);
          if (L === -1) return k.push(T.substring(M)), k;
          k.push(T.substring(M, L)), M = L + 1;
        }
        return k;
      })(Fr(E[0]).replace(Mv, ""), [","]).map((T) => Fr(T));
  }
  u(g, "k");
  function w() {
    const E = o(), T = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
    if (!T) return;
    p(T);
    const O = Fr(T[0]), k = /^:\s*/.exec(e);
    if (!k) return i("property missing ':'");
    p(k);
    let M = "";
    const L = D0(e, [";", "}"]);
    L !== -1 && (M = e.substring(0, L), p([M]), M = Fr(M).replace(Mv, ""));
    const $ = E({ type: Kt.declaration, property: O.replace(Mv, ""), value: M }), I = /^[;\s]*/.exec(e);
    return I && p(I), $;
  }
  u(w, "v");
  function _() {
    const E = [];
    if (!s()) return i("missing '{'");
    h(E);
    let T = w();
    for (; T; ) E.push(T), h(E), T = w();
    return d() ? E : i("missing '}'");
  }
  u(_, "w");
  function b() {
    const E = [], T = o();
    let O = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
    for (; O; ) {
      const k = p(O);
      E.push(k[1]);
      const M = /^,\s*/.exec(e);
      M && p(M), O = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
    }
    if (E.length) return T({ type: Kt.keyframe, values: E, declarations: _() || [] });
  }
  u(b, "b");
  const x = N("import"), P = N("charset"), R = N("namespace");
  function N(E) {
    const T = new RegExp("^@" + E + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return () => {
      const O = o(), k = T.exec(e);
      if (!k) return;
      const M = p(k), L = { type: E };
      return L[E] = M[1].trim(), O(L);
    };
  }
  u(N, "M");
  function C() {
    if (e[0] === "@") return (function() {
      const E = o(), T = /^@([-\w]+)?keyframes\s*/.exec(e);
      if (!T) return;
      const O = p(T)[1], k = /^([-\w]+)\s*/.exec(e);
      if (!k) return i("@keyframes missing name");
      const M = p(k)[1];
      if (!s()) return i("@keyframes missing '{'");
      let L = h(), $ = b();
      for (; $; ) L.push($), L = L.concat(h()), $ = b();
      return d() ? E({ type: Kt.keyframes, name: M, vendor: O, keyframes: L }) : i("@keyframes missing '}'");
    })() || (function() {
      const E = o(), T = /^@media *([^{]+)/.exec(e);
      if (!T) return;
      const O = Fr(p(T)[1]);
      if (!s()) return i("@media missing '{'");
      const k = h().concat(l());
      return d() ? E({ type: Kt.media, media: O, rules: k }) : i("@media missing '}'");
    })() || (function() {
      const E = o(), T = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
      if (!T) return;
      const O = p(T);
      return E({ type: Kt.customMedia, name: Fr(O[1]), media: Fr(O[2]) });
    })() || (function() {
      const E = o(), T = /^@supports *([^{]+)/.exec(e);
      if (!T) return;
      const O = Fr(p(T)[1]);
      if (!s()) return i("@supports missing '{'");
      const k = h().concat(l());
      return d() ? E({ type: Kt.supports, supports: O, rules: k }) : i("@supports missing '}'");
    })() || x() || P() || R() || (function() {
      const E = o(), T = /^@([-\w]+)?document *([^{]+)/.exec(e);
      if (!T) return;
      const O = p(T), k = Fr(O[1]), M = Fr(O[2]);
      if (!s()) return i("@document missing '{'");
      const L = h().concat(l());
      return d() ? E({ type: Kt.document, document: M, vendor: k, rules: L }) : i("@document missing '}'");
    })() || (function() {
      const E = o(), T = /^@page */.exec(e);
      if (!T) return;
      p(T);
      const O = g() || [];
      if (!s()) return i("@page missing '{'");
      let k = h(), M = w();
      for (; M; ) k.push(M), k = k.concat(h()), M = w();
      return d() ? E({ type: Kt.page, selectors: O, declarations: k }) : i("@page missing '}'");
    })() || (function() {
      const E = o(), T = /^@host\s*/.exec(e);
      if (!T) return;
      if (p(T), !s()) return i("@host missing '{'");
      const O = h().concat(l());
      return d() ? E({ type: Kt.host, rules: O }) : i("@host missing '}'");
    })() || (function() {
      const E = o(), T = /^@font-face\s*/.exec(e);
      if (!T) return;
      if (p(T), !s()) return i("@font-face missing '{'");
      let O = h(), k = w();
      for (; k; ) O.push(k), O = O.concat(h()), k = w();
      return d() ? E({ type: Kt.fontFace, declarations: O }) : i("@font-face missing '}'");
    })() || (function() {
      const E = o(), T = /^@container *([^{]+)/.exec(e);
      if (!T) return;
      const O = Fr(p(T)[1]);
      if (!s()) return i("@container missing '{'");
      const k = h().concat(l());
      return d() ? E({ type: Kt.container, container: O, rules: k }) : i("@container missing '}'");
    })() || (function() {
      const E = o(), T = /^@starting-style\s*/.exec(e);
      if (!T) return;
      if (p(T), !s()) return i("@starting-style missing '{'");
      const O = h().concat(l());
      return d() ? E({ type: Kt.startingStyle, rules: O }) : i("@starting-style missing '}'");
    })() || (function() {
      const E = o(), T = /^@layer *([^{;@]+)/.exec(e);
      if (!T) return;
      const O = Fr(p(T)[1]);
      if (!s()) {
        const M = /^[;\s]*/.exec(e);
        return M && p(M), E({ type: Kt.layer, layer: O });
      }
      const k = h().concat(l());
      return d() ? E({ type: Kt.layer, layer: O, rules: k }) : i("@layer missing '}'");
    })();
  }
  u(C, "A");
  function A() {
    const E = o(), T = g();
    return T ? (h(), E({ type: Kt.rule, selectors: T, declarations: _() || [] })) : i("selector missing");
  }
  return u(A, "S"), dm((function() {
    const E = l();
    return { type: Kt.stylesheet, stylesheet: { source: t?.source, rules: E, parsingErrors: a } };
  })());
}, "m"), yAe = Object.prototype.toString;
function q0(e) {
  return typeof e == "function" || yAe.call(e) === "[object Function]";
}
u(q0, "isCallable");
function YG(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
u(YG, "toInteger");
var gAe = Math.pow(2, 53) - 1;
function XG(e) {
  var t = YG(e);
  return Math.min(Math.max(t, 0), gAe);
}
u(XG, "toLength");
function dn(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !q0(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var o = XG(n.length), a = q0(r) ? Object(new r(o)) : new Array(o), i = 0, s; i < o; )
    s = n[i], t ? a[i] = t(s, i) : a[i] = s, i += 1;
  return a.length = o, a;
}
u(dn, "arrayFrom");
function ic(e) {
  "@babel/helpers - typeof";
  return ic = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ic(e);
}
u(ic, "_typeof");
function QG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
u(QG, "_classCallCheck");
function L0(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, hC(n.key), n);
  }
}
u(L0, "_defineProperties");
function ZG(e, t, r) {
  return t && L0(e.prototype, t), r && L0(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
u(ZG, "_createClass");
function e7(e, t, r) {
  return t = hC(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
u(e7, "_defineProperty");
function hC(e) {
  var t = t7(e, "string");
  return ic(t) === "symbol" ? t : String(t);
}
u(hC, "_toPropertyKey");
function t7(e, t) {
  if (ic(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (ic(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
u(t7, "_toPrimitive");
var bAe = (function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    QG(this, e), e7(this, "items", void 0), this.items = t;
  }
  return u(e, "SetLike"), ZG(e, [{
    key: "add",
    value: /* @__PURE__ */ u(function(t) {
      return this.has(t) === !1 && this.items.push(t), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ u(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ u(function(t) {
      var r = this.items.length;
      return this.items = this.items.filter(function(n) {
        return n !== t;
      }), r !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ u(function(t) {
      var r = this;
      this.items.forEach(function(n) {
        t(n, n, r);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ u(function(t) {
      return this.items.indexOf(t) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ u(function() {
      return this.items.length;
    }, "get")
  }]), e;
})(), vAe = typeof Set > "u" ? Set : bAe;
function hr(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
u(hr, "getLocalName");
var wAe = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, _Ae = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function r7(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = _Ae[t]) !== null && n !== void 0 && n.has(r));
  });
}
u(r7, "hasGlobalAriaAttributes");
function mC(e, t) {
  return r7(e, t);
}
u(mC, "ignorePresentationalRole");
function n7(e) {
  var t = a7(e);
  if (t === null || F0.indexOf(t) !== -1) {
    var r = o7(e);
    if (F0.indexOf(t || "") === -1 || mC(e, r || ""))
      return r;
  }
  return t;
}
u(n7, "getRole");
function o7(e) {
  var t = wAe[hr(e)];
  if (t !== void 0)
    return t;
  switch (hr(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !mC(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
u(o7, "getImplicitRole");
function a7(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
u(a7, "getExplicitRole");
var F0 = ["presentation", "none"];
function gt(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
u(gt, "isElement");
function yC(e) {
  return gt(e) && hr(e) === "caption";
}
u(yC, "isHTMLTableCaptionElement");
function Yu(e) {
  return gt(e) && hr(e) === "input";
}
u(Yu, "isHTMLInputElement");
function i7(e) {
  return gt(e) && hr(e) === "optgroup";
}
u(i7, "isHTMLOptGroupElement");
function s7(e) {
  return gt(e) && hr(e) === "select";
}
u(s7, "isHTMLSelectElement");
function l7(e) {
  return gt(e) && hr(e) === "table";
}
u(l7, "isHTMLTableElement");
function c7(e) {
  return gt(e) && hr(e) === "textarea";
}
u(c7, "isHTMLTextAreaElement");
function u7(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
u(u7, "safeWindow");
function d7(e) {
  return gt(e) && hr(e) === "fieldset";
}
u(d7, "isHTMLFieldSetElement");
function p7(e) {
  return gt(e) && hr(e) === "legend";
}
u(p7, "isHTMLLegendElement");
function f7(e) {
  return gt(e) && hr(e) === "slot";
}
u(f7, "isHTMLSlotElement");
function h7(e) {
  return gt(e) && e.ownerSVGElement !== void 0;
}
u(h7, "isSVGElement");
function m7(e) {
  return gt(e) && hr(e) === "svg";
}
u(m7, "isSVGSVGElement");
function y7(e) {
  return h7(e) && hr(e) === "title";
}
u(y7, "isSVGTitleElement");
function Ud(e, t) {
  if (gt(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(o) {
      return n.getElementById(o);
    }).filter(
      function(o) {
        return o !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
u(Ud, "queryIdRefs");
function io(e, t) {
  return gt(e) ? t.indexOf(n7(e)) !== -1 : !1;
}
u(io, "hasAnyConcreteRoles");
function g7(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
u(g7, "asFlatString");
function b7(e, t) {
  if (!gt(e))
    return !1;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return !0;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
u(b7, "isHidden");
function v7(e) {
  return io(e, ["button", "combobox", "listbox", "textbox"]) || gC(e, "range");
}
u(v7, "isControl");
function gC(e, t) {
  if (!gt(e))
    return !1;
  switch (t) {
    case "range":
      return io(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
u(gC, "hasAbstractRole");
function U0(e, t) {
  var r = dn(e.querySelectorAll(t));
  return Ud(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, dn(n.querySelectorAll(t)));
  }), r;
}
u(U0, "querySelectorAllSubtree");
function w7(e) {
  return s7(e) ? e.selectedOptions || U0(e, "[selected]") : U0(e, '[aria-selected="true"]');
}
u(w7, "querySelectedOptions");
function _7(e) {
  return io(e, F0);
}
u(_7, "isMarkedPresentational");
function E7(e) {
  return yC(e);
}
u(E7, "isNativeHostLanguageTextAlternativeElement");
function x7(e) {
  return io(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
u(x7, "allowsNameFromContent");
function S7(e) {
  return !1;
}
u(S7, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function T7(e) {
  return Yu(e) || c7(e) ? e.value : e.textContent || "";
}
u(T7, "getValueOfTextbox");
function B0(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
u(B0, "getTextualContent");
function bC(e) {
  var t = hr(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
u(bC, "isLabelableElement");
function vC(e) {
  if (bC(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && gt(r)) {
      var n = vC(r);
      n !== null && (t = n);
    }
  }), t;
}
u(vC, "findLabelableElement");
function A7(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : vC(e);
}
u(A7, "getControlOfLabel");
function $7(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return dn(t);
  if (!bC(e))
    return null;
  var r = e.ownerDocument;
  return dn(r.querySelectorAll("label")).filter(function(n) {
    return A7(n) === e;
  });
}
u($7, "getLabels");
function C7(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? dn(e.childNodes) : t;
}
u(C7, "getSlotContents");
function wC(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new vAe(), n = u7(e), o = t.compute, a = o === void 0 ? "name" : o, i = t.computedStyleSupportsPseudoElements, s = i === void 0 ? t.getComputedStyle !== void 0 : i, d = t.getComputedStyle, l = d === void 0 ? n.getComputedStyle.bind(n) : d, p = t.hidden, f = p === void 0 ? !1 : p;
  function h(b, x) {
    var P = "";
    if (gt(b) && s) {
      var R = l(b, "::before"), N = B0(R);
      P = "".concat(N, " ").concat(P);
    }
    var C = f7(b) ? C7(b) : dn(b.childNodes).concat(Ud(b, "aria-owns"));
    if (C.forEach(function(T) {
      var O = _(T, {
        isEmbeddedInLabel: x.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), k = gt(T) ? l(T).getPropertyValue("display") : "inline", M = k !== "inline" ? " " : "";
      P += "".concat(M).concat(O).concat(M);
    }), gt(b) && s) {
      var A = l(b, "::after"), E = B0(A);
      P = "".concat(P, " ").concat(E);
    }
    return P.trim();
  }
  u(h, "computeMiscTextAlternative");
  function m(b, x) {
    var P = b.getAttributeNode(x);
    return P !== null && !r.has(P) && P.value.trim() !== "" ? (r.add(P), P.value) : null;
  }
  u(m, "useAttribute");
  function g(b) {
    return gt(b) ? m(b, "title") : null;
  }
  u(g, "computeTooltipAttributeValue");
  function w(b) {
    if (!gt(b))
      return null;
    if (d7(b)) {
      r.add(b);
      for (var x = dn(b.childNodes), P = 0; P < x.length; P += 1) {
        var R = x[P];
        if (p7(R))
          return _(R, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (l7(b)) {
      r.add(b);
      for (var N = dn(b.childNodes), C = 0; C < N.length; C += 1) {
        var A = N[C];
        if (yC(A))
          return _(A, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (m7(b)) {
      r.add(b);
      for (var E = dn(b.childNodes), T = 0; T < E.length; T += 1) {
        var O = E[T];
        if (y7(O))
          return O.textContent;
      }
      return null;
    } else if (hr(b) === "img" || hr(b) === "area") {
      var k = m(b, "alt");
      if (k !== null)
        return k;
    } else if (i7(b)) {
      var M = m(b, "label");
      if (M !== null)
        return M;
    }
    if (Yu(b) && (b.type === "button" || b.type === "submit" || b.type === "reset")) {
      var L = m(b, "value");
      if (L !== null)
        return L;
      if (b.type === "submit")
        return "Submit";
      if (b.type === "reset")
        return "Reset";
    }
    var $ = $7(b);
    if ($ !== null && $.length !== 0)
      return r.add(b), dn($).map(function(J) {
        return _(J, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(J) {
        return J.length > 0;
      }).join(" ");
    if (Yu(b) && b.type === "image") {
      var I = m(b, "alt");
      if (I !== null)
        return I;
      var D = m(b, "title");
      return D !== null ? D : "Submit Query";
    }
    if (io(b, ["button"])) {
      var F = h(b, {
        isEmbeddedInLabel: !1
      });
      if (F !== "")
        return F;
    }
    return null;
  }
  u(w, "computeElementTextAlternative");
  function _(b, x) {
    if (r.has(b))
      return "";
    if (!f && b7(b, l) && !x.isReferenced)
      return r.add(b), "";
    var P = gt(b) ? b.getAttributeNode("aria-labelledby") : null, R = P !== null && !r.has(P) ? Ud(b, "aria-labelledby") : [];
    if (a === "name" && !x.isReferenced && R.length > 0)
      return r.add(P), R.map(function(k) {
        return _(k, {
          isEmbeddedInLabel: x.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var N = x.recursion && v7(b) && a === "name";
    if (!N) {
      var C = (gt(b) && b.getAttribute("aria-label") || "").trim();
      if (C !== "" && a === "name")
        return r.add(b), C;
      if (!_7(b)) {
        var A = w(b);
        if (A !== null)
          return r.add(b), A;
      }
    }
    if (io(b, ["menu"]))
      return r.add(b), "";
    if (N || x.isEmbeddedInLabel || x.isReferenced) {
      if (io(b, ["combobox", "listbox"])) {
        r.add(b);
        var E = w7(b);
        return E.length === 0 ? Yu(b) ? b.value : "" : dn(E).map(function(k) {
          return _(k, {
            isEmbeddedInLabel: x.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (gC(b, "range"))
        return r.add(b), b.hasAttribute("aria-valuetext") ? b.getAttribute("aria-valuetext") : b.hasAttribute("aria-valuenow") ? b.getAttribute("aria-valuenow") : b.getAttribute("value") || "";
      if (io(b, ["textbox"]))
        return r.add(b), T7(b);
    }
    if (x7(b) || gt(b) && x.isReferenced || E7(b) || S7()) {
      var T = h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
      if (T !== "")
        return r.add(b), T;
    }
    if (b.nodeType === b.TEXT_NODE)
      return r.add(b), b.textContent || "";
    if (x.recursion)
      return r.add(b), h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
    var O = g(b);
    return O !== null ? (r.add(b), O) : (r.add(b), "");
  }
  return u(_, "computeTextAlternative"), g7(_(e, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: a === "description",
    recursion: !1
  }));
}
u(wC, "computeTextAlternative");
function sc(e) {
  "@babel/helpers - typeof";
  return sc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sc(e);
}
u(sc, "_typeof");
function H0(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
u(H0, "ownKeys");
function V0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H0(Object(r), !0).forEach(function(n) {
      k7(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : H0(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
u(V0, "_objectSpread");
function k7(e, t, r) {
  return t = P7(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
u(k7, "_defineProperty");
function P7(e) {
  var t = O7(e, "string");
  return sc(t) === "symbol" ? t : String(t);
}
u(P7, "_toPropertyKey");
function O7(e, t) {
  if (sc(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (sc(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
u(O7, "_toPrimitive");
function R7(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = Ud(e, "aria-describedby").map(function(a) {
    return wC(a, V0(V0({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("aria-description");
    r = n === null ? "" : n;
  }
  if (r === "") {
    var o = e.getAttribute("title");
    r = o === null ? "" : o;
  }
  return r;
}
u(R7, "computeAccessibleDescription");
function j7(e) {
  return io(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
u(j7, "prohibitsNaming");
function I7(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return j7(e) ? "" : wC(e, t);
}
u(I7, "computeAccessibleName");
var _C = ar($$(), 1), EAe = ar(KW(), 1), xAe = ar(UG(), 1), N7 = class extends Error {
  constructor(e, t, r, n) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, r);
    let o = "";
    try {
      o = n.utils.printWithType(
        "Received",
        t,
        n.utils.printReceived
      );
    } catch {
    }
    this.message = [
      n.utils.matcherHint(
        `${n.isNot ? ".not" : ""}.${r.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${n.utils.RECEIVED_COLOR(
        "received"
      )} value must ${e}.`,
      o
    ].join(`
`);
  }
};
u(N7, "GenericTypeError");
var M7 = N7, D7 = class extends M7 {
  constructor(...e) {
    super("be an HTMLElement or an SVGElement", ...e);
  }
};
u(D7, "HtmlElementTypeError");
var Ij = D7, q7 = class extends M7 {
  constructor(...e) {
    super("be a Node", ...e);
  }
};
u(q7, "NodeTypeError");
var Nj = q7;
function EC(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView)
    throw new t(e, ...r);
}
u(EC, "checkHasWindow");
function L7(e, ...t) {
  EC(e, Nj, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node))
    throw new Nj(e, ...t);
}
u(L7, "checkNode");
function Qe(e, ...t) {
  EC(e, Ij, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement))
    throw new Ij(e, ...t);
}
u(Qe, "checkHtmlElement");
var F7 = class extends Error {
  constructor(e, t, r) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, t), this.message = [
      e.message,
      "",
      // eslint-disable-next-line new-cap
      r.utils.RECEIVED_COLOR("Failing css:"),
      // eslint-disable-next-line new-cap
      r.utils.RECEIVED_COLOR(`${e.css}`)
    ].join(`
`);
  }
};
u(F7, "InvalidCSSError");
var SAe = F7;
function U7(e, ...t) {
  const r = mAe(`selector { ${e} }`, { silent: !0 }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    const { reason: n, line: o } = r.parsingErrors[0];
    throw new SAe(
      {
        css: e,
        message: `Syntax error parsing expected css: ${n} on line: ${o}`
      },
      ...t
    );
  }
  return r.rules[0].declarations.filter((n) => n.type === "declaration").reduce(
    (n, { property: o, value: a }) => Object.assign(n, { [o]: a }),
    {}
  );
}
u(U7, "parseCSS");
function z0(e, t) {
  return typeof t == "string" ? t : e.utils.stringify(t);
}
u(z0, "display");
function Lt(e, t, r, n, o, a) {
  return [
    `${t}
`,
    // eslint-disable-next-line new-cap
    `${r}:
${e.utils.EXPECTED_COLOR(
      (0, Rj.default)(z0(e, n), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${o}:
${e.utils.RECEIVED_COLOR(
      (0, Rj.default)(z0(e, a), 2)
    )}`
  ].join(`
`);
}
u(Lt, "getMessage");
function B7(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
u(B7, "matches");
function jp(e, t) {
  console.warn(
    `Warning: ${e} has been deprecated and will be removed in future updates.`,
    t
  );
}
u(jp, "deprecate");
function Ip(e) {
  return e.replace(/\s+/g, " ").trim();
}
u(Ip, "normalize");
function na(e) {
  return e.tagName && e.tagName.toLowerCase();
}
u(na, "getTag");
function H7({ multiple: e, options: t }) {
  const r = [...t].filter((n) => n.selected);
  if (e)
    return [...r].map((n) => n.value);
  if (r.length !== 0)
    return r[0].value;
}
u(H7, "getSelectValue");
function V7(e) {
  switch (e.type) {
    case "number":
      return e.value === "" ? null : Number(e.value);
    case "checkbox":
      return e.checked;
    default:
      return e.value;
  }
}
u(V7, "getInputValue");
var TAe = ["meter", "progressbar", "slider", "spinbutton"];
function z7(e) {
  if (TAe.includes(e.getAttribute("role")))
    return Number(e.getAttribute("aria-valuenow"));
}
u(z7, "getAccessibleValue");
function xC(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case "input":
        return V7(e);
      case "select":
        return H7(e);
      default:
        return e.value ?? z7(e);
    }
}
u(xC, "getSingleElementValue");
function J7(e, { wordConnector: t = ", ", lastWordConnector: r = " and " } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(
    e.length > 1 ? r : ""
  );
}
u(J7, "toSentence");
function mb(e, t) {
  return Array.isArray(e) && Array.isArray(t) ? [...new Set(e)].every((r) => new Set(t).has(r)) : e === t;
}
u(mb, "compareAsSet");
function pm(e, t) {
  return jp(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  ), e && Qe(e, pm, this), t && Qe(t, pm, this), {
    pass: t ? t.contains(e) : !!e,
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(
        e && e.cloneNode(!1)
      )}`
    ].join(`
`), "message")
  };
}
u(pm, "toBeInTheDOM");
function SC(e) {
  (e !== null || !this.isNot) && Qe(e, SC, this);
  const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }), r = /* @__PURE__ */ u(() => `expected document not to contain element, found ${this.utils.stringify(
    e.cloneNode(!0)
  )} instead`, "errorFound"), n = /* @__PURE__ */ u(() => "element could not be found in the document", "errorNotFound");
  return {
    pass: t,
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
        "element",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(this.isNot ? r() : n())
    ].join(`
`), "message")
  };
}
u(SC, "toBeInTheDocument");
function TC(e) {
  return jp(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  ), Qe(e, TC, this), {
    pass: e.innerHTML === "",
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmpty`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
u(TC, "toBeEmpty");
function AC(e) {
  return Qe(e, AC, this), {
    pass: W7(e),
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
u(AC, "toBeEmptyDOMElement");
function W7(e) {
  return [...e.childNodes].filter((t) => t.nodeType !== 8).length === 0;
}
u(W7, "isEmptyElement");
function fm(e, t) {
  return Qe(e, fm, this), t !== null && Qe(t, fm, this), {
    pass: e.contains(t),
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainElement`,
        "element",
        "element"
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(`${this.utils.stringify(
        e.cloneNode(!1)
      )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(t && t.cloneNode(!1))}
        `)
    ].join(`
`), "message")
  };
}
u(fm, "toContainElement");
function G7(e, t) {
  const r = e.ownerDocument.createElement("div");
  return r.innerHTML = t, r.innerHTML;
}
u(G7, "getNormalizedHtml");
function $C(e, t) {
  if (Qe(e, $C, this), typeof t != "string")
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(G7(e, t)),
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainHTML`,
        "element",
        ""
      ),
      "Expected:",
      // eslint-disable-next-line new-cap
      `  ${this.utils.EXPECTED_COLOR(t)}`,
      "Received:",
      `  ${this.utils.printReceived(e.cloneNode(!0))}`
    ].join(`
`), "message")
  };
}
u($C, "toContainHTML");
function CC(e, t, r = { normalizeWhitespace: !0 }) {
  L7(e, CC, this);
  const n = r.normalizeWhitespace ? Ip(e.textContent) : e.textContent.replace(/\u00a0/g, " "), o = n !== "" && t === "";
  return {
    pass: !o && B7(n, t),
    message: /* @__PURE__ */ u(() => {
      const a = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        o ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${a} have text content`,
        t,
        "Received",
        n
      );
    }, "message")
  };
}
u(CC, "toHaveTextContent");
function hm(e, t) {
  Qe(e, hm, this);
  const r = R7(e), n = arguments.length === 1;
  let o = !1;
  return n ? o = r !== "" : o = t instanceof RegExp ? t.test(r) : this.equals(
    r,
    t
  ), {
    pass: o,
    message: /* @__PURE__ */ u(() => {
      const a = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${hm.name}`,
          "element",
          ""
        ),
        `Expected element ${a} have accessible description`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
u(hm, "toHaveAccessibleDescription");
var uu = "aria-invalid", AAe = ["false"];
function kC(e, t) {
  Qe(e, kC, this);
  const r = this.isNot ? "not to" : "to", n = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", o = e.getAttribute("aria-errormessage");
  if (o && /\s+/.test(o))
    return {
      pass: !1,
      message: /* @__PURE__ */ u(() => Lt(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
        "",
        "Received",
        `aria-errormessage="${o}"`
      ), "message")
    };
  const a = e.getAttribute(uu);
  if (!e.hasAttribute(uu) || AAe.includes(a))
    return {
      pass: !1,
      message: /* @__PURE__ */ u(() => Lt(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element to be marked as invalid with attribute",
        `${uu}="${String(!0)}"`,
        "Received",
        e.hasAttribute("aria-invalid") ? `${uu}="${e.getAttribute(uu)}` : null
      ), "message")
    };
  const i = Ip(
    e.ownerDocument.getElementById(o)?.textContent ?? ""
  );
  return {
    pass: t === void 0 ? !!i : t instanceof RegExp ? t.test(i) : this.equals(i, t),
    message: /* @__PURE__ */ u(() => Lt(
      this,
      this.utils.matcherHint(n, "element"),
      `Expected element ${r} have accessible error message`,
      t ?? "",
      "Received",
      i
    ), "message")
  };
}
u(kC, "toHaveAccessibleErrorMessage");
var $Ae = X7(_C.elementRoles);
function mm(e, t) {
  Qe(e, mm, this);
  const r = K7(e);
  return {
    pass: r.some((n) => n === t),
    message: /* @__PURE__ */ u(() => {
      const n = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${mm.name}`,
          "element",
          ""
        ),
        `Expected element ${n} have role`,
        t,
        "Received",
        r.join(", ")
      );
    }, "message")
  };
}
u(mm, "toHaveRole");
function K7(e) {
  return e.hasAttribute("role") ? e.getAttribute("role").split(" ").filter(Boolean) : Y7(e);
}
u(K7, "getExplicitOrImplicitRoles");
function Y7(e) {
  for (const { match: t, roles: r } of $Ae)
    if (t(e))
      return [...r];
  return [];
}
u(Y7, "getImplicitAriaRoles");
function X7(e) {
  function t({ name: i, attributes: s }) {
    return `${i}${s.map(({ name: d, value: l, constraints: p = [] }) => p.indexOf("undefined") !== -1 ? `:not([${d}])` : l ? `[${d}="${l}"]` : `[${d}]`).join("")}`;
  }
  u(t, "makeElementSelector");
  function r({ attributes: i = [] }) {
    return i.length;
  }
  u(r, "getSelectorSpecificity");
  function n({ specificity: i }, { specificity: s }) {
    return s - i;
  }
  u(n, "bySelectorSpecificity");
  function o(i) {
    let { attributes: s = [] } = i;
    const d = s.findIndex(
      (p) => p.value && p.name === "type" && p.value === "text"
    );
    d >= 0 && (s = [
      ...s.slice(0, d),
      ...s.slice(d + 1)
    ]);
    const l = t({ ...i, attributes: s });
    return (p) => d >= 0 && p.type !== "text" ? !1 : p.matches(l);
  }
  u(o, "match");
  let a = [];
  for (const [i, s] of e.entries())
    a = [
      ...a,
      {
        match: o(i),
        roles: Array.from(s),
        specificity: r(i)
      }
    ];
  return a.sort(n);
}
u(X7, "buildElementRoleList");
function ym(e, t) {
  Qe(e, ym, this);
  const r = I7(e), n = arguments.length === 1;
  let o = !1;
  return n ? o = r !== "" : o = t instanceof RegExp ? t.test(r) : this.equals(r, t), {
    pass: o,
    message: /* @__PURE__ */ u(() => {
      const a = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${ym.name}`,
          "element",
          ""
        ),
        `Expected element ${a} have accessible name`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
u(ym, "toHaveAccessibleName");
function J0(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
u(J0, "printAttribute");
function Q7(e, t, r) {
  return r === void 0 ? `element.hasAttribute(${e(t)})` : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
u(Q7, "getAttributeComment");
function PC(e, t, r) {
  Qe(e, PC, this);
  const n = r !== void 0, o = e.hasAttribute(t), a = e.getAttribute(t);
  return {
    pass: n ? o && this.equals(a, r) : o,
    message: /* @__PURE__ */ u(() => {
      const i = this.isNot ? "not to" : "to", s = o ? J0(this.utils.stringify, t, a) : null, d = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(t),
        {
          secondArgument: n ? this.utils.printExpected(r) : void 0,
          comment: Q7(
            this.utils.stringify,
            t,
            r
          )
        }
      );
      return Lt(
        this,
        d,
        `Expected the element ${i} have attribute`,
        J0(this.utils.stringify, t, r),
        "Received",
        s
      );
    }, "message")
  };
}
u(PC, "toHaveAttribute");
function Z7(e) {
  const t = e.pop();
  let r, n;
  return typeof t == "object" && !(t instanceof RegExp) ? (r = e, n = t) : (r = e.concat(t), n = { exact: !1 }), { expectedClassNames: r, options: n };
}
u(Z7, "getExpectedClassNamesAndOptions");
function W0(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
u(W0, "splitClassNames");
function G0(e, t) {
  return e.every(
    (r) => typeof r == "string" ? t.includes(r) : t.some((n) => r.test(n))
  );
}
u(G0, "isSubset$1");
function OC(e, ...t) {
  Qe(e, OC, this);
  const { expectedClassNames: r, options: n } = Z7(t), o = W0(e.getAttribute("class")), a = r.reduce(
    (s, d) => s.concat(
      typeof d == "string" || !d ? W0(d) : d
    ),
    []
  ), i = a.some((s) => s instanceof RegExp);
  if (n.exact && i)
    throw new Error("Exact option does not support RegExp expected class names");
  return n.exact ? {
    pass: G0(a, o) && a.length === o.length,
    message: /* @__PURE__ */ u(() => {
      const s = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(a.join(" "))
        ),
        `Expected the element ${s} have EXACTLY defined classes`,
        a.join(" "),
        "Received",
        o.join(" ")
      );
    }, "message")
  } : a.length > 0 ? {
    pass: G0(a, o),
    message: /* @__PURE__ */ u(() => {
      const s = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(a.join(" "))
        ),
        `Expected the element ${s} have class`,
        a.join(" "),
        "Received",
        o.join(" ")
      );
    }, "message")
  } : {
    pass: this.isNot ? o.length > 0 : !1,
    message: /* @__PURE__ */ u(() => this.isNot ? Lt(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      o.join(" ")
    ) : [
      this.utils.matcherHint(".toHaveClass", "element"),
      "At least one expected class must be provided."
    ].join(`
`), "message")
  };
}
u(OC, "toHaveClass");
function eK(e, t) {
  const r = {}, n = e.createElement("div");
  return Object.keys(t).forEach((o) => {
    n.style[o] = t[o], r[o] = n.style[o];
  }), r;
}
u(eK, "getStyleDeclaration");
function tK(e, t) {
  return !!Object.keys(e).length && Object.entries(e).every(([r, n]) => {
    const o = r.startsWith("--"), a = [r];
    return o || a.push(r.toLowerCase()), a.some(
      (i) => t[i] === n || t.getPropertyValue(i) === n
    );
  });
}
u(tK, "isSubset");
function K0(e) {
  return Object.keys(e).sort().map((t) => `${t}: ${e[t]};`).join(`
`);
}
u(K0, "printoutStyles");
function rK(e, t, r) {
  const n = Array.from(r).filter((o) => t[o] !== void 0).reduce(
    (o, a) => Object.assign(o, { [a]: r.getPropertyValue(a) }),
    {}
  );
  return e(K0(t), K0(n)).replace(`${EAe.default.red("+ Received")}
`, "");
}
u(rK, "expectedDiff");
function gm(e, t) {
  Qe(e, gm, this);
  const r = typeof t == "object" ? t : U7(t, gm, this), { getComputedStyle: n } = e.ownerDocument.defaultView, o = eK(e.ownerDocument, r), a = n(e);
  return {
    pass: tK(o, a),
    message: /* @__PURE__ */ u(() => {
      const i = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(i, "element", ""),
        rK(this.utils.diff, o, a)
      ].join(`

`);
    }, "message")
  };
}
u(gm, "toHaveStyle");
function RC(e) {
  return Qe(e, RC, this), {
    pass: e.ownerDocument.activeElement === e,
    message: /* @__PURE__ */ u(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveFocus`,
        "element",
        ""
      ),
      "",
      ...this.isNot ? [
        "Received element is focused:",
        `  ${this.utils.printReceived(e)}`
      ] : [
        "Expected element with focus:",
        `  ${this.utils.printExpected(e)}`,
        "Received element with focus:",
        `  ${this.utils.printReceived(
          e.ownerDocument.activeElement
        )}`
      ]
    ].join(`
`), "message")
  };
}
u(RC, "toHaveFocus");
function nK(e) {
  const t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  switch (t[0]) {
    case "radio": {
      const r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case "checkbox":
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
u(nK, "getMultiElementValue");
function oK(e, t) {
  const r = [...e.querySelectorAll(`[name="${(0, xAe.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return xC(r[0]);
      default:
        return nK(r);
    }
}
u(oK, "getFormValue");
function aK(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
u(aK, "getPureName");
function iK(e) {
  return Array.from(e.elements).map((t) => t.name).reduce(
    (t, r) => ({
      ...t,
      [aK(r)]: oK(e, r)
    }),
    {}
  );
}
u(iK, "getAllFormValues");
function jC(e, t) {
  if (Qe(e, jC, this), !e.elements)
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  const r = iK(e);
  return {
    pass: Object.entries(t).every(
      ([n, o]) => mb(r[n], o)
    ),
    message: /* @__PURE__ */ u(() => {
      const n = this.isNot ? "not to" : "to", o = `${this.isNot ? ".not" : ""}.toHaveFormValues`, a = Object.keys(r).filter((i) => t.hasOwnProperty(i)).reduce((i, s) => ({ ...i, [s]: r[s] }), {});
      return [
        this.utils.matcherHint(o, "element", ""),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, a)
      ].join(`

`);
    }, "message")
  };
}
u(jC, "toHaveFormValues");
function sK(e) {
  const { getComputedStyle: t } = e.ownerDocument.defaultView, { display: r, visibility: n, opacity: o } = t(e);
  return r !== "none" && n !== "hidden" && n !== "collapse" && o !== "0" && o !== 0;
}
u(sK, "isStyleVisible");
function lK(e, t) {
  let r;
  return t ? r = e.nodeName === "DETAILS" && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0 : r = e.nodeName === "DETAILS" ? e.hasAttribute("open") : !0, !e.hasAttribute("hidden") && r;
}
u(lK, "isAttributeVisible");
function IC(e, t) {
  return sK(e) && lK(e, t) && (!e.parentElement || IC(e.parentElement, e));
}
u(IC, "isElementVisible");
function NC(e) {
  Qe(e, NC, this);
  const t = e.ownerDocument === e.getRootNode({ composed: !0 }), r = t && IC(e);
  return {
    pass: r,
    message: /* @__PURE__ */ u(() => {
      const n = r ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${n} visible${t ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(NC, "toBeVisible");
var CAe = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function cK(e, t) {
  return na(e) === "legend" && na(t) === "fieldset" && e.isSameNode(
    Array.from(t.children).find((r) => na(r) === "legend")
  );
}
u(cK, "isFirstLegendChildOfFieldset");
function uK(e, t) {
  return DC(t) && !cK(e, t);
}
u(uK, "isElementDisabledByParent");
function dK(e) {
  return e.includes("-");
}
u(dK, "isCustomElement");
function MC(e) {
  const t = na(e);
  return CAe.includes(t) || dK(t);
}
u(MC, "canElementBeDisabled");
function DC(e) {
  return MC(e) && e.hasAttribute("disabled");
}
u(DC, "isElementDisabled");
function qC(e) {
  const t = e.parentElement;
  return !!t && (uK(e, t) || qC(t));
}
u(qC, "isAncestorDisabled");
function LC(e) {
  return MC(e) && (DC(e) || qC(e));
}
u(LC, "isElementOrAncestorDisabled");
function FC(e) {
  Qe(e, FC, this);
  const t = LC(e);
  return {
    pass: t,
    message: /* @__PURE__ */ u(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(FC, "toBeDisabled");
function UC(e) {
  Qe(e, UC, this);
  const t = !LC(e);
  return {
    pass: t,
    message: /* @__PURE__ */ u(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(UC, "toBeEnabled");
var kAe = ["select", "textarea"], PAe = ["input", "select", "textarea"], OAe = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
], RAe = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function pK(e) {
  return kAe.includes(na(e)) && e.hasAttribute("required");
}
u(pK, "isRequiredOnFormTagsExceptInput");
function fK(e) {
  return na(e) === "input" && e.hasAttribute("required") && (e.hasAttribute("type") && !OAe.includes(e.getAttribute("type")) || !e.hasAttribute("type"));
}
u(fK, "isRequiredOnSupportedInput");
function hK(e) {
  return e.hasAttribute("aria-required") && e.getAttribute("aria-required") === "true" && (PAe.includes(na(e)) || e.hasAttribute("role") && RAe.includes(e.getAttribute("role")));
}
u(hK, "isElementRequiredByARIA");
function BC(e) {
  Qe(e, BC, this);
  const t = pK(e) || fK(e) || hK(e);
  return {
    pass: t,
    message: /* @__PURE__ */ u(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(BC, "toBeRequired");
var jAe = ["form", "input", "select", "textarea"];
function mK(e) {
  return e.hasAttribute("aria-invalid") && e.getAttribute("aria-invalid") !== "false";
}
u(mK, "isElementHavingAriaInvalid");
function yK(e) {
  return jAe.includes(na(e));
}
u(yK, "isSupportsValidityMethod");
function HC(e) {
  const t = mK(e);
  return yK(e) ? t || !e.checkValidity() : t;
}
u(HC, "isElementInvalid");
function VC(e) {
  Qe(e, VC, this);
  const t = HC(e);
  return {
    pass: t,
    message: /* @__PURE__ */ u(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(VC, "toBeInvalid");
function zC(e) {
  Qe(e, zC, this);
  const t = !HC(e);
  return {
    pass: t,
    message: /* @__PURE__ */ u(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(zC, "toBeValid");
function JC(e, t) {
  if (Qe(e, JC, this), e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type))
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  const r = xC(e), n = t !== void 0;
  let o = t, a = r;
  return t == r && t !== r && (o = `${t} (${typeof t})`, a = `${r} (${typeof r})`), {
    pass: n ? mb(r, t) : !!r,
    message: /* @__PURE__ */ u(() => {
      const i = this.isNot ? "not to" : "to", s = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        t
      );
      return Lt(
        this,
        s,
        `Expected the element ${i} have value`,
        n ? o : "(any)",
        "Received",
        a
      );
    }, "message")
  };
}
u(JC, "toHaveValue");
function WC(e, t) {
  Qe(e, WC, this);
  const r = e.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(r))
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  if (r === "input" && ["radio", "checkbox"].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`
    );
  const n = gK(r, e), o = bK(t), a = o.filter(
    (d) => n.some(
      (l) => d instanceof RegExp ? d.test(l) : this.equals(l, String(d))
    )
  ).length, i = a === n.length, s = a === o.length;
  return {
    pass: i && s,
    message: /* @__PURE__ */ u(() => Lt(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      t,
      "Received",
      n
    ), "message")
  };
}
u(WC, "toHaveDisplayValue");
function gK(e, t) {
  return e === "select" ? Array.from(t).filter((r) => r.selected).map((r) => r.textContent) : [t.value];
}
u(gK, "getValues");
function bK(e) {
  return e instanceof Array ? e : [e];
}
u(bK, "getExpectedValues");
function GC(e) {
  Qe(e, GC, this);
  const t = /* @__PURE__ */ u(() => e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type), "isValidInput"), r = /* @__PURE__ */ u(() => KC(e.getAttribute("role")) && ["true", "false"].includes(e.getAttribute("aria-checked")), "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: !1,
      message: /* @__PURE__ */ u(() => `only inputs with type="checkbox" or type="radio" or elements with ${vK()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`, "message")
    };
  const n = /* @__PURE__ */ u(() => t() ? e.checked : e.getAttribute("aria-checked") === "true", "isChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ u(() => {
      const o = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${o} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(GC, "toBeChecked");
function vK() {
  return J7(
    wK().map((e) => `role="${e}"`),
    { lastWordConnector: " or " }
  );
}
u(vK, "supportedRolesSentence");
function wK() {
  return _C.roles.keys().filter(KC);
}
u(wK, "supportedRoles");
function KC(e) {
  return _C.roles.get(e)?.props["aria-checked"] !== void 0;
}
u(KC, "roleSupportsChecked");
function YC(e) {
  Qe(e, YC, this);
  const t = /* @__PURE__ */ u(() => e.tagName.toLowerCase() === "input" && e.type === "checkbox", "isValidInput"), r = /* @__PURE__ */ u(() => e.getAttribute("role") === "checkbox", "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: !1,
      message: /* @__PURE__ */ u(() => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead', "message")
    };
  const n = /* @__PURE__ */ u(() => {
    const o = e.getAttribute("aria-checked") === "mixed";
    return t() && e.indeterminate || o;
  }, "isPartiallyChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ u(() => {
      const o = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${o} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
u(YC, "toBePartiallyChecked");
function XC(e, t) {
  jp(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  ), Qe(e, XC, this);
  const r = t !== void 0, n = (e.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean);
  let o = "";
  if (n.length > 0) {
    const a = e.ownerDocument, i = n.map((s) => a.getElementById(s)).filter(Boolean);
    o = Ip(i.map((s) => s.textContent).join(" "));
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(o) : this.equals(o, t) : !!o,
    message: /* @__PURE__ */ u(() => {
      const a = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${a} have description`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(o)
      );
    }, "message")
  };
}
u(XC, "toHaveDescription");
function QC(e, t) {
  if (jp("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), Qe(e, QC, this), !e.hasAttribute("aria-invalid") || e.getAttribute("aria-invalid") === "false") {
    const a = this.isNot ? ".not" : "";
    return {
      pass: !1,
      message: /* @__PURE__ */ u(() => Lt(
        this,
        this.utils.matcherHint(`${a}.toHaveErrorMessage`, "element", ""),
        "Expected the element to have invalid state indicated by",
        'aria-invalid="true"',
        "Received",
        e.hasAttribute("aria-invalid") ? `aria-invalid="${e.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
      ), "message")
    };
  }
  const r = t !== void 0, n = (e.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean);
  let o = "";
  if (n.length > 0) {
    const a = e.ownerDocument, i = n.map((s) => a.getElementById(s)).filter(Boolean);
    o = Ip(
      i.map((s) => s.textContent).join(" ")
    );
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(o) : this.equals(o, t) : !!o,
    message: /* @__PURE__ */ u(() => {
      const a = this.isNot ? "not to" : "to";
      return Lt(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${a} have error message`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(o)
      );
    }, "message")
  };
}
u(QC, "toHaveErrorMessage");
function _K(e) {
  const t = e.ownerDocument.getSelection();
  if (["input", "textarea"].includes(e.tagName.toLowerCase()))
    return ["radio", "checkbox"].includes(e.type) ? "" : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null)
    return "";
  const r = t.getRangeAt(0), n = e.ownerDocument.createRange();
  if (t.containsNode(e, !1))
    n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n);
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    const a = e === r.startContainer || e.contains(r.startContainer), i = e === r.endContainer || e.contains(r.endContainer);
    t.removeAllRanges(), (a || i) && (n.selectNodeContents(e), a && n.setStart(
      r.startContainer,
      r.startOffset
    ), i && n.setEnd(
      r.endContainer,
      r.endOffset
    ), t.addRange(n));
  }
  const o = t.toString();
  return t.removeAllRanges(), t.addRange(r), o;
}
u(_K, "getSelection");
function ZC(e, t) {
  Qe(e, ZC, this);
  const r = t !== void 0;
  if (r && typeof t != "string")
    throw new Error("expected selection must be a string or undefined");
  const n = _K(e);
  return {
    pass: r ? mb(n, t) : !!n,
    message: /* @__PURE__ */ u(() => {
      const o = this.isNot ? "not to" : "to", a = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        t
      );
      return Lt(
        this,
        a,
        `Expected the element ${o} have selection`,
        r ? t : "(any)",
        "Received",
        n
      );
    }, "message")
  };
}
u(ZC, "toHaveSelection");
function ek(e) {
  Qe(e, ek, this);
  const t = (e.getAttribute("role") || "").split(" ").map((o) => o.trim()), r = e.tagName.toLowerCase() === "button" || e.tagName.toLowerCase() === "input" && e.type === "button" || t.includes("button"), n = e.getAttribute("aria-pressed");
  return !r || !(n === "true" || n === "false") ? {
    pass: !1,
    message: /* @__PURE__ */ u(() => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()', "message")
  } : {
    pass: r && n === "true",
    message: /* @__PURE__ */ u(() => {
      const o = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePressed`,
        "element",
        ""
      );
      return Lt(
        this,
        o,
        "Expected element to have",
        `aria-pressed="${this.isNot ? "false" : "true"}"`,
        "Received",
        `aria-pressed="${n}"`
      );
    }, "message")
  };
}
u(ek, "toBePressed");
function tk(e) {
  Qe(e, tk, this);
  const t = (e.getAttribute("role") || "").split(" ").map((o) => o.trim()), r = e.tagName.toLowerCase() === "button" || e.tagName.toLowerCase() === "input" && e.type === "button" || t.includes("button"), n = e.getAttribute("aria-pressed");
  return !r || !(n === "true" || n === "false" || n === "mixed") ? {
    pass: !1,
    message: /* @__PURE__ */ u(() => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()', "message")
  } : {
    pass: r && n === "mixed",
    message: /* @__PURE__ */ u(() => {
      const o = this.isNot ? "not to" : "to", a = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePartiallyPressed`,
        "element",
        ""
      );
      return Lt(
        this,
        a,
        `Expected element ${o} have`,
        'aria-pressed="mixed"',
        "Received",
        `aria-pressed="${n}"`
      );
    }, "message")
  };
}
u(tk, "toBePartiallyPressed");
ar(FG(), 1);
ar($$(), 1);
ar(KW(), 1);
ar(UG(), 1);
var Dv, Mj;
function EK() {
  if (Mj) return Dv;
  Mj = 1;
  var e, t, r, n, o, a, i, s, d, l, p, f, h, m, g, w, _, b, x;
  return h = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, f = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, e = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, p = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, w = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, x = /[\t\v\f\ufeff\p{Zs}]+/yu, s = /\r?\n|[\r\u2028\u2029]/y, d = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, m = /\/\/.*/y, r = /[<>.:={}]|\/(?![\/*])/y, t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, n = /(['"])(?:(?!\1)[^])*(\1)?/y, o = /[^<>{}]+/y, b = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, _ = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, a = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, i = /^(?:return|throw|yield)$/, l = RegExp(s.source), Dv = /* @__PURE__ */ u(function* (P, { jsx: R = !1 } = {}) {
    var N, C, A, E, T, O, k, M, L, $, I, D, F, J;
    for ({ length: O } = P, E = 0, T = "", J = [
      { tag: "JS" }
    ], N = [], I = 0, D = !1; E < O; ) {
      switch (M = J[J.length - 1], M.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (P[E] === "/" && (b.test(T) || a.test(T)) && (h.lastIndex = E, k = h.exec(P))) {
            E = h.lastIndex, T = k[0], D = !0, yield {
              type: "RegularExpressionLiteral",
              value: k[0],
              closed: k[1] !== void 0 && k[1] !== "\\"
            };
            continue;
          }
          if (f.lastIndex = E, k = f.exec(P)) {
            switch (F = k[0], L = f.lastIndex, $ = F, F) {
              case "(":
                T === "?NonExpressionParenKeyword" && J.push({
                  tag: "JSNonExpressionParen",
                  nesting: I
                }), I++, D = !1;
                break;
              case ")":
                I--, D = !0, M.tag === "JSNonExpressionParen" && I === M.nesting && (J.pop(), $ = "?NonExpressionParenEnd", D = !1);
                break;
              case "{":
                f.lastIndex = 0, A = !_.test(T) && (b.test(T) || a.test(T)), N.push(A), D = !1;
                break;
              case "}":
                switch (M.tag) {
                  case "InterpolationInTemplate":
                    if (N.length === M.nesting) {
                      w.lastIndex = E, k = w.exec(P), E = w.lastIndex, T = k[0], k[1] === "${" ? (T = "?InterpolationInTemplate", D = !1, yield {
                        type: "TemplateMiddle",
                        value: k[0]
                      }) : (J.pop(), D = !0, yield {
                        type: "TemplateTail",
                        value: k[0],
                        closed: k[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (N.length === M.nesting) {
                      J.pop(), E += 1, T = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                D = N.pop(), $ = D ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                D = !0;
                break;
              case "++":
              case "--":
                $ = D ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (R && (b.test(T) || a.test(T))) {
                  J.push({ tag: "JSXTag" }), E += 1, T = "<", yield {
                    type: "JSXPunctuator",
                    value: F
                  };
                  continue;
                }
                D = !1;
                break;
              default:
                D = !1;
            }
            E = L, T = $, yield {
              type: "Punctuator",
              value: F
            };
            continue;
          }
          if (e.lastIndex = E, k = e.exec(P)) {
            switch (E = e.lastIndex, $ = k[0], k[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                T !== "." && T !== "?." && ($ = "?NonExpressionParenKeyword");
            }
            T = $, D = !a.test(k[0]), yield {
              type: k[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: k[0]
            };
            continue;
          }
          if (g.lastIndex = E, k = g.exec(P)) {
            E = g.lastIndex, T = k[0], D = !0, yield {
              type: "StringLiteral",
              value: k[0],
              closed: k[2] !== void 0
            };
            continue;
          }
          if (p.lastIndex = E, k = p.exec(P)) {
            E = p.lastIndex, T = k[0], D = !0, yield {
              type: "NumericLiteral",
              value: k[0]
            };
            continue;
          }
          if (w.lastIndex = E, k = w.exec(P)) {
            E = w.lastIndex, T = k[0], k[1] === "${" ? (T = "?InterpolationInTemplate", J.push({
              tag: "InterpolationInTemplate",
              nesting: N.length
            }), D = !1, yield {
              type: "TemplateHead",
              value: k[0]
            }) : (D = !0, yield {
              type: "NoSubstitutionTemplate",
              value: k[0],
              closed: k[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (r.lastIndex = E, k = r.exec(P)) {
            switch (E = r.lastIndex, $ = k[0], k[0]) {
              case "<":
                J.push({ tag: "JSXTag" });
                break;
              case ">":
                J.pop(), T === "/" || M.tag === "JSXTagEnd" ? ($ = "?JSX", D = !0) : J.push({ tag: "JSXChildren" });
                break;
              case "{":
                J.push({
                  tag: "InterpolationInJSX",
                  nesting: N.length
                }), $ = "?InterpolationInJSX", D = !1;
                break;
              case "/":
                T === "<" && (J.pop(), J[J.length - 1].tag === "JSXChildren" && J.pop(), J.push({ tag: "JSXTagEnd" }));
            }
            T = $, yield {
              type: "JSXPunctuator",
              value: k[0]
            };
            continue;
          }
          if (t.lastIndex = E, k = t.exec(P)) {
            E = t.lastIndex, T = k[0], yield {
              type: "JSXIdentifier",
              value: k[0]
            };
            continue;
          }
          if (n.lastIndex = E, k = n.exec(P)) {
            E = n.lastIndex, T = k[0], yield {
              type: "JSXString",
              value: k[0],
              closed: k[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (o.lastIndex = E, k = o.exec(P)) {
            E = o.lastIndex, T = k[0], yield {
              type: "JSXText",
              value: k[0]
            };
            continue;
          }
          switch (P[E]) {
            case "<":
              J.push({ tag: "JSXTag" }), E++, T = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              J.push({
                tag: "InterpolationInJSX",
                nesting: N.length
              }), E++, T = "?InterpolationInJSX", D = !1, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (x.lastIndex = E, k = x.exec(P)) {
        E = x.lastIndex, yield {
          type: "WhiteSpace",
          value: k[0]
        };
        continue;
      }
      if (s.lastIndex = E, k = s.exec(P)) {
        E = s.lastIndex, D = !1, i.test(T) && (T = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: k[0]
        };
        continue;
      }
      if (d.lastIndex = E, k = d.exec(P)) {
        E = d.lastIndex, l.test(k[0]) && (D = !1, i.test(T) && (T = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: k[0],
          closed: k[1] !== void 0
        };
        continue;
      }
      if (m.lastIndex = E, k = m.exec(P)) {
        E = m.lastIndex, D = !1, yield {
          type: "SingleLineComment",
          value: k[0]
        };
        continue;
      }
      C = String.fromCodePoint(P.codePointAt(E)), E += C.length, T = C, D = !1, yield {
        type: M.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: C
      };
    }
  }, "jsTokens_1"), Dv;
}
u(EK, "requireJsTokens");
var IAe = EK();
h$(IAe);
var xK = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(xK.keyword);
new Set(xK.strict);
function Xu(e, t) {
  if (!e)
    throw new Error(t);
}
u(Xu, "assert");
function Vi(e, t) {
  return typeof t === e;
}
u(Vi, "isType");
function SK(e) {
  return e instanceof Promise;
}
u(SK, "isPromise");
function lc(e, t, r) {
  Object.defineProperty(e, t, r);
}
u(lc, "define");
function ts(e, t, r) {
  lc(e, t, { value: r, configurable: !0, writable: !0 });
}
u(ts, "defineValue");
var La = Symbol.for("tinyspy:spy"), NAe = /* @__PURE__ */ new Set(), MAe = /* @__PURE__ */ u((e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "reset"), DAe = /* @__PURE__ */ u((e) => (lc(e, La, {
  value: { reset: /* @__PURE__ */ u(() => MAe(e[La]), "reset") }
}), e[La]), "defineState"), Y0 = /* @__PURE__ */ u((e) => e[La] || DAe(e), "getInternalState");
function TK(e) {
  Xu(
    Vi("function", e) || Vi("undefined", e),
    "cannot spy on a non-function value"
  );
  let t = /* @__PURE__ */ u(function(...n) {
    let o = Y0(t);
    o.called = !0, o.callCount++, o.calls.push(n);
    let a = o.next.shift();
    if (a) {
      o.results.push(a);
      let [p, f] = a;
      if (p === "ok")
        return f;
      throw f;
    }
    let i, s = "ok", d = o.results.length;
    if (o.impl)
      try {
        new.target ? i = Reflect.construct(o.impl, n, new.target) : i = o.impl.apply(this, n), s = "ok";
      } catch (p) {
        throw i = p, s = "error", o.results.push([s, p]), p;
      }
    let l = [s, i];
    return SK(i) && i.then(
      (p) => o.resolves[d] = ["ok", p],
      (p) => o.resolves[d] = ["error", p]
    ), o.results.push(l), i;
  }, "fn");
  ts(t, "_isMockFunction", !0), ts(t, "length", e ? e.length : 0), ts(t, "name", e && e.name || "spy");
  let r = Y0(t);
  return r.reset(), r.impl = e, t;
}
u(TK, "createInternalSpy");
function AK(e) {
  return !!e && e._isMockFunction === !0;
}
u(AK, "isMockFunction");
var $K = /* @__PURE__ */ u((e, t) => {
  let r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return [e, r];
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    let o = Object.getOwnPropertyDescriptor(n, t);
    if (o)
      return [n, o];
    n = Object.getPrototypeOf(n);
  }
}, "getDescriptor"), Dj = /* @__PURE__ */ u((e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
}, "setPototype");
function rk(e, t, r) {
  Xu(
    !Vi("undefined", e),
    "spyOn could not find an object to spy upon"
  ), Xu(
    Vi("object", e) || Vi("function", e),
    "cannot spyOn on a primitive value"
  );
  let [n, o] = (() => {
    if (!Vi("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [a, i] = $K(e, n) || [];
  Xu(
    i || n in e,
    `${String(n)} does not exist`
  );
  let s = !1;
  o === "value" && i && !i.value && i.get && (o = "get", s = !0, r = i.get());
  let d;
  i ? d = i[o] : o !== "value" ? d = /* @__PURE__ */ u(() => e[n], "original") : d = e[n], d && PK(d) && (d = d[La].getOriginal());
  let l = /* @__PURE__ */ u((m) => {
    let { value: g, ...w } = i || {
      configurable: !0,
      writable: !0
    };
    o !== "value" && delete w.writable, w[o] = m, lc(e, n, w);
  }, "reassign"), p = /* @__PURE__ */ u(() => {
    a !== e ? Reflect.deleteProperty(e, n) : i && !d ? lc(e, n, i) : l(d);
  }, "restore");
  r || (r = d);
  let f = kK(TK(r), r);
  o === "value" && Dj(f, d);
  let h = f[La];
  return ts(h, "restore", p), ts(h, "getOriginal", () => s ? d() : d), ts(h, "willCall", (m) => (h.impl = m, f)), l(
    s ? () => (Dj(f, r), f) : f
  ), NAe.add(f), f;
}
u(rk, "internalSpyOn");
var qAe = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function CK(e) {
  let t = /* @__PURE__ */ new Set(), r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [
      ...Object.getOwnPropertyNames(e),
      ...Object.getOwnPropertySymbols(e)
    ];
    for (let o of n)
      r[o] || qAe.has(o) || (t.add(o), r[o] = Object.getOwnPropertyDescriptor(e, o));
    e = Object.getPrototypeOf(e);
  }
  return {
    properties: t,
    descriptors: r
  };
}
u(CK, "getAllProperties");
function kK(e, t) {
  if (!t || // the original is already a spy, so it has all the properties
  La in t)
    return e;
  let { properties: r, descriptors: n } = CK(t);
  for (let o of r) {
    let a = n[o];
    $K(e, o) || lc(e, o, a);
  }
  return e;
}
u(kK, "wrap");
function PK(e) {
  return AK(e) && "getOriginal" in e[La];
}
u(PK, "isSpyFunction");
var yb = /* @__PURE__ */ new Set();
function Al(e) {
  return typeof e == "function" && "_isMockFunction" in e && e._isMockFunction;
}
u(Al, "isMockFunction");
function LAe(e, t, r) {
  const n = r ? { [{
    get: "getter",
    set: "setter"
  }[r]]: t } : t;
  let o;
  const a = OK(e, t), i = a && a[r || "value"];
  Al(i) && (o = i.mock._state());
  try {
    const s = rk(e, n), d = nk(s);
    return o && d.mock._state(o), d;
  } catch (s) {
    throw s instanceof TypeError && Symbol.toStringTag && e[Symbol.toStringTag] === "Module" && (s.message.includes("Cannot redefine property") || s.message.includes("Cannot replace module namespace") || s.message.includes("can't redefine non-configurable property")) ? new TypeError(`Cannot spy on export "${String(n)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: s }) : s;
  }
}
u(LAe, "spyOn");
var FAe = 0;
function nk(e) {
  const t = e;
  let r, n = [], o = !1, a = [], i = [], s = [];
  const d = Y0(e), l = {
    get calls() {
      return d.calls;
    },
    get contexts() {
      return i;
    },
    get instances() {
      return a;
    },
    get invocationCallOrder() {
      return s;
    },
    get results() {
      return d.results.map(([m, g]) => ({
        type: m === "error" ? "throw" : "return",
        value: g
      }));
    },
    get settledResults() {
      return d.resolves.map(([m, g]) => ({
        type: m === "error" ? "rejected" : "fulfilled",
        value: g
      }));
    },
    get lastCall() {
      return d.calls[d.calls.length - 1];
    },
    _state(m) {
      return m && (r = m.implementation, n = m.onceImplementations, o = m.implementationChangedTemporarily), {
        implementation: r,
        onceImplementations: n,
        implementationChangedTemporarily: o
      };
    }
  };
  function p(...m) {
    return a.push(this), i.push(this), s.push(++FAe), (o ? r : n.shift() || r || d.getOriginal() || (() => {
    })).apply(this, m);
  }
  u(p, "mockCall");
  let f = t.name;
  t.getMockName = () => f || "vi.fn()", t.mockName = (m) => (f = m, t), t.mockClear = () => (d.reset(), a = [], i = [], s = [], t), t.mockReset = () => (t.mockClear(), r = void 0, n = [], t), t.mockRestore = () => (t.mockReset(), d.restore(), t), Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()), t.getMockImplementation = () => o ? r : n.at(0) || r, t.mockImplementation = (m) => (r = m, d.willCall(p), t), t.mockImplementationOnce = (m) => (n.push(m), t);
  function h(m, g) {
    const w = r;
    r = m, d.willCall(p), o = !0;
    const _ = /* @__PURE__ */ u(() => {
      r = w, o = !1;
    }, "reset"), b = g();
    return typeof b == "object" && b && typeof b.then == "function" ? b.then(() => (_(), t)) : (_(), t);
  }
  return u(h, "withImplementation"), t.withImplementation = h, t.mockReturnThis = () => t.mockImplementation(function() {
    return this;
  }), t.mockReturnValue = (m) => t.mockImplementation(() => m), t.mockReturnValueOnce = (m) => t.mockImplementationOnce(() => m), t.mockResolvedValue = (m) => t.mockImplementation(() => Promise.resolve(m)), t.mockResolvedValueOnce = (m) => t.mockImplementationOnce(() => Promise.resolve(m)), t.mockRejectedValue = (m) => t.mockImplementation(() => Promise.reject(m)), t.mockRejectedValueOnce = (m) => t.mockImplementationOnce(() => Promise.reject(m)), Object.defineProperty(t, "mock", { get: /* @__PURE__ */ u(() => l, "get") }), d.willCall(p), yb.add(t), t;
}
u(nk, "enhanceSpy");
function X0(e) {
  const t = nk(rk({ spy: e || function() {
  } }, "spy"));
  return e && t.mockImplementation(e), t;
}
u(X0, "fn");
function OK(e, t) {
  const r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    const o = Object.getOwnPropertyDescriptor(n, t);
    if (o)
      return o;
    n = Object.getPrototypeOf(n);
  }
}
u(OK, "getDescriptor");
var Bd = Symbol.for("matchers-object"), Hd = Symbol.for("$$jest-matchers-object-storybook"), ok = Symbol.for("expect-global"), Q0 = Symbol.for("asymmetric-matchers-object"), UAe = {
  toSatisfy(e, t, r) {
    const { printReceived: n, printExpected: o, matcherHint: a } = this.utils, i = t(e);
    return {
      pass: i,
      message: /* @__PURE__ */ u(() => i ? `${a(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${r || o(t)}
Received:
${n(e)}` : `${a(".toSatisfy", "received", "")}

Expected value to satisfy:
${r || o(t)}

Received:
${n(e)}`, "message")
    };
  },
  toBeOneOf(e, t) {
    const { equals: r, customTesters: n } = this, { printReceived: o, printExpected: a, matcherHint: i } = this.utils;
    if (!Array.isArray(t))
      throw new TypeError(`You must provide an array to ${i(".toBeOneOf")}, not '${typeof t}'.`);
    const s = t.length === 0 || t.some((d) => r(d, e, n));
    return {
      pass: s,
      message: /* @__PURE__ */ u(() => s ? `${i(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${a(t)}
Received:
${o(e)}` : `${i(".toBeOneOf", "received", "")}

Expected value to be one of:
${a(t)}

Received:
${o(e)}`, "message")
    };
  }
}, bm = Ot.green, ak = Ot.red, BAe = Ot.inverse, HAe = Ot.bold, ba = Ot.dim;
function RK(e, t = "received", r = "expected", n = {}) {
  const { comment: o = "", isDirectExpectCall: a = !1, isNot: i = !1, promise: s = "", secondArgument: d = "", expectedColor: l = bm, receivedColor: p = ak, secondArgumentColor: f = bm } = n;
  let h = "", m = "expect";
  return !a && t !== "" && (h += ba(`${m}(`) + p(t), m = ")"), s !== "" && (h += ba(`${m}.`) + s, m = ""), i && (h += `${ba(`${m}.`)}not`, m = ""), e.includes(".") ? m += e : (h += ba(`${m}.`) + e, m = ""), r === "" ? m += "()" : (h += ba(`${m}(`) + l(r), d && (h += ba(", ") + f(d)), m = ")"), o !== "" && (m += ` // ${o}`), m !== "" && (h += ba(m)), h;
}
u(RK, "matcherHint");
var VAe = "Â·";
function ik(e) {
  return e.replace(/\s+$/gm, (t) => VAe.repeat(t.length));
}
u(ik, "replaceTrailingSpaces");
function jK(e) {
  return ak(ik(jr(e)));
}
u(jK, "printReceived");
function IK(e) {
  return bm(ik(jr(e)));
}
u(IK, "printExpected");
function sk() {
  return {
    EXPECTED_COLOR: bm,
    RECEIVED_COLOR: ak,
    INVERTED_COLOR: BAe,
    BOLD_WEIGHT: HAe,
    DIM_COLOR: ba,
    diff: Ds,
    matcherHint: RK,
    printReceived: jK,
    printExpected: IK,
    printDiffOrStringify: x$,
    printWithType: NK
  };
}
u(sk, "getMatcherUtils");
function NK(e, t, r) {
  const n = Id(t), o = n !== "null" && n !== "undefined" ? `${e} has type:  ${n}
` : "", a = `${e} has value: ${r(t)}`;
  return o + a;
}
u(NK, "printWithType");
function gb() {
  return globalThis[Hd].customEqualityTesters;
}
u(gb, "getCustomEqualityTesters");
function et(e, t, r, n) {
  return r = r || [], $l(e, t, [], [], r, n ? lk : qK);
}
u(et, "equals");
function Z0(e) {
  return !!e && typeof e == "object" && "asymmetricMatch" in e && yn("Function", e.asymmetricMatch);
}
u(Z0, "isAsymmetric");
function MK(e, t) {
  const r = Z0(e), n = Z0(t);
  if (!(r && n)) {
    if (r)
      return e.asymmetricMatch(t);
    if (n)
      return t.asymmetricMatch(e);
  }
}
u(MK, "asymmetricMatch");
function $l(e, t, r, n, o, a) {
  let i = !0;
  const s = MK(e, t);
  if (s !== void 0)
    return s;
  const d = { equals: et };
  for (let g = 0; g < o.length; g++) {
    const w = o[g].call(d, e, t, o);
    if (w !== void 0)
      return w;
  }
  if (typeof URL == "function" && e instanceof URL && t instanceof URL)
    return e.href === t.href;
  if (Object.is(e, t))
    return !0;
  if (e === null || t === null)
    return e === t;
  const l = Object.prototype.toString.call(e);
  if (l !== Object.prototype.toString.call(t))
    return !1;
  switch (l) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof e != typeof t ? !1 : typeof e != "object" && typeof t != "object" ? Object.is(e, t) : Object.is(e.valueOf(), t.valueOf());
    case "[object Date]": {
      const g = +e, w = +t;
      return g === w || Number.isNaN(g) && Number.isNaN(w);
    }
    case "[object RegExp]":
      return e.source === t.source && e.flags === t.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return e.equals(t);
    case "[object Temporal.Duration]":
      return e.toString() === t.toString();
  }
  if (typeof e != "object" || typeof t != "object")
    return !1;
  if (t1(e) && t1(t))
    return e.isEqualNode(t);
  let p = r.length;
  for (; p--; ) {
    if (r[p] === e)
      return n[p] === t;
    if (n[p] === t)
      return !1;
  }
  if (r.push(e), n.push(t), l === "[object Array]" && e.length !== t.length)
    return !1;
  if (e instanceof Error && t instanceof Error)
    try {
      return DK(e, t, r, n, o, a);
    } finally {
      r.pop(), n.pop();
    }
  const f = e1(e, a);
  let h, m = f.length;
  if (e1(t, a).length !== m)
    return !1;
  for (; m--; )
    if (h = f[m], i = a(t, h) && $l(e[h], t[h], r, n, o, a), !i)
      return !1;
  return r.pop(), n.pop(), i;
}
u($l, "eq");
function DK(e, t, r, n, o, a) {
  let i = Object.getPrototypeOf(e) === Object.getPrototypeOf(t) && e.name === t.name && e.message === t.message;
  return typeof t.cause < "u" && i && (i = $l(e.cause, t.cause, r, n, o, a)), e instanceof AggregateError && t instanceof AggregateError && i && (i = $l(e.errors, t.errors, r, n, o, a)), i && (i = $l({ ...e }, { ...t }, r, n, o, a)), i;
}
u(DK, "isErrorEqual");
function e1(e, t) {
  const r = [];
  for (const n in e)
    t(e, n) && r.push(n);
  return r.concat(Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable));
}
u(e1, "keys");
function qK(e, t) {
  return lk(e, t) && e[t] !== void 0;
}
u(qK, "hasDefinedKey");
function lk(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
u(lk, "hasKey");
function yn(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
u(yn, "isA");
function t1(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && typeof e.nodeType == "number" && "nodeName" in e && typeof e.nodeName == "string" && "isEqualNode" in e && typeof e.isEqualNode == "function";
}
u(t1, "isDomNode");
var LK = "@@__IMMUTABLE_KEYED__@@", FK = "@@__IMMUTABLE_SET__@@", zAe = "@@__IMMUTABLE_LIST__@@", bb = "@@__IMMUTABLE_ORDERED__@@", JAe = "@@__IMMUTABLE_RECORD__@@";
function UK(e) {
  return !!(e && e[LK] && !e[bb]);
}
u(UK, "isImmutableUnorderedKeyed");
function BK(e) {
  return !!(e && e[FK] && !e[bb]);
}
u(BK, "isImmutableUnorderedSet");
function Np(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
u(Np, "isObjectLiteral");
function HK(e) {
  return !!(e && Np(e) && e[zAe]);
}
u(HK, "isImmutableList");
function VK(e) {
  return !!(e && Np(e) && e[LK] && e[bb]);
}
u(VK, "isImmutableOrderedKeyed");
function zK(e) {
  return !!(e && Np(e) && e[FK] && e[bb]);
}
u(zK, "isImmutableOrderedSet");
function JK(e) {
  return !!(e && Np(e) && e[JAe]);
}
u(JK, "isImmutableRecord");
var WK = Symbol.iterator;
function r1(e) {
  return !!(e != null && e[WK]);
}
u(r1, "hasIterator");
function Gr(e, t, r = [], n = [], o = []) {
  if (typeof e != "object" || typeof t != "object" || Array.isArray(e) || Array.isArray(t) || !r1(e) || !r1(t))
    return;
  if (e.constructor !== t.constructor)
    return !1;
  let a = n.length;
  for (; a--; )
    if (n[a] === e)
      return o[a] === t;
  n.push(e), o.push(t);
  const i = [...r.filter((l) => l !== Gr), s];
  function s(l, p) {
    return Gr(l, p, [...r], [...n], [...o]);
  }
  if (u(s, "iterableEqualityWithStack"), e.size !== void 0) {
    if (e.size !== t.size)
      return !1;
    if (yn("Set", e) || BK(e)) {
      let l = !0;
      for (const p of e)
        if (!t.has(p)) {
          let f = !1;
          for (const h of t)
            et(p, h, i) === !0 && (f = !0);
          if (f === !1) {
            l = !1;
            break;
          }
        }
      return n.pop(), o.pop(), l;
    } else if (yn("Map", e) || UK(e)) {
      let l = !0;
      for (const p of e)
        if (!t.has(p[0]) || !et(p[1], t.get(p[0]), i)) {
          let f = !1;
          for (const h of t) {
            const m = et(p[0], h[0], i);
            let g = !1;
            m === !0 && (g = et(p[1], h[1], i)), g === !0 && (f = !0);
          }
          if (f === !1) {
            l = !1;
            break;
          }
        }
      return n.pop(), o.pop(), l;
    }
  }
  const d = t[WK]();
  for (const l of e) {
    const p = d.next();
    if (p.done || !et(l, p.value, i))
      return !1;
  }
  if (!d.next().done)
    return !1;
  if (!HK(e) && !VK(e) && !zK(e) && !JK(e)) {
    const l = Object.entries(e), p = Object.entries(t);
    if (!et(l, p, i))
      return !1;
  }
  return n.pop(), o.pop(), !0;
}
u(Gr, "iterableEquality");
function vb(e, t) {
  return !e || typeof e != "object" || e === Object.prototype ? !1 : Object.prototype.hasOwnProperty.call(e, t) || vb(Object.getPrototypeOf(e), t);
}
u(vb, "hasPropertyInObject");
function GK(e) {
  return Ku(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
u(GK, "isObjectWithKeys");
function Lc(e, t, r = []) {
  const n = r.filter((a) => a !== Lc), o = /* @__PURE__ */ u((a = /* @__PURE__ */ new WeakMap()) => (i, s) => {
    if (GK(s))
      return Object.keys(s).every((d) => {
        if (s[d] != null && typeof s[d] == "object") {
          if (a.has(s[d]))
            return et(i[d], s[d], n);
          a.set(s[d], !0);
        }
        const l = i != null && vb(i, d) && et(i[d], s[d], [...n, o(a)]);
        return a.delete(s[d]), l;
      });
  }, "subsetEqualityWithContext");
  return o()(e, t);
}
u(Lc, "subsetEquality");
function n1(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor))
    return !1;
}
u(n1, "typeEquality");
function o1(e, t) {
  let r = e, n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer))
      return;
    try {
      r = new DataView(e), n = new DataView(t);
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength)
    return !1;
  for (let o = 0; o < r.byteLength; o++)
    if (r.getUint8(o) !== n.getUint8(o))
      return !1;
  return !0;
}
u(o1, "arrayBufferEquality");
function vm(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t))
    return;
  const n = Object.keys(e), o = Object.keys(t), a = r.filter((i) => i !== vm);
  return et(e, t, a, !0) && et(n, o);
}
u(vm, "sparseArrayEquality");
function KK(e, t = "#{this}", r = "#{exp}") {
  const n = `expected ${t} to be ${r} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(e) ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
` : n;
}
u(KK, "generateToBeMessage");
function YK(e, t) {
  return `${t} ${e}${t === 1 ? "" : "s"}`;
}
u(YK, "pluralize");
function Sf(e) {
  return [...Object.keys(e), ...Object.getOwnPropertySymbols(e).filter((t) => {
    var r;
    return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0 ? void 0 : r.enumerable;
  })];
}
u(Sf, "getObjectKeys");
function XK(e, t, r) {
  let n = 0;
  const o = /* @__PURE__ */ u((a = /* @__PURE__ */ new WeakMap()) => (i, s) => {
    if (Array.isArray(i)) {
      if (Array.isArray(s) && s.length === i.length)
        return s.map((d, l) => o(a)(i[l], d));
    } else {
      if (i instanceof Date)
        return i;
      if (Ku(i) && Ku(s)) {
        if (et(i, s, [
          ...r,
          Gr,
          Lc
        ]))
          return s;
        const d = {};
        a.set(i, d), typeof i.constructor == "function" && typeof i.constructor.name == "string" && Object.defineProperty(d, "constructor", {
          enumerable: !1,
          value: i.constructor
        });
        for (const l of Sf(i))
          vb(s, l) ? d[l] = a.has(i[l]) ? a.get(i[l]) : o(a)(i[l], s[l]) : a.has(i[l]) || (n += 1, Ku(i[l]) && (n += Sf(i[l]).length), o(a)(i[l], s[l]));
        if (Sf(d).length > 0)
          return d;
      }
    }
    return i;
  }, "getObjectSubsetWithContext");
  return {
    subset: o()(e, t),
    stripped: n
  };
}
u(XK, "getObjectSubset");
if (!Object.prototype.hasOwnProperty.call(globalThis, Bd)) {
  const e = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, Bd, { get: /* @__PURE__ */ u(() => e, "get") });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Hd)) {
  const e = /* @__PURE__ */ Object.create(null), t = [];
  Object.defineProperty(globalThis, Hd, {
    configurable: !0,
    get: /* @__PURE__ */ u(() => ({
      state: globalThis[Bd].get(globalThis[ok]),
      matchers: e,
      customEqualityTesters: t
    }), "get")
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Q0)) {
  const e = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, Q0, { get: /* @__PURE__ */ u(() => e, "get") });
}
function Vd(e) {
  return globalThis[Bd].get(e);
}
u(Vd, "getState");
function Tf(e, t) {
  const r = globalThis[Bd], n = r.get(t) || {}, o = Object.defineProperties(n, {
    ...Object.getOwnPropertyDescriptors(n),
    ...Object.getOwnPropertyDescriptors(e)
  });
  r.set(t, o);
}
u(Tf, "setState");
var QK = class {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(e, t = !1) {
    this.sample = e, this.inverse = t;
  }
  getMatcherContext(e) {
    return {
      ...Vd(e || globalThis[ok]),
      equals: et,
      isNot: this.inverse,
      customTesters: gb(),
      utils: {
        ...sk(),
        diff: Ds,
        stringify: jr,
        iterableEquality: Gr,
        subsetEquality: Lc
      }
    };
  }
};
u(QK, "AsymmetricMatcher");
var fa = QK;
fa.prototype[Symbol.for("chai/inspect")] = function(e) {
  const t = jr(this, e.depth, { min: !0 });
  return t.length <= e.truncate ? t : `${this.toString()}{â€¦}`;
};
var ZK = class extends fa {
  constructor(e, t = !1) {
    if (!yn("String", e))
      throw new Error("Expected is not a string");
    super(e, t);
  }
  asymmetricMatch(e) {
    const t = yn("String", e) && e.includes(this.sample);
    return this.inverse ? !t : t;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
};
u(ZK, "StringContaining");
var qj = ZK, eY = class extends fa {
  asymmetricMatch(e) {
    return e != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
};
u(eY, "Anything");
var WAe = eY, tY = class extends fa {
  constructor(e, t = !1) {
    super(e, t);
  }
  getPrototype(e) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.constructor.prototype === e ? null : e.constructor.prototype;
  }
  hasProperty(e, t) {
    return e ? Object.prototype.hasOwnProperty.call(e, t) ? !0 : this.hasProperty(this.getPrototype(e), t) : !1;
  }
  asymmetricMatch(e) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let t = !0;
    const r = this.getMatcherContext();
    for (const n in this.sample)
      if (!this.hasProperty(e, n) || !et(this.sample[n], e[n], r.customTesters)) {
        t = !1;
        break;
      }
    return this.inverse ? !t : t;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
};
u(tY, "ObjectContaining");
var Lj = tY, rY = class extends fa {
  constructor(e, t = !1) {
    super(e, t);
  }
  asymmetricMatch(e) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    const t = this.getMatcherContext(), r = this.sample.length === 0 || Array.isArray(e) && this.sample.every((n) => e.some((o) => et(n, o, t.customTesters)));
    return this.inverse ? !r : r;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
};
u(rY, "ArrayContaining");
var Fj = rY, nY = class extends fa {
  constructor(e) {
    if (typeof e > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(e);
  }
  fnNameFor(e) {
    if (e.name)
      return e.name;
    const t = Function.prototype.toString.call(e).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return t ? t[1] : "<anonymous>";
  }
  asymmetricMatch(e) {
    return this.sample === String ? typeof e == "string" || e instanceof String : this.sample === Number ? typeof e == "number" || e instanceof Number : this.sample === Function ? typeof e == "function" || typeof e == "function" : this.sample === Boolean ? typeof e == "boolean" || e instanceof Boolean : this.sample === BigInt ? typeof e == "bigint" || e instanceof BigInt : this.sample === Symbol ? typeof e == "symbol" || e instanceof Symbol : this.sample === Object ? typeof e == "object" : e instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
};
u(nY, "Any");
var GAe = nY, oY = class extends fa {
  constructor(e, t = !1) {
    if (!yn("String", e) && !yn("RegExp", e))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(e), t);
  }
  asymmetricMatch(e) {
    const t = yn("String", e) && this.sample.test(e);
    return this.inverse ? !t : t;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
};
u(oY, "StringMatching");
var Uj = oY, aY = class extends fa {
  precision;
  constructor(e, t = 2, r = !1) {
    if (!yn("Number", e))
      throw new Error("Expected is not a Number");
    if (!yn("Number", t))
      throw new Error("Precision is not a Number");
    super(e), this.inverse = r, this.precision = t;
  }
  asymmetricMatch(e) {
    if (!yn("Number", e))
      return !1;
    let t = !1;
    return e === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? t = !0 : t = Math.abs(this.sample - e) < 10 ** -this.precision / 2, this.inverse ? !t : t;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${YK("digit", this.precision)})`
    ].join(" ");
  }
};
u(aY, "CloseTo");
var Bj = aY, KAe = /* @__PURE__ */ u((e, t) => {
  t.addMethod(e.expect, "anything", () => new WAe()), t.addMethod(e.expect, "any", (r) => new GAe(r)), t.addMethod(e.expect, "stringContaining", (r) => new qj(r)), t.addMethod(e.expect, "objectContaining", (r) => new Lj(r)), t.addMethod(e.expect, "arrayContaining", (r) => new Fj(r)), t.addMethod(e.expect, "stringMatching", (r) => new Uj(r)), t.addMethod(e.expect, "closeTo", (r, n) => new Bj(r, n)), e.expect.not = {
    stringContaining: /* @__PURE__ */ u((r) => new qj(r, !0), "stringContaining"),
    objectContaining: /* @__PURE__ */ u((r) => new Lj(r, !0), "objectContaining"),
    arrayContaining: /* @__PURE__ */ u((r) => new Fj(r, !0), "arrayContaining"),
    stringMatching: /* @__PURE__ */ u((r) => new Uj(r, !0), "stringMatching"),
    closeTo: /* @__PURE__ */ u((r, n) => new Bj(r, n, !0), "closeTo")
  };
}, "JestAsymmetricMatchers");
function a1(e, t, r) {
  const n = e.flag(t, "negate") ? "not." : "", o = `${e.flag(t, "_name")}(${r ? "expected" : ""})`, a = e.flag(t, "promise");
  return `expect(actual)${a ? `.${a}` : ""}.${n}${o}`;
}
u(a1, "createAssertionMessage");
function i1(e, t, r, n) {
  const o = e;
  if (o && t instanceof Promise) {
    t = t.finally(() => {
      if (!o.promises)
        return;
      const i = o.promises.indexOf(t);
      i !== -1 && o.promises.splice(i, 1);
    }), o.promises || (o.promises = []), o.promises.push(t);
    let a = !1;
    return o.onFinished ?? (o.onFinished = []), o.onFinished.push(() => {
      if (!a) {
        var i;
        const s = (((i = globalThis.__vitest_worker__) === null || i === void 0 ? void 0 : i.onFilterStackTrace) || ((d) => d || ""))(n.stack);
        console.warn([
          `Promise returned by \`${r}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          s
        ].join(""));
      }
    }), {
      then(i, s) {
        return a = !0, t.then(i, s);
      },
      catch(i) {
        return t.catch(i);
      },
      finally(i) {
        return t.finally(i);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return t;
}
u(i1, "recordAsyncExpect");
function s1(e, t) {
  var r;
  e.result || (e.result = { state: "fail" }), e.result.state = "fail", (r = e.result).errors || (r.errors = []), e.result.errors.push(Rg(t));
}
u(s1, "handleTestError");
function ck(e, t, r) {
  return function(...n) {
    if (t !== "withTest" && e.flag(this, "_name", t), !e.flag(this, "soft"))
      return r.apply(this, n);
    const o = e.flag(this, "vitest-test");
    if (!o)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      const a = r.apply(this, n);
      return a && typeof a == "object" && typeof a.then == "function" ? a.then(oG, (i) => {
        s1(o, i);
      }) : a;
    } catch (a) {
      s1(o, a);
    }
  };
}
u(ck, "wrapAssertion");
var YAe = /* @__PURE__ */ u((e, t) => {
  const { AssertionError: r } = e, n = gb();
  function o(l, p) {
    const f = /* @__PURE__ */ u((h) => {
      const m = ck(t, h, p);
      t.addMethod(e.Assertion.prototype, h, m), t.addMethod(globalThis[Hd].matchers, h, m);
    }, "addMethod");
    Array.isArray(l) ? l.forEach((h) => f(h)) : f(l);
  }
  u(o, "def"), [
    "throw",
    "throws",
    "Throw"
  ].forEach((l) => {
    t.overwriteMethod(e.Assertion.prototype, l, (p) => function(...f) {
      const h = t.flag(this, "promise"), m = t.flag(this, "object"), g = t.flag(this, "negate");
      if (h === "rejects")
        t.flag(this, "object", () => {
          throw m;
        });
      else if (h === "resolves" && typeof m != "function") {
        if (g)
          return;
        {
          const w = t.flag(this, "message") || "expected promise to throw an error, but it didn't", _ = { showDiff: !1 };
          throw new r(w, _, t.flag(this, "ssfi"));
        }
      }
      p.apply(this, f);
    });
  }), o("withTest", function(l) {
    return t.flag(this, "vitest-test", l), this;
  }), o("toEqual", function(l) {
    const p = t.flag(this, "object"), f = et(p, l, [...n, Gr]);
    return this.assert(f, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", l, p);
  }), o("toStrictEqual", function(l) {
    const p = t.flag(this, "object"), f = et(p, l, [
      ...n,
      Gr,
      n1,
      vm,
      o1
    ], !0);
    return this.assert(f, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", l, p);
  }), o("toBe", function(l) {
    const p = this._obj, f = Object.is(p, l);
    let h = "";
    return f || (et(p, l, [
      ...n,
      Gr,
      n1,
      vm,
      o1
    ], !0) ? h = "toStrictEqual" : et(p, l, [...n, Gr]) && (h = "toEqual")), this.assert(f, KK(h), "expected #{this} not to be #{exp} // Object.is equality", l, p);
  }), o("toMatchObject", function(l) {
    const p = this._obj, f = et(p, l, [
      ...n,
      Gr,
      Lc
    ]), h = t.flag(this, "negate"), { subset: m, stripped: g } = XK(p, l, n);
    if (f && h || !f && !h) {
      const w = t.getMessage(this, [
        f,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        l,
        m,
        !1
      ]), _ = g === 0 ? w : `${w}
(${g} matching ${g === 1 ? "property" : "properties"} omitted from actual)`;
      throw new r(_, {
        showDiff: !0,
        expected: l,
        actual: m
      });
    }
  }), o("toMatch", function(l) {
    const p = this._obj;
    if (typeof p != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
    return this.assert(typeof l == "string" ? p.includes(l) : p.match(l), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", l, p);
  }), o("toContain", function(l) {
    const p = this._obj;
    if (typeof Node < "u" && p instanceof Node) {
      if (!(l instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof l}`);
      return this.assert(p.contains(l), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", l, p);
    }
    if (typeof DOMTokenList < "u" && p instanceof DOMTokenList) {
      Zn(l, "class name", ["string"]);
      const f = t.flag(this, "negate") ? p.value.replace(l, "").trim() : `${p.value} ${l}`;
      return this.assert(p.contains(l), `expected "${p.value}" to contain "${l}"`, `expected "${p.value}" not to contain "${l}"`, f, p.value);
    }
    return typeof p == "string" && typeof l == "string" ? this.assert(p.includes(l), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", l, p) : (p != null && typeof p != "string" && t.flag(this, "object", Array.from(p)), this.contain(l));
  }), o("toContainEqual", function(l) {
    const p = t.flag(this, "object"), f = Array.from(p).findIndex((h) => et(h, l, n));
    this.assert(f !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", l);
  }), o("toBeTruthy", function() {
    const l = t.flag(this, "object");
    this.assert(!!l, "expected #{this} to be truthy", "expected #{this} to not be truthy", !0, l);
  }), o("toBeFalsy", function() {
    const l = t.flag(this, "object");
    this.assert(!l, "expected #{this} to be falsy", "expected #{this} to not be falsy", !1, l);
  }), o("toBeGreaterThan", function(l) {
    const p = this._obj;
    return Zn(p, "actual", ["number", "bigint"]), Zn(l, "expected", ["number", "bigint"]), this.assert(p > l, `expected ${p} to be greater than ${l}`, `expected ${p} to be not greater than ${l}`, l, p, !1);
  }), o("toBeGreaterThanOrEqual", function(l) {
    const p = this._obj;
    return Zn(p, "actual", ["number", "bigint"]), Zn(l, "expected", ["number", "bigint"]), this.assert(p >= l, `expected ${p} to be greater than or equal to ${l}`, `expected ${p} to be not greater than or equal to ${l}`, l, p, !1);
  }), o("toBeLessThan", function(l) {
    const p = this._obj;
    return Zn(p, "actual", ["number", "bigint"]), Zn(l, "expected", ["number", "bigint"]), this.assert(p < l, `expected ${p} to be less than ${l}`, `expected ${p} to be not less than ${l}`, l, p, !1);
  }), o("toBeLessThanOrEqual", function(l) {
    const p = this._obj;
    return Zn(p, "actual", ["number", "bigint"]), Zn(l, "expected", ["number", "bigint"]), this.assert(p <= l, `expected ${p} to be less than or equal to ${l}`, `expected ${p} to be not less than or equal to ${l}`, l, p, !1);
  }), o("toBeNaN", function() {
    const l = t.flag(this, "object");
    this.assert(Number.isNaN(l), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, l);
  }), o("toBeUndefined", function() {
    const l = t.flag(this, "object");
    this.assert(l === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, l);
  }), o("toBeNull", function() {
    const l = t.flag(this, "object");
    this.assert(l === null, "expected #{this} to be null", "expected #{this} not to be null", null, l);
  }), o("toBeDefined", function() {
    const l = t.flag(this, "object");
    this.assert(typeof l < "u", "expected #{this} to be defined", "expected #{this} to be undefined", l);
  }), o("toBeTypeOf", function(l) {
    const p = typeof this._obj, f = l === p;
    return this.assert(f, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", l, p);
  }), o("toBeInstanceOf", function(l) {
    return this.instanceOf(l);
  }), o("toHaveLength", function(l) {
    return this.have.length(l);
  }), o("toHaveProperty", function(...l) {
    Array.isArray(l[0]) && (l[0] = l[0].map((x) => String(x).replace(/([.[\]])/g, "\\$1")).join("."));
    const p = this._obj, [f, h] = l, m = /* @__PURE__ */ u(() => Object.prototype.hasOwnProperty.call(p, f) ? {
      value: p[f],
      exists: !0
    } : t.getPathInfo(p, f), "getValue"), { value: g, exists: w } = m(), _ = w && (l.length === 1 || et(h, g, n)), b = l.length === 1 ? "" : ` with value ${t.objDisplay(h)}`;
    return this.assert(_, `expected #{this} to have property "${f}"${b}`, `expected #{this} to not have property "${f}"${b}`, h, w ? g : void 0);
  }), o("toBeCloseTo", function(l, p = 2) {
    const f = this._obj;
    let h = !1, m = 0, g = 0;
    return l === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY || l === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY ? h = !0 : (m = 10 ** -p / 2, g = Math.abs(f - l), h = g < m), this.assert(h, `expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${m}`, `expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${m}`, l, f, !1);
  });
  function a(l) {
    if (!Al(l._obj))
      throw new TypeError(`${t.inspect(l._obj)} is not a spy or a call to a spy!`);
  }
  u(a, "assertIsMock");
  function i(l) {
    return a(l), l._obj;
  }
  u(i, "getSpy"), o(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls.length;
    return this.assert(h === l, `expected "${f}" to be called #{exp} times, but got ${h} times`, `expected "${f}" to not be called #{exp} times`, l, h, !1);
  }), o("toHaveBeenCalledOnce", function() {
    const l = i(this), p = l.getMockName(), f = l.mock.calls.length;
    return this.assert(f === 1, `expected "${p}" to be called once, but got ${f} times`, `expected "${p}" to not be called once`, 1, f, !1);
  }), o(["toHaveBeenCalled", "toBeCalled"], function() {
    const l = i(this), p = l.getMockName(), f = l.mock.calls.length, h = f > 0, m = t.flag(this, "negate");
    let g = t.getMessage(this, [
      h,
      `expected "${p}" to be called at least once`,
      `expected "${p}" to not be called at all, but actually been called ${f} times`,
      !0,
      h
    ]);
    if (h && m && (g = Af(l, g)), h && m || !h && !m)
      throw new r(g);
  });
  function s(l, p) {
    return l.length === p.length && l.every((f, h) => et(f, p[h], [...n, Gr]));
  }
  u(s, "equalsArgumentArray"), o(["toHaveBeenCalledWith", "toBeCalledWith"], function(...l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls.some((w) => s(w, l)), m = t.flag(this, "negate"), g = t.getMessage(this, [
      h,
      `expected "${f}" to be called with arguments: #{exp}`,
      `expected "${f}" to not be called with arguments: #{exp}`,
      l
    ]);
    if (h && m || !h && !m)
      throw new r(Af(p, g, l));
  }), o("toHaveBeenCalledExactlyOnceWith", function(...l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls.length, m = p.mock.calls.some((_) => s(_, l)) && h === 1, g = t.flag(this, "negate"), w = t.getMessage(this, [
      m,
      `expected "${f}" to be called once with arguments: #{exp}`,
      `expected "${f}" to not be called once with arguments: #{exp}`,
      l
    ]);
    if (m && g || !m && !g)
      throw new r(Af(p, w, l));
  }), o(["toHaveBeenNthCalledWith", "nthCalledWith"], function(l, ...p) {
    const f = i(this), h = f.getMockName(), m = f.mock.calls[l - 1], g = f.mock.calls.length, w = l <= g;
    this.assert(m && s(m, p), `expected ${Cl(l)} "${h}" call to have been called with #{exp}${w ? "" : `, but called only ${g} times`}`, `expected ${Cl(l)} "${h}" call to not have been called with #{exp}`, p, m, w);
  }), o(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...l) {
    const p = i(this), f = p.getMockName(), h = p.mock.calls[p.mock.calls.length - 1];
    this.assert(h && s(h, l), `expected last "${f}" call to have been called with #{exp}`, `expected last "${f}" call to not have been called with #{exp}`, l, h);
  });
  function d(l, p, f) {
    const h = l.mock.invocationCallOrder, m = p.mock.invocationCallOrder;
    return h.length === 0 ? !f : m.length === 0 ? !1 : h[0] < m[0];
  }
  u(d, "isSpyCalledBeforeAnotherSpy"), o(["toHaveBeenCalledBefore"], function(l, p = !0) {
    const f = i(this);
    if (!Al(l))
      throw new TypeError(`${t.inspect(l)} is not a spy or a call to a spy`);
    this.assert(d(f, l, p), `expected "${f.getMockName()}" to have been called before "${l.getMockName()}"`, `expected "${f.getMockName()}" to not have been called before "${l.getMockName()}"`, l, f);
  }), o(["toHaveBeenCalledAfter"], function(l, p = !0) {
    const f = i(this);
    if (!Al(l))
      throw new TypeError(`${t.inspect(l)} is not a spy or a call to a spy`);
    this.assert(d(l, f, p), `expected "${f.getMockName()}" to have been called after "${l.getMockName()}"`, `expected "${f.getMockName()}" to not have been called after "${l.getMockName()}"`, l, f);
  }), o(["toThrow", "toThrowError"], function(l) {
    if (typeof l == "string" || typeof l > "u" || l instanceof RegExp)
      return this.throws(l === "" ? /^$/ : l);
    const p = this._obj, f = t.flag(this, "promise"), h = t.flag(this, "negate");
    let m = null;
    if (f === "rejects")
      m = p;
    else if (f === "resolves" && typeof p != "function") {
      if (h)
        return;
      {
        const g = t.flag(this, "message") || "expected promise to throw an error, but it didn't", w = { showDiff: !1 };
        throw new r(g, w, t.flag(this, "ssfi"));
      }
    } else {
      let g = !1;
      try {
        p();
      } catch (w) {
        g = !0, m = w;
      }
      if (!g && !h) {
        const w = t.flag(this, "message") || "expected function to throw an error, but it didn't", _ = { showDiff: !1 };
        throw new r(w, _, t.flag(this, "ssfi"));
      }
    }
    if (typeof l == "function") {
      const g = l.name || l.prototype.constructor.name;
      return this.assert(m && m instanceof l, `expected error to be instance of ${g}`, `expected error not to be instance of ${g}`, l, m);
    }
    if (l instanceof Error) {
      const g = et(m, l, [...n, Gr]);
      return this.assert(g, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", l, m);
    }
    if (typeof l == "object" && "asymmetricMatch" in l && typeof l.asymmetricMatch == "function") {
      const g = l;
      return this.assert(m && g.asymmetricMatch(m), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", g, m);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof l}"`);
  }), [{
    name: "toHaveResolved",
    condition: /* @__PURE__ */ u((l) => l.mock.settledResults.length > 0 && l.mock.settledResults.some(({ type: p }) => p === "fulfilled"), "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: /* @__PURE__ */ u((l) => l.mock.calls.length > 0 && l.mock.results.some(({ type: p }) => p !== "throw"), "condition"),
    action: "called"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function() {
      const h = i(this), m = h.getMockName(), g = p(h);
      this.assert(g, `expected "${m}" to be successfully ${f} at least once`, `expected "${m}" to not be successfully ${f}`, g, !g, !1);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: /* @__PURE__ */ u((l, p) => l.mock.settledResults.reduce((f, { type: h }) => h === "fulfilled" ? ++f : f, 0) === p, "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: /* @__PURE__ */ u((l, p) => l.mock.results.reduce((f, { type: h }) => h === "throw" ? f : ++f, 0) === p, "condition"),
    action: "called"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h) {
      const m = i(this), g = m.getMockName(), w = p(m, h);
      this.assert(w, `expected "${g}" to be successfully ${f} ${h} times`, `expected "${g}" to not be successfully ${f} ${h} times`, `expected resolved times: ${h}`, `received resolved times: ${w}`, !1);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: /* @__PURE__ */ u((l, p) => l.mock.settledResults.some(({ type: f, value: h }) => f === "fulfilled" && et(p, h)), "condition"),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: /* @__PURE__ */ u((l, p) => l.mock.results.some(({ type: f, value: h }) => f === "return" && et(p, h)), "condition"),
    action: "return"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h) {
      const m = i(this), g = p(m, h), w = t.flag(this, "negate");
      if (g && w || !g && !w) {
        const _ = m.getMockName(), b = t.getMessage(this, [
          g,
          `expected "${_}" to ${f} with: #{exp} at least once`,
          `expected "${_}" to not ${f} with: #{exp}`,
          h
        ]), x = f === "return" ? m.mock.results : m.mock.settledResults;
        throw new r(iY(m, x, b, h));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: /* @__PURE__ */ u((l, p) => {
      const f = l.mock.settledResults[l.mock.settledResults.length - 1];
      return f && f.type === "fulfilled" && et(f.value, p);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: /* @__PURE__ */ u((l, p) => {
      const f = l.mock.results[l.mock.results.length - 1];
      return f && f.type === "return" && et(f.value, p);
    }, "condition"),
    action: "return"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h) {
      const m = i(this), g = f === "return" ? m.mock.results : m.mock.settledResults, w = g[g.length - 1], _ = m.getMockName();
      this.assert(p(m, h), `expected last "${_}" call to ${f} #{exp}`, `expected last "${_}" call to not ${f} #{exp}`, h, w?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: /* @__PURE__ */ u((l, p, f) => {
      const h = l.mock.settledResults[p - 1];
      return h && h.type === "fulfilled" && et(h.value, f);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: /* @__PURE__ */ u((l, p, f) => {
      const h = l.mock.results[p - 1];
      return h && h.type === "return" && et(h.value, f);
    }, "condition"),
    action: "return"
  }].forEach(({ name: l, condition: p, action: f }) => {
    o(l, function(h, m) {
      const g = i(this), w = g.getMockName(), _ = (f === "return" ? g.mock.results : g.mock.settledResults)[h - 1], b = `${Cl(h)} call`;
      this.assert(p(g, h, m), `expected ${b} "${w}" call to ${f} #{exp}`, `expected ${b} "${w}" call to not ${f} #{exp}`, m, _?.value);
    });
  }), o("withContext", function(l) {
    for (const p in l)
      t.flag(this, p, l[p]);
    return this;
  }), t.addProperty(e.Assertion.prototype, "resolves", /* @__PURE__ */ u(function() {
    const l = new Error("resolves");
    t.flag(this, "promise", "resolves"), t.flag(this, "error", l);
    const p = t.flag(this, "vitest-test"), f = t.flag(this, "object");
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof f?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof f}'.`);
    const h = new Proxy(this, { get: /* @__PURE__ */ u((m, g, w) => {
      const _ = Reflect.get(m, g, w);
      return typeof _ != "function" ? _ instanceof e.Assertion ? h : _ : (...b) => {
        t.flag(this, "_name", g);
        const x = f.then((P) => (t.flag(this, "object", P), _.call(this, ...b)), (P) => {
          const R = new r(`promise rejected "${t.inspect(P)}" instead of resolving`, { showDiff: !1 });
          throw R.cause = P, R.stack = l.stack.replace(l.message, R.message), R;
        });
        return i1(p, x, a1(t, this, !!b.length), l);
      };
    }, "get") });
    return h;
  }, "__VITEST_RESOLVES__")), t.addProperty(e.Assertion.prototype, "rejects", /* @__PURE__ */ u(function() {
    const l = new Error("rejects");
    t.flag(this, "promise", "rejects"), t.flag(this, "error", l);
    const p = t.flag(this, "vitest-test"), f = t.flag(this, "object"), h = typeof f == "function" ? f() : f;
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof h?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof h}'.`);
    const m = new Proxy(this, { get: /* @__PURE__ */ u((g, w, _) => {
      const b = Reflect.get(g, w, _);
      return typeof b != "function" ? b instanceof e.Assertion ? m : b : (...x) => {
        t.flag(this, "_name", w);
        const P = h.then((R) => {
          const N = new r(`promise resolved "${t.inspect(R)}" instead of rejecting`, {
            showDiff: !0,
            expected: new Error("rejected promise"),
            actual: R
          });
          throw N.stack = l.stack.replace(l.message, N.message), N;
        }, (R) => (t.flag(this, "object", R), b.call(this, ...x)));
        return i1(p, P, a1(t, this, !!x.length), l);
      };
    }, "get") });
    return m;
  }, "__VITEST_REJECTS__"));
}, "JestChaiExpect");
function Cl(e) {
  const t = e % 10, r = e % 100;
  return t === 1 && r !== 11 ? `${e}st` : t === 2 && r !== 12 ? `${e}nd` : t === 3 && r !== 13 ? `${e}rd` : `${e}th`;
}
u(Cl, "ordinalOf");
function Af(e, t, r) {
  return e.mock.calls.length && (t += Ot.gray(`

Received: 

${e.mock.calls.map((n, o) => {
    let a = Ot.bold(`  ${Cl(o + 1)} ${e.getMockName()} call:

`);
    return r ? a += Ds(r, n, { omitAnnotationLines: !0 }) : a += jr(n).split(`
`).map((i) => `    ${i}`).join(`
`), a += `
`, a;
  }).join(`
`)}`)), t += Ot.gray(`

Number of calls: ${Ot.bold(e.mock.calls.length)}
`), t;
}
u(Af, "formatCalls");
function iY(e, t, r, n) {
  return t.length && (r += Ot.gray(`

Received: 

${t.map((o, a) => {
    let i = Ot.bold(`  ${Cl(a + 1)} ${e.getMockName()} call return:

`);
    return n ? i += Ds(n, o.value, { omitAnnotationLines: !0 }) : i += jr(o).split(`
`).map((s) => `    ${s}`).join(`
`), i += `
`, i;
  }).join(`
`)}`)), r += Ot.gray(`

Number of calls: ${Ot.bold(e.mock.calls.length)}
`), r;
}
u(iY, "formatReturns");
function sY(e, t) {
  const r = e._obj, n = ao.flag(e, "negate"), o = ao.flag(e, "promise") || "", a = {
    ...sk(),
    diff: Ds,
    stringify: jr,
    iterableEquality: Gr,
    subsetEquality: Lc
  };
  return {
    state: {
      ...Vd(t),
      customTesters: gb(),
      isNot: n,
      utils: a,
      promise: o,
      equals: et,
      suppressedErrors: [],
      soft: ao.flag(e, "soft"),
      poll: ao.flag(e, "poll")
    },
    isNot: n,
    obj: r
  };
}
u(sY, "getMatcherState");
var lY = class extends Error {
  constructor(e, t, r) {
    super(e), this.actual = t, this.expected = r;
  }
};
u(lY, "JestExtendError");
var Hj = lY;
function cY(e, t, r) {
  return (n, o) => {
    Object.entries(r).forEach(([a, i]) => {
      function s(...h) {
        const { state: m, isNot: g, obj: w } = sY(this, t), _ = i.call(m, w, ...h);
        if (_ && typeof _ == "object" && typeof _.then == "function")
          return _.then(({ pass: N, message: C, actual: A, expected: E }) => {
            if (N && g || !N && !g)
              throw new Hj(C(), A, E);
          });
        const { pass: b, message: x, actual: P, expected: R } = _;
        if (b && g || !b && !g)
          throw new Hj(x(), P, R);
      }
      u(s, "expectWrapper");
      const d = ck(o, a, s);
      o.addMethod(globalThis[Hd].matchers, a, d), o.addMethod(e.Assertion.prototype, a, d);
      const l = class extends fa {
        constructor(h = !1, ...m) {
          super(m, h);
        }
        asymmetricMatch(h) {
          const { pass: m } = i.call(this.getMatcherContext(t), h, ...this.sample);
          return this.inverse ? !m : m;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${a}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((h) => jr(h)).join(", ")}>`;
        }
      };
      u(l, "CustomMatcher");
      let p = l;
      const f = /* @__PURE__ */ u((...h) => new p(!1, ...h), "customMatcher");
      Object.defineProperty(t, a, {
        configurable: !0,
        enumerable: !0,
        value: f,
        writable: !0
      }), Object.defineProperty(t.not, a, {
        configurable: !0,
        enumerable: !0,
        value: /* @__PURE__ */ u((...h) => new p(!0, ...h), "value"),
        writable: !0
      }), Object.defineProperty(globalThis[Q0], a, {
        configurable: !0,
        enumerable: !0,
        value: f,
        writable: !0
      });
    });
  };
}
u(cY, "JestExtendPlugin");
var XAe = /* @__PURE__ */ u((e, t) => {
  t.addMethod(e.expect, "extend", (r, n) => {
    es(cY(e, r, n));
  });
}, "JestExtend");
function uY() {
  es(XAe), es(YAe), es(KAe);
  const e = /* @__PURE__ */ u((n, o) => {
    const { assertionCalls: a } = Vd(e);
    return Tf({ assertionCalls: a + 1, soft: !1 }, e), qa(n, o);
  }, "expect");
  Object.assign(e, qa), e.getState = () => Vd(e), e.setState = (n) => Tf(n, e), e.extend = (n) => qa.extend(e, n), e.soft = (...n) => {
    const o = e(...n);
    return e.setState({
      soft: !0
    }), o;
  }, e.extend(UAe), e.unreachable = (n) => {
    H.fail(`expected${n ? ` "${n}" ` : " "}not to be reached`);
  };
  function t(n) {
    const o = /* @__PURE__ */ u(() => new Error(
      `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`
    ), "errorGen");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(o(), t), e.setState({
      expectedAssertionsNumber: n,
      expectedAssertionsNumberErrorGen: o
    });
  }
  u(t, "assertions");
  function r() {
    const n = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, r), e.setState({
      isExpectingAssertions: !0,
      isExpectingAssertionsError: n
    });
  }
  return u(r, "hasAssertions"), Tf(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: !1,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    e
  ), ao.addMethod(e, "assertions", t), ao.addMethod(e, "hasAssertions", r), e.extend(WG), e;
}
u(uY, "createExpect");
var dY = uY();
Object.defineProperty(globalThis, ok, {
  value: dY,
  writable: !0,
  configurable: !0
});
function pY(e, t, r) {
  Object.defineProperty(e, t, r);
}
u(pY, "f");
var $f = Symbol.for("tinyspy:spy"), QAe = /* @__PURE__ */ u((e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "P"), ZAe = /* @__PURE__ */ u((e) => (pY(e, $f, { value: { reset: /* @__PURE__ */ u(() => QAe(e[$f]), "reset") } }), e[$f]), "K"), e$e = /* @__PURE__ */ u((e) => e[$f] || ZAe(e), "T"), l1 = /* @__PURE__ */ new Set();
function fY(e) {
  return l1.add(e), () => void l1.delete(e);
}
u(fY, "onMockCall");
function hY(e) {
  const t = e ? X0(e) : X0();
  return mY(t);
}
u(hY, "fn");
function mY(e) {
  const t = c1(e), r = t.mockImplementation.bind(null);
  return t.mockImplementation = (n) => c1(r(n)), t;
}
u(mY, "reactiveMock");
function c1(e) {
  const t = e$e(e), r = t.impl;
  return t.willCall(function(...n) {
    return l1.forEach((o) => o(e, n)), r?.apply(this, n);
  }), e;
}
u(c1, "listenWhenCalled");
function yY() {
  yb.forEach((e) => e.mockClear());
}
u(yY, "clearAllMocks");
function gY() {
  yb.forEach((e) => e.mockReset());
}
u(gY, "resetAllMocks");
function bY() {
  yb.forEach((e) => e.mockRestore());
}
u(bY, "restoreAllMocks");
function t$e(e, t = {}) {
  return e;
}
u(t$e, "mocked");
var vY = {};
vp(vY, {
  buildQueries: () => xo,
  configure: () => gX,
  createEvent: () => Zu,
  findAllByAltText: () => dQ,
  findAllByDisplayValue: () => aQ,
  findAllByLabelText: () => qX,
  findAllByPlaceholderText: () => WX,
  findAllByRole: () => TQ,
  findAllByTestId: () => OQ,
  findAllByText: () => ZX,
  findAllByTitle: () => gQ,
  findByAltText: () => pQ,
  findByDisplayValue: () => iQ,
  findByLabelText: () => LX,
  findByPlaceholderText: () => GX,
  findByRole: () => AQ,
  findByTestId: () => RQ,
  findByText: () => eQ,
  findByTitle: () => bQ,
  fireEvent: () => pc,
  getAllByAltText: () => cQ,
  getAllByDisplayValue: () => nQ,
  getAllByLabelText: () => FX,
  getAllByPlaceholderText: () => zX,
  getAllByRole: () => xQ,
  getAllByTestId: () => kQ,
  getAllByText: () => XX,
  getAllByTitle: () => mQ,
  getByAltText: () => uQ,
  getByDisplayValue: () => oQ,
  getByLabelText: () => UX,
  getByPlaceholderText: () => JX,
  getByRole: () => SQ,
  getByTestId: () => PQ,
  getByText: () => QX,
  getByTitle: () => yQ,
  getConfig: () => Ve,
  getDefaultNormalizer: () => Eb,
  getElementError: () => Dp,
  getMultipleElementsFoundError: () => qp,
  getNodeText: () => Fc,
  getQueriesForElement: () => Em,
  getRoles: () => kk,
  getSuggestedQuery: () => Jd,
  isInaccessible: () => Mp,
  logDOM: () => y1,
  logRoles: () => S$e,
  makeFindQuery: () => vs,
  makeGetAllQuery: () => Tb,
  makeSingleQuery: () => bs,
  prettyDOM: () => dc,
  prettyFormat: () => uk,
  queries: () => _m,
  queryAllByAltText: () => sQ,
  queryAllByAttribute: () => ui,
  queryAllByDisplayValue: () => tQ,
  queryAllByLabelText: () => BX,
  queryAllByPlaceholderText: () => HX,
  queryAllByRole: () => _Q,
  queryAllByTestId: () => $Q,
  queryAllByText: () => KX,
  queryAllByTitle: () => fQ,
  queryByAltText: () => lQ,
  queryByAttribute: () => Ok,
  queryByDisplayValue: () => rQ,
  queryByLabelText: () => MX,
  queryByPlaceholderText: () => VX,
  queryByRole: () => EQ,
  queryByTestId: () => CQ,
  queryByText: () => YX,
  queryByTitle: () => hQ,
  queryHelpers: () => T$e,
  screen: () => z$e,
  waitFor: () => Sb,
  waitForElementToBeRemoved: () => IQ,
  within: () => Em,
  wrapAllByQueryWithSuggestion: () => Ir,
  wrapSingleQueryWithSuggestion: () => Fa
});
var uk = ar(zTe()), r$e = Object.prototype.toString;
function u1(e) {
  return typeof e == "function" || r$e.call(e) === "[object Function]";
}
u(u1, "isCallable");
function wY(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
u(wY, "toInteger");
var n$e = Math.pow(2, 53) - 1;
function _Y(e) {
  var t = wY(e);
  return Math.min(Math.max(t, 0), n$e);
}
u(_Y, "toLength");
function pn(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !u1(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var o = _Y(n.length), a = u1(r) ? Object(new r(o)) : new Array(o), i = 0, s; i < o; )
    s = n[i], t ? a[i] = t(s, i) : a[i] = s, i += 1;
  return a.length = o, a;
}
u(pn, "arrayFrom");
function cc(e) {
  "@babel/helpers - typeof";
  return cc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cc(e);
}
u(cc, "_typeof");
function EY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
u(EY, "_classCallCheck");
function d1(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, dk(n.key), n);
  }
}
u(d1, "_defineProperties");
function xY(e, t, r) {
  return t && d1(e.prototype, t), r && d1(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
u(xY, "_createClass");
function SY(e, t, r) {
  return t = dk(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
u(SY, "_defineProperty");
function dk(e) {
  var t = TY(e, "string");
  return cc(t) === "symbol" ? t : String(t);
}
u(dk, "_toPropertyKey");
function TY(e, t) {
  if (cc(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (cc(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
u(TY, "_toPrimitive");
var o$e = (function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    EY(this, e), SY(this, "items", void 0), this.items = t;
  }
  return u(e, "SetLike"), xY(e, [{
    key: "add",
    value: /* @__PURE__ */ u(function(t) {
      return this.has(t) === !1 && this.items.push(t), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ u(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ u(function(t) {
      var r = this.items.length;
      return this.items = this.items.filter(function(n) {
        return n !== t;
      }), r !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ u(function(t) {
      var r = this;
      this.items.forEach(function(n) {
        t(n, n, r);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ u(function(t) {
      return this.items.indexOf(t) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ u(function() {
      return this.items.length;
    }, "get")
  }]), e;
})(), a$e = typeof Set > "u" ? Set : o$e;
function mr(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
u(mr, "getLocalName");
var i$e = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, s$e = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function AY(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = s$e[t]) !== null && n !== void 0 && n.has(r));
  });
}
u(AY, "hasGlobalAriaAttributes");
function pk(e, t) {
  return AY(e, t);
}
u(pk, "ignorePresentationalRole");
function $Y(e) {
  var t = kY(e);
  if (t === null || t === "presentation") {
    var r = CY(e);
    if (t !== "presentation" || pk(e, r || ""))
      return r;
  }
  return t;
}
u($Y, "getRole");
function CY(e) {
  var t = i$e[mr(e)];
  if (t !== void 0)
    return t;
  switch (mr(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !pk(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
u(CY, "getImplicitRole");
function kY(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
u(kY, "getExplicitRole");
function bt(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
u(bt, "isElement");
function fk(e) {
  return bt(e) && mr(e) === "caption";
}
u(fk, "isHTMLTableCaptionElement");
function Qu(e) {
  return bt(e) && mr(e) === "input";
}
u(Qu, "isHTMLInputElement");
function PY(e) {
  return bt(e) && mr(e) === "optgroup";
}
u(PY, "isHTMLOptGroupElement");
function OY(e) {
  return bt(e) && mr(e) === "select";
}
u(OY, "isHTMLSelectElement");
function RY(e) {
  return bt(e) && mr(e) === "table";
}
u(RY, "isHTMLTableElement");
function jY(e) {
  return bt(e) && mr(e) === "textarea";
}
u(jY, "isHTMLTextAreaElement");
function IY(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
u(IY, "safeWindow");
function NY(e) {
  return bt(e) && mr(e) === "fieldset";
}
u(NY, "isHTMLFieldSetElement");
function MY(e) {
  return bt(e) && mr(e) === "legend";
}
u(MY, "isHTMLLegendElement");
function DY(e) {
  return bt(e) && mr(e) === "slot";
}
u(DY, "isHTMLSlotElement");
function qY(e) {
  return bt(e) && e.ownerSVGElement !== void 0;
}
u(qY, "isSVGElement");
function LY(e) {
  return bt(e) && mr(e) === "svg";
}
u(LY, "isSVGSVGElement");
function FY(e) {
  return qY(e) && mr(e) === "title";
}
u(FY, "isSVGTitleElement");
function zd(e, t) {
  if (bt(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(o) {
      return n.getElementById(o);
    }).filter(
      function(o) {
        return o !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
u(zd, "queryIdRefs");
function so(e, t) {
  return bt(e) ? t.indexOf($Y(e)) !== -1 : !1;
}
u(so, "hasAnyConcreteRoles");
function UY(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
u(UY, "asFlatString");
function BY(e, t) {
  if (!bt(e))
    return !1;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return !0;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
u(BY, "isHidden");
function HY(e) {
  return so(e, ["button", "combobox", "listbox", "textbox"]) || hk(e, "range");
}
u(HY, "isControl");
function hk(e, t) {
  if (!bt(e))
    return !1;
  switch (t) {
    case "range":
      return so(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
u(hk, "hasAbstractRole");
function p1(e, t) {
  var r = pn(e.querySelectorAll(t));
  return zd(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, pn(n.querySelectorAll(t)));
  }), r;
}
u(p1, "querySelectorAllSubtree");
function VY(e) {
  return OY(e) ? e.selectedOptions || p1(e, "[selected]") : p1(e, '[aria-selected="true"]');
}
u(VY, "querySelectedOptions");
function zY(e) {
  return so(e, ["none", "presentation"]);
}
u(zY, "isMarkedPresentational");
function JY(e) {
  return fk(e);
}
u(JY, "isNativeHostLanguageTextAlternativeElement");
function WY(e) {
  return so(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
u(WY, "allowsNameFromContent");
function GY(e) {
  return !1;
}
u(GY, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function KY(e) {
  return Qu(e) || jY(e) ? e.value : e.textContent || "";
}
u(KY, "getValueOfTextbox");
function f1(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
u(f1, "getTextualContent");
function mk(e) {
  var t = mr(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
u(mk, "isLabelableElement");
function yk(e) {
  if (mk(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && bt(r)) {
      var n = yk(r);
      n !== null && (t = n);
    }
  }), t;
}
u(yk, "findLabelableElement");
function YY(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : yk(e);
}
u(YY, "getControlOfLabel");
function XY(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return pn(t);
  if (!mk(e))
    return null;
  var r = e.ownerDocument;
  return pn(r.querySelectorAll("label")).filter(function(n) {
    return YY(n) === e;
  });
}
u(XY, "getLabels");
function QY(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? pn(e.childNodes) : t;
}
u(QY, "getSlotContents");
function gk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new a$e(), n = IY(e), o = t.compute, a = o === void 0 ? "name" : o, i = t.computedStyleSupportsPseudoElements, s = i === void 0 ? t.getComputedStyle !== void 0 : i, d = t.getComputedStyle, l = d === void 0 ? n.getComputedStyle.bind(n) : d, p = t.hidden, f = p === void 0 ? !1 : p;
  function h(b, x) {
    var P = "";
    if (bt(b) && s) {
      var R = l(b, "::before"), N = f1(R);
      P = "".concat(N, " ").concat(P);
    }
    var C = DY(b) ? QY(b) : pn(b.childNodes).concat(zd(b, "aria-owns"));
    if (C.forEach(function(T) {
      var O = _(T, {
        isEmbeddedInLabel: x.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), k = bt(T) ? l(T).getPropertyValue("display") : "inline", M = k !== "inline" ? " " : "";
      P += "".concat(M).concat(O).concat(M);
    }), bt(b) && s) {
      var A = l(b, "::after"), E = f1(A);
      P = "".concat(P, " ").concat(E);
    }
    return P.trim();
  }
  u(h, "computeMiscTextAlternative");
  function m(b, x) {
    var P = b.getAttributeNode(x);
    return P !== null && !r.has(P) && P.value.trim() !== "" ? (r.add(P), P.value) : null;
  }
  u(m, "useAttribute");
  function g(b) {
    return bt(b) ? m(b, "title") : null;
  }
  u(g, "computeTooltipAttributeValue");
  function w(b) {
    if (!bt(b))
      return null;
    if (NY(b)) {
      r.add(b);
      for (var x = pn(b.childNodes), P = 0; P < x.length; P += 1) {
        var R = x[P];
        if (MY(R))
          return _(R, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (RY(b)) {
      r.add(b);
      for (var N = pn(b.childNodes), C = 0; C < N.length; C += 1) {
        var A = N[C];
        if (fk(A))
          return _(A, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (LY(b)) {
      r.add(b);
      for (var E = pn(b.childNodes), T = 0; T < E.length; T += 1) {
        var O = E[T];
        if (FY(O))
          return O.textContent;
      }
      return null;
    } else if (mr(b) === "img" || mr(b) === "area") {
      var k = m(b, "alt");
      if (k !== null)
        return k;
    } else if (PY(b)) {
      var M = m(b, "label");
      if (M !== null)
        return M;
    }
    if (Qu(b) && (b.type === "button" || b.type === "submit" || b.type === "reset")) {
      var L = m(b, "value");
      if (L !== null)
        return L;
      if (b.type === "submit")
        return "Submit";
      if (b.type === "reset")
        return "Reset";
    }
    var $ = XY(b);
    if ($ !== null && $.length !== 0)
      return r.add(b), pn($).map(function(J) {
        return _(J, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(J) {
        return J.length > 0;
      }).join(" ");
    if (Qu(b) && b.type === "image") {
      var I = m(b, "alt");
      if (I !== null)
        return I;
      var D = m(b, "title");
      return D !== null ? D : "Submit Query";
    }
    if (so(b, ["button"])) {
      var F = h(b, {
        isEmbeddedInLabel: !1
      });
      if (F !== "")
        return F;
    }
    return null;
  }
  u(w, "computeElementTextAlternative");
  function _(b, x) {
    if (r.has(b))
      return "";
    if (!f && BY(b, l) && !x.isReferenced)
      return r.add(b), "";
    var P = bt(b) ? b.getAttributeNode("aria-labelledby") : null, R = P !== null && !r.has(P) ? zd(b, "aria-labelledby") : [];
    if (a === "name" && !x.isReferenced && R.length > 0)
      return r.add(P), R.map(function(k) {
        return _(k, {
          isEmbeddedInLabel: x.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var N = x.recursion && HY(b) && a === "name";
    if (!N) {
      var C = (bt(b) && b.getAttribute("aria-label") || "").trim();
      if (C !== "" && a === "name")
        return r.add(b), C;
      if (!zY(b)) {
        var A = w(b);
        if (A !== null)
          return r.add(b), A;
      }
    }
    if (so(b, ["menu"]))
      return r.add(b), "";
    if (N || x.isEmbeddedInLabel || x.isReferenced) {
      if (so(b, ["combobox", "listbox"])) {
        r.add(b);
        var E = VY(b);
        return E.length === 0 ? Qu(b) ? b.value : "" : pn(E).map(function(k) {
          return _(k, {
            isEmbeddedInLabel: x.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (hk(b, "range"))
        return r.add(b), b.hasAttribute("aria-valuetext") ? b.getAttribute("aria-valuetext") : b.hasAttribute("aria-valuenow") ? b.getAttribute("aria-valuenow") : b.getAttribute("value") || "";
      if (so(b, ["textbox"]))
        return r.add(b), KY(b);
    }
    if (WY(b) || bt(b) && x.isReferenced || JY(b) || GY()) {
      var T = h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
      if (T !== "")
        return r.add(b), T;
    }
    if (b.nodeType === b.TEXT_NODE)
      return r.add(b), b.textContent || "";
    if (x.recursion)
      return r.add(b), h(b, {
        isEmbeddedInLabel: x.isEmbeddedInLabel
      });
    var O = g(b);
    return O !== null ? (r.add(b), O) : (r.add(b), "");
  }
  return u(_, "computeTextAlternative"), UY(_(e, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: a === "description",
    recursion: !1
  }));
}
u(gk, "computeTextAlternative");
function uc(e) {
  "@babel/helpers - typeof";
  return uc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, uc(e);
}
u(uc, "_typeof");
function h1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
u(h1, "ownKeys");
function m1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h1(Object(r), !0).forEach(function(n) {
      ZY(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : h1(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
u(m1, "_objectSpread");
function ZY(e, t, r) {
  return t = eX(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
u(ZY, "_defineProperty");
function eX(e) {
  var t = tX(e, "string");
  return uc(t) === "symbol" ? t : String(t);
}
u(eX, "_toPropertyKey");
function tX(e, t) {
  if (uc(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (uc(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
u(tX, "_toPrimitive");
function bk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = zd(e, "aria-describedby").map(function(o) {
    return gk(o, m1(m1({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("title");
    r = n === null ? "" : n;
  }
  return r;
}
u(bk, "computeAccessibleDescription");
function rX(e) {
  return so(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
u(rX, "prohibitsNaming");
function wb(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return rX(e) ? "" : gk(e, t);
}
u(wb, "computeAccessibleName");
var an = ar($$()), l$e = ar(JTe());
function vk(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
u(vk, "escapeHTML");
var c$e = /* @__PURE__ */ u((e, t, r, n, o, a, i) => {
  const s = n + r.indent, d = r.colors;
  return e.map((l) => {
    const p = t[l];
    let f = i(p, r, s, o, a);
    return typeof p != "string" && (f.indexOf(`
`) !== -1 && (f = r.spacingOuter + s + f + r.spacingOuter + n), f = "{" + f + "}"), r.spacingInner + n + d.prop.open + l + d.prop.close + "=" + d.value.open + f + d.value.close;
  }).join("");
}, "printProps"), u$e = 3, d$e = /* @__PURE__ */ u((e, t, r, n, o, a) => e.map((i) => {
  const s = typeof i == "string" ? nX(i, t) : a(i, t, r, n, o);
  return s === "" && typeof i == "object" && i !== null && i.nodeType !== u$e ? "" : t.spacingOuter + r + s;
}).join(""), "printChildren"), nX = /* @__PURE__ */ u((e, t) => {
  const r = t.colors.content;
  return r.open + vk(e) + r.close;
}, "printText"), p$e = /* @__PURE__ */ u((e, t) => {
  const r = t.colors.comment;
  return r.open + "<!--" + vk(e) + "-->" + r.close;
}, "printComment"), f$e = /* @__PURE__ */ u((e, t, r, n, o) => {
  const a = n.colors.tag;
  return a.open + "<" + e + (t && a.close + t + n.spacingOuter + o + a.open) + (r ? ">" + a.close + r + n.spacingOuter + o + a.open + "</" + e : (t && !n.min ? "" : " ") + "/") + ">" + a.close;
}, "printElement"), h$e = /* @__PURE__ */ u((e, t) => {
  const r = t.colors.tag;
  return r.open + "<" + e + r.close + " â€¦" + r.open + " />" + r.close;
}, "printElementAsLeaf"), m$e = 1, oX = 3, aX = 8, iX = 11, y$e = /^((HTML|SVG)\w*)?Element$/, sX = /* @__PURE__ */ u((e) => {
  const {
    tagName: t
  } = e;
  return !!(typeof t == "string" && t.includes("-") || typeof e.hasAttribute == "function" && e.hasAttribute("is"));
}, "isCustomElement"), g$e = /* @__PURE__ */ u((e) => {
  const t = e.constructor.name, {
    nodeType: r
  } = e;
  return r === m$e && (y$e.test(t) || sX(e)) || r === oX && t === "Text" || r === aX && t === "Comment" || r === iX && t === "DocumentFragment";
}, "testNode");
function lX(e) {
  return e.nodeType === oX;
}
u(lX, "nodeIsText");
function cX(e) {
  return e.nodeType === aX;
}
u(cX, "nodeIsComment");
function Cf(e) {
  return e.nodeType === iX;
}
u(Cf, "nodeIsFragment");
function uX(e) {
  return {
    test: /* @__PURE__ */ u((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || sX(t)) && g$e(t);
    }, "test"),
    serialize: /* @__PURE__ */ u((t, r, n, o, a, i) => {
      if (lX(t))
        return nX(t.data, r);
      if (cX(t))
        return p$e(t.data, r);
      const s = Cf(t) ? "DocumentFragment" : t.tagName.toLowerCase();
      return ++o > r.maxDepth ? h$e(s, r) : f$e(s, c$e(Cf(t) ? [] : Array.from(t.attributes).map((d) => d.name).sort(), Cf(t) ? {} : Array.from(t.attributes).reduce((d, l) => (d[l.name] = l.value, d), {}), r, n + r.indent, o, a, i), d$e(Array.prototype.slice.call(t.childNodes || t.children).filter(e), r, n + r.indent, o, a, i), r, n);
    }, "serialize")
  };
}
u(uX, "createDOMElementFilter");
var dX = null, wk = null, _k = null;
try {
  const e = module && module.require;
  wk = e.call(module, "fs").readFileSync, _k = e.call(module, "@babel/code-frame").codeFrameColumns, dX = e.call(module, "picocolors");
} catch {
}
function pX(e) {
  const t = e.indexOf("(") + 1, r = e.indexOf(")"), n = e.slice(t, r), o = n.split(":"), [a, i, s] = [o[0], parseInt(o[1], 10), parseInt(o[2], 10)];
  let d = "";
  try {
    d = wk(a, "utf-8");
  } catch {
    return "";
  }
  const l = _k(d, {
    start: {
      line: i,
      column: s
    }
  }, {
    highlightCode: !0,
    linesBelow: 0
  });
  return dX.dim(n) + `
` + l + `
`;
}
u(pX, "getCodeFrame");
function fX() {
  if (!wk || !_k)
    return "";
  const e = new Error().stack.split(`
`).slice(1).find((t) => !t.includes("node_modules/"));
  return pX(e);
}
u(fX, "getUserCodeFrame");
var hX = 3;
function kf() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === !0 || // modern timers
    // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : !1;
}
u(kf, "jestFakeTimersAreEnabled");
function _b() {
  if (typeof window > "u")
    throw new Error("Could not find default container");
  return window.document;
}
u(_b, "getDocument");
function Ek(e) {
  if (e.defaultView)
    return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView)
    return e.ownerDocument.defaultView;
  if (e.window)
    return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : e.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(e) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof e.debug == "function" && typeof e.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof e + ".");
}
u(Ek, "getWindowFromNode");
function Eo(e) {
  if (!e || typeof e.querySelector != "function" || typeof e.querySelectorAll != "function")
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + t(e) + ".");
  function t(r) {
    return typeof r == "object" ? r === null ? "null" : r.constructor.name : typeof r;
  }
  u(t, "getTypeName");
}
u(Eo, "checkContainerType");
var b$e = /* @__PURE__ */ u(() => {
  if (typeof process > "u")
    return !1;
  let e;
  try {
    var t;
    const r = (t = Fh) == null ? void 0 : t.COLORS;
    r && (e = JSON.parse(r));
  } catch {
  }
  return typeof e == "boolean" ? e : process.versions !== void 0 && process.versions.node !== void 0;
}, "shouldHighlight"), {
  DOMCollection: v$e
} = uk.plugins, w$e = 1, _$e = 8;
function mX(e) {
  return e.nodeType !== _$e && (e.nodeType !== w$e || !e.matches(Ve().defaultIgnore));
}
u(mX, "filterCommentsAndDefaultIgnoreTagsTags");
function dc(e, t, r) {
  if (r === void 0 && (r = {}), e || (e = _b().body), typeof t != "number" && (t = typeof process < "u" && typeof Fh < "u" && Fh.DEBUG_PRINT_LIMIT || 7e3), t === 0)
    return "";
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if (n === "object" ? n = e.constructor.name : e = {}, !("outerHTML" in e))
    throw new TypeError("Expected an element or document but got " + n);
  const {
    filterNode: o = mX,
    ...a
  } = r, i = uk.format(e, {
    plugins: [uX(o), v$e],
    printFunctionName: !1,
    highlight: b$e(),
    ...a
  });
  return t !== void 0 && e.outerHTML.length > t ? i.slice(0, t) + "..." : i;
}
u(dc, "prettyDOM");
var y1 = /* @__PURE__ */ u(function() {
  const e = fX();
  console.log(e ? dc(...arguments) + `

` + e : dc(...arguments));
}, "logDOM"), rs = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: /* @__PURE__ */ u((e) => e(), "asyncWrapper"),
  unstable_advanceTimersWrapper: /* @__PURE__ */ u((e) => e(), "unstable_advanceTimersWrapper"),
  eventWrapper: /* @__PURE__ */ u((e) => e(), "eventWrapper"),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: !1,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: !1,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: !1,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(e, t) {
    const r = dc(t), n = new Error([e, "Ignored nodes: comments, " + rs.defaultIgnore + `
` + r].filter(Boolean).join(`

`));
    return n.name = "TestingLibraryElementError", n;
  },
  _disableExpensiveErrorDiagnostics: !1,
  computedStyleSupportsPseudoElements: !1
};
function yX(e) {
  try {
    return rs._disableExpensiveErrorDiagnostics = !0, e();
  } finally {
    rs._disableExpensiveErrorDiagnostics = !1;
  }
}
u(yX, "runWithExpensiveErrorDiagnosticsDisabled");
function gX(e) {
  typeof e == "function" && (e = e(rs)), rs = {
    ...rs,
    ...e
  };
}
u(gX, "configure");
function Ve() {
  return rs;
}
u(Ve, "getConfig");
var E$e = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function xk(e) {
  return E$e.includes(e.nodeName.toLowerCase()) ? "" : e.nodeType === hX ? e.textContent : Array.from(e.childNodes).map((t) => xk(t)).join("");
}
u(xk, "getTextContent");
function wm(e) {
  let t;
  return e.tagName.toLowerCase() === "label" ? t = xk(e) : t = e.value || e.textContent, t;
}
u(wm, "getLabelContent");
function Sk(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!bX(e)) return [];
  const r = e.ownerDocument.querySelectorAll("label");
  return Array.from(r).filter((n) => n.control === e);
}
u(Sk, "getRealLabels");
function bX(e) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) || e.tagName === "INPUT" && e.getAttribute("type") !== "hidden";
}
u(bX, "isLabelable");
function Tk(e, t, r) {
  let {
    selector: n = "*"
  } = r === void 0 ? {} : r;
  const o = t.getAttribute("aria-labelledby"), a = o ? o.split(" ") : [];
  return a.length ? a.map((i) => {
    const s = e.querySelector('[id="' + i + '"]');
    return s ? {
      content: wm(s),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(Sk(t)).map((i) => {
    const s = wm(i), d = Array.from(i.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((l) => l.matches(n))[0];
    return {
      content: s,
      formControl: d
    };
  });
}
u(Tk, "getLabels");
function Ak(e) {
  if (e == null)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + e + " was passed instead of a matcher. Did you do something like getByText(" + e + ")?"
    );
}
u(Ak, "assertNotNullOrUndefined");
function Ls(e, t, r, n) {
  if (typeof e != "string")
    return !1;
  Ak(r);
  const o = n(e);
  return typeof r == "string" || typeof r == "number" ? o.toLowerCase().includes(r.toString().toLowerCase()) : typeof r == "function" ? r(o, t) : $k(r, o);
}
u(Ls, "fuzzyMatches");
function po(e, t, r, n) {
  if (typeof e != "string")
    return !1;
  Ak(r);
  const o = n(e);
  return r instanceof Function ? r(o, t) : r instanceof RegExp ? $k(r, o) : o === String(r);
}
u(po, "matches");
function Eb(e) {
  let {
    trim: t = !0,
    collapseWhitespace: r = !0
  } = e === void 0 ? {} : e;
  return (n) => {
    let o = n;
    return o = t ? o.trim() : o, o = r ? o.replace(/\s+/g, " ") : o, o;
  };
}
u(Eb, "getDefaultNormalizer");
function ci(e) {
  let {
    trim: t,
    collapseWhitespace: r,
    normalizer: n
  } = e;
  if (!n)
    return Eb({
      trim: t,
      collapseWhitespace: r
    });
  if (typeof t < "u" || typeof r < "u")
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return n;
}
u(ci, "makeNormalizer");
function $k(e, t) {
  const r = e.test(t);
  return e.global && e.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), e.lastIndex = 0), r;
}
u($k, "matchRegExp");
function Fc(e) {
  return e.matches("input[type=submit], input[type=button], input[type=reset]") ? e.value : Array.from(e.childNodes).filter((t) => t.nodeType === hX && !!t.textContent).map((t) => t.textContent).join("");
}
u(Fc, "getNodeText");
var x$e = vX(an.elementRoles);
function Ck(e) {
  return e.hidden === !0 || e.getAttribute("aria-hidden") === "true" || e.ownerDocument.defaultView.getComputedStyle(e).display === "none";
}
u(Ck, "isSubtreeInaccessible");
function Mp(e, t) {
  t === void 0 && (t = {});
  const {
    isSubtreeInaccessible: r = Ck
  } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === "hidden")
    return !0;
  let n = e;
  for (; n; ) {
    if (r(n))
      return !0;
    n = n.parentElement;
  }
  return !1;
}
u(Mp, "isInaccessible");
function xb(e) {
  for (const {
    match: t,
    roles: r
  } of x$e)
    if (t(e))
      return [...r];
  return [];
}
u(xb, "getImplicitAriaRoles");
function vX(e) {
  function t(i) {
    let {
      name: s,
      attributes: d
    } = i;
    return "" + s + d.map((l) => {
      let {
        name: p,
        value: f,
        constraints: h = []
      } = l;
      const m = h.indexOf("undefined") !== -1, g = h.indexOf("set") !== -1;
      return typeof f < "u" ? "[" + p + '="' + f + '"]' : m ? ":not([" + p + "])" : g ? "[" + p + "]:not([" + p + '=""])' : "[" + p + "]";
    }).join("");
  }
  u(t, "makeElementSelector");
  function r(i) {
    let {
      attributes: s = []
    } = i;
    return s.length;
  }
  u(r, "getSelectorSpecificity");
  function n(i, s) {
    let {
      specificity: d
    } = i, {
      specificity: l
    } = s;
    return l - d;
  }
  u(n, "bySelectorSpecificity");
  function o(i) {
    let {
      attributes: s = []
    } = i;
    const d = s.findIndex((p) => p.value && p.name === "type" && p.value === "text");
    d >= 0 && (s = [...s.slice(0, d), ...s.slice(d + 1)]);
    const l = t({
      ...i,
      attributes: s
    });
    return (p) => d >= 0 && p.type !== "text" ? !1 : p.matches(l);
  }
  u(o, "match");
  let a = [];
  for (const [i, s] of e.entries())
    a = [...a, {
      match: o(i),
      roles: Array.from(s),
      specificity: r(i)
    }];
  return a.sort(n);
}
u(vX, "buildElementRoleList");
function kk(e, t) {
  let {
    hidden: r = !1
  } = t === void 0 ? {} : t;
  function n(o) {
    return [o, ...Array.from(o.children).reduce((a, i) => [...a, ...n(i)], [])];
  }
  return u(n, "flattenDOM"), n(e).filter((o) => r === !1 ? Mp(o) === !1 : !0).reduce((o, a) => {
    let i = [];
    return a.hasAttribute("role") ? i = a.getAttribute("role").split(" ").slice(0, 1) : i = xb(a), i.reduce((s, d) => Array.isArray(s[d]) ? {
      ...s,
      [d]: [...s[d], a]
    } : {
      ...s,
      [d]: [a]
    }, o);
  }, {});
}
u(kk, "getRoles");
function Pk(e, t) {
  let {
    hidden: r,
    includeDescription: n
  } = t;
  const o = kk(e, {
    hidden: r
  });
  return Object.entries(o).filter((a) => {
    let [i] = a;
    return i !== "generic";
  }).map((a) => {
    let [i, s] = a;
    const d = "-".repeat(50), l = s.map((p) => {
      const f = 'Name "' + wb(p, {
        computedStyleSupportsPseudoElements: Ve().computedStyleSupportsPseudoElements
      }) + `":
`, h = dc(p.cloneNode(!1));
      if (n) {
        const m = 'Description "' + bk(p, {
          computedStyleSupportsPseudoElements: Ve().computedStyleSupportsPseudoElements
        }) + `":
`;
        return "" + f + m + h;
      }
      return "" + f + h;
    }).join(`

`);
    return i + `:

` + l + `

` + d;
  }).join(`
`);
}
u(Pk, "prettyRoles");
var S$e = /* @__PURE__ */ u(function(e, t) {
  let {
    hidden: r = !1
  } = t === void 0 ? {} : t;
  return console.log(Pk(e, {
    hidden: r
  }));
}, "logRoles");
function wX(e) {
  return e.tagName === "OPTION" ? e.selected : Uc(e, "aria-selected");
}
u(wX, "computeAriaSelected");
function _X(e) {
  return e.getAttribute("aria-busy") === "true";
}
u(_X, "computeAriaBusy");
function EX(e) {
  if (!("indeterminate" in e && e.indeterminate))
    return "checked" in e ? e.checked : Uc(e, "aria-checked");
}
u(EX, "computeAriaChecked");
function xX(e) {
  return Uc(e, "aria-pressed");
}
u(xX, "computeAriaPressed");
function SX(e) {
  var t, r;
  return (t = (r = Uc(e, "aria-current")) != null ? r : e.getAttribute("aria-current")) != null ? t : !1;
}
u(SX, "computeAriaCurrent");
function TX(e) {
  return Uc(e, "aria-expanded");
}
u(TX, "computeAriaExpanded");
function Uc(e, t) {
  const r = e.getAttribute(t);
  if (r === "true")
    return !0;
  if (r === "false")
    return !1;
}
u(Uc, "checkBooleanAttribute");
function AX(e) {
  const t = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  return e.getAttribute("aria-level") && Number(e.getAttribute("aria-level")) || t[e.tagName];
}
u(AX, "computeHeadingLevel");
function $X(e) {
  const t = e.getAttribute("aria-valuenow");
  return t === null ? void 0 : +t;
}
u($X, "computeAriaValueNow");
function CX(e) {
  const t = e.getAttribute("aria-valuemax");
  return t === null ? void 0 : +t;
}
u(CX, "computeAriaValueMax");
function kX(e) {
  const t = e.getAttribute("aria-valuemin");
  return t === null ? void 0 : +t;
}
u(kX, "computeAriaValueMin");
function PX(e) {
  const t = e.getAttribute("aria-valuetext");
  return t === null ? void 0 : t;
}
u(PX, "computeAriaValueText");
var Vj = Eb();
function OX(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
u(OX, "escapeRegExp");
function g1(e) {
  return new RegExp(OX(e.toLowerCase()), "i");
}
u(g1, "getRegExpMatcher");
function Fo(e, t, r, n) {
  let {
    variant: o,
    name: a
  } = n, i = "";
  const s = {}, d = [["Role", "TestId"].includes(e) ? r : g1(r)];
  a && (s.name = g1(a)), e === "Role" && Mp(t) && (s.hidden = !0, i = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(s).length > 0 && d.push(s);
  const l = o + "By" + e;
  return {
    queryName: e,
    queryMethod: l,
    queryArgs: d,
    variant: o,
    warning: i,
    toString() {
      i && console.warn(i);
      let [p, f] = d;
      return p = typeof p == "string" ? "'" + p + "'" : p, f = f ? ", { " + Object.entries(f).map((h) => {
        let [m, g] = h;
        return m + ": " + g;
      }).join(", ") + " }" : "", l + "(" + p + f + ")";
    }
  };
}
u(Fo, "makeSuggestion");
function Uo(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
u(Uo, "canSuggest");
function Jd(e, t, r) {
  var n, o;
  if (t === void 0 && (t = "get"), e.matches(Ve().defaultIgnore))
    return;
  const a = (n = e.getAttribute("role")) != null ? n : (o = xb(e)) == null ? void 0 : o[0];
  if (a !== "generic" && Uo("Role", r, a))
    return Fo("Role", e, a, {
      variant: t,
      name: wb(e, {
        computedStyleSupportsPseudoElements: Ve().computedStyleSupportsPseudoElements
      })
    });
  const i = Tk(document, e).map((h) => h.content).join(" ");
  if (Uo("LabelText", r, i))
    return Fo("LabelText", e, i, {
      variant: t
    });
  const s = e.getAttribute("placeholder");
  if (Uo("PlaceholderText", r, s))
    return Fo("PlaceholderText", e, s, {
      variant: t
    });
  const d = Vj(Fc(e));
  if (Uo("Text", r, d))
    return Fo("Text", e, d, {
      variant: t
    });
  if (Uo("DisplayValue", r, e.value))
    return Fo("DisplayValue", e, Vj(e.value), {
      variant: t
    });
  const l = e.getAttribute("alt");
  if (Uo("AltText", r, l))
    return Fo("AltText", e, l, {
      variant: t
    });
  const p = e.getAttribute("title");
  if (Uo("Title", r, p))
    return Fo("Title", e, p, {
      variant: t
    });
  const f = e.getAttribute(Ve().testIdAttribute);
  if (Uo("TestId", r, f))
    return Fo("TestId", e, f, {
      variant: t
    });
}
u(Jd, "getSuggestedQuery");
function xu(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
u(xu, "copyStackTrace");
function RX(e, t) {
  let {
    container: r = _b(),
    timeout: n = Ve().asyncUtilTimeout,
    showOriginalStackTrace: o = Ve().showOriginalStackTrace,
    stackTraceError: a,
    interval: i = 50,
    onTimeout: s = /* @__PURE__ */ u((l) => (Object.defineProperty(l, "message", {
      value: Ve().getElementError(l.message, r).message
    }), l), "onTimeout"),
    mutationObserverOptions: d = {
      subtree: !0,
      childList: !0,
      attributes: !0,
      characterData: !0
    }
  } = t;
  if (typeof e != "function")
    throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (l, p) => {
    let f, h, m, g = !1, w = "idle";
    const _ = setTimeout(N, n), b = kf();
    if (b) {
      const {
        unstable_advanceTimersWrapper: C
      } = Ve();
      for (R(); !g; ) {
        if (!kf()) {
          const A = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          o || xu(A, a), p(A);
          return;
        }
        if (await C(async () => {
          jest.advanceTimersByTime(i);
        }), g)
          break;
        R();
      }
    } else {
      try {
        Eo(r);
      } catch (A) {
        p(A);
        return;
      }
      h = setInterval(P, i);
      const {
        MutationObserver: C
      } = Ek(r);
      m = new C(P), m.observe(r, d), R();
    }
    function x(C, A) {
      g = !0, clearTimeout(_), b || (clearInterval(h), m.disconnect()), C ? p(C) : l(A);
    }
    u(x, "onDone");
    function P() {
      if (kf()) {
        const C = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return o || xu(C, a), p(C);
      } else
        return R();
    }
    u(P, "checkRealTimersCallback");
    function R() {
      if (w !== "pending")
        try {
          const C = yX(e);
          typeof C?.then == "function" ? (w = "pending", C.then((A) => {
            w = "resolved", x(null, A);
          }, (A) => {
            w = "rejected", f = A;
          })) : x(null, C);
        } catch (C) {
          f = C;
        }
    }
    u(R, "checkCallback");
    function N() {
      let C;
      f ? (C = f, !o && C.name === "TestingLibraryElementError" && xu(C, a)) : (C = new Error("Timed out in waitFor."), o || xu(C, a)), x(s(C), null);
    }
    u(N, "handleTimeout");
  });
}
u(RX, "waitFor");
function Sb(e, t) {
  const r = new Error("STACK_TRACE_MESSAGE");
  return Ve().asyncWrapper(() => RX(e, {
    stackTraceError: r,
    ...t
  }));
}
u(Sb, "waitForWrapper");
function Dp(e, t) {
  return Ve().getElementError(e, t);
}
u(Dp, "getElementError");
function qp(e, t) {
  return Dp(e + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", t);
}
u(qp, "getMultipleElementsFoundError");
function ui(e, t, r, n) {
  let {
    exact: o = !0,
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  } = n === void 0 ? {} : n;
  const d = o ? po : Ls, l = ci({
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  });
  return Array.from(t.querySelectorAll("[" + e + "]")).filter((p) => d(p.getAttribute(e), p, r, l));
}
u(ui, "queryAllByAttribute");
function Ok(e, t, r, n) {
  const o = ui(e, t, r, n);
  if (o.length > 1)
    throw qp("Found multiple elements by [" + e + "=" + r + "]", t);
  return o[0] || null;
}
u(Ok, "queryByAttribute");
function bs(e, t) {
  return function(r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
      o[a - 1] = arguments[a];
    const i = e(r, ...o);
    if (i.length > 1) {
      const s = i.map((d) => Dp(null, d).message).join(`

`);
      throw qp(t(r, ...o) + `

Here are the matching elements:

` + s, r);
    }
    return i[0] || null;
  };
}
u(bs, "makeSingleQuery");
function Rk(e, t) {
  return Ve().getElementError(`A better query is available, try this:
` + e.toString() + `
`, t);
}
u(Rk, "getSuggestionError");
function Tb(e, t) {
  return function(r) {
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
      o[a - 1] = arguments[a];
    const i = e(r, ...o);
    if (!i.length)
      throw Ve().getElementError(t(r, ...o), r);
    return i;
  };
}
u(Tb, "makeGetAllQuery");
function vs(e) {
  return (t, r, n, o) => Sb(() => e(t, r, n), {
    container: t,
    ...o
  });
}
u(vs, "makeFindQuery");
var Fa = /* @__PURE__ */ u((e, t, r) => function(n) {
  for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
    a[i - 1] = arguments[i];
  const s = e(n, ...a), [{
    suggest: d = Ve().throwSuggestions
  } = {}] = a.slice(-1);
  if (s && d) {
    const l = Jd(s, r);
    if (l && !t.endsWith(l.queryName))
      throw Rk(l.toString(), n);
  }
  return s;
}, "wrapSingleQueryWithSuggestion"), Ir = /* @__PURE__ */ u((e, t, r) => function(n) {
  for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
    a[i - 1] = arguments[i];
  const s = e(n, ...a), [{
    suggest: d = Ve().throwSuggestions
  } = {}] = a.slice(-1);
  if (s.length && d) {
    const l = [...new Set(s.map((p) => {
      var f;
      return (f = Jd(p, r)) == null ? void 0 : f.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      l.length === 1 && !t.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        Jd(s[0], r).queryName
      )
    )
      throw Rk(l[0], n);
  }
  return s;
}, "wrapAllByQueryWithSuggestion");
function xo(e, t, r) {
  const n = Fa(bs(e, t), e.name, "query"), o = Tb(e, r), a = bs(o, t), i = Fa(a, e.name, "get"), s = Ir(o, e.name.replace("query", "get"), "getAll"), d = vs(Ir(o, e.name, "findAll")), l = vs(Fa(a, e.name, "find"));
  return [n, s, i, d, l];
}
u(xo, "buildQueries");
var T$e = Object.freeze({
  __proto__: null,
  getElementError: Dp,
  wrapAllByQueryWithSuggestion: Ir,
  wrapSingleQueryWithSuggestion: Fa,
  getMultipleElementsFoundError: qp,
  queryAllByAttribute: ui,
  queryByAttribute: Ok,
  makeSingleQuery: bs,
  makeGetAllQuery: Tb,
  makeFindQuery: vs,
  buildQueries: xo
});
function jX(e) {
  return Array.from(e.querySelectorAll("label,input")).map((t) => ({
    node: t,
    textToMatch: wm(t)
  })).filter((t) => {
    let {
      textToMatch: r
    } = t;
    return r !== null;
  });
}
u(jX, "queryAllLabels");
var A$e = /* @__PURE__ */ u(function(e, t, r) {
  let {
    exact: n = !0,
    trim: o,
    collapseWhitespace: a,
    normalizer: i
  } = r === void 0 ? {} : r;
  const s = n ? po : Ls, d = ci({
    collapseWhitespace: a,
    trim: o,
    normalizer: i
  });
  return jX(e).filter((l) => {
    let {
      node: p,
      textToMatch: f
    } = l;
    return s(f, p, t, d);
  }).map((l) => {
    let {
      node: p
    } = l;
    return p;
  });
}, "queryAllLabelsByText"), Wd = /* @__PURE__ */ u(function(e, t, r) {
  let {
    selector: n = "*",
    exact: o = !0,
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  } = r === void 0 ? {} : r;
  Eo(e);
  const d = o ? po : Ls, l = ci({
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  }), p = Array.from(e.querySelectorAll("*")).filter((f) => Sk(f).length || f.hasAttribute("aria-labelledby")).reduce((f, h) => {
    const m = Tk(e, h, {
      selector: n
    });
    m.filter((w) => !!w.formControl).forEach((w) => {
      d(w.content, w.formControl, t, l) && w.formControl && f.push(w.formControl);
    });
    const g = m.filter((w) => !!w.content).map((w) => w.content);
    return d(g.join(" "), h, t, l) && f.push(h), g.length > 1 && g.forEach((w, _) => {
      d(w, h, t, l) && f.push(h);
      const b = [...g];
      b.splice(_, 1), b.length > 1 && d(b.join(" "), h, t, l) && f.push(h);
    }), f;
  }, []).concat(ui("aria-label", e, t, {
    exact: o,
    normalizer: l
  }));
  return Array.from(new Set(p)).filter((f) => f.matches(n));
}, "queryAllByLabelText"), ws = /* @__PURE__ */ u(function(e, t) {
  for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
    n[o - 2] = arguments[o];
  const a = Wd(e, t, ...n);
  if (!a.length) {
    const i = A$e(e, t, ...n);
    if (i.length) {
      const s = i.map((d) => IX(e, d)).filter((d) => !!d);
      throw s.length ? Ve().getElementError(s.map((d) => "Found a label with the text of: " + t + ", however the element associated with this label (<" + d + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + d + " />, you can use aria-label or aria-labelledby instead.").join(`

`), e) : Ve().getElementError("Found a label with the text of: " + t + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, e);
    } else
      throw Ve().getElementError("Unable to find a label with the text of: " + t, e);
  }
  return a;
}, "getAllByLabelText");
function IX(e, t) {
  const r = t.getAttribute("for");
  if (!r)
    return null;
  const n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
u(IX, "getTagNameOfElementAssociatedWithLabelViaFor");
var NX = /* @__PURE__ */ u((e, t) => "Found multiple elements with the text of: " + t, "getMultipleError$7"), MX = Fa(bs(Wd, NX), Wd.name, "query"), DX = bs(ws, NX), qX = vs(Ir(ws, ws.name, "findAll")), LX = vs(Fa(DX, ws.name, "find")), FX = Ir(ws, ws.name, "getAll"), UX = Fa(DX, ws.name, "get"), BX = Ir(Wd, Wd.name, "queryAll"), b1 = /* @__PURE__ */ u(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return Eo(t[0]), ui("placeholder", ...t);
}, "queryAllByPlaceholderText"), $$e = /* @__PURE__ */ u((e, t) => "Found multiple elements with the placeholder text of: " + t, "getMultipleError$6"), C$e = /* @__PURE__ */ u((e, t) => "Unable to find an element with the placeholder text of: " + t, "getMissingError$6"), HX = Ir(b1, b1.name, "queryAll"), [VX, zX, JX, WX, GX] = xo(b1, $$e, C$e), v1 = /* @__PURE__ */ u(function(e, t, r) {
  let {
    selector: n = "*",
    exact: o = !0,
    collapseWhitespace: a,
    trim: i,
    ignore: s = Ve().defaultIgnore,
    normalizer: d
  } = r === void 0 ? {} : r;
  Eo(e);
  const l = o ? po : Ls, p = ci({
    collapseWhitespace: a,
    trim: i,
    normalizer: d
  });
  let f = [];
  return typeof e.matches == "function" && e.matches(n) && (f = [e]), [...f, ...Array.from(e.querySelectorAll(n))].filter((h) => !s || !h.matches(s)).filter((h) => l(Fc(h), h, t, p));
}, "queryAllByText"), k$e = /* @__PURE__ */ u((e, t) => "Found multiple elements with the text: " + t, "getMultipleError$5"), P$e = /* @__PURE__ */ u(function(e, t, r) {
  r === void 0 && (r = {});
  const {
    collapseWhitespace: n,
    trim: o,
    normalizer: a,
    selector: i
  } = r, s = ci({
    collapseWhitespace: n,
    trim: o,
    normalizer: a
  })(t.toString()), d = s !== t.toString(), l = (i ?? "*") !== "*";
  return "Unable to find an element with the text: " + (d ? s + " (normalized from '" + t + "')" : t) + (l ? ", which matches selector '" + i + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
}, "getMissingError$5"), KX = Ir(v1, v1.name, "queryAll"), [YX, XX, QX, ZX, eQ] = xo(v1, k$e, P$e), w1 = /* @__PURE__ */ u(function(e, t, r) {
  let {
    exact: n = !0,
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  } = r === void 0 ? {} : r;
  Eo(e);
  const s = n ? po : Ls, d = ci({
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  });
  return Array.from(e.querySelectorAll("input,textarea,select")).filter((l) => l.tagName === "SELECT" ? Array.from(l.options).filter((p) => p.selected).some((p) => s(Fc(p), p, t, d)) : s(l.value, l, t, d));
}, "queryAllByDisplayValue"), O$e = /* @__PURE__ */ u((e, t) => "Found multiple elements with the display value: " + t + ".", "getMultipleError$4"), R$e = /* @__PURE__ */ u((e, t) => "Unable to find an element with the display value: " + t + ".", "getMissingError$4"), tQ = Ir(w1, w1.name, "queryAll"), [rQ, nQ, oQ, aQ, iQ] = xo(w1, O$e, R$e), j$e = /^(img|input|area|.+-.+)$/i, _1 = /* @__PURE__ */ u(function(e, t, r) {
  return r === void 0 && (r = {}), Eo(e), ui("alt", e, t, r).filter((n) => j$e.test(n.tagName));
}, "queryAllByAltText"), I$e = /* @__PURE__ */ u((e, t) => "Found multiple elements with the alt text: " + t, "getMultipleError$3"), N$e = /* @__PURE__ */ u((e, t) => "Unable to find an element with the alt text: " + t, "getMissingError$3"), sQ = Ir(_1, _1.name, "queryAll"), [lQ, cQ, uQ, dQ, pQ] = xo(_1, I$e, N$e), M$e = /* @__PURE__ */ u((e) => {
  var t;
  return e.tagName.toLowerCase() === "title" && ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === "svg";
}, "isSvgTitle"), E1 = /* @__PURE__ */ u(function(e, t, r) {
  let {
    exact: n = !0,
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  } = r === void 0 ? {} : r;
  Eo(e);
  const s = n ? po : Ls, d = ci({
    collapseWhitespace: o,
    trim: a,
    normalizer: i
  });
  return Array.from(e.querySelectorAll("[title], svg > title")).filter((l) => s(l.getAttribute("title"), l, t, d) || M$e(l) && s(Fc(l), l, t, d));
}, "queryAllByTitle"), D$e = /* @__PURE__ */ u((e, t) => "Found multiple elements with the title: " + t + ".", "getMultipleError$2"), q$e = /* @__PURE__ */ u((e, t) => "Unable to find an element with the title: " + t + ".", "getMissingError$2"), fQ = Ir(E1, E1.name, "queryAll"), [hQ, mQ, yQ, gQ, bQ] = xo(E1, D$e, q$e), x1 = /* @__PURE__ */ u(function(e, t, r) {
  let {
    hidden: n = Ve().defaultHidden,
    name: o,
    description: a,
    queryFallbacks: i = !1,
    selected: s,
    busy: d,
    checked: l,
    pressed: p,
    current: f,
    level: h,
    expanded: m,
    value: {
      now: g,
      min: w,
      max: _,
      text: b
    } = {}
  } = r === void 0 ? {} : r;
  if (Eo(e), s !== void 0) {
    var x;
    if (((x = an.roles.get(t)) == null ? void 0 : x.props["aria-selected"]) === void 0)
      throw new Error('"aria-selected" is not supported on role "' + t + '".');
  }
  if (d !== void 0) {
    var P;
    if (((P = an.roles.get(t)) == null ? void 0 : P.props["aria-busy"]) === void 0)
      throw new Error('"aria-busy" is not supported on role "' + t + '".');
  }
  if (l !== void 0) {
    var R;
    if (((R = an.roles.get(t)) == null ? void 0 : R.props["aria-checked"]) === void 0)
      throw new Error('"aria-checked" is not supported on role "' + t + '".');
  }
  if (p !== void 0) {
    var N;
    if (((N = an.roles.get(t)) == null ? void 0 : N.props["aria-pressed"]) === void 0)
      throw new Error('"aria-pressed" is not supported on role "' + t + '".');
  }
  if (f !== void 0) {
    var C;
    if (((C = an.roles.get(t)) == null ? void 0 : C.props["aria-current"]) === void 0)
      throw new Error('"aria-current" is not supported on role "' + t + '".');
  }
  if (h !== void 0 && t !== "heading")
    throw new Error('Role "' + t + '" cannot have "level" property.');
  if (g !== void 0) {
    var A;
    if (((A = an.roles.get(t)) == null ? void 0 : A.props["aria-valuenow"]) === void 0)
      throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
  }
  if (_ !== void 0) {
    var E;
    if (((E = an.roles.get(t)) == null ? void 0 : E.props["aria-valuemax"]) === void 0)
      throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
  }
  if (w !== void 0) {
    var T;
    if (((T = an.roles.get(t)) == null ? void 0 : T.props["aria-valuemin"]) === void 0)
      throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
  }
  if (b !== void 0) {
    var O;
    if (((O = an.roles.get(t)) == null ? void 0 : O.props["aria-valuetext"]) === void 0)
      throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
  }
  if (m !== void 0) {
    var k;
    if (((k = an.roles.get(t)) == null ? void 0 : k.props["aria-expanded"]) === void 0)
      throw new Error('"aria-expanded" is not supported on role "' + t + '".');
  }
  const M = /* @__PURE__ */ new WeakMap();
  function L($) {
    return M.has($) || M.set($, Ck($)), M.get($);
  }
  return u(L, "cachedIsSubtreeInaccessible"), Array.from(e.querySelectorAll(
    // Only query elements that can be matched by the following filters
    vQ(t)
  )).filter(($) => {
    if ($.hasAttribute("role")) {
      const I = $.getAttribute("role");
      if (i)
        return I.split(" ").filter(Boolean).some((F) => F === t);
      const [D] = I.split(" ");
      return D === t;
    }
    return xb($).some((I) => I === t);
  }).filter(($) => {
    if (s !== void 0)
      return s === wX($);
    if (d !== void 0)
      return d === _X($);
    if (l !== void 0)
      return l === EX($);
    if (p !== void 0)
      return p === xX($);
    if (f !== void 0)
      return f === SX($);
    if (m !== void 0)
      return m === TX($);
    if (h !== void 0)
      return h === AX($);
    if (g !== void 0 || _ !== void 0 || w !== void 0 || b !== void 0) {
      let D = !0;
      if (g !== void 0 && D && (D = g === $X($)), _ !== void 0 && D && (D = _ === CX($)), w !== void 0 && D && (D = w === kX($)), b !== void 0) {
        var I;
        D && (D = po((I = PX($)) != null ? I : null, $, b, (F) => F));
      }
      return D;
    }
    return !0;
  }).filter(($) => o === void 0 ? !0 : po(wb($, {
    computedStyleSupportsPseudoElements: Ve().computedStyleSupportsPseudoElements
  }), $, o, (I) => I)).filter(($) => a === void 0 ? !0 : po(bk($, {
    computedStyleSupportsPseudoElements: Ve().computedStyleSupportsPseudoElements
  }), $, a, (I) => I)).filter(($) => n === !1 ? Mp($, {
    isSubtreeInaccessible: L
  }) === !1 : !0);
}, "queryAllByRole");
function vQ(e) {
  var t;
  const r = '*[role~="' + e + '"]', n = (t = an.roleElements.get(e)) != null ? t : /* @__PURE__ */ new Set(), o = new Set(Array.from(n).map((a) => {
    let {
      name: i
    } = a;
    return i;
  }));
  return [r].concat(Array.from(o)).join(",");
}
u(vQ, "makeRoleSelector");
var wQ = /* @__PURE__ */ u((e) => {
  let t = "";
  return e === void 0 ? t = "" : typeof e == "string" ? t = ' and name "' + e + '"' : t = " and name `" + e + "`", t;
}, "getNameHint"), L$e = /* @__PURE__ */ u(function(e, t, r) {
  let {
    name: n
  } = r === void 0 ? {} : r;
  return 'Found multiple elements with the role "' + t + '"' + wQ(n);
}, "getMultipleError$1"), F$e = /* @__PURE__ */ u(function(e, t, r) {
  let {
    hidden: n = Ve().defaultHidden,
    name: o,
    description: a
  } = r === void 0 ? {} : r;
  if (Ve()._disableExpensiveErrorDiagnostics)
    return 'Unable to find role="' + t + '"' + wQ(o);
  let i = "";
  Array.from(e.children).forEach((p) => {
    i += Pk(p, {
      hidden: n,
      includeDescription: a !== void 0
    });
  });
  let s;
  i.length === 0 ? n === !1 ? s = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : s = "There are no available roles." : s = (`
Here are the ` + (n === !1 ? "accessible" : "available") + ` roles:

  ` + i.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let d = "";
  o === void 0 ? d = "" : typeof o == "string" ? d = ' and name "' + o + '"' : d = " and name `" + o + "`";
  let l = "";
  return a === void 0 ? l = "" : typeof a == "string" ? l = ' and description "' + a + '"' : l = " and description `" + a + "`", (`
Unable to find an ` + (n === !1 ? "accessible " : "") + 'element with the role "' + t + '"' + d + l + `

` + s).trim();
}, "getMissingError$1"), _Q = Ir(x1, x1.name, "queryAll"), [EQ, xQ, SQ, TQ, AQ] = xo(x1, L$e, F$e), jk = /* @__PURE__ */ u(() => Ve().testIdAttribute, "getTestIdAttribute"), S1 = /* @__PURE__ */ u(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return Eo(t[0]), ui(jk(), ...t);
}, "queryAllByTestId"), U$e = /* @__PURE__ */ u((e, t) => "Found multiple elements by: [" + jk() + '="' + t + '"]', "getMultipleError"), B$e = /* @__PURE__ */ u((e, t) => "Unable to find an element by: [" + jk() + '="' + t + '"]', "getMissingError"), $Q = Ir(S1, S1.name, "queryAll"), [CQ, kQ, PQ, OQ, RQ] = xo(S1, U$e, B$e), _m = Object.freeze({
  __proto__: null,
  queryAllByLabelText: BX,
  queryByLabelText: MX,
  getAllByLabelText: FX,
  getByLabelText: UX,
  findAllByLabelText: qX,
  findByLabelText: LX,
  queryByPlaceholderText: VX,
  queryAllByPlaceholderText: HX,
  getByPlaceholderText: JX,
  getAllByPlaceholderText: zX,
  findAllByPlaceholderText: WX,
  findByPlaceholderText: GX,
  queryByText: YX,
  queryAllByText: KX,
  getByText: QX,
  getAllByText: XX,
  findAllByText: ZX,
  findByText: eQ,
  queryByDisplayValue: rQ,
  queryAllByDisplayValue: tQ,
  getByDisplayValue: oQ,
  getAllByDisplayValue: nQ,
  findAllByDisplayValue: aQ,
  findByDisplayValue: iQ,
  queryByAltText: lQ,
  queryAllByAltText: sQ,
  getByAltText: uQ,
  getAllByAltText: cQ,
  findAllByAltText: dQ,
  findByAltText: pQ,
  queryByTitle: hQ,
  queryAllByTitle: fQ,
  getByTitle: yQ,
  getAllByTitle: mQ,
  findAllByTitle: gQ,
  findByTitle: bQ,
  queryByRole: EQ,
  queryAllByRole: _Q,
  getAllByRole: xQ,
  getByRole: SQ,
  findAllByRole: TQ,
  findByRole: AQ,
  queryByTestId: CQ,
  queryAllByTestId: $Q,
  getByTestId: PQ,
  getAllByTestId: kQ,
  findAllByTestId: OQ,
  findByTestId: RQ
});
function Em(e, t, r) {
  return t === void 0 && (t = _m), r === void 0 && (r = {}), Object.keys(t).reduce((n, o) => {
    const a = t[o];
    return n[o] = a.bind(null, e), n;
  }, r);
}
u(Em, "getQueriesForElement");
var jQ = /* @__PURE__ */ u((e) => !e || Array.isArray(e) && !e.length, "isRemoved");
function T1(e) {
  if (jQ(e))
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
u(T1, "initialCheck");
async function IQ(e, t) {
  const r = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof e != "function") {
    T1(e);
    const n = (Array.isArray(e) ? e : [e]).map((o) => {
      let a = o.parentElement;
      if (a === null) return () => null;
      for (; a.parentElement; ) a = a.parentElement;
      return () => a.contains(o) ? o : null;
    });
    e = /* @__PURE__ */ u(() => n.map((o) => o()).filter(Boolean), "callback");
  }
  return T1(e()), Sb(() => {
    let n;
    try {
      n = e();
    } catch (o) {
      if (o.name === "TestingLibraryElementError")
        return;
      throw o;
    }
    if (!jQ(n))
      throw r;
  }, t);
}
u(IQ, "waitForElementToBeRemoved");
var zj = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !0
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      button: 0,
      composed: !0
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
}, Jj = {
  doubleClick: "dblClick"
};
function pc(e, t) {
  return Ve().eventWrapper(() => {
    if (!t)
      throw new Error("Unable to fire an event - please provide an event object.");
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
u(pc, "fireEvent");
function Zu(e, t, r, n) {
  let {
    EventType: o = "Event",
    defaultInit: a = {}
  } = n === void 0 ? {} : n;
  if (!t)
    throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  const i = {
    ...a,
    ...r
  }, {
    target: {
      value: s,
      files: d,
      ...l
    } = {}
  } = i;
  s !== void 0 && NQ(t, s), d !== void 0 && Object.defineProperty(t, "files", {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    value: d
  }), Object.assign(t, l);
  const p = Ek(t), f = p[o] || p.Event;
  let h;
  if (typeof f == "function")
    h = new f(e, i);
  else {
    h = p.document.createEvent(o);
    const {
      bubbles: m,
      cancelable: g,
      detail: w,
      ..._
    } = i;
    h.initEvent(e, m, g, w), Object.keys(_).forEach((b) => {
      h[b] = _[b];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((m) => {
    const g = i[m];
    typeof g == "object" && (typeof p.DataTransfer == "function" ? Object.defineProperty(h, m, {
      value: Object.getOwnPropertyNames(g).reduce((w, _) => (Object.defineProperty(w, _, {
        value: g[_]
      }), w), new p.DataTransfer())
    }) : Object.defineProperty(h, m, {
      value: g
    }));
  }), h;
}
u(Zu, "createEvent");
Object.keys(zj).forEach((e) => {
  const {
    EventType: t,
    defaultInit: r
  } = zj[e], n = e.toLowerCase();
  Zu[e] = (o, a) => Zu(n, o, a, {
    EventType: t,
    defaultInit: r
  }), pc[e] = (o, a) => pc(o, Zu[e](o, a));
});
function NQ(e, t) {
  const {
    set: r
  } = Object.getOwnPropertyDescriptor(e, "value") || {}, n = Object.getPrototypeOf(e), {
    set: o
  } = Object.getOwnPropertyDescriptor(n, "value") || {};
  if (o && r !== o)
    o.call(e, t);
  else if (r)
    r.call(e, t);
  else
    throw new Error("The given element does not have a value setter");
}
u(NQ, "setNativeValue");
Object.keys(Jj).forEach((e) => {
  const t = Jj[e];
  pc[e] = function() {
    return pc[t](...arguments);
  };
});
function MQ(e) {
  return e.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
u(MQ, "unindent");
function DQ(e) {
  return l$e.default.compressToEncodedURIComponent(MQ(e));
}
u(DQ, "encode");
function qQ(e) {
  return "https://testing-playground.com/#markup=" + DQ(e);
}
u(qQ, "getPlaygroundUrl");
var H$e = /* @__PURE__ */ u((e, t, r) => Array.isArray(e) ? e.forEach((n) => y1(n, t, r)) : y1(e, t, r), "debug"), V$e = /* @__PURE__ */ u(function(e) {
  if (e === void 0 && (e = _b().body), !e || !("innerHTML" in e)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!e.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  const t = qQ(e.innerHTML);
  return console.log(`Open this URL in your browser

` + t), t;
}, "logTestingPlaygroundURL"), Wj = {
  debug: H$e,
  logTestingPlaygroundURL: V$e
}, z$e = typeof document < "u" && document.body ? Em(document.body, _m, Wj) : Object.keys(_m).reduce((e, t) => (e[t] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, e), Wj);
function De(e, t, r) {
  return e.namespaceURI && e.namespaceURI !== "http://www.w3.org/1999/xhtml" || (t = Array.isArray(t) ? t : [
    t
  ], !t.includes(e.tagName.toLowerCase())) ? !1 : r ? Object.entries(r).every(([n, o]) => e[n] === o) : !0;
}
u(De, "isElementType");
function tn(e) {
  var t;
  if (LQ(e) && e.defaultView)
    return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${FQ(e)}`);
}
u(tn, "getWindow");
function LQ(e) {
  return e.nodeType === 9;
}
u(LQ, "isDocument");
function FQ(e) {
  return typeof e == "function" ? `function ${e.name}` : e === null ? "null" : String(e);
}
u(FQ, "describe");
function Ik(e, t) {
  return new Promise((r, n) => {
    const o = new t();
    o.onerror = n, o.onabort = n, o.onload = () => {
      r(String(o.result));
    }, o.readAsText(e);
  });
}
u(Ik, "readBlobText");
function Ab(e, t) {
  const r = {
    ...t,
    length: t.length,
    item: /* @__PURE__ */ u((n) => r[n], "item"),
    [Symbol.iterator]: /* @__PURE__ */ u(function* () {
      for (let n = 0; n < r.length; n++)
        yield r[n];
    }, "nextFile")
  };
  return r.constructor = e.FileList, e.FileList && Object.setPrototypeOf(r, e.FileList.prototype), Object.freeze(r), r;
}
u(Ab, "createFileList");
function Xo(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(Xo, "_define_property");
var UQ = class {
  getAsFile() {
    return this.file;
  }
  getAsString(e) {
    typeof this.data == "string" && e(this.data);
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(e, t) {
    Xo(this, "kind", void 0), Xo(this, "type", void 0), Xo(this, "file", null), Xo(this, "data", void 0), typeof e == "string" ? (this.kind = "string", this.type = String(t), this.data = e) : (this.kind = "file", this.type = e.type, this.file = e);
  }
};
u(UQ, "DataTransferItemStub");
var BQ = UQ, HQ = class extends Array {
  add(...e) {
    const t = new BQ(e[0], e[1]);
    return this.push(t), t;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(e) {
    this.splice(e, 1);
  }
};
u(HQ, "DataTransferItemListStub");
var J$e = HQ;
function Su(e, t) {
  const [r, n] = e.split("/"), o = !n || n === "*";
  return (a) => t ? a.type === (o ? r : e) : o ? a.type.startsWith(`${r}/`) : a.type === r;
}
u(Su, "getTypeMatcher");
function VQ(e) {
  var t;
  return new (t = class {
    getData(r) {
      var n;
      const o = (n = this.items.find(Su(r, !0))) !== null && n !== void 0 ? n : this.items.find(Su(r, !1));
      let a = "";
      return o?.getAsString((i) => {
        a = i;
      }), a;
    }
    setData(r, n) {
      const o = this.items.findIndex(Su(r, !0)), a = new BQ(n, r);
      o >= 0 ? this.items.splice(o, 1, a) : this.items.push(a);
    }
    clearData(r) {
      if (r) {
        const n = this.items.findIndex(Su(r, !0));
        n >= 0 && this.items.remove(n);
      } else
        this.items.clear();
    }
    get types() {
      const r = [];
      return this.files.length && r.push("Files"), this.items.forEach((n) => r.push(n.type)), Object.freeze(r), r;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      Xo(this, "dropEffect", "none"), Xo(this, "effectAllowed", "uninitialized"), Xo(this, "items", new J$e()), Xo(this, "files", Ab(e, []));
    }
  }, u(t, "DataTransferStub"), t)();
}
u(VQ, "createDataTransferStub");
function $b(e, t = []) {
  const r = typeof e.DataTransfer > "u" ? VQ(e) : (
    /* istanbul ignore next */
    new e.DataTransfer()
  );
  return Object.defineProperty(r, "files", {
    get: /* @__PURE__ */ u(() => Ab(e, t), "get")
  }), r;
}
u($b, "createDataTransfer");
async function zQ(e, t) {
  return t.kind === "file" ? t.getAsFile() : new e.Blob([
    await new Promise((r) => t.getAsString(r))
  ], {
    type: t.type
  });
}
u(zQ, "getBlobFromDataTransferItem");
function Nk(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(Nk, "_define_property");
function Mk(e, ...t) {
  var r;
  const n = Object.fromEntries(t.map((o) => [
    typeof o == "string" ? "text/plain" : o.type,
    Promise.resolve(o)
  ]));
  return typeof e.ClipboardItem < "u" ? new e.ClipboardItem(n) : new (r = class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(o) {
      const a = await this.data[o];
      if (!a)
        throw new Error(`${o} is not one of the available MIME types on this item.`);
      return a instanceof e.Blob ? a : new e.Blob([
        a
      ], {
        type: o
      });
    }
    constructor(o) {
      Nk(this, "data", void 0), this.data = o;
    }
  }, u(r, "ClipboardItem"), r)(n);
}
u(Mk, "createClipboardItem");
var fc = Symbol("Manage ClipboardSub");
function A1(e, t) {
  var r;
  return Object.assign(new (r = class extends e.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let n = "";
      for (const o of this.items) {
        const a = o.types.includes("text/plain") ? "text/plain" : o.types.find((i) => i.startsWith("text/"));
        a && (n += await o.getType(a).then((i) => Ik(i, e.FileReader)));
      }
      return n;
    }
    async write(n) {
      this.items = n;
    }
    async writeText(n) {
      this.items = [
        Mk(e, n)
      ];
    }
    constructor(...n) {
      super(...n), Nk(this, "items", []);
    }
  }, u(r, "Clipboard"), r)(), {
    [fc]: t
  });
}
u(A1, "createClipboardStub");
function Cb(e) {
  return !!e?.[fc];
}
u(Cb, "isClipboardStub");
function JQ(e) {
  if (Cb(e.navigator.clipboard))
    return e.navigator.clipboard[fc];
  const t = Object.getOwnPropertyDescriptor(e.navigator, "clipboard");
  let r;
  const n = {
    resetClipboardStub: /* @__PURE__ */ u(() => {
      r = A1(e, n);
    }, "resetClipboardStub"),
    detachClipboardStub: /* @__PURE__ */ u(() => {
      t ? Object.defineProperty(e.navigator, "clipboard", t) : Object.defineProperty(e.navigator, "clipboard", {
        value: void 0,
        configurable: !0
      });
    }, "detachClipboardStub")
  };
  return r = A1(e, n), Object.defineProperty(e.navigator, "clipboard", {
    get: /* @__PURE__ */ u(() => r, "get"),
    configurable: !0
  }), r[fc];
}
u(JQ, "attachClipboardStubToView");
function WQ(e) {
  Cb(e.navigator.clipboard) && e.navigator.clipboard[fc].resetClipboardStub();
}
u(WQ, "resetClipboardStubOnView");
function GQ(e) {
  Cb(e.navigator.clipboard) && e.navigator.clipboard[fc].detachClipboardStub();
}
u(GQ, "detachClipboardStubFromView");
async function KQ(e) {
  const t = e.defaultView, r = t?.navigator.clipboard, n = r && await r.read();
  if (!n)
    throw new Error("The Clipboard API is unavailable.");
  const o = $b(t);
  for (const a of n)
    for (const i of a.types)
      o.setData(i, await a.getType(i).then((s) => Ik(s, t.FileReader)));
  return o;
}
u(KQ, "readDataTransferFromClipboard");
async function Dk(e, t) {
  const r = tn(e), n = r.navigator.clipboard, o = [];
  for (let a = 0; a < t.items.length; a++) {
    const i = t.items[a], s = await zQ(r, i);
    o.push(Mk(r, s));
  }
  if (!(n && await n.write(o).then(
    () => !0,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => !1
  )))
    throw new Error("The Clipboard API is unavailable.");
}
u(Dk, "writeDataTransferToClipboard");
var xm = globalThis;
typeof xm.afterEach == "function" && xm.afterEach(() => {
  typeof globalThis.window < "u" && WQ(globalThis.window);
});
typeof xm.afterAll == "function" && xm.afterAll(() => {
  typeof globalThis.window < "u" && GQ(globalThis.window);
});
var YQ = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");
function kb(e) {
  return e.matches(YQ);
}
u(kb, "isFocusable");
function XQ(e) {
  return new e.constructor(e.type, e);
}
u(XQ, "cloneEvent");
function yo(e) {
  for (let r = e; r; r = r.parentElement)
    if (De(r, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (r.hasAttribute("disabled"))
        return !0;
    } else if (De(r, "fieldset")) {
      var t;
      if (r.hasAttribute("disabled") && !(!((t = r.querySelector(":scope > legend")) === null || t === void 0) && t.contains(e)))
        return !0;
    } else if (r.tagName.includes("-") && r.constructor.formAssociated && r.hasAttribute("disabled"))
      return !0;
  return !1;
}
u(yo, "isDisabled");
function Bc(e) {
  const t = e.activeElement;
  return t?.shadowRoot ? Bc(t.shadowRoot) : yo(t) ? e.ownerDocument ? (
    /* istanbul ignore next */
    e.ownerDocument.body
  ) : e.body : t;
}
u(Bc, "getActiveElement");
function Pf(e) {
  var t;
  return (t = Bc(e)) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  );
}
u(Pf, "getActiveElementOrBody");
function QQ(e, t) {
  let r = e;
  do {
    if (t(r))
      return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
u(QQ, "findClosest");
function Xa(e) {
  return e.hasAttribute("contenteditable") && (e.getAttribute("contenteditable") == "true" || e.getAttribute("contenteditable") == "");
}
u(Xa, "isContentEditable");
function hc(e) {
  const t = ZQ(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
u(hc, "getContentEditable");
function ZQ(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
u(ZQ, "getElement");
var eZ = (function(e) {
  return e.button = "button", e.color = "color", e.file = "file", e.image = "image", e.reset = "reset", e.submit = "submit", e.checkbox = "checkbox", e.radio = "radio", e;
})(eZ || {});
function qk(e) {
  return De(e, "button") || De(e, "input") && e.type in eZ;
}
u(qk, "isClickableInput");
function _s(e) {
  return Lk(e) && !e.readOnly || Xa(e);
}
u(_s, "isEditable");
var tZ = (function(e) {
  return e.text = "text", e.date = "date", e["datetime-local"] = "datetime-local", e.email = "email", e.month = "month", e.number = "number", e.password = "password", e.search = "search", e.tel = "tel", e.time = "time", e.url = "url", e.week = "week", e;
})(tZ || {});
function Lk(e) {
  return De(e, "textarea") || De(e, "input") && e.type in tZ;
}
u(Lk, "isEditableInputOrTextArea");
function zn(e) {
  return Fk(e) && Lk(e);
}
u(zn, "hasOwnSelection");
function rZ(e) {
  return Fk(e) && qk(e);
}
u(rZ, "hasNoSelection");
function Fk(e) {
  return e.nodeType === 1;
}
u(Fk, "isElement");
function nZ(e) {
  const t = e.ownerDocument.getSelection();
  if (t?.focusNode && zn(e)) {
    const n = hc(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        const o = ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3 ? n.firstChild : n;
        t.setBaseAndExtent(o, 0, o, 0);
      }
    } else
      t.setBaseAndExtent(e, 0, e, 0);
  }
}
u(nZ, "updateSelectionOnFocus");
function mc(e, t) {
  return Ve().eventWrapper(e);
}
u(mc, "wrapEvent");
function ia(e) {
  const t = QQ(e, kb), r = Bc(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r && (mc(t ? () => t.focus() : () => r?.blur()), nZ(t ?? e.ownerDocument.body));
}
u(ia, "focusElement");
function oZ(e) {
  !kb(e) || Bc(e.ownerDocument) !== e || mc(() => e.blur());
}
u(oZ, "blurElement");
var Qa = {};
Qa.click = (e, t, r) => {
  const n = t.closest("button,input,label,select,textarea"), o = n && De(n, "label") && n.control;
  if (o && o !== t)
    return () => {
      kb(o) && (ia(o), r.dispatchEvent(o, XQ(e)));
    };
  if (De(t, "input", {
    type: "file"
  }))
    return () => {
      oZ(t), t.dispatchEvent(new (tn(t)).Event("fileDialog")), ia(t);
    };
};
var yc = Symbol("Displayed value in UI"), Qo = Symbol("Displayed selection in UI"), Sm = Symbol("Initial value to compare on blur");
function aZ(e) {
  return typeof e == "object" && yc in e;
}
u(aZ, "isUIValue");
function iZ(e) {
  return !!e && typeof e == "object" && Qo in e;
}
u(iZ, "isUISelectionStart");
function sZ(e, t) {
  e[Sm] === void 0 && (e[Sm] = e.value), e[yc] = t, e.value = Object.assign(new String(t), {
    [yc]: !0
  });
}
u(sZ, "setUIValue");
function Jn(e) {
  return e[yc] === void 0 ? e.value : String(e[yc]);
}
u(Jn, "getUIValue");
function Pb(e) {
  e[yc] = void 0;
}
u(Pb, "setUIValueClean");
function Uk(e) {
  e[Sm] = void 0;
}
u(Uk, "clearInitialValue");
function lZ(e) {
  return e[Sm];
}
u(lZ, "getInitialValue");
function cZ(e, t) {
  e[Qo] = t;
}
u(cZ, "setUISelectionRaw");
function Fs(e, { focusOffset: t, anchorOffset: r = t }, n = "replace") {
  const o = Jn(e).length, a = /* @__PURE__ */ u((f) => Math.max(0, Math.min(o, f)), "sanitizeOffset"), i = n === "replace" || e[Qo] === void 0 ? a(r) : e[Qo].anchorOffset, s = a(t), d = Math.min(i, s), l = Math.max(i, s);
  if (e[Qo] = {
    anchorOffset: i,
    focusOffset: s
  }, e.selectionStart === d && e.selectionEnd === l)
    return;
  const p = Object.assign(new Number(d), {
    [Qo]: !0
  });
  try {
    e.setSelectionRange(p, l);
  } catch {
  }
}
u(Fs, "setUISelection");
function gc(e) {
  var t, r, n;
  const o = (n = e[Qo]) !== null && n !== void 0 ? n : {
    anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
    focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0
  };
  return {
    ...o,
    startOffset: Math.min(o.anchorOffset, o.focusOffset),
    endOffset: Math.max(o.anchorOffset, o.focusOffset)
  };
}
u(gc, "getUISelection");
function uZ(e) {
  return !!e[Qo];
}
u(uZ, "hasUISelection");
function ed(e) {
  e[Qo] = void 0;
}
u(ed, "setUISelectionClean");
var Tm = globalThis.parseInt;
function dZ(e) {
  const t = e.replace(/\D/g, "");
  if (t.length < 2)
    return e;
  const r = Tm(t[0], 10), n = Tm(t[1], 10);
  if (r >= 3 || r === 2 && n >= 4) {
    let o;
    return r >= 3 ? o = 1 : o = 2, $1(t, o);
  }
  return e.length === 2 ? e : $1(t, 2);
}
u(dZ, "buildTimeValue");
function $1(e, t) {
  const r = e.slice(0, t), n = Math.min(Tm(r, 10), 23), o = e.slice(t), a = Tm(o, 10), i = Math.min(a, 59);
  return `${n.toString().padStart(2, "0")}:${i.toString().padStart(2, "0")}`;
}
u($1, "build");
function Bk(e, t) {
  const r = e.cloneNode();
  return r.value = t, r.value === t;
}
u(Bk, "isValidDateOrTimeValue");
var pZ = (function(e) {
  return e.email = "email", e.password = "password", e.search = "search", e.telephone = "telephone", e.text = "text", e.url = "url", e;
})(pZ || {});
function fZ(e) {
  var t;
  const r = (t = e.getAttribute("maxlength")) !== null && t !== void 0 ? t : "";
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
u(fZ, "getMaxLength");
function hZ(e) {
  return De(e, "textarea") || De(e, "input") && e.type in pZ;
}
u(hZ, "supportsMaxLength");
function Hk(e, t, r, n) {
  if (td(e) && t + r >= 0 && t + r <= e.nodeValue.length)
    return {
      node: e,
      offset: t + r
    };
  const o = C1(e, t, r);
  if (o) {
    if (td(o))
      return {
        node: o,
        offset: r > 0 ? Math.min(1, o.nodeValue.length) : Math.max(o.nodeValue.length - 1, 0)
      };
    if (De(o, "br")) {
      const a = C1(o, void 0, r);
      return a ? td(a) ? {
        node: a,
        offset: r > 0 ? 0 : a.nodeValue.length
      } : r < 0 && De(a, "br") ? {
        node: o.parentNode,
        offset: Tu(o)
      } : {
        node: a.parentNode,
        offset: Tu(a) + (r > 0 ? 0 : 1)
      } : r < 0 && n === "deleteContentBackward" ? {
        node: o.parentNode,
        offset: Tu(o)
      } : void 0;
    } else
      return {
        node: o.parentNode,
        offset: Tu(o) + (r > 0 ? 1 : 0)
      };
  }
}
u(Hk, "getNextCursorPosition");
function C1(e, t, r) {
  const n = Number(t) + (r < 0 ? -1 : 0);
  return t !== void 0 && Ob(e) && n >= 0 && n < e.children.length && (e = e.children[n]), yZ(e, r === 1 ? "next" : "previous", mZ);
}
u(C1, "getNextCharacterContentNode");
function mZ(e) {
  if (td(e))
    return !0;
  if (Ob(e)) {
    if (De(e, [
      "input",
      "textarea"
    ]))
      return e.type !== "hidden";
    if (De(e, "br"))
      return !0;
  }
  return !1;
}
u(mZ, "isTreatedAsCharacterContent");
function Tu(e) {
  let t = 0;
  for (; e.previousSibling; )
    t++, e = e.previousSibling;
  return t;
}
u(Tu, "getOffset");
function Ob(e) {
  return e.nodeType === 1;
}
u(Ob, "isElement");
function td(e) {
  return e.nodeType === 3;
}
u(td, "isTextNode");
function yZ(e, t, r) {
  for (; ; ) {
    var n;
    const o = e[`${t}Sibling`];
    if (o) {
      if (e = gZ(o, t === "next" ? "first" : "last"), r(e))
        return e;
    } else if (e.parentNode && (!Ob(e.parentNode) || !Xa(e.parentNode) && e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
      e = e.parentNode;
    else
      break;
  }
}
u(yZ, "walkNodes");
function gZ(e, t) {
  for (; e.hasChildNodes(); )
    e = e[`${t}Child`];
  return e;
}
u(gZ, "getDescendant");
var Gd = Symbol("Track programmatic changes for React workaround");
function bZ(e) {
  return Object.getOwnPropertyNames(e).some((t) => t.startsWith("__react")) && tn(e).REACT_VERSION === 17;
}
u(bZ, "isReact17Element");
function vZ(e) {
  bZ(e) && (e[Gd] = {
    previousValue: String(e.value),
    tracked: []
  });
}
u(vZ, "startTrackValue");
function wZ(e, t) {
  var r, n;
  (n = e[Gd]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t), e[Gd] || (Pb(e), Fs(e, {
    focusOffset: t.length
  }));
}
u(wZ, "trackOrSetValue");
function _Z(e, t) {
  var r;
  const n = e[Gd];
  if (e[Gd] = void 0, !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length))
    return;
  const o = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  o || Pb(e), uZ(e) && Fs(e, {
    focusOffset: o ? t : e.value.length
  });
}
u(_Z, "commitValueAfterInput");
function Vk(e) {
  const t = EZ(e);
  if (t && zn(t))
    return {
      type: "input",
      selection: gc(t)
    };
  const r = t?.ownerDocument.getSelection();
  return {
    type: hc(e) && r?.anchorNode && hc(r.anchorNode) ? "contenteditable" : "default",
    selection: r
  };
}
u(Vk, "getTargetTypeAndSelection");
function EZ(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
u(EZ, "getElement");
function xZ(e) {
  const t = Vk(e);
  if (t.type === "input")
    return t.selection;
  if (t.type === "contenteditable") {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
u(xZ, "getInputRange");
function Za({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var o, a;
  if (Vk(e).type === "input")
    return Fs(e, {
      anchorOffset: n,
      focusOffset: t
    });
  (a = r.ownerDocument) === null || a === void 0 || (o = a.getSelection()) === null || o === void 0 || o.setBaseAndExtent(r, n, e, t);
}
u(Za, "setSelection");
function zk(e) {
  return De(e, "input") && [
    "date",
    "time"
  ].includes(e.type);
}
u(zk, "isDateOrTime");
function Es(e, t, r, n = "insertText") {
  const o = xZ(t);
  o && (!zk(t) && !e.dispatchUIEvent(t, "beforeinput", {
    inputType: n,
    data: r
  }) || ("startContainer" in o ? SZ(e, t, o, r, n) : TZ(e, t, o, r, n)));
}
u(Es, "input");
function SZ(e, t, r, n, o) {
  let a = !1;
  if (!r.collapsed)
    a = !0, r.deleteContents();
  else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(o)) {
    const i = Hk(r.startContainer, r.startOffset, o === "deleteContentBackward" ? -1 : 1, o);
    if (i) {
      a = !0;
      const s = r.cloneRange();
      s.comparePoint(i.node, i.offset) < 0 ? s.setStart(i.node, i.offset) : s.setEnd(i.node, i.offset), s.deleteContents();
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      const i = r.endOffset;
      r.endContainer.insertData(i, n), r.setStart(r.endContainer, i + n.length), r.setEnd(r.endContainer, i + n.length);
    } else {
      const i = t.ownerDocument.createTextNode(n);
      r.insertNode(i), r.setStart(i, n.length), r.setEnd(i, n.length);
    }
  (a || n) && e.dispatchUIEvent(t, "input", {
    inputType: o
  });
}
u(SZ, "editContenteditable");
function TZ(e, t, r, n, o) {
  let a = n;
  if (hZ(t)) {
    const l = fZ(t);
    if (l !== void 0 && n.length > 0) {
      const p = l - t.value.length;
      if (p > 0)
        a = n.substring(0, p);
      else
        return;
    }
  }
  const { newValue: i, newOffset: s, oldValue: d } = AZ(a, t, r, o);
  i === d && s === r.startOffset && s === r.endOffset || De(t, "input", {
    type: "number"
  }) && !$Z(i) || (sZ(t, i), Za({
    focusNode: t,
    anchorOffset: s,
    focusOffset: s
  }), zk(t) ? Bk(t, i) && (k1(e, t, s, {}), e.dispatchUIEvent(t, "change"), Uk(t)) : k1(e, t, s, {
    data: n,
    inputType: o
  }));
}
u(TZ, "editInputElement");
function AZ(e, t, { startOffset: r, endOffset: n }, o) {
  const a = Jn(t), i = Math.max(0, r === n && o === "deleteContentBackward" ? r - 1 : r), s = a.substring(0, i), d = Math.min(a.length, r === n && o === "deleteContentForward" ? r + 1 : n), l = a.substring(d, a.length);
  let p = `${s}${e}${l}`, f = i + e.length;
  if (De(t, "input", {
    type: "time"
  })) {
    const h = dZ(p);
    h !== "" && Bk(t, h) && (p = h, f = h.length);
  }
  return {
    oldValue: a,
    newValue: p,
    newOffset: f
  };
}
u(AZ, "calculateNewValue");
function k1(e, t, r, n) {
  e.dispatchUIEvent(t, "input", n), _Z(t, r);
}
u(k1, "commitInput");
function $Z(e) {
  var t, r;
  const n = e.split("e", 2);
  return !(/[^\d.\-e]/.test(e) || Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 || Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 || n[1] && !/^-?\d*$/.test(n[1]));
}
u($Z, "isValidNumberInput");
Qa.cut = (e, t, r) => () => {
  _s(t) && Es(r, t, "", "deleteByCut");
};
function CZ(e) {
  return e ? Xa(e) ? e.textContent : Jn(e) : null;
}
u(CZ, "getValueOrTextContent");
function kZ(e) {
  const t = tn(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    const { display: n, visibility: o } = t.getComputedStyle(r);
    if (n === "none" || o === "hidden")
      return !1;
  }
  return !0;
}
u(kZ, "isVisible");
function PZ(e, t) {
  const r = e.ownerDocument, n = r.querySelectorAll(YQ), o = Array.from(n).filter((d) => d === e || !(Number(d.getAttribute("tabindex")) < 0 || yo(d)));
  Number(e.getAttribute("tabindex")) >= 0 && o.sort((d, l) => {
    const p = Number(d.getAttribute("tabindex")), f = Number(l.getAttribute("tabindex"));
    return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
  });
  const a = {};
  let i = [
    r.body
  ];
  const s = De(e, "input", {
    type: "radio"
  }) ? e.name : void 0;
  o.forEach((d) => {
    const l = d;
    if (De(l, "input", {
      type: "radio"
    }) && l.name) {
      if (l === e) {
        i.push(l);
        return;
      } else if (l.name === s)
        return;
      if (l.checked) {
        i = i.filter((p) => !De(p, "input", {
          type: "radio",
          name: l.name
        })), i.push(l), a[l.name] = l;
        return;
      }
      if (typeof a[l.name] < "u")
        return;
    }
    i.push(l);
  });
  for (let d = i.findIndex((l) => l === e); ; )
    if (d += t ? -1 : 1, d === i.length ? d = 0 : d === -1 && (d = i.length - 1), i[d] === e || i[d] === r.body || kZ(i[d]))
      return i[d];
}
u(PZ, "getTabDestination");
function P1(e, t) {
  if (zn(e)) {
    const r = gc(e);
    Za({
      focusNode: e,
      focusOffset: r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset
    });
  } else {
    const r = e.ownerDocument.getSelection();
    if (!r?.focusNode)
      return;
    if (r.isCollapsed) {
      const n = Hk(r.focusNode, r.focusOffset, t);
      n && Za({
        focusNode: n.node,
        focusOffset: n.offset
      });
    } else
      r[t < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}
u(P1, "moveSelection");
function Jk(e) {
  if (zn(e))
    return Za({
      focusNode: e,
      anchorOffset: 0,
      focusOffset: Jn(e).length
    });
  var t;
  const r = (t = hc(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  Za({
    focusNode: r,
    anchorOffset: 0,
    focusOffset: r.childNodes.length
  });
}
u(Jk, "selectAll");
function OZ(e) {
  if (zn(e))
    return gc(e).startOffset === 0 && gc(e).endOffset === Jn(e).length;
  var t;
  const r = (t = hc(e)) !== null && t !== void 0 ? t : e.ownerDocument.body, n = e.ownerDocument.getSelection();
  return n?.anchorNode === r && n.focusNode === r && n.anchorOffset === 0 && n.focusOffset === r.childNodes.length;
}
u(OZ, "isAllSelected");
function hl(e, t, r) {
  var n;
  if (zn(e))
    return Za({
      focusNode: e,
      anchorOffset: t,
      focusOffset: r
    });
  if (Xa(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return Za({
      focusNode: e.firstChild,
      anchorOffset: t,
      focusOffset: r
    });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
u(hl, "setSelectionRange");
function Au(e, t, r) {
  const n = tn(t), o = Array.from(t.ownerDocument.querySelectorAll(t.name ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let a = o.findIndex((i) => i === t) + r; ; a += r) {
    if (o[a] || (a = r > 0 ? 0 : o.length - 1), o[a] === t)
      return;
    if (!yo(o[a])) {
      ia(o[a]), e.dispatchUIEvent(o[a], "click");
      return;
    }
  }
}
u(Au, "walkRadio");
Qa.keydown = (e, t, r) => {
  var n, o;
  return (o = (n = Gj[e.key]) === null || n === void 0 ? void 0 : n.call(Gj, e, t, r)) !== null && o !== void 0 ? o : W$e(e, t, r);
};
var Gj = {
  ArrowDown: /* @__PURE__ */ u((e, t, r) => {
    if (De(t, "input", {
      type: "radio"
    }))
      return () => Au(r, t, 1);
  }, "ArrowDown"),
  ArrowLeft: /* @__PURE__ */ u((e, t, r) => De(t, "input", {
    type: "radio"
  }) ? () => Au(r, t, -1) : () => P1(t, -1), "ArrowLeft"),
  ArrowRight: /* @__PURE__ */ u((e, t, r) => De(t, "input", {
    type: "radio"
  }) ? () => Au(r, t, 1) : () => P1(t, 1), "ArrowRight"),
  ArrowUp: /* @__PURE__ */ u((e, t, r) => {
    if (De(t, "input", {
      type: "radio"
    }))
      return () => Au(r, t, -1);
  }, "ArrowUp"),
  Backspace: /* @__PURE__ */ u((e, t, r) => {
    if (_s(t))
      return () => {
        Es(r, t, "", "deleteContentBackward");
      };
  }, "Backspace"),
  Delete: /* @__PURE__ */ u((e, t, r) => {
    if (_s(t))
      return () => {
        Es(r, t, "", "deleteContentForward");
      };
  }, "Delete"),
  End: /* @__PURE__ */ u((e, t) => {
    if (De(t, [
      "input",
      "textarea"
    ]) || Xa(t))
      return () => {
        var r, n;
        const o = (n = (r = CZ(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0 ? n : (
          /* istanbul ignore next */
          0
        );
        hl(t, o, o);
      };
  }, "End"),
  Home: /* @__PURE__ */ u((e, t) => {
    if (De(t, [
      "input",
      "textarea"
    ]) || Xa(t))
      return () => {
        hl(t, 0, 0);
      };
  }, "Home"),
  PageDown: /* @__PURE__ */ u((e, t) => {
    if (De(t, [
      "input"
    ]))
      return () => {
        const r = Jn(t).length;
        hl(t, r, r);
      };
  }, "PageDown"),
  PageUp: /* @__PURE__ */ u((e, t) => {
    if (De(t, [
      "input"
    ]))
      return () => {
        hl(t, 0, 0);
      };
  }, "PageUp"),
  Tab: /* @__PURE__ */ u((e, t, r) => () => {
    const n = PZ(t, r.system.keyboard.modifiers.Shift);
    ia(n), zn(n) && Fs(n, {
      anchorOffset: 0,
      focusOffset: n.value.length
    });
  }, "Tab")
}, W$e = /* @__PURE__ */ u((e, t, r) => {
  if (e.code === "KeyA" && r.system.keyboard.modifiers.Control)
    return () => Jk(t);
}, "combinationBehavior");
Qa.keypress = (e, t, r) => {
  if (e.key === "Enter") {
    if (De(t, "button") || De(t, "input") && G$e.includes(t.type) || De(t, "a") && t.href)
      return () => {
        r.dispatchUIEvent(t, "click");
      };
    if (De(t, "input")) {
      const n = t.form, o = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return o ? () => r.dispatchUIEvent(o, "click") : n && K$e.includes(t.type) && n.querySelectorAll("input").length === 1 ? () => r.dispatchUIEvent(n, "submit") : void 0;
    }
  }
  if (_s(t)) {
    const n = e.key === "Enter" ? Xa(t) && !r.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", o = e.key === "Enter" ? `
` : e.key;
    return () => Es(r, t, o, n);
  }
};
var G$e = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
], K$e = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];
Qa.keyup = (e, t, r) => {
  var n;
  return (n = Kj[e.key]) === null || n === void 0 ? void 0 : n.call(Kj, e, t, r);
};
var Kj = {
  " ": /* @__PURE__ */ u((e, t, r) => {
    if (qk(t))
      return () => r.dispatchUIEvent(t, "click");
  }, " ")
};
Qa.paste = (e, t, r) => {
  if (_s(t))
    return () => {
      var n;
      const o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData("text");
      o && Es(r, t, o, "insertFromPaste");
    };
};
var RZ = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
};
function Wk(e) {
  return RZ[e].EventType;
}
u(Wk, "getEventClass");
var Y$e = [
  "MouseEvent",
  "PointerEvent"
];
function jZ(e) {
  return Y$e.includes(Wk(e));
}
u(jZ, "isMouseEvent");
function IZ(e) {
  return Wk(e) === "KeyboardEvent";
}
u(IZ, "isKeyboardEvent");
var X$e = {
  ClipboardEvent: [
    MZ
  ],
  Event: [],
  FocusEvent: [
    rl,
    DZ
  ],
  InputEvent: [
    rl,
    qZ
  ],
  MouseEvent: [
    rl,
    Of,
    O1
  ],
  PointerEvent: [
    rl,
    Of,
    O1,
    FZ
  ],
  KeyboardEvent: [
    rl,
    Of,
    LZ
  ]
};
function Gk(e, t, r) {
  const n = tn(t), { EventType: o, defaultInit: a } = RZ[e], i = new (NZ(n))[o](e, a);
  return X$e[o].forEach((s) => s(i, r ?? {})), i;
}
u(Gk, "createEvent");
function NZ(e) {
  var t, r, n, o, a, i, s, d, l, p, f, h, m, g, w, _;
  const b = (_ = e.Event) !== null && _ !== void 0 ? _ : (t = class {
  }, u(t, "Event"), t);
  var x;
  const P = (x = e.AnimationEvent) !== null && x !== void 0 ? x : (r = class extends b {
  }, u(r, "AnimationEvent"), r);
  var R;
  const N = (R = e.ClipboardEvent) !== null && R !== void 0 ? R : (n = class extends b {
  }, u(n, "ClipboardEvent"), n);
  var C;
  const A = (C = e.PopStateEvent) !== null && C !== void 0 ? C : (o = class extends b {
  }, u(o, "PopStateEvent"), o);
  var E;
  const T = (E = e.ProgressEvent) !== null && E !== void 0 ? E : (a = class extends b {
  }, u(a, "ProgressEvent"), a);
  var O;
  const k = (O = e.TransitionEvent) !== null && O !== void 0 ? O : (i = class extends b {
  }, u(i, "TransitionEvent"), i);
  var M;
  const L = (M = e.UIEvent) !== null && M !== void 0 ? M : (s = class extends b {
  }, u(s, "UIEvent"), s);
  var $;
  const I = ($ = e.CompositionEvent) !== null && $ !== void 0 ? $ : (d = class extends L {
  }, u(d, "CompositionEvent"), d);
  var D;
  const F = (D = e.FocusEvent) !== null && D !== void 0 ? D : (l = class extends L {
  }, u(l, "FocusEvent"), l);
  var J;
  const oe = (J = e.InputEvent) !== null && J !== void 0 ? J : (p = class extends L {
  }, u(p, "InputEvent"), p);
  var ce;
  const le = (ce = e.KeyboardEvent) !== null && ce !== void 0 ? ce : (f = class extends L {
  }, u(f, "KeyboardEvent"), f);
  var re;
  const we = (re = e.MouseEvent) !== null && re !== void 0 ? re : (h = class extends L {
  }, u(h, "MouseEvent"), h);
  var _e;
  const de = (_e = e.DragEvent) !== null && _e !== void 0 ? _e : (m = class extends we {
  }, u(m, "DragEvent"), m);
  var ne;
  const $e = (ne = e.PointerEvent) !== null && ne !== void 0 ? ne : (g = class extends we {
  }, u(g, "PointerEvent"), g);
  var Se;
  const nt = (Se = e.TouchEvent) !== null && Se !== void 0 ? Se : (w = class extends L {
  }, u(w, "TouchEvent"), w);
  return {
    Event: b,
    AnimationEvent: P,
    ClipboardEvent: N,
    PopStateEvent: A,
    ProgressEvent: T,
    TransitionEvent: k,
    UIEvent: L,
    CompositionEvent: I,
    FocusEvent: F,
    InputEvent: oe,
    KeyboardEvent: le,
    MouseEvent: we,
    DragEvent: de,
    PointerEvent: $e,
    TouchEvent: nt
  };
}
u(NZ, "getEventConstructors");
function ha(e, t) {
  for (const [r, n] of Object.entries(t))
    Object.defineProperty(e, r, {
      get: /* @__PURE__ */ u(() => n ?? null, "get")
    });
}
u(ha, "assignProps");
function Tt(e) {
  return Number(e ?? 0);
}
u(Tt, "sanitizeNumber");
function MZ(e, { clipboardData: t }) {
  ha(e, {
    clipboardData: t
  });
}
u(MZ, "initClipboardEvent");
function DZ(e, { relatedTarget: t }) {
  ha(e, {
    relatedTarget: t
  });
}
u(DZ, "initFocusEvent");
function qZ(e, { data: t, inputType: r, isComposing: n }) {
  ha(e, {
    data: t,
    isComposing: !!n,
    inputType: String(r)
  });
}
u(qZ, "initInputEvent");
function rl(e, { view: t, detail: r }) {
  ha(e, {
    view: t,
    detail: Tt(r ?? 0)
  });
}
u(rl, "initUIEvent");
function Of(e, { altKey: t, ctrlKey: r, metaKey: n, shiftKey: o, modifierAltGraph: a, modifierCapsLock: i, modifierFn: s, modifierFnLock: d, modifierNumLock: l, modifierScrollLock: p, modifierSymbol: f, modifierSymbolLock: h }) {
  ha(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!o,
    getModifierState(m) {
      return !!{
        Alt: t,
        AltGraph: a,
        CapsLock: i,
        Control: r,
        Fn: s,
        FnLock: d,
        Meta: n,
        NumLock: l,
        ScrollLock: p,
        Shift: o,
        Symbol: f,
        SymbolLock: h
      }[m];
    }
  });
}
u(Of, "initUIEventModifiers");
function LZ(e, { key: t, code: r, location: n, repeat: o, isComposing: a, charCode: i }) {
  ha(e, {
    key: String(t),
    code: String(r),
    location: Tt(n),
    repeat: !!o,
    isComposing: !!a,
    charCode: i
  });
}
u(LZ, "initKeyboardEvent");
function O1(e, { x: t, y: r, screenX: n, screenY: o, clientX: a = t, clientY: i = r, button: s, buttons: d, relatedTarget: l, offsetX: p, offsetY: f, pageX: h, pageY: m }) {
  ha(e, {
    screenX: Tt(n),
    screenY: Tt(o),
    clientX: Tt(a),
    x: Tt(a),
    clientY: Tt(i),
    y: Tt(i),
    button: Tt(s),
    buttons: Tt(d),
    relatedTarget: l,
    offsetX: Tt(p),
    offsetY: Tt(f),
    pageX: Tt(h),
    pageY: Tt(m)
  });
}
u(O1, "initMouseEvent");
function FZ(e, { pointerId: t, width: r, height: n, pressure: o, tangentialPressure: a, tiltX: i, tiltY: s, twist: d, pointerType: l, isPrimary: p }) {
  ha(e, {
    pointerId: Tt(t),
    width: Tt(r ?? 1),
    height: Tt(n ?? 1),
    pressure: Tt(o),
    tangentialPressure: Tt(a),
    tiltX: Tt(i),
    tiltY: Tt(s),
    twist: Tt(d),
    pointerType: String(l),
    isPrimary: !!p
  });
}
u(FZ, "initPointerEvent");
function UZ(e, t, r, n = !1) {
  (jZ(t) || IZ(t)) && (r = {
    ...r,
    ...this.system.getUIEventModifiers()
  });
  const o = Gk(t, e, r);
  return Kk.call(this, e, o, n);
}
u(UZ, "dispatchUIEvent");
function Kk(e, t, r = !1) {
  var n;
  const o = t.type, a = r ? () => {
  } : (n = Qa[o]) === null || n === void 0 ? void 0 : n.call(Qa, t, e, this);
  if (a) {
    t.preventDefault();
    let i = !1;
    return Object.defineProperty(t, "defaultPrevented", {
      get: /* @__PURE__ */ u(() => i, "get")
    }), Object.defineProperty(t, "preventDefault", {
      value: /* @__PURE__ */ u(() => {
        i = t.cancelable;
      }, "value")
    }), mc(() => e.dispatchEvent(t)), i || a(), !i;
  }
  return mc(() => e.dispatchEvent(t));
}
u(Kk, "dispatchEvent");
function Aa(e, t, r) {
  const n = Gk(t, e, r);
  mc(() => e.dispatchEvent(n));
}
u(Aa, "dispatchDOMEvent");
var Yj = Symbol("patched focus/blur methods");
function Yk(e) {
  if (e.prototype[Yj])
    return;
  const { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: {
      configurable: !0,
      get: /* @__PURE__ */ u(() => o, "get")
    },
    blur: {
      configurable: !0,
      get: /* @__PURE__ */ u(() => a, "get")
    },
    [Yj]: {
      configurable: !0,
      get: /* @__PURE__ */ u(() => ({
        focus: t,
        blur: r
      }), "get")
    }
  });
  let n;
  function o(i) {
    if (this.ownerDocument.visibilityState !== "hidden")
      return t.call(this, i);
    const s = R1(this.ownerDocument);
    if (s === this)
      return;
    const d = Symbol("focus call");
    n = d, s && (r.call(s), Aa(s, "blur", {
      relatedTarget: this
    }), Aa(s, "focusout", {
      relatedTarget: n === d ? this : null
    })), n === d && (t.call(this, i), Aa(this, "focus", {
      relatedTarget: s
    })), n === d && Aa(this, "focusin", {
      relatedTarget: s
    });
  }
  u(o, "patchedFocus");
  function a() {
    if (this.ownerDocument.visibilityState !== "hidden")
      return r.call(this);
    const i = R1(this.ownerDocument);
    i === this && (n = Symbol("blur call"), r.call(this), Aa(i, "blur", {
      relatedTarget: null
    }), Aa(i, "focusout", {
      relatedTarget: null
    }));
  }
  u(a, "patchedBlur");
}
u(Yk, "patchFocus");
function R1(e) {
  const t = Bc(e);
  return t?.tagName === "BODY" ? null : t;
}
u(R1, "getActiveTarget");
var qv = Symbol("Interceptor for programmatical calls");
function zi(e, t, r) {
  const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), o = Object.getOwnPropertyDescriptor(e, t), a = n?.set ? "set" : "value";
  if (typeof n?.[a] != "function" || n[a][qv])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function i(...s) {
    const { applyNative: d = !1, realArgs: l, then: p } = r.call(this, ...s), f = (!d && o || n)[a];
    a === "set" ? f.call(this, l) : f.call(this, ...l), p?.();
  }
  u(i, "intercept"), i[qv] = qv, Object.defineProperty(e, t, {
    ...o ?? n,
    [a]: i
  });
}
u(zi, "prepareInterceptor");
function BZ(e) {
  zi(e, "value", /* @__PURE__ */ u(function(t) {
    const r = aZ(t);
    return r && vZ(this), {
      applyNative: !!r,
      realArgs: HZ(this, t),
      then: r ? void 0 : () => wZ(this, String(t))
    };
  }, "interceptorImpl"));
}
u(BZ, "prepareValueInterceptor");
function HZ(e, t) {
  return De(e, "input", {
    type: "number"
  }) && String(t) !== "" && !Number.isNaN(Number(t)) ? String(Number(t)) : String(t);
}
u(HZ, "sanitizeValue");
function VZ(e) {
  zi(e, "setSelectionRange", /* @__PURE__ */ u(function(t, ...r) {
    const n = iZ(t);
    return {
      applyNative: !!n,
      realArgs: [
        Number(t),
        ...r
      ],
      then: /* @__PURE__ */ u(() => n ? void 0 : ed(e), "then")
    };
  }, "interceptorImpl")), zi(e, "selectionStart", /* @__PURE__ */ u(function(t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ u(() => ed(e), "then")
    };
  }, "interceptorImpl")), zi(e, "selectionEnd", /* @__PURE__ */ u(function(t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ u(() => ed(e), "then")
    };
  }, "interceptorImpl")), zi(e, "select", /* @__PURE__ */ u(function() {
    return {
      realArgs: [],
      then: /* @__PURE__ */ u(() => cZ(e, {
        anchorOffset: 0,
        focusOffset: Jn(e).length
      }), "then")
    };
  }, "interceptorImpl"));
}
u(VZ, "prepareSelectionInterceptor");
function zZ(e) {
  zi(e, "setRangeText", /* @__PURE__ */ u(function(...t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ u(() => {
        Pb(e), ed(e);
      }, "then")
    };
  }, "interceptorImpl"));
}
u(zZ, "prepareRangeTextInterceptor");
var kl = Symbol("Node prepared with document state workarounds");
function Xk(e) {
  e[kl] || (e.addEventListener("focus", (t) => {
    const r = t.target;
    j1(r);
  }, {
    capture: !0,
    passive: !0
  }), e.activeElement && j1(e.activeElement), e.addEventListener("blur", (t) => {
    const r = t.target, n = lZ(r);
    n !== void 0 && (r.value !== n && Aa(r, "change"), Uk(r));
  }, {
    capture: !0,
    passive: !0
  }), e[kl] = kl);
}
u(Xk, "prepareDocument");
function j1(e) {
  e[kl] || (De(e, [
    "input",
    "textarea"
  ]) && (BZ(e), VZ(e), zZ(e)), e[kl] = kl);
}
u(j1, "prepareElement");
function JZ(e) {
  return WZ(e) ? e : e.ownerDocument;
}
u(JZ, "getDocumentFromNode");
function WZ(e) {
  return e.nodeType === 9;
}
u(WZ, "isDocument");
var Jr = (function(e) {
  return e[e.Trigger = 2] = "Trigger", e[e.Call = 1] = "Call", e;
})({});
function ml(e, t) {
  e.levelRefs[t] = {};
}
u(ml, "setLevelRef");
function $u(e, t) {
  return e.levelRefs[t];
}
u($u, "getLevelRef");
function xs(e) {
  const t = e.delay;
  if (typeof t == "number")
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t)
    ]);
}
u(xs, "wait");
var Rf = (function(e) {
  return e[e.EachTrigger = 4] = "EachTrigger", e[e.EachApiCall = 2] = "EachApiCall", e[e.EachTarget = 1] = "EachTarget", e[e.Never = 0] = "Never", e;
})({});
function va(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(va, "_define_property");
var Gn = (function(e) {
  return e[e.STANDARD = 0] = "STANDARD", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.NUMPAD = 3] = "NUMPAD", e;
})({}), Q$e = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function I1(e) {
  return Q$e.includes(e);
}
u(I1, "isModifierKey");
var Z$e = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function N1(e) {
  return Z$e.includes(e);
}
u(N1, "isModifierLock");
var GZ = class {
  isKeyPressed(e) {
    return this.pressed.has(String(e.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((e) => e.keyDef);
  }
  /** Press a key */
  async keydown(e, t) {
    const r = String(t.key), n = String(t.code), o = Pf(e.config.document);
    this.setKeydownTarget(o), this.pressed.add(n, t), I1(r) && (this.modifiers[r] = !0);
    const a = e.dispatchUIEvent(o, "keydown", {
      key: r,
      code: n
    });
    N1(r) && !this.modifiers[r] && (this.modifiers[r] = !0, this.modifierLockStart[r] = !0), a && this.pressed.setUnprevented(n), a && this.hasKeyPress(r) && e.dispatchUIEvent(Pf(e.config.document), "keypress", {
      key: r,
      code: n,
      charCode: t.key === "Enter" ? 13 : String(t.key).charCodeAt(0)
    });
  }
  /** Release a key */
  async keyup(e, t) {
    const r = String(t.key), n = String(t.code), o = this.pressed.isUnprevented(n);
    this.pressed.delete(n), I1(r) && !this.pressed.values().find((a) => a.keyDef.key === r) && (this.modifiers[r] = !1), e.dispatchUIEvent(Pf(e.config.document), "keyup", {
      key: r,
      code: n
    }, !o), N1(r) && this.modifiers[r] && (this.modifierLockStart[r] ? this.modifierLockStart[r] = !1 : this.modifiers[r] = !1);
  }
  setKeydownTarget(e) {
    e !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = e;
  }
  hasKeyPress(e) {
    return (e.length === 1 || e === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(e) {
    va(this, "system", void 0), va(this, "modifiers", {
      Alt: !1,
      AltGraph: !1,
      CapsLock: !1,
      Control: !1,
      Fn: !1,
      FnLock: !1,
      Meta: !1,
      NumLock: !1,
      ScrollLock: !1,
      Shift: !1,
      Symbol: !1,
      SymbolLock: !1
    }), va(this, "pressed", new class {
      add(t, r) {
        var n, o, a;
        (a = (n = this.registry)[o = t]) !== null && a !== void 0 || (n[o] = {
          keyDef: r,
          unpreventedDefault: !1
        });
      }
      has(t) {
        return !!this.registry[t];
      }
      setUnprevented(t) {
        const r = this.registry[t];
        r && (r.unpreventedDefault = !0);
      }
      isUnprevented(t) {
        var r;
        return !!(!((r = this.registry[t]) === null || r === void 0) && r.unpreventedDefault);
      }
      delete(t) {
        delete this.registry[t];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        va(this, "registry", {});
      }
    }()), va(this, "carryChar", ""), va(this, "lastKeydownTarget", void 0), va(this, "modifierLockStart", {}), this.system = e;
  }
};
u(GZ, "KeyboardHost");
var eCe = GZ, tCe = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((e) => ({
    code: `Digit${e}`,
    key: e
  })),
  ...")!@#$%^&*(".split("").map((e, t) => ({
    code: `Digit${t}`,
    key: e,
    shiftKey: !0
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((e) => ({
    code: `Key${e.toUpperCase()}`,
    key: e
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((e) => ({
    code: `Key${e}`,
    key: e,
    shiftKey: !0
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: !0
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: !0
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: Gn.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: Gn.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: Gn.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: Gn.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: Gn.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: Gn.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: Gn.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: Gn.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: Gn.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: Gn.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
], rCe = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];
function KZ(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(KZ, "_define_property");
var YZ = class {
  getButtons() {
    let e = 0;
    for (const t of Object.keys(this.pressed))
      e |= 2 ** Number(t);
    return e;
  }
  down(e) {
    const t = Am(e.button);
    if (t in this.pressed) {
      this.pressed[t].push(e);
      return;
    }
    return this.pressed[t] = [
      e
    ], t;
  }
  up(e) {
    const t = Am(e.button);
    if (t in this.pressed && (this.pressed[t] = this.pressed[t].filter((r) => r.name !== e.name), this.pressed[t].length === 0))
      return delete this.pressed[t], t;
  }
  constructor() {
    KZ(this, "pressed", {});
  }
};
u(YZ, "Buttons");
var XZ = YZ, Xj = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function Am(e = 0) {
  return e in Xj ? Xj[e] : Number(e);
}
u(Am, "getMouseButtonId");
var Qj = {
  1: 2,
  2: 1
};
function $m(e) {
  return e = Am(e), e in Qj ? Qj[e] : e;
}
u($m, "getMouseEventButton");
function QZ(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(QZ, "_define_property");
var ZZ = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(e) {
    return this.pressedKeys.has(e.name);
  }
  addPressed(e) {
    return this.pressedKeys.add(e.name);
  }
  removePressed(e) {
    return this.pressedKeys.delete(e.name);
  }
  constructor() {
    QZ(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
u(ZZ, "Device");
var nCe = ZZ;
function Pl(e, t) {
  const r = [];
  for (let a = e; a; a = a.parentElement)
    r.push(a);
  const n = [];
  for (let a = t; a; a = a.parentElement)
    n.push(a);
  let o = 0;
  for (; !(o >= r.length || o >= n.length || r[r.length - 1 - o] !== n[n.length - 1 - o]); o++)
    ;
  return [
    r.slice(0, r.length - o),
    n.slice(0, n.length - o),
    n.slice(n.length - o)
  ];
}
u(Pl, "getTreeDiff");
function Cm({ target: e, node: t, offset: r }) {
  return zn(e) ? {
    node: e,
    offset: r ?? Jn(e).length
  } : t ? {
    node: t,
    offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length)
  } : Qk(e, r);
}
u(Cm, "resolveCaretPosition");
function Qk(e, t, r = !0) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0;
  const o = t === void 0 ? -1 : 1;
  for (; t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length; ) {
    if (t && n === e.childNodes.length)
      throw new Error("The given offset is out of bounds.");
    const a = e.childNodes.item(n), i = String(a.textContent);
    if (i.length)
      if (t !== void 0 && i.length < t)
        t -= i.length;
      else {
        if (a.nodeType === 1)
          return Qk(a, t, !1);
        if (a.nodeType === 3)
          return {
            node: a,
            offset: t ?? a.nodeValue.length
          };
      }
    n += o;
  }
  return {
    node: e,
    offset: e.childNodes.length
  };
}
u(Qk, "findNodeAtTextOffset");
function eee({ document: e, target: t, clickCount: r, node: n, offset: o }) {
  if (rZ(t))
    return;
  const a = zn(t), i = String(a ? Jn(t) : t.textContent), [s, d] = n ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      o,
      o
    ]
  ) : tee(i, o, r);
  if (a)
    return Fs(t, {
      anchorOffset: s ?? i.length,
      focusOffset: d ?? i.length
    }), {
      node: t,
      start: s ?? 0,
      end: d ?? i.length
    };
  {
    const { node: l, offset: p } = Cm({
      target: t,
      node: n,
      offset: s
    }), { node: f, offset: h } = Cm({
      target: t,
      node: n,
      offset: d
    }), m = t.ownerDocument.createRange();
    try {
      m.setStart(l, p), m.setEnd(f, h);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    const g = e.getSelection();
    return g?.removeAllRanges(), g?.addRange(m.cloneRange()), m;
  }
}
u(eee, "setSelectionPerMouseDown");
function tee(e, t, r) {
  if (r % 3 === 1 || e.length === 0)
    return [
      t,
      t
    ];
  const n = t ?? e.length;
  return r % 3 === 2 ? [
    n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length
  ] : [
    n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length
  ];
}
u(tee, "getTextRange");
function ree(e, { document: t, target: r, node: n, offset: o }) {
  const a = Cm({
    target: r,
    node: n,
    offset: o
  });
  if ("node" in e) {
    if (a.node === e.node) {
      const i = a.offset < e.start ? e.end : e.start, s = a.offset > e.end || a.offset < e.start ? a.offset : e.end;
      Fs(e.node, {
        anchorOffset: i,
        focusOffset: s
      });
    }
  } else {
    const i = e.cloneRange(), s = i.comparePoint(a.node, a.offset);
    s < 0 ? i.setStart(a.node, a.offset) : s > 0 && i.setEnd(a.node, a.offset);
    const d = t.getSelection();
    d?.removeAllRanges(), d?.addRange(i.cloneRange());
  }
}
u(ree, "modifySelectionPerMouseMove");
function Zk(e, t) {
  var r, n, o, a, i, s, d, l, p, f, h, m, g, w, _, b, x, P, R, N, C, A, E, T;
  return e.target !== t.target || ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !== ((n = t.coords) === null || n === void 0 ? void 0 : n.x) || ((o = e.coords) === null || o === void 0 ? void 0 : o.y) !== ((a = t.coords) === null || a === void 0 ? void 0 : a.y) || ((i = e.coords) === null || i === void 0 ? void 0 : i.clientX) !== ((s = t.coords) === null || s === void 0 ? void 0 : s.clientX) || ((d = e.coords) === null || d === void 0 ? void 0 : d.clientY) !== ((l = t.coords) === null || l === void 0 ? void 0 : l.clientY) || ((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !== ((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) || ((h = e.coords) === null || h === void 0 ? void 0 : h.offsetY) !== ((m = t.coords) === null || m === void 0 ? void 0 : m.offsetY) || ((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !== ((w = t.coords) === null || w === void 0 ? void 0 : w.pageX) || ((_ = e.coords) === null || _ === void 0 ? void 0 : _.pageY) !== ((b = t.coords) === null || b === void 0 ? void 0 : b.pageY) || ((x = e.coords) === null || x === void 0 ? void 0 : x.screenX) !== ((P = t.coords) === null || P === void 0 ? void 0 : P.screenX) || ((R = e.coords) === null || R === void 0 ? void 0 : R.screenY) !== ((N = t.coords) === null || N === void 0 ? void 0 : N.screenY) || ((C = e.caret) === null || C === void 0 ? void 0 : C.node) !== ((A = t.caret) === null || A === void 0 ? void 0 : A.node) || ((E = e.caret) === null || E === void 0 ? void 0 : E.offset) !== ((T = t.caret) === null || T === void 0 ? void 0 : T.offset);
}
u(Zk, "isDifferentPointerPosition");
function wa(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(wa, "_define_property");
var nee = class {
  move(e, t, r) {
    const n = this.position, o = this.getTarget(e);
    if (this.position = t, !Zk(n, t))
      return;
    const a = this.getTarget(e), i = this.getEventInit("mousemove"), [s, d] = Pl(o, a);
    return {
      leave: /* @__PURE__ */ u(() => {
        o !== a && (e.dispatchUIEvent(o, "mouseout", i), s.forEach((l) => e.dispatchUIEvent(l, "mouseleave", i)));
      }, "leave"),
      enter: /* @__PURE__ */ u(() => {
        o !== a && (e.dispatchUIEvent(a, "mouseover", i), d.forEach((l) => e.dispatchUIEvent(l, "mouseenter", i)));
      }, "enter"),
      move: /* @__PURE__ */ u(() => {
        r || (e.dispatchUIEvent(a, "mousemove", i), this.modifySelecting(e));
      }, "move")
    };
  }
  down(e, t, r) {
    const n = this.buttons.down(t);
    if (n === void 0)
      return;
    const o = this.getTarget(e);
    this.buttonDownTarget[n] = o;
    const a = this.getEventInit("mousedown", t.button), i = yo(o);
    !r && (i || e.dispatchUIEvent(o, "mousedown", a)) && (this.startSelecting(e, a.detail), ia(o)), !i && $m(t.button) === 2 && e.dispatchUIEvent(o, "contextmenu", this.getEventInit("contextmenu", t.button));
  }
  up(e, t, r) {
    const n = this.buttons.up(t);
    if (n === void 0)
      return;
    const o = this.getTarget(e);
    if (!yo(o)) {
      if (!r) {
        const i = this.getEventInit("mouseup", t.button);
        e.dispatchUIEvent(o, "mouseup", i), this.endSelecting();
      }
      const a = Pl(this.buttonDownTarget[n], o)[2][0];
      if (a) {
        const i = this.getEventInit("click", t.button);
        i.detail && (e.dispatchUIEvent(a, i.button === 0 ? "click" : "auxclick", i), i.button === 0 && i.detail === 2 && e.dispatchUIEvent(a, "dblclick", {
          ...this.getEventInit("dblclick", t.button),
          detail: i.detail
        }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(e, t) {
    const r = {
      ...this.position.coords
    };
    return r.button = $m(t), r.buttons = this.buttons.getButtons(), e === "mousedown" ? r.detail = this.clickCount.getOnDown(r.button) : e === "mouseup" ? r.detail = this.clickCount.getOnUp(r.button) : (e === "click" || e === "auxclick") && (r.detail = this.clickCount.incOnClick(r.button)), r;
  }
  getTarget(e) {
    var t;
    return (t = this.position.target) !== null && t !== void 0 ? t : e.config.document.body;
  }
  startSelecting(e, t) {
    var r, n;
    this.selecting = eee({
      document: e.config.document,
      target: this.getTarget(e),
      node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset,
      clickCount: t
    });
  }
  modifySelecting(e) {
    var t, r;
    this.selecting && ree(this.selecting, {
      document: e.config.document,
      target: this.getTarget(e),
      node: (t = this.position.caret) === null || t === void 0 ? void 0 : t.node,
      offset: (r = this.position.caret) === null || r === void 0 ? void 0 : r.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    wa(this, "position", {}), wa(this, "buttons", new XZ()), wa(this, "selecting", void 0), wa(this, "buttonDownTarget", {}), wa(this, "clickCount", new class {
      incOnClick(e) {
        const t = this.down[e] === void 0 ? void 0 : Number(this.down[e]) + 1;
        return this.count = this.count[e] === void 0 ? {} : {
          [e]: Number(this.count[e]) + 1
        }, t;
      }
      getOnDown(e) {
        var t;
        this.down = {
          [e]: (t = this.count[e]) !== null && t !== void 0 ? t : 0
        };
        var r;
        return this.count = {
          [e]: (r = this.count[e]) !== null && r !== void 0 ? r : 0
        }, Number(this.count[e]) + 1;
      }
      getOnUp(e) {
        return this.down[e] === void 0 ? void 0 : Number(this.down[e]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        wa(this, "down", {}), wa(this, "count", {});
      }
    }());
  }
};
u(nee, "Mouse");
var oCe = nee;
function Kd(e, t) {
  var r;
  return ((r = eP(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== "none";
}
u(Kd, "hasPointerEvents");
function oee(e) {
  const t = tn(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    const o = t.getComputedStyle(r).pointerEvents;
    if (o && ![
      "inherit",
      "unset"
    ].includes(o))
      return {
        pointerEvents: o,
        tree: n
      };
  }
}
u(oee, "closestPointerEventsDeclaration");
var Zj = Symbol("Last check for pointer-events");
function eP(e, t) {
  const r = t[Zj];
  if (!(e.config.pointerEventsCheck !== Rf.Never && (!r || M1(e.config.pointerEventsCheck, Rf.EachApiCall) && r[Jr.Call] !== $u(e, Jr.Call) || M1(e.config.pointerEventsCheck, Rf.EachTrigger) && r[Jr.Trigger] !== $u(e, Jr.Trigger))))
    return r?.result;
  const n = oee(t);
  return t[Zj] = {
    [Jr.Call]: $u(e, Jr.Call),
    [Jr.Trigger]: $u(e, Jr.Trigger),
    result: n
  }, n;
}
u(eP, "checkPointerEvents");
function yl(e, t) {
  const r = eP(e, t);
  if (r?.pointerEvents === "none")
    throw new Error([
      `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      aee(r.tree)
    ].join(`
`));
}
u(yl, "assertPointerEvents");
function aee(e) {
  return e.reverse().map((t, r) => [
    "".padEnd(r),
    t.tagName,
    t.id && `#${t.id}`,
    t.hasAttribute("data-testid") && `(testId=${t.getAttribute("data-testid")})`,
    iee(t),
    e.length > 1 && r === 0 && "  <-- This element declared `pointer-events: none`",
    e.length > 1 && r === e.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join(`
`);
}
u(aee, "printTree");
function iee(e) {
  var t;
  let r;
  if (e.hasAttribute("aria-label"))
    r = e.getAttribute("aria-label");
  else if (e.hasAttribute("aria-labelledby")) {
    var n, o;
    r = (o = e.ownerDocument.getElementById(e.getAttribute("aria-labelledby"))) === null || o === void 0 || (n = o.textContent) === null || n === void 0 ? void 0 : n.trim();
  } else if (De(e, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && !((t = e.labels) === null || t === void 0) && t.length)
    r = Array.from(e.labels).map((i) => {
      var s;
      return (s = i.textContent) === null || s === void 0 ? void 0 : s.trim();
    }).join("|");
  else if (De(e, "button")) {
    var a;
    r = (a = e.textContent) === null || a === void 0 ? void 0 : a.trim();
  }
  return r = r?.replace(/\n/g, "  "), Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}â€¦`), r ? `(label=${r})` : "";
}
u(iee, "getLabelDescr");
function M1(e, t) {
  return (e & t) > 0;
}
u(M1, "hasBitFlag");
function eo(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(eo, "_define_property");
var see = class {
  init(e) {
    const t = this.getTarget(e), [, r] = Pl(null, t), n = this.getEventInit();
    return yl(e, t), e.dispatchUIEvent(t, "pointerover", n), r.forEach((o) => e.dispatchUIEvent(o, "pointerenter", n)), this;
  }
  move(e, t) {
    const r = this.position, n = this.getTarget(e);
    if (this.position = t, !Zk(r, t))
      return;
    const o = this.getTarget(e), a = this.getEventInit(-1), [i, s] = Pl(n, o);
    return {
      leave: /* @__PURE__ */ u(() => {
        Kd(e, n) && n !== o && (e.dispatchUIEvent(n, "pointerout", a), i.forEach((d) => e.dispatchUIEvent(d, "pointerleave", a)));
      }, "leave"),
      enter: /* @__PURE__ */ u(() => {
        yl(e, o), n !== o && (e.dispatchUIEvent(o, "pointerover", a), s.forEach((d) => e.dispatchUIEvent(d, "pointerenter", a)));
      }, "enter"),
      move: /* @__PURE__ */ u(() => {
        e.dispatchUIEvent(o, "pointermove", a);
      }, "move")
    };
  }
  down(e, t = 0) {
    if (this.isDown)
      return;
    const r = this.getTarget(e);
    yl(e, r), this.isDown = !0, this.isPrevented = !e.dispatchUIEvent(r, "pointerdown", this.getEventInit(t));
  }
  up(e, t = 0) {
    if (!this.isDown)
      return;
    const r = this.getTarget(e);
    yl(e, r), this.isPrevented = !1, this.isDown = !1, e.dispatchUIEvent(r, "pointerup", this.getEventInit(t));
  }
  release(e) {
    const t = this.getTarget(e), [r] = Pl(t, null), n = this.getEventInit();
    Kd(e, t) && (e.dispatchUIEvent(t, "pointerout", n), r.forEach((o) => e.dispatchUIEvent(o, "pointerleave", n))), this.isCancelled = !0;
  }
  getTarget(e) {
    var t;
    return (t = this.position.target) !== null && t !== void 0 ? t : e.config.document.body;
  }
  getEventInit(e) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: $m(e),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId: e, pointerType: t, isPrimary: r }, n) {
    eo(this, "pointerId", void 0), eo(this, "pointerType", void 0), eo(this, "isPrimary", void 0), eo(this, "buttons", void 0), eo(this, "isMultitouch", !1), eo(this, "isCancelled", !1), eo(this, "isDown", !1), eo(this, "isPrevented", !1), eo(this, "position", {}), this.pointerId = e, this.pointerType = t, this.isPrimary = r, this.isMultitouch = !r, this.buttons = n;
  }
};
u(see, "Pointer");
var aCe = see;
function Bo(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(Bo, "_define_property");
var lee = class {
  isKeyPressed(e) {
    return this.devices.get(e.pointerType).isPressed(e);
  }
  async press(e, t, r) {
    this.devices.get(t.pointerType).addPressed(t), this.buttons.down(t);
    const n = this.getPointerName(t), o = t.pointerType === "touch" ? this.pointers.new(n, t.pointerType, this.buttons) : this.pointers.get(n);
    o.position = r, o.pointerType !== "touch" && (this.mouse.position = r), o.pointerType === "touch" && o.init(e), o.down(e, t.button), o.pointerType !== "touch" && this.mouse.down(e, t, o.isPrevented);
  }
  async move(e, t, r) {
    const n = this.pointers.get(t), o = n.move(e, r), a = n.pointerType === "touch" ? void 0 : this.mouse.move(e, r, n.isPrevented);
    o?.leave(), a?.leave(), o?.enter(), a?.enter(), o?.move(), a?.move();
  }
  async release(e, t, r) {
    const n = this.devices.get(t.pointerType);
    n.removePressed(t), this.buttons.up(t);
    const o = this.pointers.get(this.getPointerName(t)), a = o.isPrevented;
    if (o.position = r, o.pointerType !== "touch" && (this.mouse.position = r), n.countPressed === 0 && o.up(e, t.button), o.pointerType === "touch" && o.release(e), o.pointerType === "touch" && !o.isMultitouch) {
      const i = this.mouse.move(e, r, a);
      i?.leave(), i?.enter(), i?.move(), this.mouse.down(e, t, a);
    }
    if (!o.isMultitouch) {
      const i = this.mouse.move(e, r, a);
      i?.leave(), i?.enter(), i?.move(), this.mouse.up(e, t, a);
    }
  }
  getPointerName(e) {
    return e.pointerType === "touch" ? e.name : e.pointerType;
  }
  getPreviousPosition(e) {
    return this.pointers.has(e) ? this.pointers.get(e).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(e) {
    var t;
    return (t = this.mouse.position.target) !== null && t !== void 0 ? t : e.config.document.body;
  }
  setMousePosition(e) {
    this.mouse.position = e, this.pointers.get("mouse").position = e;
  }
  constructor(e) {
    Bo(this, "system", void 0), Bo(this, "mouse", void 0), Bo(this, "buttons", void 0), Bo(this, "devices", new class {
      get(t) {
        var r, n, o;
        return (o = (r = this.registry)[n = t]) !== null && o !== void 0 ? o : r[n] = new nCe();
      }
      constructor() {
        Bo(this, "registry", {});
      }
    }()), Bo(this, "pointers", new class {
      new(t, r, n) {
        const o = r !== "touch" || !Object.values(this.registry).some((a) => a.pointerType === "touch" && !a.isCancelled);
        return o || Object.values(this.registry).forEach((a) => {
          a.pointerType === r && !a.isCancelled && (a.isMultitouch = !0);
        }), this.registry[t] = new aCe({
          pointerId: this.nextId++,
          pointerType: r,
          isPrimary: o
        }, n), this.registry[t];
      }
      get(t) {
        if (!this.has(t))
          throw new Error(`Trying to access pointer "${t}" which does not exist.`);
        return this.registry[t];
      }
      has(t) {
        return t in this.registry;
      }
      constructor() {
        Bo(this, "registry", {}), Bo(this, "nextId", 1);
      }
    }()), this.system = e, this.buttons = new XZ(), this.mouse = new oCe(), this.pointers.new("mouse", "mouse", this.buttons);
  }
};
u(lee, "PointerHost");
var iCe = lee;
function D1(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
u(D1, "_define_property");
var cee = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    D1(this, "keyboard", new eCe(this)), D1(this, "pointer", new iCe(this));
  }
};
u(cee, "System");
var uee = cee;
async function dee(e) {
  const t = [];
  return this.config.skipHover || t.push({
    target: e
  }), t.push({
    keys: "[MouseLeft]",
    target: e
  }), this.pointer(t);
}
u(dee, "click");
async function pee(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
u(pee, "dblClick");
async function fee(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}
u(fee, "tripleClick");
async function hee(e) {
  return this.pointer({
    target: e
  });
}
u(hee, "hover");
async function mee(e) {
  return yl(this, this.system.pointer.getMouseTarget(this)), this.pointer({
    target: e.ownerDocument.body
  });
}
u(mee, "unhover");
async function yee({ shift: e } = {}) {
  return this.keyboard(e === !0 ? "{Shift>}{Tab}{/Shift}" : e === !1 ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
u(yee, "tab");
var tP = (function(e) {
  return e["{"] = "}", e["["] = "]", e;
})(tP || {});
function rP(e, t) {
  let r = 0;
  const n = e[r] in tP ? e[r] : "";
  r += n.length;
  const o = new RegExp(`^\\${n}{2}`).test(e) ? "" : n;
  return {
    type: o,
    ...o === "" ? gee(e, r, t) : bee(e, r, o, t)
  };
}
u(rP, "readNextDescriptor");
function gee(e, t, r) {
  const n = e[t];
  return nP(n, e, t, r), t += n.length, {
    consumedLength: t,
    descriptor: n,
    releasePrevious: !1,
    releaseSelf: !0,
    repeat: 1
  };
}
u(gee, "readPrintableChar");
function bee(e, t, r, n) {
  var o, a;
  const i = e[t] === "/" ? "/" : "";
  t += i.length;
  const s = r === "{" && e[t] === "\\";
  t += Number(s);
  const d = s ? e[t] : (o = e.slice(t).match(r === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || o === void 0 ? void 0 : o[0];
  nP(d, e, t, n), t += d.length;
  var l;
  const p = (l = (a = e.slice(t).match(/^>\d+/)) === null || a === void 0 ? void 0 : a[0]) !== null && l !== void 0 ? l : "";
  t += p.length;
  const f = e[t] === "/" || !p && e[t] === ">" ? e[t] : "";
  t += f.length;
  const h = tP[r], m = e[t] === h ? h : "";
  if (!m)
    throw new Error(oP([
      !p && "repeat modifier",
      !f && "release modifier",
      `"${h}"`
    ].filter(Boolean).join(" or "), e[t], e, n));
  return t += m.length, {
    consumedLength: t,
    descriptor: d,
    releasePrevious: !!i,
    repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
    releaseSelf: vee(f, p)
  };
}
u(bee, "readTag");
function nP(e, t, r, n) {
  if (!e)
    throw new Error(oP("key descriptor", t[r], t, n));
}
u(nP, "assertDescriptor");
function vee(e, t) {
  if (e)
    return e === "/";
  if (t)
    return !1;
}
u(vee, "hasReleaseSelf");
function oP(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ""}" in "${r}"
    See ${n === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}
u(oP, "getErrorMessage");
function wee(e, t) {
  const r = [];
  do {
    const { type: o, descriptor: a, consumedLength: i, releasePrevious: s, releaseSelf: d = !0, repeat: l } = rP(t, "keyboard");
    var n;
    const p = (n = e.find((f) => {
      if (o === "[") {
        var h;
        return ((h = f.code) === null || h === void 0 ? void 0 : h.toLowerCase()) === a.toLowerCase();
      } else if (o === "{") {
        var m;
        return ((m = f.key) === null || m === void 0 ? void 0 : m.toLowerCase()) === a.toLowerCase();
      }
      return f.key === a;
    })) !== null && n !== void 0 ? n : {
      key: "Unknown",
      code: "Unknown",
      [o === "[" ? "code" : "key"]: a
    };
    r.push({
      keyDef: p,
      releasePrevious: s,
      releaseSelf: d,
      repeat: l
    }), t = t.slice(i);
  } while (t);
  return r;
}
u(wee, "parseKeyDef");
async function _ee(e) {
  const t = wee(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++)
    await xs(this.config), await Eee(this, t[r]);
}
u(_ee, "keyboard");
async function Eee(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: o }) {
  const { system: a } = e;
  if (a.keyboard.isKeyPressed(t) && await a.keyboard.keyup(e, t), !r) {
    for (let i = 1; i <= o; i++)
      await a.keyboard.keydown(e, t), i < o && await xs(e.config);
    n && await a.keyboard.keyup(e, t);
  }
}
u(Eee, "keyboardAction");
async function xee(e) {
  for (const t of e.system.keyboard.getPressedKeys())
    await e.system.keyboard.keyup(e, t);
}
u(xee, "releaseAllKeys");
function aP(e) {
  const t = zn(e) ? {
    "text/plain": See(e)
  } : {
    "text/plain": String(e.ownerDocument.getSelection())
  }, r = $b(tn(e));
  for (const n in t)
    t[n] && r.setData(n, t[n]);
  return r;
}
u(aP, "copySelection");
function See(e) {
  const t = gc(e);
  return Jn(e).substring(t.startOffset, t.endOffset);
}
u(See, "readSelectedValueFromInput");
async function Tee() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = aP(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "copy", {
      clipboardData: n
    }) && this.config.writeToClipboard && await Dk(e, n), n;
}
u(Tee, "copy");
async function Aee() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = aP(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "cut", {
      clipboardData: n
    }) && this.config.writeToClipboard && await Dk(r.ownerDocument, n), n;
}
u(Aee, "cut");
async function $ee(e) {
  const t = this.config.document;
  var r;
  const n = (r = t.activeElement) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    t.body
  );
  var o;
  const a = (o = typeof e == "string" ? Cee(t, e) : e) !== null && o !== void 0 ? o : await KQ(t).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(n, "paste", {
    clipboardData: a
  });
}
u($ee, "paste");
function Cee(e, t) {
  const r = $b(tn(e));
  return r.setData("text", t), r;
}
u(Cee, "getClipboardDataFromString");
function q1(e, t) {
  const r = [];
  do {
    const { descriptor: n, consumedLength: o, releasePrevious: a, releaseSelf: i = !0 } = rP(t, "pointer"), s = e.find((d) => d.name === n);
    s && r.push({
      keyDef: s,
      releasePrevious: a,
      releaseSelf: i
    }), t = t.slice(o);
  } while (t);
  return r;
}
u(q1, "parseKeyDef");
async function kee(e) {
  const { pointerMap: t } = this.config, r = [];
  (Array.isArray(e) ? e : [
    e
  ]).forEach((n) => {
    typeof n == "string" ? r.push(...q1(t, n)) : "keys" in n ? r.push(...q1(t, n.keys).map((o) => ({
      ...n,
      ...o
    }))) : r.push(n);
  });
  for (let n = 0; n < r.length; n++)
    await xs(this.config), await Pee(this, r[n]);
  this.system.pointer.resetClickCount();
}
u(kee, "pointer");
async function Pee(e, t) {
  var r, n;
  const o = "pointerName" in t && t.pointerName ? t.pointerName : "keyDef" in t ? e.system.pointer.getPointerName(t.keyDef) : "mouse", a = e.system.pointer.getPreviousPosition(o);
  var i, s, d, l;
  const p = {
    target: (i = t.target) !== null && i !== void 0 ? i : Oee(e, a),
    coords: (s = t.coords) !== null && s !== void 0 ? s : a?.coords,
    caret: {
      node: (d = t.node) !== null && d !== void 0 ? d : L1(t) || a == null || (r = a.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (l = t.offset) !== null && l !== void 0 ? l : L1(t) || a == null || (n = a.caret) === null || n === void 0 ? void 0 : n.offset
    }
  };
  "keyDef" in t ? (e.system.pointer.isKeyPressed(t.keyDef) && (ml(e, Jr.Trigger), await e.system.pointer.release(e, t.keyDef, p)), t.releasePrevious || (ml(e, Jr.Trigger), await e.system.pointer.press(e, t.keyDef, p), t.releaseSelf && (ml(e, Jr.Trigger), await e.system.pointer.release(e, t.keyDef, p)))) : (ml(e, Jr.Trigger), await e.system.pointer.move(e, o, p));
}
u(Pee, "pointerAction");
function L1(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0 ? r : e.offset !== void 0);
}
u(L1, "hasCaretPosition");
function Oee(e, t) {
  if (!t)
    throw new Error("This pointer has no previous position. Provide a target property!");
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
u(Oee, "getPrevTarget");
async function Ree(e) {
  if (!_s(e) || yo(e))
    throw new Error("clear()` is only supported on editable elements.");
  if (ia(e), e.ownerDocument.activeElement !== e)
    throw new Error("The element to be cleared could not be focused.");
  if (Jk(e), !OZ(e))
    throw new Error("The element content to be cleared could not be selected.");
  Es(this, e, "", "deleteContentBackward");
}
u(Ree, "clear");
async function jee(e, t) {
  return iP.call(this, !0, e, t);
}
u(jee, "selectOptions");
async function Iee(e, t) {
  return iP.call(this, !1, e, t);
}
u(Iee, "deselectOptions");
async function iP(e, t, r) {
  if (!e && !t.multiple)
    throw Ve().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", t);
  const n = Array.isArray(r) ? r : [
    r
  ], o = Array.from(t.querySelectorAll('option, [role="option"]')), a = n.map((s) => {
    if (typeof s != "string" && o.includes(s))
      return s;
    {
      const d = o.find((l) => l.value === s || l.innerHTML === s);
      if (d)
        return d;
      throw Ve().getElementError(`Value "${String(s)}" not found in options`, t);
    }
  }).filter((s) => !yo(s));
  if (yo(t) || !a.length) return;
  const i = /* @__PURE__ */ u((s) => {
    s.selected = e, this.dispatchUIEvent(t, "input", {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }), this.dispatchUIEvent(t, "change");
  }, "selectOption");
  if (De(t, "select"))
    if (t.multiple)
      for (const s of a) {
        const d = this.config.pointerEventsCheck === 0 ? !0 : Kd(this, s);
        d && (this.dispatchUIEvent(s, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(s, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(s, "pointermove"), this.dispatchUIEvent(s, "mousemove"), this.dispatchUIEvent(s, "pointerdown"), this.dispatchUIEvent(s, "mousedown")), ia(t), d && (this.dispatchUIEvent(s, "pointerup"), this.dispatchUIEvent(s, "mouseup")), i(s), d && this.dispatchUIEvent(s, "click"), await xs(this.config);
      }
    else if (a.length === 1) {
      const s = this.config.pointerEventsCheck === 0 ? !0 : Kd(this, t);
      s ? await this.click(t) : ia(t), i(a[0]), s && (this.dispatchUIEvent(t, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(t, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(t, "pointerup"), this.dispatchUIEvent(t, "mouseup"), this.dispatchUIEvent(t, "click")), await xs(this.config);
    } else
      throw Ve().getElementError("Cannot select multiple options on a non-multiple select", t);
  else if (t.getAttribute("role") === "listbox")
    for (const s of a)
      await this.click(s), await this.unhover(s);
  else
    throw Ve().getElementError("Cannot select options on elements that are neither select nor listbox elements", t);
}
u(iP, "selectOptionsBase");
async function Nee(e, t, { skipClick: r = this.config.skipClick, skipAutoClose: n = this.config.skipAutoClose, initialSelectionStart: o, initialSelectionEnd: a } = {}) {
  e.disabled || (r || await this.click(e), o !== void 0 && hl(e, o, a ?? o), await this.keyboard(t), n || await xee(this));
}
u(Nee, "type");
var eI = Symbol("files and value properties are mocked");
function jf(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
u(jf, "restoreProperty");
function Mee(e, t) {
  var r;
  (r = e[eI]) === null || r === void 0 || r.restore();
  const n = Object.getOwnPropertyDescriptor(e, "type"), o = Object.getOwnPropertyDescriptor(e, "value"), a = Object.getOwnPropertyDescriptor(e, "files");
  function i() {
    jf(e, "type", n), jf(e, "value", o), jf(e, "files", a);
  }
  u(i, "restore"), e[eI] = {
    restore: i
  }, Object.defineProperties(e, {
    files: {
      configurable: !0,
      get: /* @__PURE__ */ u(() => t, "get")
    },
    value: {
      configurable: !0,
      get: /* @__PURE__ */ u(() => t.length ? `C:\\fakepath\\${t[0].name}` : "", "get"),
      set(s) {
        if (s === "")
          i();
        else {
          var d;
          o == null || (d = o.set) === null || d === void 0 || d.call(e, s);
        }
      }
    },
    type: {
      configurable: !0,
      get: /* @__PURE__ */ u(() => "file", "get"),
      set(s) {
        s !== "file" && (i(), e.type = s);
      }
    }
  });
}
u(Mee, "setFiles");
async function Dee(e, t) {
  const r = De(e, "label") ? e.control : e;
  if (!r || !De(r, "input", {
    type: "file"
  }))
    throw new TypeError(`The ${r === e ? "given" : "associated"} ${r?.tagName} element does not accept file uploads`);
  if (yo(e)) return;
  const n = (Array.isArray(t) ? t : [
    t
  ]).filter((a) => !this.config.applyAccept || qee(a, r.accept)).slice(0, r.multiple ? void 0 : 1), o = /* @__PURE__ */ u(() => {
    var a;
    n.length === ((a = r.files) === null || a === void 0 ? void 0 : a.length) && n.every((i, s) => {
      var d;
      return i === ((d = r.files) === null || d === void 0 ? void 0 : d.item(s));
    }) || (Mee(r, Ab(tn(e), n)), this.dispatchUIEvent(r, "input"), this.dispatchUIEvent(r, "change"));
  }, "fileDialog");
  r.addEventListener("fileDialog", o), await this.click(e), r.removeEventListener("fileDialog", o);
}
u(Dee, "upload");
function Cu(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
u(Cu, "normalize");
function qee(e, t) {
  if (!t)
    return !0;
  const r = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return Cu(t).trim().split(/\s*,\s*/).some((n) => n.startsWith(".") ? Cu(e.name).endsWith(n) : r.includes(n) ? Cu(e.type).startsWith(n.replace("*", "")) : Cu(e.type) === n);
}
u(qee, "isAcceptableFile");
var tI = {
  click: dee,
  dblClick: pee,
  tripleClick: fee,
  hover: hee,
  unhover: mee,
  tab: yee,
  keyboard: _ee,
  copy: Tee,
  cut: Aee,
  paste: $ee,
  pointer: kee,
  clear: Ree,
  deselectOptions: Iee,
  selectOptions: jee,
  type: Nee,
  upload: Dee
};
function Lee(e) {
  return Ve().asyncWrapper(e);
}
u(Lee, "wrapAsync");
var Fee = {
  applyAccept: !0,
  autoModify: !0,
  delay: 0,
  document: globalThis.document,
  keyboardMap: tCe,
  pointerMap: rCe,
  pointerEventsCheck: Rf.EachApiCall,
  skipAutoClose: !1,
  skipClick: !1,
  skipHover: !1,
  writeToClipboard: !1,
  advanceTimers: /* @__PURE__ */ u(() => Promise.resolve(), "advanceTimers")
}, sCe = {
  ...Fee,
  writeToClipboard: !0
};
function sP(e = {}, t = sCe, r) {
  const n = Vee(e, r, t);
  return {
    ...t,
    ...e,
    document: n
  };
}
u(sP, "createConfig");
function Uee(e = {}) {
  const t = sP(e);
  Xk(t.document), Yk(tn(t.document).HTMLElement);
  var r;
  const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    globalThis.window
  );
  return JQ(n), Rb(t).api;
}
u(Uee, "setupMain");
function br({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  const o = sP(r, Fee, n);
  Xk(o.document), Yk(tn(o.document).HTMLElement);
  var a;
  const i = (a = t ?? e) !== null && a !== void 0 ? a : new uee();
  return {
    api: Rb(o, i).api,
    system: i
  };
}
u(br, "setupDirect");
function Bee(e) {
  return Rb({
    ...this.config,
    ...e
  }, this.system).api;
}
u(Bee, "setupSub");
function Hee(e, t) {
  function r(...n) {
    return ml(e, Jr.Call), Lee(() => t.apply(e, n).then(async (o) => (await xs(e.config), o)));
  }
  return u(r, "method"), Object.defineProperty(r, "name", {
    get: /* @__PURE__ */ u(() => t.name, "get")
  }), r;
}
u(Hee, "wrapAndBindImpl");
function Rb(e, t = new uee()) {
  const r = {};
  return Object.assign(r, {
    config: e,
    dispatchEvent: Kk.bind(r),
    dispatchUIEvent: UZ.bind(r),
    system: t,
    levelRefs: {},
    ...tI
  }), {
    instance: r,
    api: {
      ...Object.fromEntries(Object.entries(tI).map(([n, o]) => [
        n,
        Hee(r, o)
      ])),
      setup: Bee.bind(r)
    }
  };
}
u(Rb, "createInstance");
function Vee(e, t, r) {
  var n, o;
  return (o = (n = e.document) !== null && n !== void 0 ? n : t && JZ(t)) !== null && o !== void 0 ? o : r.document;
}
u(Vee, "getDocument");
var zee = {};
vp(zee, {
  clear: () => Jee,
  click: () => Wee,
  copy: () => Gee,
  cut: () => Kee,
  dblClick: () => Yee,
  deselectOptions: () => Xee,
  hover: () => Qee,
  keyboard: () => Zee,
  paste: () => tte,
  pointer: () => ete,
  selectOptions: () => rte,
  tab: () => ste,
  tripleClick: () => nte,
  type: () => ote,
  unhover: () => ate,
  upload: () => ite
});
function Jee(e) {
  return br().api.clear(e);
}
u(Jee, "clear");
function Wee(e, t = {}) {
  return br(t, e).api.click(e);
}
u(Wee, "click");
function Gee(e = {}) {
  return br(e).api.copy();
}
u(Gee, "copy");
function Kee(e = {}) {
  return br(e).api.cut();
}
u(Kee, "cut");
function Yee(e, t = {}) {
  return br(t).api.dblClick(e);
}
u(Yee, "dblClick");
function Xee(e, t, r = {}) {
  return br(r).api.deselectOptions(e, t);
}
u(Xee, "deselectOptions");
function Qee(e, t = {}) {
  return br(t).api.hover(e);
}
u(Qee, "hover");
async function Zee(e, t = {}) {
  const { api: r, system: n } = br(t);
  return r.keyboard(e).then(() => n);
}
u(Zee, "keyboard");
async function ete(e, t = {}) {
  const { api: r, system: n } = br(t);
  return r.pointer(e).then(() => n);
}
u(ete, "pointer");
function tte(e, t) {
  return br(t).api.paste(e);
}
u(tte, "paste");
function rte(e, t, r = {}) {
  return br(r).api.selectOptions(e, t);
}
u(rte, "selectOptions");
function nte(e, t = {}) {
  return br(t).api.tripleClick(e);
}
u(nte, "tripleClick");
function ote(e, t, r = {}) {
  return br(r, e).api.type(e, t, r);
}
u(ote, "type");
function ate(e, t = {}) {
  const { api: r, system: n } = br(t);
  return n.pointer.setMousePosition({
    target: e
  }), r.unhover(e);
}
u(ate, "unhover");
function ite(e, t, r = {}) {
  return br(r).api.upload(e, t);
}
u(ite, "upload");
function ste(e = {}) {
  return br().api.tab(e);
}
u(ste, "tab");
var lte = {
  ...zee,
  setup: Uee
}, F1 = jc(
  { ...vY },
  {
    getKeys: /* @__PURE__ */ u((e) => Object.keys(e).filter((t) => t !== "eventWrapper"), "getKeys"),
    intercept: /* @__PURE__ */ u((e, t) => t[0] === "fireEvent" || e.startsWith("find") || e.startsWith("waitFor"), "intercept")
  }
);
F1.screen = new Proxy(F1.screen, {
  get(e, t, r) {
    return typeof window < "u" && globalThis.location?.href?.includes("viewMode=docs") && qt.warn(Be`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `), Reflect.get(e, t, r);
  }
});
var {
  buildQueries: Zje,
  configure: eIe,
  createEvent: tIe,
  fireEvent: rIe,
  findAllByAltText: nIe,
  findAllByDisplayValue: oIe,
  findAllByLabelText: aIe,
  findAllByPlaceholderText: iIe,
  findAllByRole: sIe,
  findAllByTestId: lIe,
  findAllByText: cIe,
  findAllByTitle: uIe,
  findByAltText: dIe,
  findByDisplayValue: pIe,
  findByLabelText: fIe,
  findByPlaceholderText: hIe,
  findByRole: mIe,
  findByTestId: yIe,
  findByText: gIe,
  findByTitle: bIe,
  getAllByAltText: vIe,
  getAllByDisplayValue: wIe,
  getAllByLabelText: _Ie,
  getAllByPlaceholderText: EIe,
  getAllByRole: xIe,
  getAllByTestId: SIe,
  getAllByText: TIe,
  getAllByTitle: AIe,
  getByAltText: $Ie,
  getByDisplayValue: CIe,
  getByLabelText: kIe,
  getByPlaceholderText: PIe,
  getByRole: OIe,
  getByTestId: RIe,
  getByText: jIe,
  getByTitle: IIe,
  getConfig: NIe,
  getDefaultNormalizer: MIe,
  getElementError: DIe,
  getNodeText: qIe,
  getQueriesForElement: LIe,
  getRoles: FIe,
  getSuggestedQuery: UIe,
  isInaccessible: BIe,
  logDOM: HIe,
  logRoles: VIe,
  prettyDOM: zIe,
  queries: JIe,
  queryAllByAltText: WIe,
  queryAllByAttribute: GIe,
  queryAllByDisplayValue: KIe,
  queryAllByLabelText: YIe,
  queryAllByPlaceholderText: XIe,
  queryAllByRole: QIe,
  queryAllByTestId: ZIe,
  queryAllByText: eNe,
  queryAllByTitle: tNe,
  queryByAltText: rNe,
  queryByAttribute: nNe,
  queryByDisplayValue: oNe,
  queryByLabelText: aNe,
  queryByPlaceholderText: iNe,
  queryByRole: sNe,
  queryByTestId: lNe,
  queryByText: cNe,
  queryByTitle: uNe,
  queryHelpers: dNe,
  screen: pNe,
  waitFor: fNe,
  waitForElementToBeRemoved: hNe,
  within: lCe,
  prettyFormat: mNe
} = F1, cCe = lte, { userEvent: yNe } = jc(
  { userEvent: lte },
  { intercept: !0, getKeys: /* @__PURE__ */ u((e) => Object.keys(e).filter((t) => t !== "eventWrapper"), "getKeys") }
), { expect: gNe } = jc(
  { expect: dY },
  {
    getKeys: /* @__PURE__ */ u((e, t) => {
      if ("constructor" in e && e.constructor === z) {
        const r = ["assert", "__methods", "__flags", "_obj"], n = Object.keys(Object.getPrototypeOf(e)).filter(
          (o) => !r.includes(o)
        );
        return t > 2 ? n : [...n, "not"];
      }
      return "any" in e ? Object.keys(e).filter((r) => r !== "any") : Object.keys(e);
    }, "getKeys"),
    mutate: !0,
    intercept: /* @__PURE__ */ u((e) => e !== "expect", "intercept")
  }
), uCe = G({
  "../node_modules/@ngard/tiny-isequal/index.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.isEqual = /* @__PURE__ */ (function() {
      var t = Object.prototype.toString, r = Object.getPrototypeOf, n = Object.getOwnPropertySymbols ? function(o) {
        return Object.keys(o).concat(Object.getOwnPropertySymbols(o));
      } : Object.keys;
      return function(o, a) {
        return (/* @__PURE__ */ u(function i(s, d, l) {
          var p, f, h, m = t.call(s), g = t.call(d);
          if (s === d) return !0;
          if (s == null || d == null) return !1;
          if (l.indexOf(s) > -1 && l.indexOf(d) > -1) return !0;
          if (l.push(s, d), m != g || (p = n(s), f = n(d), p.length != f.length || p.some(function(w) {
            return !i(s[w], d[w], l);
          }))) return !1;
          switch (m.slice(8, -1)) {
            case "Symbol":
              return s.valueOf() == d.valueOf();
            case "Date":
            case "Number":
              return +s == +d || +s != +s && +d != +d;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + s == "" + d;
            case "Set":
            case "Map":
              p = s.entries(), f = d.entries();
              do
                if (!i((h = p.next()).value, f.next().value, l)) return !1;
              while (!h.done);
              return !0;
            case "ArrayBuffer":
              s = new Uint8Array(s), d = new Uint8Array(d);
            case "DataView":
              s = new Uint8Array(s.buffer), d = new Uint8Array(d.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (s.length != d.length) return !1;
              for (h = 0; h < s.length; h++) if ((h in s || h in d) && (h in s != h in d || !i(s[h], d[h], l))) return !1;
              return !0;
            case "Object":
              return i(r(s), r(d), l);
            default:
              return !1;
          }
        }, "n"))(o, a, []);
      };
    })();
  }
});
function cte(e) {
  return e.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, o) => `${r} ${n}${o}`).replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`).replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`).replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`).replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`).replace(/ +/g, " ").trim();
}
u(cte, "toStartCaseStr");
var rI = ar(uCe(), 1), ute = /* @__PURE__ */ u((e) => e.map((t) => typeof t < "u").filter(Boolean).length, "count"), dCe = /* @__PURE__ */ u((e, t) => {
  const { exists: r, eq: n, neq: o, truthy: a } = e;
  if (ute([r, n, o, a]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: o })}`);
  if (typeof n < "u")
    return (0, rI.isEqual)(t, n);
  if (typeof o < "u")
    return !(0, rI.isEqual)(t, o);
  if (typeof r < "u") {
    const i = typeof t < "u";
    return r ? i : !i;
  }
  return typeof a > "u" || a ? !!t : !t;
}, "testValue"), pCe = /* @__PURE__ */ u((e, t, r) => {
  if (!e.if)
    return !0;
  const { arg: n, global: o } = e.if;
  if (ute([n, o]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: o })}`);
  const a = n ? t[n] : r[o];
  return dCe(e.if, a);
}, "includeConditionalArg"), dte = {};
vp(dte, {
  argsEnhancers: () => mCe
});
var pte = /* @__PURE__ */ u((e, t) => typeof t[e] > "u" && !(e in t), "isInInitialArgs"), fCe = /* @__PURE__ */ u((e) => {
  const {
    initialArgs: t,
    argTypes: r,
    id: n,
    parameters: { actions: o }
  } = e;
  if (!o || o.disable || !o.argTypesRegex || !r)
    return {};
  const a = new RegExp(o.argTypesRegex);
  return Object.entries(r).filter(
    ([i]) => !!a.test(i)
  ).reduce((i, [s, d]) => (pte(s, t) && (i[s] = Eg(s, { implicit: !0, id: n })), i), {});
}, "inferActionsFromArgTypesRegex"), hCe = /* @__PURE__ */ u((e) => {
  const {
    initialArgs: t,
    argTypes: r,
    parameters: { actions: n }
  } = e;
  return n?.disable || !r ? {} : Object.entries(r).filter(([o, a]) => !!a.action).reduce((o, [a, i]) => (pte(a, t) && (o[a] = Eg(typeof i.action == "string" ? i.action : a)), o), {});
}, "addActionsFromArgTypes"), mCe = [
  hCe,
  fCe
], fte = {};
vp(fte, {
  loaders: () => gCe
});
var nI = !1, yCe = /* @__PURE__ */ u((e) => {
  const { parameters: t } = e;
  t?.actions?.disable || nI || (fY((r, n) => {
    const o = r.getMockName();
    o !== "spy" && o !== "vi.fn()" && (!/^next\/.*::/.test(o) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((a) => o.startsWith(a))) && Eg(o)(n);
  }), nI = !0);
}, "logActionsWhenMockCalled"), gCe = [yCe], oI = /* @__PURE__ */ u(() => ({
  ...dte,
  ...fte
}), "default"), { document: Mn } = globalThis, bCe = /* @__PURE__ */ u(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, "isReduceMotionEnabled"), aI = /* @__PURE__ */ u((e) => {
  (Array.isArray(e) ? e : [e]).forEach(vCe);
}, "clearStyles"), vCe = /* @__PURE__ */ u((e) => {
  if (!Mn)
    return;
  const t = Mn.getElementById(e);
  t && t.parentElement && t.parentElement.removeChild(t);
}, "clearStyle"), wCe = /* @__PURE__ */ u((e, t) => {
  if (!Mn)
    return;
  const r = Mn.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    const n = Mn.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, Mn.head.appendChild(n);
  }
}, "addGridStyle"), _Ce = /* @__PURE__ */ u((e, t, r) => {
  if (!Mn)
    return;
  const n = Mn.getElementById(e);
  if (n)
    n.innerHTML !== t && (n.innerHTML = t);
  else {
    const o = Mn.createElement("style");
    o.setAttribute("id", e), o.innerHTML = t;
    const a = `addon-backgrounds-grid${r ? `-docs-${r}` : ""}`, i = Mn.getElementById(a);
    i ? i.parentElement?.insertBefore(o, i) : Mn.head.appendChild(o);
  }
}, "addBackgroundStyle"), ECe = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
}, iI = "addon-backgrounds", sI = "addon-backgrounds-grid", xCe = bCe() ? "" : "transition: background-color 0.3s;", SCe = /* @__PURE__ */ u((e, t) => {
  const { globals: r = {}, parameters: n = {}, viewMode: o, id: a } = t, {
    options: i = r1e,
    disable: s,
    grid: d = ECe
  } = n[zh] || {}, l = r[zh] || {}, p = typeof l == "string" ? l : l?.value, f = p ? i[p] : void 0, h = typeof f == "string" ? f : f?.value || "transparent", m = typeof l == "string" ? !1 : l.grid || !1, g = !!f && !s, w = o === "docs" ? `#anchor--${a} .docs-story` : ".sb-show-main", _ = o === "docs" ? `#anchor--${a} .docs-story` : ".sb-show-main", b = n.layout === void 0 || n.layout === "padded", x = o === "docs" ? 20 : b ? 16 : 0, { cellAmount: P, cellSize: R, opacity: N, offsetX: C = x, offsetY: A = x } = d, E = o === "docs" ? `${iI}-docs-${a}` : `${iI}-color`, T = o === "docs" ? a : null;
  Ss(() => {
    const k = `
    ${w} {
      background: ${h} !important;
      ${xCe}
      }`;
    if (!g) {
      aI(E);
      return;
    }
    _Ce(E, k, T);
  }, [w, E, T, g, h]);
  const O = o === "docs" ? `${sI}-docs-${a}` : `${sI}`;
  return Ss(() => {
    if (!m) {
      aI(O);
      return;
    }
    const k = [
      `${R * P}px ${R * P}px`,
      `${R * P}px ${R * P}px`,
      `${R}px ${R}px`,
      `${R}px ${R}px`
    ].join(", "), M = `
        ${_} {
          background-size: ${k} !important;
          background-position: ${C}px ${A}px, ${C}px ${A}px, ${C}px ${A}px, ${C}px ${A}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${N}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${N}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${N / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${N / 2}) 1px, transparent 1px) !important;
        }
      `;
    wCe(O, M);
  }, [P, R, _, O, m, C, A, N]), e();
}, "withBackgroundAndGrid"), TCe = globalThis.FEATURES?.backgrounds ? [SCe] : [], ACe = {
  [zh]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: !1
  }
}, $Ce = {
  [zh]: { value: void 0, grid: !1 }
}, lI = /* @__PURE__ */ u(() => ({
  decorators: TCe,
  parameters: ACe,
  initialGlobals: $Ce
}), "default"), { step: CCe } = jc(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: /* @__PURE__ */ u(async (e, t, r) => t(r), "step")
  },
  { intercept: !0 }
), cI = /* @__PURE__ */ u(() => ({
  parameters: {
    throwPlayFunctionExceptions: !1
  },
  runStep: CCe
}), "default"), uI = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
}, kCe = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), Yt = /* @__PURE__ */ u((e, t = {}, r) => {
  const n = kCe.includes(e) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e);
  return Object.entries(t).forEach(([o, a]) => {
    /[A-Z]/.test(o) ? (o === "onClick" && (n.addEventListener("click", a), n.addEventListener("keydown", (i) => {
      (i.key === "Enter" || i.key === " ") && (i.preventDefault(), a());
    })), o === "onMouseEnter" && n.addEventListener("mouseenter", a), o === "onMouseLeave" && n.addEventListener("mouseleave", a)) : n.setAttribute(o, a);
  }), r?.forEach((o) => {
    if (!(o == null || o === !1))
      try {
        n.appendChild(o);
      } catch {
        n.appendChild(document.createTextNode(String(o)));
      }
  }), n;
}, "createElement"), Yp = /* @__PURE__ */ u((e) => uI[e] && Yt(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  uI[e].map(
    (t) => Yt("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: t
    })
  )
), "createIcon"), PCe = /* @__PURE__ */ u((e) => {
  if ("elements" in e) {
    const { elements: n, color: o, style: a } = e;
    return {
      id: void 0,
      priority: 0,
      selectors: n,
      styles: {
        outline: `2px ${a} ${o}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  const { menu: t, ...r } = e;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...r,
    menu: Array.isArray(t) ? t.every(Array.isArray) ? t : [t] : void 0
  };
}, "normalizeOptions"), OCe = /* @__PURE__ */ u((e) => e instanceof Function, "isFunction"), du = /* @__PURE__ */ new Map(), Pi = /* @__PURE__ */ new Map(), Xp = /* @__PURE__ */ new Map(), No = /* @__PURE__ */ u((e) => {
  const t = Symbol();
  return Pi.set(t, []), du.set(t, e), { get: /* @__PURE__ */ u(() => du.get(t), "get"), set: /* @__PURE__ */ u((r) => {
    const n = du.get(t), o = OCe(r) ? r(n) : r;
    o !== n && (du.set(t, o), Pi.get(t)?.forEach((a) => {
      Xp.get(a)?.(), Xp.set(a, a(o));
    }));
  }, "set"), subscribe: /* @__PURE__ */ u((r) => (Pi.get(t)?.push(r), () => {
    const n = Pi.get(t);
    n && Pi.set(
      t,
      n.filter((o) => o !== r)
    );
  }), "subscribe"), teardown: /* @__PURE__ */ u(() => {
    Pi.get(t)?.forEach((r) => {
      Xp.get(r)?.(), Xp.delete(r);
    }), Pi.delete(t), du.delete(t);
  }, "teardown") };
}, "useStore"), dI = /* @__PURE__ */ u((e) => {
  const t = document.getElementById("storybook-root"), r = /* @__PURE__ */ new Map();
  for (const n of e) {
    const { priority: o = 0 } = n;
    for (const a of n.selectors) {
      const i = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${a}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...t?.querySelectorAll(a) || []
      ];
      for (const s of i) {
        const d = r.get(s);
        (!d || d.priority <= o) && r.set(s, {
          ...n,
          priority: o,
          selectors: Array.from(new Set((d?.selectors || []).concat(a)))
        });
      }
    }
  }
  return r;
}, "mapElements"), RCe = /* @__PURE__ */ u((e) => Array.from(e.entries()).map(([t, { selectors: r, styles: n, hoverStyles: o, focusStyles: a, menu: i }]) => {
  const { top: s, left: d, width: l, height: p } = t.getBoundingClientRect(), { position: f } = getComputedStyle(t);
  return {
    element: t,
    selectors: r,
    styles: n,
    hoverStyles: o,
    focusStyles: a,
    menu: i,
    top: f === "fixed" ? s : s + window.scrollY,
    left: f === "fixed" ? d : d + window.scrollX,
    width: l,
    height: p
  };
}).sort((t, r) => r.width * r.height - t.width * t.height), "mapBoxes"), pI = /* @__PURE__ */ u((e, t) => {
  const r = e.getBoundingClientRect(), { x: n, y: o } = t;
  return r?.top && r?.left && n >= r.left && n <= r.left + r.width && o >= r.top && o <= r.top + r.height;
}, "isOverMenu"), fI = /* @__PURE__ */ u((e, t, r) => {
  if (!t || !r)
    return !1;
  let { left: n, top: o, width: a, height: i } = e;
  i < Ta && (o = o - Math.round((Ta - i) / 2), i = Ta), a < Ta && (n = n - Math.round((Ta - a) / 2), a = Ta), t.style.position === "fixed" && (n += window.scrollX, o += window.scrollY);
  const { x: s, y: d } = r;
  return s >= n && s <= n + a && d >= o && d <= o + i;
}, "isTargeted"), jCe = /* @__PURE__ */ u((e, t, r = {}) => {
  const { x: n, y: o } = t, { margin: a = 5, topOffset: i = 0, centered: s = !1 } = r, { scrollX: d, scrollY: l, innerHeight: p, innerWidth: f } = window, h = Math.min(
    e.style.position === "fixed" ? o - l : o,
    p - e.clientHeight - a - i + l
  ), m = s ? e.clientWidth / 2 : 0, g = e.style.position === "fixed" ? Math.max(Math.min(n - d, f - m - a), m + a) : Math.max(
    Math.min(n, f - m - a + d),
    m + a + d
  );
  Object.assign(e.style, {
    ...g !== n && { left: `${g}px` },
    ...h !== o && { top: `${h}px` }
  });
}, "keepInViewport"), hI = /* @__PURE__ */ u((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.showPopover();
}, "showPopover"), ICe = /* @__PURE__ */ u((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.hidePopover();
}, "hidePopover"), NCe = /* @__PURE__ */ u((e) => ({
  top: e.top,
  left: e.left,
  width: e.width,
  height: e.height,
  selectors: e.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(e.element.attributes).map((t) => [t.name, t.value])
    ),
    localName: e.element.localName,
    tagName: e.element.tagName,
    outerHTML: e.element.outerHTML
  }
}), "getEventDetails"), ht = "storybook-highlights-menu", mI = "storybook-highlights-root", MCe = "storybook-root", DCe = /* @__PURE__ */ u((e) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
  const { document: t } = globalThis, r = No([]), n = No(/* @__PURE__ */ new Map()), o = No([]), a = No(), i = No(), s = No([]), d = No([]), l = No(), p = No();
  let f = t.getElementById(mI);
  r.subscribe(() => {
    f || (f = Yt("div", { id: mI }), t.body.appendChild(f));
  }), r.subscribe((A) => {
    const E = t.getElementById(MCe);
    if (!E)
      return;
    n.set(dI(A));
    const T = new MutationObserver(() => n.set(dI(A)));
    return T.observe(E, { subtree: !0, childList: !0 }), () => {
      T.disconnect();
    };
  }), n.subscribe((A) => {
    const E = /* @__PURE__ */ u(() => requestAnimationFrame(() => o.set(RCe(A))), "updateBoxes"), T = new ResizeObserver(E);
    T.observe(t.body), Array.from(A.keys()).forEach((k) => T.observe(k));
    const O = Array.from(t.body.querySelectorAll("*")).filter((k) => {
      const { overflow: M, overflowX: L, overflowY: $ } = window.getComputedStyle(k);
      return ["auto", "scroll"].some((I) => [M, L, $].includes(I));
    });
    return O.forEach((k) => k.addEventListener("scroll", E)), () => {
      T.disconnect(), O.forEach((k) => k.removeEventListener("scroll", E));
    };
  }), n.subscribe((A) => {
    const E = Array.from(A.keys()).filter(({ style: O }) => O.position === "sticky"), T = /* @__PURE__ */ u(() => requestAnimationFrame(() => {
      o.set(
        (O) => O.map((k) => {
          if (E.includes(k.element)) {
            const { top: M, left: L } = k.element.getBoundingClientRect();
            return { ...k, top: M + window.scrollY, left: L + window.scrollX };
          }
          return k;
        })
      );
    }), "updateBoxes");
    return t.addEventListener("scroll", T), () => t.removeEventListener("scroll", T);
  }), n.subscribe((A) => {
    s.set((E) => E.filter(({ element: T }) => A.has(T)));
  }), s.subscribe((A) => {
    A.length ? (p.set((E) => A.some((T) => T.element === E?.element) ? E : void 0), l.set((E) => A.some((T) => T.element === E?.element) ? E : void 0)) : (p.set(void 0), l.set(void 0), a.set(void 0));
  });
  const h = new Map(/* @__PURE__ */ new Map());
  r.subscribe((A) => {
    A.forEach(({ keyframes: E }) => {
      if (E) {
        let T = h.get(E);
        T || (T = t.createElement("style"), T.setAttribute("data-highlight", "keyframes"), h.set(E, T), t.head.appendChild(T)), T.innerHTML = E;
      }
    }), h.forEach((E, T) => {
      A.some((O) => O.keyframes === T) || (E.remove(), h.delete(T));
    });
  });
  const m = new Map(/* @__PURE__ */ new Map());
  o.subscribe((A) => {
    A.forEach((E) => {
      let T = m.get(E.element);
      if (f && !T) {
        const O = {
          popover: "manual",
          "data-highlight-dimensions": `w${E.width.toFixed(0)}h${E.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${E.left.toFixed(0)}y${E.top.toFixed(0)}`
        };
        T = f.appendChild(
          Yt("div", O, [Yt("div")])
        ), m.set(E.element, T);
      }
    }), m.forEach((E, T) => {
      A.some(({ element: O }) => O === T) || (E.remove(), m.delete(T));
    });
  }), o.subscribe((A) => {
    const E = A.filter((O) => O.menu);
    if (!E.length)
      return;
    const T = /* @__PURE__ */ u((O) => {
      requestAnimationFrame(() => {
        const k = t.getElementById(ht), M = { x: O.pageX, y: O.pageY };
        if (k && !pI(k, M)) {
          const L = E.filter(($) => {
            const I = m.get($.element);
            return fI($, I, M);
          });
          a.set(L.length ? M : void 0), s.set(L);
        }
      });
    }, "onClick");
    return t.addEventListener("click", T), () => t.removeEventListener("click", T);
  });
  const g = /* @__PURE__ */ u(() => {
    const A = t.getElementById(ht), E = i.get();
    !E || A && pI(A, E) || d.set((T) => {
      const O = o.get().filter(($) => {
        const I = m.get($.element);
        return fI($, I, E);
      }), k = T.filter(($) => O.includes($)), M = O.filter(($) => !T.includes($)), L = T.length - k.length;
      return M.length || L ? [...k, ...M] : T;
    });
  }, "updateHovered");
  i.subscribe(g), o.subscribe(g);
  const w = /* @__PURE__ */ u(() => {
    const A = p.get(), E = A ? [A] : s.get(), T = E.length === 1 ? E[0] : l.get(), O = a.get() !== void 0;
    o.get().forEach((k) => {
      const M = m.get(k.element);
      if (M) {
        const L = T === k, $ = O ? T ? L : E.includes(k) : d.get()?.includes(k);
        Object.assign(M.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...k.styles,
          ...$ ? k.hoverStyles : {},
          ...L ? k.focusStyles : {},
          position: getComputedStyle(k.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: ZR - 10,
          top: `${k.top}px`,
          left: `${k.left}px`,
          width: `${k.width}px`,
          height: `${k.height}px`,
          margin: 0,
          padding: 0,
          cursor: k.menu && $ ? "pointer" : "default",
          pointerEvents: k.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(M.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${Ta}px`,
          minWidth: `${Ta}px`,
          boxSizing: "content-box",
          padding: M.style.outlineWidth || "0px"
        }), hI(M);
      }
    });
  }, "updateBoxStyles");
  o.subscribe(w), s.subscribe(w), d.subscribe(w), l.subscribe(w), p.subscribe(w);
  const _ = /* @__PURE__ */ u(() => {
    if (!f)
      return;
    let A = t.getElementById(ht);
    if (A)
      A.innerHTML = "";
    else {
      const k = { id: ht, popover: "manual" };
      A = f.appendChild(Yt("div", k)), f.appendChild(
        Yt("style", {}, [
          `
            #${ht} {
              position: absolute;
              z-index: ${ZR};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${ht} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${ht} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${ht} li {
              padding: 0 4px;
              margin: 0;
            }
            #${ht} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${ht} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${ht} button:focus-visible {
              outline-color: #029CFD;
            }
            #${ht} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${ht} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${ht} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${ht} li > button:hover svg, #${ht} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${ht} .element-list li svg {
              display: none;
            }
            #${ht} li.selectable svg, #${ht} li.selected svg {
              display: block;
            }
            #${ht} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${ht} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${ht} .menu-items, #${ht} .menu-items li {
              padding: 0;
            }
            #${ht} .menu-item {
              display: flex;
            }
            #${ht} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    const E = p.get(), T = E ? [E] : s.get();
    if (T.length && (A.style.position = getComputedStyle(T[0].element).position === "fixed" ? "fixed" : "absolute", A.appendChild(
      Yt(
        "ul",
        { class: "element-list" },
        T.map((k) => {
          const M = T.length > 1 && !!k.menu?.some(
            (I) => I.some(
              (D) => !D.selectors || D.selectors.some((F) => k.selectors.includes(F))
            )
          ), L = M ? {
            class: "selectable",
            onClick: /* @__PURE__ */ u(() => p.set(k), "onClick"),
            onMouseEnter: /* @__PURE__ */ u(() => l.set(k), "onMouseEnter"),
            onMouseLeave: /* @__PURE__ */ u(() => l.set(void 0), "onMouseLeave")
          } : E ? { class: "selected", onClick: /* @__PURE__ */ u(() => p.set(void 0), "onClick") } : {}, $ = M || E;
          return Yt("li", L, [
            Yt($ ? "button" : "div", $ ? { type: "button" } : {}, [
              E ? Yp("chevronLeft") : null,
              Yt("code", {}, [k.element.outerHTML]),
              M ? Yp("chevronRight") : null
            ])
          ]);
        })
      )
    )), p.get() || s.get().length === 1) {
      const k = p.get() || s.get()[0], M = k.menu?.filter(
        (L) => L.some(
          ($) => !$.selectors || $.selectors.some((I) => k.selectors.includes(I))
        )
      );
      M?.length && A.appendChild(
        Yt(
          "ul",
          { class: "menu-list" },
          M.map(
            (L) => Yt("li", {}, [
              Yt(
                "ul",
                { class: "menu-items" },
                L.map(
                  ({ id: $, title: I, description: D, iconLeft: F, iconRight: J, clickEvent: oe }) => {
                    const ce = oe && (() => e.emit(oe, $, NCe(k)));
                    return Yt("li", {}, [
                      Yt(
                        ce ? "button" : "div",
                        ce ? { class: "menu-item", type: "button", onClick: ce } : { class: "menu-item" },
                        [
                          F ? Yp(F) : null,
                          Yt("div", { class: "menu-item-content" }, [
                            Yt(D ? "strong" : "span", {}, [I]),
                            D && Yt("span", {}, [D])
                          ]),
                          J ? Yp(J) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    const O = a.get();
    O ? (Object.assign(A.style, {
      display: "block",
      left: `${A.style.position === "fixed" ? O.x - window.scrollX : O.x}px`,
      top: `${A.style.position === "fixed" ? O.y - window.scrollY : O.y}px`
    }), hI(A), requestAnimationFrame(() => jCe(A, O, { topOffset: 15, centered: !0 }))) : (ICe(A), Object.assign(A.style, { display: "none" }));
  }, "renderMenu");
  s.subscribe(_), p.subscribe(_);
  const b = /* @__PURE__ */ u((A) => {
    const E = PCe(A);
    r.set((T) => {
      const O = E.id ? T.filter((k) => k.id !== E.id) : T;
      return E.selectors?.length ? [...O, E] : O;
    });
  }, "addHighlight"), x = /* @__PURE__ */ u((A) => {
    A && r.set((E) => E.filter((T) => T.id !== A));
  }, "removeHighlight"), P = /* @__PURE__ */ u(() => {
    r.set([]), n.set(/* @__PURE__ */ new Map()), o.set([]), a.set(void 0), i.set(void 0), s.set([]), d.set([]), l.set(void 0), p.set(void 0);
  }, "resetState");
  let R;
  const N = /* @__PURE__ */ u((A, E) => {
    const T = "scrollIntoView-highlight";
    clearTimeout(R), x(T);
    const O = t.querySelector(A);
    if (!O) {
      console.warn(`Cannot scroll into view: ${A} not found`);
      return;
    }
    O.scrollIntoView({ behavior: "smooth", block: "center", ...E });
    const k = `kf-${Math.random().toString(36).substring(2, 15)}`;
    r.set((M) => [
      ...M,
      {
        id: T,
        priority: 1e3,
        selectors: [A],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${k} 3s linear forwards`
        },
        keyframes: `@keyframes ${k} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), R = setTimeout(() => x(T), 3500);
  }, "scrollIntoView"), C = /* @__PURE__ */ u((A) => {
    requestAnimationFrame(() => i.set({ x: A.pageX, y: A.pageY }));
  }, "onMouseMove");
  t.body.addEventListener("mousemove", C), e.on(n1e, b), e.on(o1e, x), e.on(a1e, P), e.on(i1e, N), e.on(ys, ({ newPhase: A }) => {
    A === "loading" && P();
  });
}, "useHighlights");
globalThis?.FEATURES?.highlight && Bn?.ready && Bn.ready().then(DCe);
var yI = /* @__PURE__ */ u(() => ({}), "default");
function lP() {
  const e = xe.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
u(lP, "getDocumentWidthAndHeight");
function hte() {
  const e = xe.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  const t = e.getContext("2d");
  uo(t != null);
  const { width: r, height: n } = lP();
  return km(e, t, { width: r, height: n }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "2147483647", e.style.pointerEvents = "none", xe.document.body.appendChild(e), { canvas: e, context: t, width: r, height: n };
}
u(hte, "createCanvas");
function km(e, t, { width: r, height: n }) {
  e.style.width = `${r}px`, e.style.height = `${n}px`;
  const o = xe.window.devicePixelRatio;
  e.width = Math.floor(r * o), e.height = Math.floor(n * o), t.scale(o, o);
}
u(km, "setCanvasWidthAndHeight");
var Qt = {};
function mte() {
  Qt.canvas || (Qt = hte());
}
u(mte, "init");
function cP() {
  Qt.context && Qt.context.clearRect(0, 0, Qt.width ?? 0, Qt.height ?? 0);
}
u(cP, "clear");
function yte(e) {
  cP(), e(Qt.context);
}
u(yte, "draw");
function gte() {
  uo(Qt.canvas), uo(Qt.context), km(Qt.canvas, Qt.context, { width: 0, height: 0 });
  const { width: e, height: t } = lP();
  km(Qt.canvas, Qt.context, { width: e, height: t }), Qt.width = e, Qt.height = t;
}
u(gte, "rescale");
function bte() {
  Qt.canvas && (cP(), Qt.canvas.parentNode?.removeChild(Qt.canvas), Qt = {});
}
u(bte, "destroy");
var Js = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, Zo = 6;
function U1(e, { x: t, y: r, w: n, h: o, r: a }) {
  t = t - n / 2, r = r - o / 2, n < 2 * a && (a = n / 2), o < 2 * a && (a = o / 2), e.beginPath(), e.moveTo(t + a, r), e.arcTo(t + n, r, t + n, r + o, a), e.arcTo(t + n, r + o, t, r + o, a), e.arcTo(t, r + o, t, r, a), e.arcTo(t, r, t + n, r, a), e.closePath();
}
u(U1, "roundedRect");
function vte(e, { padding: t, border: r, width: n, height: o, top: a, left: i }) {
  const s = n - r.left - r.right - t.left - t.right, d = o - t.top - t.bottom - r.top - r.bottom;
  let l = i + r.left + t.left, p = a + r.top + t.top;
  return e === "top" ? l += s / 2 : e === "right" ? (l += s, p += d / 2) : e === "bottom" ? (l += s / 2, p += d) : e === "left" ? p += d / 2 : e === "center" && (l += s / 2, p += d / 2), { x: l, y: p };
}
u(vte, "positionCoordinate");
function wte(e, t, { margin: r, border: n, padding: o }, a, i) {
  let s = /* @__PURE__ */ u((h) => 0, "shift"), d = 0, l = 0;
  const p = i ? 1 : 0.5, f = i ? a * 2 : 0;
  return e === "padding" ? s = /* @__PURE__ */ u((h) => o[h] * p + f, "shift") : e === "border" ? s = /* @__PURE__ */ u((h) => o[h] + n[h] * p + f, "shift") : e === "margin" && (s = /* @__PURE__ */ u((h) => o[h] + n[h] + r[h] * p + f, "shift")), t === "top" ? l = -s("top") : t === "right" ? d = s("right") : t === "bottom" ? l = s("bottom") : t === "left" && (d = -s("left")), { offsetX: d, offsetY: l };
}
u(wte, "offset");
function _te(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
u(_te, "collide");
function Ete(e, t, r) {
  return e === "top" ? t.y = r.y - r.h - Zo : e === "right" ? t.x = r.x + r.w / 2 + Zo + t.w / 2 : e === "bottom" ? t.y = r.y + r.h + Zo : e === "left" && (t.x = r.x - r.w / 2 - Zo - t.w / 2), { x: t.x, y: t.y };
}
u(Ete, "overlapAdjustment");
function uP(e, t, { x: r, y: n, w: o, h: a }, i) {
  return U1(e, { x: r, y: n, w: o, h: a, r: 3 }), e.fillStyle = `${Js[t]}dd`, e.fill(), e.strokeStyle = Js[t], e.stroke(), e.fillStyle = Js.text, e.fillText(i, r, n), U1(e, { x: r, y: n, w: o, h: a, r: 3 }), e.fillStyle = `${Js[t]}dd`, e.fill(), e.strokeStyle = Js[t], e.stroke(), e.fillStyle = Js.text, e.fillText(i, r, n), { x: r, y: n, w: o, h: a };
}
u(uP, "textWithRect");
function dP(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  const r = e.measureText(t), n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent, o = r.width + Zo * 2, a = n + Zo * 2;
  return { w: o, h: a };
}
u(dP, "configureText");
function xte(e, t, { type: r, position: n = "center", text: o }, a, i = !1) {
  let { x: s, y: d } = vte(n, t);
  const { offsetX: l, offsetY: p } = wte(r, n, t, Zo + 1, i);
  s += l, d += p;
  const { w: f, h } = dP(e, o);
  if (a && _te({ x: s, y: d, w: f, h }, a)) {
    const m = Ete(n, { x: s, y: d, w: f }, a);
    s = m.x, d = m.y;
  }
  return uP(e, r, { x: s, y: d, w: f, h }, o);
}
u(xte, "drawLabel");
function Ste(e, { w: t, h: r }) {
  const n = t * 0.5 + Zo, o = r * 0.5 + Zo;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * n,
    offsetY: (e.y === "top" ? -1 : 1) * o
  };
}
u(Ste, "floatingOffset");
function Tte(e, t, { type: r, text: n }) {
  const { floatingAlignment: o, extremities: a } = t;
  let i = a[o.x], s = a[o.y];
  const { w: d, h: l } = dP(e, n), { offsetX: p, offsetY: f } = Ste(o, {
    w: d,
    h: l
  });
  return i += p, s += f, uP(e, r, { x: i, y: s, w: d, h: l }, n);
}
u(Tte, "drawFloatingLabel");
function nl(e, t, r, n) {
  const o = [];
  r.forEach((a, i) => {
    const s = n && a.position === "center" ? Tte(e, t, a) : xte(e, t, a, o[i - 1], n);
    o[i] = s;
  });
}
u(nl, "drawStack");
function Ate(e, t, r, n) {
  const o = r.reduce((a, i) => (Object.prototype.hasOwnProperty.call(a, i.position) || (a[i.position] = []), a[i.position]?.push(i), a), {});
  o.top && nl(e, t, o.top, n), o.right && nl(e, t, o.right, n), o.bottom && nl(e, t, o.bottom, n), o.left && nl(e, t, o.left, n), o.center && nl(e, t, o.center, n);
}
u(Ate, "labelStacks");
var jb = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, gI = 30;
function Ur(e) {
  return parseInt(e.replace("px", ""), 10);
}
u(Ur, "pxToNumber");
function Ji(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
u(Ji, "round");
function Ib(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
u(Ib, "filterZeroValues");
function $te(e) {
  const t = {
    top: xe.window.scrollY,
    bottom: xe.window.scrollY + xe.window.innerHeight,
    left: xe.window.scrollX,
    right: xe.window.scrollX + xe.window.innerWidth
  }, r = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: r.left > r.right ? "left" : "right",
    y: r.top > r.bottom ? "top" : "bottom"
  };
}
u($te, "floatingAlignment");
function Cte(e) {
  const t = xe.getComputedStyle(e);
  let { top: r, left: n, right: o, bottom: a, width: i, height: s } = e.getBoundingClientRect();
  const {
    marginTop: d,
    marginBottom: l,
    marginLeft: p,
    marginRight: f,
    paddingTop: h,
    paddingBottom: m,
    paddingLeft: g,
    paddingRight: w,
    borderBottomWidth: _,
    borderTopWidth: b,
    borderLeftWidth: x,
    borderRightWidth: P
  } = t;
  r = r + xe.window.scrollY, n = n + xe.window.scrollX, a = a + xe.window.scrollY, o = o + xe.window.scrollX;
  const R = {
    top: Ur(d),
    bottom: Ur(l),
    left: Ur(p),
    right: Ur(f)
  }, N = {
    top: Ur(h),
    bottom: Ur(m),
    left: Ur(g),
    right: Ur(w)
  }, C = {
    top: Ur(b),
    bottom: Ur(_),
    left: Ur(x),
    right: Ur(P)
  }, A = {
    top: r - R.top,
    bottom: a + R.bottom,
    left: n - R.left,
    right: o + R.right
  };
  return {
    margin: R,
    padding: N,
    border: C,
    top: r,
    left: n,
    bottom: a,
    right: o,
    width: i,
    height: s,
    extremities: A,
    floatingAlignment: $te(A)
  };
}
u(Cte, "measureElement");
function kte(e, { margin: t, width: r, height: n, top: o, left: a, bottom: i, right: s }) {
  const d = n + t.bottom + t.top;
  e.fillStyle = jb.margin, e.fillRect(a, o - t.top, r, t.top), e.fillRect(s, o - t.top, t.right, d), e.fillRect(a, i, r, t.bottom), e.fillRect(a - t.left, o - t.top, t.left, d);
  const l = [
    {
      type: "margin",
      text: Ji(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: Ji(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: Ji(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: Ji(t.left),
      position: "left"
    }
  ];
  return Ib(l);
}
u(kte, "drawMargin");
function Pte(e, { padding: t, border: r, width: n, height: o, top: a, left: i, bottom: s, right: d }) {
  const l = n - r.left - r.right, p = o - t.top - t.bottom - r.top - r.bottom;
  e.fillStyle = jb.padding, e.fillRect(i + r.left, a + r.top, l, t.top), e.fillRect(
    d - t.right - r.right,
    a + t.top + r.top,
    t.right,
    p
  ), e.fillRect(
    i + r.left,
    s - t.bottom - r.bottom,
    l,
    t.bottom
  ), e.fillRect(i + r.left, a + t.top + r.top, t.left, p);
  const f = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return Ib(f);
}
u(Pte, "drawPadding");
function Ote(e, { border: t, width: r, height: n, top: o, left: a, bottom: i, right: s }) {
  const d = n - t.top - t.bottom;
  e.fillStyle = jb.border, e.fillRect(a, o, r, t.top), e.fillRect(a, i - t.bottom, r, t.bottom), e.fillRect(a, o + t.top, t.left, d), e.fillRect(s - t.right, o + t.top, t.right, d);
  const l = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return Ib(l);
}
u(Ote, "drawBorder");
function Rte(e, { padding: t, border: r, width: n, height: o, top: a, left: i }) {
  const s = n - r.left - r.right - t.left - t.right, d = o - t.top - t.bottom - r.top - r.bottom;
  return e.fillStyle = jb.content, e.fillRect(
    i + r.left + t.left,
    a + r.top + t.top,
    s,
    d
  ), [
    {
      type: "content",
      position: "center",
      text: `${Ji(s)} x ${Ji(d)}`
    }
  ];
}
u(Rte, "drawContent");
function jte(e) {
  return (t) => {
    if (e && t) {
      const r = Cte(e), n = kte(t, r), o = Pte(t, r), a = Ote(t, r), i = Rte(t, r), s = r.width <= gI * 3 || r.height <= gI;
      Ate(
        t,
        r,
        [...i, ...o, ...a, ...n],
        s
      );
    }
  };
}
u(jte, "drawBoxModel");
function Ite(e) {
  yte(jte(e));
}
u(Ite, "drawSelectedElement");
var qCe = /* @__PURE__ */ u((e, t) => {
  const r = xe.document.elementFromPoint(e, t), n = /* @__PURE__ */ u((o) => {
    if (o && o.shadowRoot) {
      const a = o.shadowRoot.elementFromPoint(e, t);
      return o.isEqualNode(a) ? o : a.shadowRoot ? n(a) : a;
    }
    return o;
  }, "crawlShadows");
  return n(r) || r;
}, "deepElementFromPoint"), bI, Qp = { x: 0, y: 0 };
function B1(e, t) {
  bI = qCe(e, t), Ite(bI);
}
u(B1, "findAndDrawElement");
var LCe = /* @__PURE__ */ u((e, t) => {
  const { measureEnabled: r } = t.globals || {};
  return Ss(() => {
    if (typeof globalThis.document > "u")
      return;
    const n = /* @__PURE__ */ u((o) => {
      window.requestAnimationFrame(() => {
        o.stopPropagation(), Qp.x = o.clientX, Qp.y = o.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", n), () => {
      globalThis.document.removeEventListener("pointermove", n);
    };
  }, []), Ss(() => {
    const n = /* @__PURE__ */ u((a) => {
      window.requestAnimationFrame(() => {
        a.stopPropagation(), B1(a.clientX, a.clientY);
      });
    }, "onPointerOver"), o = /* @__PURE__ */ u(() => {
      window.requestAnimationFrame(() => {
        gte();
      });
    }, "onResize");
    return t.viewMode === "story" && r && (globalThis.document.addEventListener("pointerover", n), mte(), globalThis.window.addEventListener("resize", o), B1(Qp.x, Qp.y)), () => {
      globalThis.window.removeEventListener("resize", o), bte();
    };
  }, [r, t.viewMode]), e();
}, "withMeasure"), FCe = globalThis.FEATURES?.measure ? [LCe] : [], UCe = {
  [t1e]: !1
}, vI = /* @__PURE__ */ u(() => ({
  decorators: FCe,
  initialGlobals: UCe
}), "default"), wI = /* @__PURE__ */ u((e) => {
  (Array.isArray(e) ? e : [e]).forEach(BCe);
}, "clearStyles"), BCe = /* @__PURE__ */ u((e) => {
  const t = typeof e == "string" ? e : e.join(""), r = xe.document.getElementById(t);
  r && r.parentElement && r.parentElement.removeChild(r);
}, "clearStyle"), HCe = /* @__PURE__ */ u((e, t) => {
  const r = xe.document.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    const n = xe.document.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, xe.document.head.appendChild(n);
  }
}, "addOutlineStyles");
function Nte(e) {
  return Be`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
u(Nte, "outlineCSS");
var VCe = /* @__PURE__ */ u((e, t) => {
  const r = t.globals || {}, n = [!0, "true"].includes(r[WW]), o = t.viewMode === "docs", a = Wte(() => Nte(o ? '[data-story-block="true"]' : ".sb-show-main"), [t]);
  return Ss(() => {
    const i = o ? `addon-outline-docs-${t.id}` : "addon-outline";
    return n ? HCe(i, a) : wI(i), () => {
      wI(i);
    };
  }, [n, a, t]), e();
}, "withOutline"), zCe = globalThis.FEATURES?.outline ? [VCe] : [], JCe = {
  [WW]: !1
}, _I = /* @__PURE__ */ u(() => ({ decorators: zCe, initialGlobals: JCe }), "default"), WCe = /* @__PURE__ */ u(({ parameters: e }) => {
  e?.test?.mockReset === !0 ? gY() : e?.test?.clearMocks === !0 ? yY() : e?.test?.restoreMocks !== !1 && bY();
}, "resetAllMocksLoader"), H1 = /* @__PURE__ */ u((e, t = 0, r) => {
  if (t > 5 || e == null)
    return e;
  if (Al(e))
    return r && e.mockName(r), e;
  if (typeof e == "function" && "isAction" in e && e.isAction && !("implicit" in e && e.implicit)) {
    const n = hY(e);
    return r && n.mockName(r), n;
  }
  if (Array.isArray(e)) {
    t++;
    for (let n = 0; n < e.length; n++)
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = H1(e[n], t));
    return e;
  }
  if (typeof e == "object" && e.constructor === Object) {
    t++;
    for (const [n, o] of Object.entries(e))
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = H1(o, t, n));
    return e;
  }
  return e;
}, "traverseArgs"), GCe = /* @__PURE__ */ u(({ initialArgs: e }) => {
  H1(e);
}, "nameSpiesAndWrapActionsInSpies"), EI = !1, KCe = /* @__PURE__ */ u(async (e) => {
  globalThis.HTMLElement && e.canvasElement instanceof globalThis.HTMLElement && (e.canvas = lCe(e.canvasElement));
  const t = globalThis.window?.navigator?.clipboard;
  if (t && (e.userEvent = jc(
    { userEvent: cCe.setup() },
    {
      intercept: !0,
      getKeys: /* @__PURE__ */ u((r) => Object.keys(r).filter((n) => n !== "eventWrapper"), "getKeys")
    }
  ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
    get: /* @__PURE__ */ u(() => t, "get"),
    configurable: !0
  }), !EI)) {
    const r = HTMLElement.prototype.focus;
    let n = HTMLElement.prototype.focus;
    const o = /* @__PURE__ */ new Set();
    Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: !0,
        set: /* @__PURE__ */ u((a) => {
          n = a;
        }, "set"),
        get() {
          return o.has(this) ? r : (o.add(this), setTimeout(() => o.delete(this), 0), n);
        }
      }
    }), EI = !0;
  }
}, "enhanceContext"), xI = /* @__PURE__ */ u(() => ({
  loaders: [WCe, GCe, KCe]
}), "default"), YCe = {
  [p1e]: { value: void 0, isRotated: !1 }
}, SI = /* @__PURE__ */ u(() => ({
  initialGlobals: YCe
}), "default");
function Nb() {
  return [
    // @ts-expect-error CJS fallback
    (vI.default ?? vI)(),
    // @ts-expect-error CJS fallback
    (lI.default ?? lI)(),
    // @ts-expect-error CJS fallback
    (yI.default ?? yI)(),
    // @ts-expect-error CJS fallback
    (_I.default ?? _I)(),
    // @ts-expect-error CJS fallback
    (SI.default ?? SI)(),
    // @ts-expect-error CJS fallback
    (oI.default ?? oI)(),
    // @ts-expect-error CJS fallback
    (cI.default ?? cI)(),
    // @ts-expect-error CJS fallback
    (xI.default ?? xI)()
  ];
}
u(Nb, "getCoreAnnotations");
function XCe(e) {
  let t;
  const r = {
    _tag: "Preview",
    input: e,
    get composed() {
      if (t)
        return t;
      const { addons: n, ...o } = e;
      return t = Xd(
        Ts([...Nb(), ...n ?? [], o])
      ), t;
    },
    meta(n) {
      return Dte(n, this);
    }
  };
  return globalThis.globalProjectAnnotations = r.composed, r;
}
u(XCe, "definePreview");
function QCe(e) {
  return e;
}
u(QCe, "definePreviewAddon");
function ZCe(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Preview";
}
u(ZCe, "isPreview");
function Mte(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Meta";
}
u(Mte, "isMeta");
function Dte(e, t) {
  return {
    _tag: "Meta",
    input: e,
    preview: t,
    // @ts-expect-error hard
    story(r = {}) {
      return pP(typeof r == "function" ? { render: r } : r, this);
    }
  };
}
u(Dte, "defineMeta");
function Mb(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Story";
}
u(Mb, "isStory");
function pP(e, t) {
  let r;
  const n = /* @__PURE__ */ u(() => (r || (r = wP(
    e,
    t.input,
    void 0,
    t.preview.composed
  )), r), "compose"), o = [];
  return {
    _tag: "Story",
    input: e,
    meta: t,
    // @ts-expect-error this is a private property used only once in renderers/react/src/preview
    __compose: n,
    __children: o,
    get composed() {
      const a = n(), { args: i, argTypes: s, parameters: d, id: l, tags: p, globals: f, storyName: h } = a;
      return { args: i, argTypes: s, parameters: d, id: l, tags: p, name: h, globals: f };
    },
    get play() {
      return e.play ?? t.input?.play ?? (async () => {
      });
    },
    async run(a) {
      await n().run(a);
    },
    test(a, i, s) {
      const d = typeof i != "function" ? i : {}, l = typeof i != "function" ? s : i, p = Im(this.play) || Im(l) ? async ({ context: h }) => {
        await this.play?.(h), await l(h);
      } : async (h) => {
        await this.play?.(h), await l(h);
      }, f = this.extend({
        ...d,
        name: a,
        tags: ["test-fn", "!autodocs", ...d.tags ?? []],
        play: p
      });
      return o.push(f), f;
    },
    extend(a) {
      return pP(
        {
          ...this.input,
          ...a,
          args: { ...this.input.args || {}, ...a.args },
          argTypes: Ka(this.input.argTypes, a.argTypes),
          afterEach: [
            ...Ye(this.input?.afterEach ?? []),
            ...Ye(a.afterEach ?? [])
          ],
          beforeEach: [
            ...Ye(this.input?.beforeEach ?? []),
            ...Ye(a.beforeEach ?? [])
          ],
          decorators: [
            ...Ye(this.input?.decorators ?? []),
            ...Ye(a.decorators ?? [])
          ],
          globals: { ...this.input.globals, ...a.globals },
          loaders: [
            ...Ye(this.input?.loaders ?? []),
            ...Ye(a.loaders ?? [])
          ],
          parameters: Ka(this.input.parameters, a.parameters),
          tags: Fte(...this.input.tags ?? [], ...a.tags ?? [])
        },
        this.meta
      );
    }
  };
}
u(pP, "defineStory");
function qte(e) {
  return "__children" in e ? e.__children : [];
}
u(qte, "getStoryChildren");
var Lte = /* @__PURE__ */ u((e) => e.toLowerCase().replace(/[ â€™â€“â€”â€•â€²Â¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), "sanitize"), V1 = /* @__PURE__ */ u((e, t) => {
  const r = Lte(e);
  if (r === "")
    throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
  return r;
}, "sanitizeSafe"), eke = /* @__PURE__ */ u((e, t) => `${V1(e, "kind")}${t ? `--${V1(t, "name")}` : ""}`, "toId"), tke = /* @__PURE__ */ u((e, t) => `${e}:${V1(t, "test")}`, "toTestId"), rke = /* @__PURE__ */ u((e) => cte(e), "storyNameFromExport");
function z1(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
u(z1, "matches");
function Pm(e, { includeStories: t, excludeStories: r }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    e !== "__esModule" && (!t || z1(e, t)) && (!r || !z1(e, r))
  );
}
u(Pm, "isExportStory");
var Fte = /* @__PURE__ */ u((...e) => {
  const t = e.reduce((r, n) => (n.startsWith("!") ? r.delete(n.slice(1)) : r.add(n), r), /* @__PURE__ */ new Set());
  return Array.from(t);
}, "combineTags");
function Ute() {
  const e = {
    setHandler: /* @__PURE__ */ u(() => {
    }, "setHandler"),
    send: /* @__PURE__ */ u(() => {
    }, "send")
  };
  return new VW({ transport: e });
}
u(Ute, "mockChannel");
var Bte = class {
  constructor() {
    this.getChannel = /* @__PURE__ */ u(() => {
      if (!this.channel) {
        const e = Ute();
        return this.setChannel(e), e;
      }
      return this.channel;
    }, "getChannel"), this.ready = /* @__PURE__ */ u(() => this.promise, "ready"), this.hasChannel = /* @__PURE__ */ u(() => !!this.channel, "hasChannel"), this.setChannel = /* @__PURE__ */ u((e) => {
      this.channel = e, this.resolve();
    }, "setChannel"), this.promise = new Promise((e) => {
      this.resolve = () => e(this.getChannel());
    });
  }
};
u(Bte, "AddonStore");
var nke = Bte, Lv = "__STORYBOOK_ADDONS_PREVIEW";
function Hte() {
  return xe[Lv] || (xe[Lv] = new nke()), xe[Lv];
}
u(Hte, "getAddonsStore");
var Bn = Hte(), Vte = class {
  constructor() {
    this.hookListsMap = void 0, this.mountedDecorators = void 0, this.prevMountedDecorators = void 0, this.currentHooks = void 0, this.nextHookIndex = void 0, this.currentPhase = void 0, this.currentEffects = void 0, this.prevEffects = void 0, this.currentDecoratorName = void 0, this.hasUpdates = void 0, this.currentContext = void 0, this.renderListener = /* @__PURE__ */ u((e) => {
      e === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener"), this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e) => {
      e.destroy && e.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    const e = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e;
  }
  triggerEffects() {
    this.prevEffects.forEach((e) => {
      !this.currentEffects.includes(e) && e.destroy && e.destroy();
    }), this.currentEffects.forEach((e) => {
      this.prevEffects.includes(e) || (e.destroy = e.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), Bn.getChannel().on(Vh, this.renderListener);
  }
  removeRenderListeners() {
    Bn.getChannel().removeListener(Vh, this.renderListener);
  }
};
u(Vte, "HooksContext");
var zte = Vte;
function J1(e) {
  const t = /* @__PURE__ */ u((...r) => {
    const { hooks: n } = typeof r[0] == "function" ? r[1] : r[0], o = n.currentPhase, a = n.currentHooks, i = n.nextHookIndex, s = n.currentDecoratorName;
    n.currentDecoratorName = e.name, n.prevMountedDecorators.has(e) ? (n.currentPhase = "UPDATE", n.currentHooks = n.hookListsMap.get(e) || []) : (n.currentPhase = "MOUNT", n.currentHooks = [], n.hookListsMap.set(e, n.currentHooks), n.prevMountedDecorators.add(e)), n.nextHookIndex = 0;
    const d = xe.STORYBOOK_HOOKS_CONTEXT;
    xe.STORYBOOK_HOOKS_CONTEXT = n;
    const l = e(...r);
    if (xe.STORYBOOK_HOOKS_CONTEXT = d, n.currentPhase === "UPDATE" && n.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return n.currentPhase = o, n.currentHooks = a, n.nextHookIndex = i, n.currentDecoratorName = s, l;
  }, "hookified");
  return t.originalFn = e, t;
}
u(J1, "hookify");
var Fv = 0, oke = 25, ake = /* @__PURE__ */ u((e) => (t, r) => {
  const n = e(
    J1(t),
    r.map((o) => J1(o))
  );
  return (o) => {
    const { hooks: a } = o;
    a.prevMountedDecorators ??= /* @__PURE__ */ new Set(), a.mountedDecorators = /* @__PURE__ */ new Set([t, ...r]), a.currentContext = o, a.hasUpdates = !1;
    let i = n(o);
    for (Fv = 1; a.hasUpdates; )
      if (a.hasUpdates = !1, a.currentEffects = [], i = n(o), Fv += 1, Fv > oke)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return a.addRenderListeners(), i;
  };
}, "applyHooks"), ike = /* @__PURE__ */ u((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), "areDepsEqual"), fP = /* @__PURE__ */ u(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
function hP() {
  return xe.STORYBOOK_HOOKS_CONTEXT || null;
}
u(hP, "getHooksContextOrNull");
function Db() {
  const e = hP();
  if (e == null)
    throw fP();
  return e;
}
u(Db, "getHooksContextOrThrow");
function Jte(e, t, r) {
  const n = Db();
  if (n.currentPhase === "MOUNT") {
    r != null && !Array.isArray(r) && wt.warn(
      `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`
    );
    const o = { name: e, deps: r };
    return n.currentHooks.push(o), t(o), o;
  }
  if (n.currentPhase === "UPDATE") {
    const o = n.getNextHook();
    if (o == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return o.name !== e && wt.warn(
      `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), r != null && o.deps == null && wt.warn(
      `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), r != null && o.deps != null && r.length !== o.deps.length && wt.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`), (r == null || o.deps == null || !ike(r, o.deps)) && (t(o), o.deps = r), o;
  }
  throw fP();
}
u(Jte, "useHook");
function Lp(e, t, r) {
  const { memoizedState: n } = Jte(
    e,
    (o) => {
      o.memoizedState = t();
    },
    r
  );
  return n;
}
u(Lp, "useMemoLike");
function Wte(e, t) {
  return Lp("useMemo", e, t);
}
u(Wte, "useMemo");
function Yd(e, t) {
  return Lp("useCallback", () => e, t);
}
u(Yd, "useCallback");
function mP(e, t) {
  return Lp(e, () => ({ current: t }), []);
}
u(mP, "useRefLike");
function ske(e) {
  return mP("useRef", e);
}
u(ske, "useRef");
function Gte() {
  const e = hP();
  if (e != null && e.currentPhase !== "NONE")
    e.hasUpdates = !0;
  else
    try {
      Bn.getChannel().emit(GA);
    } catch {
      wt.warn("State updates of Storybook preview hooks work only in browser");
    }
}
u(Gte, "triggerUpdate");
function yP(e, t) {
  const r = mP(
    e,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof t == "function" ? t() : t
  ), n = /* @__PURE__ */ u((o) => {
    r.current = typeof o == "function" ? o(r.current) : o, Gte();
  }, "setState");
  return [r.current, n];
}
u(yP, "useStateLike");
function lke(e) {
  return yP("useState", e);
}
u(lke, "useState");
function cke(e, t, r) {
  const n = r != null ? () => r(t) : t, [o, a] = yP("useReducer", n);
  return [o, /* @__PURE__ */ u((i) => a((s) => e(s, i)), "dispatch")];
}
u(cke, "useReducer");
function Ss(e, t) {
  const r = Db(), n = Lp("useEffect", () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
u(Ss, "useEffect");
function uke(e, t = []) {
  const r = Bn.getChannel();
  return Ss(() => (Object.entries(e).forEach(([n, o]) => r.on(n, o)), () => {
    Object.entries(e).forEach(
      ([n, o]) => r.removeListener(n, o)
    );
  }), [...Object.keys(e), ...t]), Yd(r.emit.bind(r), [r]);
}
u(uke, "useChannel");
function qb() {
  const { currentContext: e } = Db();
  if (e == null)
    throw fP();
  return e;
}
u(qb, "useStoryContext");
function dke(e, t) {
  const { parameters: r } = qb();
  if (e)
    return r[e] ?? t;
}
u(dke, "useParameter");
function pke() {
  const e = Bn.getChannel(), { id: t, args: r } = qb(), n = Yd(
    (a) => e.emit(QA, { storyId: t, updatedArgs: a }),
    [e, t]
  ), o = Yd(
    (a) => e.emit(KA, { storyId: t, argNames: a }),
    [e, t]
  );
  return [r, n, o];
}
u(pke, "useArgs");
function fke() {
  const e = Bn.getChannel(), { globals: t } = qb(), r = Yd(
    (n) => e.emit(XA, { globals: n }),
    [e]
  );
  return [t, r];
}
u(fke, "useGlobals");
var hke = /* @__PURE__ */ u(({
  name: e,
  parameterName: t,
  wrapper: r,
  skipIfNoParametersOrOptions: n = !1
}) => {
  const o = /* @__PURE__ */ u((a) => (i, s) => {
    const d = s.parameters && s.parameters[t];
    return d && d.disable || n && !a && !d ? i(s) : r(i, s, {
      options: a,
      parameters: d
    });
  }, "decorator");
  return (...a) => typeof a[0] == "function" ? o()(...a) : (...i) => {
    if (i.length > 1)
      return a.length > 1 ? o(a)(...i) : o(...a)(...i);
    throw new Error(
      `Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`
    );
  };
}, "makeDecorator"), Uv = ar(m6(), 1), Ii = Symbol("incompatible"), W1 = /* @__PURE__ */ u((e, t) => {
  const r = t.type;
  if (e == null || !r || t.mapping)
    return e;
  switch (r.name) {
    case "string":
      return String(e);
    case "enum":
      return e;
    case "number":
      return Number(e);
    case "boolean":
      return String(e) === "true";
    case "array":
      return !r.value || !Array.isArray(e) ? Ii : e.reduce((n, o, a) => {
        const i = W1(o, { type: r.value });
        return i !== Ii && (n[a] = i), n;
      }, new Array(e.length));
    case "object":
      return typeof e == "string" || typeof e == "number" ? e : !r.value || typeof e != "object" ? Ii : Object.entries(e).reduce((n, [o, a]) => {
        const i = W1(a, { type: r.value[o] });
        return i === Ii ? n : Object.assign(n, { [o]: i });
      }, {});
    case "other": {
      const n = typeof e == "string" || typeof e == "number" || typeof e == "boolean";
      return r.value === "ReactNode" && n ? e : Ii;
    }
    default:
      return Ii;
  }
}, "map"), mke = /* @__PURE__ */ u((e, t) => Object.entries(e).reduce((r, [n, o]) => {
  if (!t[n])
    return r;
  const a = W1(o, t[n]);
  return a === Ii ? r : Object.assign(r, { [n]: a });
}, {}), "mapArgsToTypes"), G1 = /* @__PURE__ */ u((e, t) => Array.isArray(e) && Array.isArray(t) ? t.reduce(
  (r, n, o) => (r[o] = G1(e[o], t[o]), r),
  [...e]
).filter((r) => r !== void 0) : !Yr(e) || !Yr(t) ? t : Object.keys({ ...e, ...t }).reduce((r, n) => {
  if (n in t) {
    const o = G1(e[n], t[n]);
    o !== void 0 && (r[n] = o);
  } else
    r[n] = e[n];
  return r;
}, {}), "combineArgs"), yke = /* @__PURE__ */ u((e, t) => Object.entries(t).reduce((r, [n, { options: o }]) => {
  function a() {
    return n in e && (r[n] = e[n]), r;
  }
  if (u(a, "allowArg"), !o)
    return a();
  if (!Array.isArray(o))
    return qt.error(Be`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), a();
  if (o.some((f) => f && ["object", "function"].includes(typeof f)))
    return qt.error(Be`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), a();
  const i = Array.isArray(e[n]), s = i && e[n].findIndex((f) => !o.includes(f)), d = i && s === -1;
  if (e[n] === void 0 || o.includes(e[n]) || d)
    return a();
  const l = i ? `${n}[${s}]` : n, p = o.map((f) => typeof f == "string" ? `'${f}'` : String(f)).join(", ");
  return qt.warn(`Received illegal value for '${l}'. Supported options: ${p}`), r;
}, {}), "validateOptions"), rd = Symbol("Deeply equal"), Om = /* @__PURE__ */ u((e, t) => {
  if (typeof e != typeof t)
    return t;
  if (p6(e, t))
    return rd;
  if (Array.isArray(e) && Array.isArray(t)) {
    const r = t.reduce((n, o, a) => {
      const i = Om(e[a], o);
      return i !== rd && (n[a] = i), n;
    }, new Array(t.length));
    return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
  }
  return Yr(e) && Yr(t) ? Object.keys({ ...e, ...t }).reduce((r, n) => {
    const o = Om(e?.[n], t?.[n]);
    return o === rd ? r : Object.assign(r, { [n]: o });
  }, {}) : t;
}, "deepDiff"), Kte = "UNTARGETED";
function Yte({
  args: e,
  argTypes: t
}) {
  const r = {};
  return Object.entries(e).forEach(([n, o]) => {
    const { target: a = Kte } = t[n] || {};
    r[a] = r[a] || {}, r[a][n] = o;
  }), r;
}
u(Yte, "groupArgsByTarget");
function Xte(e) {
  return Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e;
}
u(Xte, "deleteUndefined");
var Qte = class {
  constructor() {
    this.initialArgsByStoryId = {}, this.argsByStoryId = {};
  }
  get(e) {
    if (!(e in this.argsByStoryId))
      throw new Error(`No args known for ${e} -- has it been rendered yet?`);
    return this.argsByStoryId[e];
  }
  setInitial(e) {
    if (!this.initialArgsByStoryId[e.id])
      this.initialArgsByStoryId[e.id] = e.initialArgs, this.argsByStoryId[e.id] = e.initialArgs;
    else if (this.initialArgsByStoryId[e.id] !== e.initialArgs) {
      const t = Om(this.initialArgsByStoryId[e.id], this.argsByStoryId[e.id]);
      this.initialArgsByStoryId[e.id] = e.initialArgs, this.argsByStoryId[e.id] = e.initialArgs, t !== rd && this.updateFromDelta(e, t);
    }
  }
  updateFromDelta(e, t) {
    const r = yke(t, e.argTypes);
    this.argsByStoryId[e.id] = G1(this.argsByStoryId[e.id], r);
  }
  updateFromPersisted(e, t) {
    const r = mke(t, e.argTypes);
    return this.updateFromDelta(e, r);
  }
  update(e, t) {
    if (!(e in this.argsByStoryId))
      throw new Error(`No args known for ${e} -- has it been rendered yet?`);
    this.argsByStoryId[e] = Xte({
      ...this.argsByStoryId[e],
      ...t
    });
  }
};
u(Qte, "ArgsStore");
var gke = Qte, Zte = /* @__PURE__ */ u((e = {}) => Object.entries(e).reduce((t, [r, { defaultValue: n }]) => (typeof n < "u" && (t[r] = n), t), {}), "getValuesFromArgTypes"), ere = class {
  constructor({
    globals: e = {},
    globalTypes: t = {}
  }) {
    this.set({ globals: e, globalTypes: t });
  }
  set({ globals: e = {}, globalTypes: t = {} }) {
    const r = this.initialGlobals && Om(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(t)]);
    const n = Zte(t);
    this.initialGlobals = { ...n, ...e }, this.globals = this.initialGlobals, r && r !== rd && this.updateFromPersisted(r);
  }
  filterAllowedGlobals(e) {
    return Object.entries(e).reduce((t, [r, n]) => (this.allowedGlobalNames.has(r) ? t[r] = n : wt.warn(
      `Attempted to set a global (${r}) that is not defined in initial globals or globalTypes`
    ), t), {});
  }
  updateFromPersisted(e) {
    const t = this.filterAllowedGlobals(e);
    this.globals = { ...this.globals, ...t };
  }
  get() {
    return this.globals;
  }
  update(e) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(e) };
    for (const t in e)
      e[t] === void 0 && (this.globals[t] = this.initialGlobals[t]);
  }
};
u(ere, "GlobalsStore");
var bke = ere, vke = ar(m6(), 1), wke = (0, vke.default)(1)(
  (e) => Object.values(e).reduce(
    (t, r) => (t[r.importPath] = t[r.importPath] || r, t),
    {}
  )
), tre = class {
  constructor({ entries: e } = { v: 5, entries: {} }) {
    this.entries = e;
  }
  entryFromSpecifier(e) {
    const t = Object.values(this.entries);
    if (e === "*")
      return t[0];
    if (typeof e == "string")
      return this.entries[e] ? this.entries[e] : t.find((o) => o.id.startsWith(e));
    const { name: r, title: n } = e;
    return t.find((o) => o.name === r && o.title === n);
  }
  storyIdToEntry(e) {
    const t = this.entries[e];
    if (!t)
      throw new nve({ storyId: e });
    return t;
  }
  importPathToEntry(e) {
    return wke(this.entries)[e];
  }
};
u(tre, "StoryIndexStore");
var _ke = tre, Eke = /* @__PURE__ */ u((e) => typeof e == "string" ? { name: e } : e, "normalizeType"), xke = /* @__PURE__ */ u((e) => typeof e == "string" ? { type: e } : e, "normalizeControl"), Ske = /* @__PURE__ */ u((e, t) => {
  const { type: r, control: n, ...o } = e, a = {
    name: t,
    ...o
  };
  return r && (a.type = Eke(r)), n ? a.control = xke(n) : n === !1 && (a.control = { disable: !0 }), a;
}, "normalizeInputType"), Rm = /* @__PURE__ */ u((e) => ec(e, Ske), "normalizeInputTypes"), Ye = /* @__PURE__ */ u((e) => Array.isArray(e) ? e : e ? [e] : [], "normalizeArrays"), Tke = Be`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function nd(e, t, r) {
  const n = t, o = typeof t == "function" ? t : null, { story: a } = n;
  a && (wt.debug("deprecated story", a), EW(Tke));
  const i = rke(e), s = typeof n != "function" && n.name || n.storyName || a?.name || i, d = [
    ...Ye(n.decorators),
    ...Ye(a?.decorators)
  ], l = { ...a?.parameters, ...n.parameters }, p = { ...a?.args, ...n.args }, f = { ...a?.argTypes, ...n.argTypes }, h = [...Ye(n.loaders), ...Ye(a?.loaders)], m = [
    ...Ye(n.beforeEach),
    ...Ye(a?.beforeEach)
  ], g = [
    ...Ye(n.afterEach),
    ...Ye(a?.afterEach)
  ], { render: w, play: _, tags: b = [], globals: x = {} } = n, P = l.__id || eke(r.id, i);
  return {
    moduleExport: t,
    id: P,
    name: s,
    tags: b,
    decorators: d,
    parameters: l,
    args: p,
    argTypes: Rm(f),
    loaders: h,
    beforeEach: m,
    afterEach: g,
    globals: x,
    ...w && { render: w },
    ...o && { userStoryFn: o },
    ..._ && { play: _ }
  };
}
u(nd, "normalizeStory");
function jm(e, t = e.title, r) {
  const { id: n, argTypes: o } = e;
  return {
    id: Lte(n || t),
    ...e,
    title: t,
    ...o && { argTypes: Rm(o) },
    parameters: {
      fileName: r,
      ...e.parameters
    }
  };
}
u(jm, "normalizeComponentAnnotations");
var Ake = /* @__PURE__ */ u((e) => {
  const { globals: t, globalTypes: r } = e;
  (t || r) && wt.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: t,
      globalTypes: r
    })
  );
}, "checkGlobals"), $ke = /* @__PURE__ */ u((e) => {
  const { options: t } = e;
  t?.storySort && wt.error("The storySort option parameter can only be set globally");
}, "checkStorySort"), Zp = /* @__PURE__ */ u((e) => {
  e && (Ake(e), $ke(e));
}, "checkDisallowedParameters");
function rre(e, t, r) {
  const { default: n, __namedExportsOrder: o, ...a } = e, i = Object.values(a)[0];
  if (Mb(i)) {
    const l = jm(i.meta.input, r, t);
    Zp(l.parameters);
    const p = { meta: l, stories: {}, moduleExports: e };
    return Object.keys(a).forEach((f) => {
      if (Pm(f, l)) {
        const h = a[f], m = nd(f, h.input, l);
        Zp(m.parameters), p.stories[m.id] = m, qte(h).forEach((g) => {
          const w = g.input.name, _ = tke(m.id, w);
          g.input.parameters ??= {}, g.input.parameters.__id = _, p.stories[_] = nd(w, g.input, l);
        });
      }
    }), p.projectAnnotations = i.meta.preview.composed, p;
  }
  const s = jm(
    n,
    r,
    t
  );
  Zp(s.parameters);
  const d = { meta: s, stories: {}, moduleExports: e };
  return Object.keys(a).forEach((l) => {
    if (Pm(l, s)) {
      const p = nd(l, a[l], s);
      Zp(p.parameters), d.stories[p.id] = p;
    }
  }), d;
}
u(rre, "processCSFFile");
function Im(e) {
  return e != null && nre(e).includes("mount");
}
u(Im, "mountDestructured");
function nre(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t)
    return [];
  const r = K1(t[1]);
  if (!r.length)
    return [];
  const n = r[0];
  return n.startsWith("{") && n.endsWith("}") ? K1(n.slice(1, -1).replace(/\s/g, "")).map((o) => o.replace(/:.*|=.*/g, "")) : [];
}
u(nre, "getUsedProps");
function K1(e) {
  const t = [], r = [];
  let n = 0;
  for (let a = 0; a < e.length; a++)
    if (e[a] === "{" || e[a] === "[")
      r.push(e[a] === "{" ? "}" : "]");
    else if (e[a] === r[r.length - 1])
      r.pop();
    else if (!r.length && e[a] === ",") {
      const i = e.substring(n, a).trim();
      i && t.push(i), n = a + 1;
    }
  const o = e.substring(n).trim();
  return o && t.push(o), t;
}
u(K1, "splitByComma");
function ore(e, t, r) {
  const n = r(e);
  return (o) => t(n, o);
}
u(ore, "decorateStory");
function are({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: o,
  story: a,
  parameters: i,
  initialArgs: s,
  argTypes: d,
  ...l
} = {}) {
  return l;
}
u(are, "sanitizeStoryContextUpdate");
function ire(e, t) {
  const r = {}, n = /* @__PURE__ */ u((a) => (i) => {
    if (!r.value)
      throw new Error("Decorated function called without init");
    return r.value = {
      ...r.value,
      ...are(i)
    }, a(r.value);
  }, "bindWithContext"), o = t.reduce(
    (a, i) => ore(a, i, n),
    e
  );
  return (a) => (r.value = a, o(a));
}
u(ire, "defaultDecorateStory");
function gP(e, t, r) {
  const { moduleExport: n, id: o, name: a } = e || {}, i = bP(
    e,
    t,
    r
  ), s = /* @__PURE__ */ u(async (C) => {
    const A = {};
    for (const E of [
      Ye(r.loaders),
      Ye(t.loaders),
      Ye(e.loaders)
    ]) {
      if (C.abortSignal.aborted)
        return A;
      const T = await Promise.all(E.map((O) => O(C)));
      Object.assign(A, ...T);
    }
    return A;
  }, "applyLoaders"), d = /* @__PURE__ */ u(async (C) => {
    const A = new Array();
    for (const E of [
      ...Ye(r.beforeEach),
      ...Ye(t.beforeEach),
      ...Ye(e.beforeEach)
    ]) {
      if (C.abortSignal.aborted)
        return A;
      const T = await E(C);
      T && A.push(T);
    }
    return A;
  }, "applyBeforeEach"), l = /* @__PURE__ */ u(async (C) => {
    const A = [
      ...Ye(r.afterEach),
      ...Ye(t.afterEach),
      ...Ye(e.afterEach)
    ].reverse();
    for (const E of A) {
      if (C.abortSignal.aborted)
        return;
      await E(C);
    }
  }, "applyAfterEach"), p = /* @__PURE__ */ u((C) => C.originalStoryFn(C.args, C), "undecoratedStoryFn"), { applyDecorators: f = ire, runStep: h } = r, m = [
    ...Ye(e?.decorators),
    ...Ye(t?.decorators),
    ...Ye(r?.decorators)
  ], g = e?.userStoryFn || e?.render || t.render || r.render, w = ake(f)(p, m), _ = /* @__PURE__ */ u((C) => w(C), "unboundStoryFn"), b = e?.play ?? t?.play, x = Im(b);
  if (!g && !x)
    throw new fve({ id: o });
  const P = /* @__PURE__ */ u((C) => async () => (await C.renderToCanvas(), C.canvas), "defaultMount"), R = e.mount ?? t.mount ?? r.mount ?? P, N = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...i,
    moduleExport: n,
    id: o,
    name: a,
    story: a,
    originalStoryFn: g,
    undecoratedStoryFn: p,
    unboundStoryFn: _,
    applyLoaders: s,
    applyBeforeEach: d,
    applyAfterEach: l,
    playFunction: b,
    runStep: h,
    mount: R,
    testingLibraryRender: N,
    renderToCanvas: r.renderToCanvas,
    usesMount: x
  };
}
u(gP, "prepareStory");
function sre(e, t, r) {
  return {
    ...bP(void 0, e, t),
    moduleExport: r
  };
}
u(sre, "prepareMeta");
function bP(e, t, r) {
  const n = ["dev", "test"], o = xe.DOCS_OPTIONS?.autodocs === !0 ? ["autodocs"] : [], a = e?.tags?.includes("test-fn") ? ["!autodocs"] : [], i = Fte(
    ...n,
    ...o,
    ...r.tags ?? [],
    ...t.tags ?? [],
    ...a,
    ...e?.tags ?? []
  ), s = Ka(
    r.parameters,
    t.parameters,
    e?.parameters
  ), { argTypesEnhancers: d = [], argsEnhancers: l = [] } = r, p = Ka(
    r.argTypes,
    t.argTypes,
    e?.argTypes
  );
  if (e) {
    const x = e?.userStoryFn || e?.render || t.render || r.render;
    s.__isArgsStory = x && x.length > 0;
  }
  const f = {
    ...r.args,
    ...t.args,
    ...e?.args
  }, h = {
    ...t.globals,
    ...e?.globals
  }, m = {
    componentId: t.id,
    title: t.title,
    kind: t.title,
    // Back compat
    id: e?.id || t.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: e?.name || "__meta",
    story: e?.name || "__meta",
    // Back compat
    component: t.component,
    subcomponents: t.subcomponents,
    tags: i,
    parameters: s,
    initialArgs: f,
    argTypes: p,
    storyGlobals: h
  };
  m.argTypes = d.reduce(
    (x, P) => P({ ...m, argTypes: x }),
    m.argTypes
  );
  const g = { ...f };
  m.initialArgs = [...l].reduce(
    (x, P) => ({
      ...x,
      ...P({
        ...m,
        initialArgs: x
      })
    }),
    g
  );
  const { name: w, story: _, ...b } = m;
  return b;
}
u(bP, "preparePartialAnnotations");
function vP(e) {
  const { args: t } = e;
  let r = {
    ...e,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (xe.FEATURES?.argTypeTargetsV7) {
    const a = Yte(e);
    r = {
      ...e,
      allArgs: e.args,
      argsByTarget: a,
      args: a[Kte] || {}
    };
  }
  const n = Object.entries(r.args).reduce((a, [i, s]) => {
    if (!r.argTypes[i]?.mapping)
      return a[i] = s, a;
    const d = /* @__PURE__ */ u((l) => {
      const p = r.argTypes[i].mapping;
      return p && l in p ? p[l] : l;
    }, "mappingFn");
    return a[i] = Array.isArray(s) ? s.map(d) : d(s), a;
  }, {}), o = Object.entries(n).reduce((a, [i, s]) => {
    const d = r.argTypes[i] || {};
    return pCe(d, n, r.globals) && (a[i] = s), a;
  }, {});
  return { ...r, unmappedArgs: t, args: o };
}
u(vP, "prepareContext");
var Y1 = /* @__PURE__ */ u((e, t, r) => {
  const n = typeof e;
  switch (n) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: n };
  }
  return e ? r.has(e) ? (wt.warn(Be`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (r.add(e), Array.isArray(e) ? { name: "array", value: e.length > 0 ? Y1(e[0], t, new Set(r)) : { name: "other", value: "unknown" } } : { name: "object", value: ec(e, (o) => Y1(o, t, new Set(r))) }) : { name: "object", value: {} };
}, "inferType"), lre = /* @__PURE__ */ u((e) => {
  const { id: t, argTypes: r = {}, initialArgs: n = {} } = e, o = ec(n, (i, s) => ({
    name: s,
    type: Y1(i, `${t}.${s}`, /* @__PURE__ */ new Set())
  })), a = ec(r, (i, s) => ({
    name: s
  }));
  return Ka(o, a, r);
}, "inferArgTypes");
lre.secondPass = !0;
var TI = /* @__PURE__ */ u((e, t) => Array.isArray(t) ? t.includes(e) : e.match(t), "matches"), Cke = /* @__PURE__ */ u((e, t, r) => !t && !r ? e : e && n8(e, (n, o) => {
  const a = n.name || o.toString();
  return !!(!t || TI(a, t)) && (!r || !TI(a, r));
}), "filterArgTypes"), kke = /* @__PURE__ */ u((e, t, r) => {
  const { type: n, options: o } = e;
  if (n) {
    if (r.color && r.color.test(t)) {
      const a = n.name;
      if (a === "string")
        return { control: { type: "color" } };
      a !== "enum" && wt.warn(
        `Addon controls: Control of type color only supports string, received "${a}" instead`
      );
    }
    if (r.date && r.date.test(t))
      return { control: { type: "date" } };
    switch (n.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        const { value: a } = n;
        return { control: { type: a?.length <= 5 ? "radio" : "select" }, options: a };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: o ? "select" : "object" } };
    }
  }
}, "inferControl"), cre = /* @__PURE__ */ u((e) => {
  const {
    argTypes: t,
    parameters: { __isArgsStory: r, controls: { include: n = null, exclude: o = null, matchers: a = {} } = {} }
  } = e;
  if (!r)
    return t;
  const i = Cke(t, n, o), s = ec(i, (d, l) => d?.type && kke(d, l.toString(), a));
  return Ka(s, i);
}, "inferControls");
cre.secondPass = !0;
function Xd({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: o,
  beforeEach: a,
  afterEach: i,
  initialGlobals: s,
  ...d
}) {
  return {
    ...e && { argTypes: Rm(e) },
    ...t && { globalTypes: Rm(t) },
    decorators: Ye(n),
    loaders: Ye(o),
    beforeEach: Ye(a),
    afterEach: Ye(i),
    argTypesEnhancers: [
      ...r || [],
      lre,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      cre
    ],
    initialGlobals: s,
    ...d
  };
}
u(Xd, "normalizeProjectAnnotations");
var Pke = /* @__PURE__ */ u((e) => async () => {
  const t = [];
  for (const r of e) {
    const n = await r();
    n && t.unshift(n);
  }
  return async () => {
    for (const r of t)
      await r();
  };
}, "composeBeforeAllHooks");
function ure(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (o, a) => async () => a(t, o, n),
      async () => r(n)
    )();
  };
}
u(ure, "composeStepRunners");
function bc(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
u(bc, "getField");
function Ho(e, t, r = {}) {
  return bc(e, t).reduce((n, o) => {
    const a = Ye(o);
    return r.reverseFileOrder ? [...a, ...n] : [...n, ...a];
  }, []);
}
u(Ho, "getArrayField");
function ku(e, t) {
  return Object.assign({}, ...bc(e, t));
}
u(ku, "getObjectField");
function ol(e, t) {
  return bc(e, t).pop();
}
u(ol, "getSingletonField");
function Ts(e) {
  const t = Ho(e, "argTypesEnhancers"), r = bc(e, "runStep"), n = Ho(e, "beforeAll");
  return {
    parameters: Ka(...bc(e, "parameters")),
    decorators: Ho(e, "decorators", {
      reverseFileOrder: !(xe.FEATURES?.legacyDecoratorFileOrder ?? !1)
    }),
    args: ku(e, "args"),
    argsEnhancers: Ho(e, "argsEnhancers"),
    argTypes: ku(e, "argTypes"),
    argTypesEnhancers: [
      ...t.filter((o) => !o.secondPass),
      ...t.filter((o) => o.secondPass)
    ],
    initialGlobals: ku(e, "initialGlobals"),
    globalTypes: ku(e, "globalTypes"),
    loaders: Ho(e, "loaders"),
    beforeAll: Pke(n),
    beforeEach: Ho(e, "beforeEach"),
    afterEach: Ho(e, "afterEach"),
    render: ol(e, "render"),
    renderToCanvas: ol(e, "renderToCanvas"),
    applyDecorators: ol(e, "applyDecorators"),
    runStep: ure(r),
    tags: Ho(e, "tags"),
    mount: ol(e, "mount"),
    testingLibraryRender: ol(e, "testingLibraryRender")
  };
}
u(Ts, "composeConfigs");
var dre = class {
  constructor() {
    this.reports = [];
  }
  async addReport(e) {
    this.reports.push(e);
  }
};
u(dre, "ReporterAPI");
var pre = dre;
function fre(e, t, r) {
  return Mb(e) ? {
    story: e.input,
    meta: e.meta.input,
    preview: e.meta.preview.composed
  } : { story: e, meta: Mte(t) ? t.input : t, preview: r };
}
u(fre, "getCsfFactoryAnnotations");
function Oke(e) {
  globalThis.defaultProjectAnnotations = e;
}
u(Oke, "setDefaultProjectAnnotations");
var Rke = "ComposedStory", jke = "Unnamed Story";
function hre(e) {
  return e ? Ts([e]) : {};
}
u(hre, "extractAnnotation");
function Ike(e) {
  const t = Array.isArray(e) ? e : [e];
  return globalThis.globalProjectAnnotations = Ts([
    ...Nb(),
    globalThis.defaultProjectAnnotations ?? {},
    Ts(t.map(hre))
  ]), globalThis.globalProjectAnnotations ?? {};
}
u(Ike, "setProjectAnnotations");
var ka = [];
function wP(e, t, r, n, o) {
  if (e === void 0)
    throw new Error("Expected a story but received undefined.");
  t.title = t.title ?? Rke;
  const a = jm(t), i = o || e.storyName || e.story?.name || e.name || jke, s = nd(
    i,
    e,
    a
  ), d = Xd(
    Ts([
      n ?? globalThis.globalProjectAnnotations ?? {},
      r ?? {}
    ])
  ), l = gP(
    s,
    a,
    d
  ), p = {
    ...Zte(d.globalTypes),
    ...d.initialGlobals,
    ...l.storyGlobals
  }, f = new pre(), h = /* @__PURE__ */ u(() => {
    const b = vP({
      hooks: new zte(),
      globals: p,
      args: { ...l.initialArgs },
      viewMode: "story",
      reporting: f,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: /* @__PURE__ */ u((x, P) => l.runStep(x, P, b), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: d.globalTypes,
      ...l,
      context: null,
      mount: null
    });
    return b.parameters.__isPortableStory = !0, b.context = b, l.renderToCanvas && (b.renderToCanvas = async () => {
      const x = await l.renderToCanvas?.(
        {
          componentId: l.componentId,
          title: l.title,
          id: l.id,
          name: l.name,
          tags: l.tags,
          showMain: /* @__PURE__ */ u(() => {
          }, "showMain"),
          showError: /* @__PURE__ */ u((P) => {
            throw new Error(`${P.title}
${P.description}`);
          }, "showError"),
          showException: /* @__PURE__ */ u((P) => {
            throw P;
          }, "showException"),
          forceRemount: !0,
          storyContext: b,
          storyFn: /* @__PURE__ */ u(() => l.unboundStoryFn(b), "storyFn"),
          unboundStoryFn: l.unboundStoryFn
        },
        b.canvasElement
      );
      x && ka.push(x);
    }), b.mount = l.mount(b), b;
  }, "initializeContext");
  let m;
  const g = /* @__PURE__ */ u(async (b) => {
    const x = h();
    return x.canvasElement ??= globalThis?.document?.body, m && (x.loaded = m.loaded), Object.assign(x, b), l.playFunction(x);
  }, "play"), w = /* @__PURE__ */ u((b) => {
    const x = h();
    return Object.assign(x, b), mre(l, x);
  }, "run"), _ = l.playFunction ? g : void 0;
  return Object.assign(
    /* @__PURE__ */ u(function(b) {
      const x = h();
      return m && (x.loaded = m.loaded), x.args = {
        ...x.initialArgs,
        ...b
      }, l.unboundStoryFn(x);
    }, "storyFn"),
    {
      id: l.id,
      storyName: i,
      load: /* @__PURE__ */ u(async () => {
        for (const x of [...ka].reverse())
          await x();
        ka.length = 0;
        const b = h();
        b.loaded = await l.applyLoaders(b), ka.push(...(await l.applyBeforeEach(b)).filter(Boolean)), m = b;
      }, "load"),
      globals: p,
      args: l.initialArgs,
      parameters: l.parameters,
      argTypes: l.argTypes,
      play: _,
      run: w,
      reporting: f,
      tags: l.tags
    }
  );
}
u(wP, "composeStory");
var Nke = /* @__PURE__ */ u((e, t, r, n) => wP(e, t, r, {}, n), "defaultComposeStory");
function Mke(e, t, r = Nke) {
  const { default: n, __esModule: o, __namedExportsOrder: a, ...i } = e;
  let s = n;
  return Object.entries(i).reduce(
    (d, [l, p]) => {
      const { story: f, meta: h } = fre(p);
      return !s && h && (s = h), Pm(l, s) ? Object.assign(d, {
        [l]: r(f, s, t, l)
      }) : d;
    },
    {}
  );
}
u(Mke, "composeStories");
function Dke(e) {
  return e.extend({
    mount: /* @__PURE__ */ u(async ({ mount: t, page: r }, n) => {
      await n(async (o, ...a) => {
        if (!("__pw_type" in o) || "__pw_type" in o && o.__pw_type !== "jsx")
          throw new Error(Be`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        const { props: i, ...s } = o;
        await r.evaluate(async (l) => {
          const p = await globalThis.__pwUnwrapObject?.(l);
          return ("__pw_type" in p ? p.type : p)?.load?.();
        }, s);
        const d = await t(o, ...a);
        return await r.evaluate(async (l) => {
          const p = await globalThis.__pwUnwrapObject?.(l), f = "__pw_type" in p ? p.type : p, h = document.querySelector("#root");
          return f?.play?.({ canvasElement: h });
        }, s), d;
      });
    }, "mount")
  });
}
u(Dke, "createPlaywrightTest");
async function mre(e, t) {
  for (const a of [...ka].reverse())
    await a();
  if (ka.length = 0, !t.canvasElement) {
    const a = document.createElement("div");
    globalThis?.document?.body?.appendChild(a), t.canvasElement = a, ka.push(() => {
      globalThis?.document?.body?.contains(a) && globalThis?.document?.body?.removeChild(a);
    });
  }
  if (t.loaded = await e.applyLoaders(t), t.abortSignal.aborted)
    return;
  ka.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  const r = e.playFunction, n = e.usesMount;
  if (n || await t.mount(), t.abortSignal.aborted)
    return;
  r && (n || (t.mount = async () => {
    throw new w8({ playFunction: r.toString() });
  }), await r(t));
  let o;
  bA() ? o = vA() : await wA(t.abortSignal), await e.applyAfterEach(t), await o?.();
}
u(mre, "runStory");
var AI = 1e3, qke = 1e4, yre = class {
  constructor(e, t, r) {
    this.importFn = t, this.storyIndex = new _ke(e), this.projectAnnotations = Xd(
      Ts([...Nb(), r])
    );
    const { initialGlobals: n, globalTypes: o } = this.projectAnnotations;
    this.args = new gke(), this.userGlobals = new bke({ globals: n, globalTypes: o }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, Uv.default)(AI)(rre), this.prepareMetaWithCache = (0, Uv.default)(AI)(sre), this.prepareStoryWithCache = (0, Uv.default)(qke)(gP);
  }
  setProjectAnnotations(e) {
    this.projectAnnotations = Xd(e);
    const { initialGlobals: t, globalTypes: r } = e;
    this.userGlobals.set({ globals: t, globalTypes: r });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: e,
    storyIndex: t
  }) {
    e && (this.importFn = e), t && (this.storyIndex.entries = t.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(e) {
    return this.storyIndex.storyIdToEntry(e);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(e) {
    const { importPath: t, title: r } = this.storyIndex.storyIdToEntry(e), n = await this.importFn(t);
    return this.processCSFFileWithCache(n, t, r);
  }
  async loadAllCSFFiles() {
    const e = {};
    return Object.entries(this.storyIndex.entries).forEach(([t, { importPath: r }]) => {
      e[r] = t;
    }), (await Promise.all(
      Object.entries(e).map(async ([t, r]) => ({
        importPath: t,
        csfFile: await this.loadCSFFileByStoryId(r)
      }))
    )).reduce(
      (t, { importPath: r, csfFile: n }) => (t[r] = n, t),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: e }) {
    const t = e.meta;
    return this.prepareMetaWithCache(
      t,
      this.projectAnnotations,
      e.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: e }) {
    const t = await this.loadCSFFileByStoryId(e);
    return this.storyFromCSFFile({ storyId: e, csfFile: t });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: e,
    csfFile: t
  }) {
    const r = t.stories[e];
    if (!r)
      throw new dve({ storyId: e });
    const n = t.meta, o = this.prepareStoryWithCache(
      r,
      n,
      t.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(o), this.hooks[o.id] = this.hooks[o.id] || new zte(), o;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: e
  }) {
    return Object.keys(this.storyIndex.entries).filter((t) => !!e.stories[t]).map((t) => this.storyFromCSFFile({ storyId: t, csfFile: e }));
  }
  async loadEntry(e) {
    const t = await this.storyIdToEntry(e), r = t.type === "docs" ? t.storiesImports : [], [n, ...o] = await Promise.all([
      this.importFn(t.importPath),
      ...r.map((a) => {
        const i = this.storyIndex.importPathToEntry(a);
        return this.loadCSFFileByStoryId(i.id);
      })
    ]);
    return { entryExports: n, csfFiles: o };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(e, { forceInitialArgs: t = !1 } = {}) {
    const r = this.userGlobals.get(), { initialGlobals: n } = this.userGlobals, o = new pre();
    return vP({
      ...e,
      args: t ? e.initialArgs : this.args.get(e.id),
      initialGlobals: n,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: r,
      reporting: o,
      globals: {
        ...r,
        ...e.storyGlobals
      },
      hooks: this.hooks[e.id]
    });
  }
  addCleanupCallbacks(e, ...t) {
    this.cleanupCallbacks[e.id] = (this.cleanupCallbacks[e.id] || []).concat(t);
  }
  async cleanupStory(e) {
    this.hooks[e.id].clean();
    const t = this.cleanupCallbacks[e.id];
    if (t)
      for (const r of [...t].reverse())
        await r();
    delete this.cleanupCallbacks[e.id];
  }
  extract(e = { includeDocsOnly: !1 }) {
    const { cachedCSFFiles: t } = this;
    if (console.log("extract: extracting stories", t), !t)
      throw new ave();
    const r = Object.entries(this.storyIndex.entries).reduce(
      (n, [o, a]) => {
        if (a.type === "docs")
          return n;
        const i = t[a.importPath], s = this.storyFromCSFFile({ storyId: o, csfFile: i });
        return !e.includeDocsOnly && s.parameters.docsOnly || (n[o] = Object.entries(s).reduce(
          (d, [l, p]) => l === "story" && a.subtype === "test" ? { ...d, story: a.parentName } : l === "moduleExport" || typeof p == "function" ? d : Array.isArray(p) ? Object.assign(d, { [l]: p.slice().sort() }) : Object.assign(d, { [l]: p }),
          {
            args: s.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...s.storyGlobals
            },
            storyId: a.parent ? a.parent : o
          }
        )), n;
      },
      {}
    );
    return console.log("extract: stories", r), r;
  }
};
u(yre, "StoryStore");
var Lke = yre;
function Fke(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
u(Fke, "slash");
function Uke(e) {
  return e.flatMap((t) => t.split("/")).filter(Boolean).join("/");
}
u(Uke, "pathJoin");
var Lb = new Error("prepareAborted"), { AbortController: $I } = globalThis;
function X1(e) {
  try {
    const { name: t = "Error", message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: "Error", message: String(e) };
  }
}
u(X1, "serializeError");
var gre = class {
  constructor(e, t, r, n, o, a, i = { autoplay: !0, forceInitialArgs: !1 }, s) {
    this.channel = e, this.store = t, this.renderToScreen = r, this.callbacks = n, this.id = o, this.viewMode = a, this.renderOptions = i, this.type = "story", this.notYetRendered = !0, this.rerenderEnqueued = !1, this.disableKeyListeners = !1, this.teardownRender = /* @__PURE__ */ u(() => {
    }, "teardownRender"), this.torndown = !1, this.abortController = new $I(), this.renderId = Date.now(), s && (this.story = s, this.phase = "preparing");
  }
  async runPhase(e, t, r) {
    this.phase = t, this.channel.emit(ys, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), r && (await r(), this.checkIfAborted(e));
  }
  checkIfAborted(e) {
    return e.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(ys, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    })), e.aborted;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), Lb;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(e) {
    return !!(this.id === e.id && this.story && this.story === e.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(e) {
    return this.canvasElement = e, this.render({ initial: !0, forceRemount: !0 });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    const { forceInitialArgs: e } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: e });
  }
  async render({
    initial: e = !1,
    forceRemount: t = !1
  } = {}) {
    const { canvasElement: r } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    const n = this.story;
    if (!r)
      throw new Error("cannot render when canvasElement is unset");
    const {
      id: o,
      componentId: a,
      title: i,
      name: s,
      tags: d,
      applyLoaders: l,
      applyBeforeEach: p,
      applyAfterEach: f,
      unboundStoryFn: h,
      playFunction: m,
      runStep: g
    } = n;
    t && !e && (this.cancelRender(), this.abortController = new $I());
    const w = this.abortController.signal;
    let _ = !1;
    const b = n.usesMount;
    try {
      const x = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: w,
        canvasElement: r,
        loaded: {},
        step: /* @__PURE__ */ u((M, L) => g(M, L, x), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: /* @__PURE__ */ u(async () => {
          const M = await this.renderToScreen(P, r);
          this.teardownRender = M || (() => {
          }), _ = !0;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: /* @__PURE__ */ u(async (...M) => {
          this.callbacks.showStoryDuringRender?.();
          let L = null;
          return await this.runPhase(w, "rendering", async () => {
            L = await n.mount(x)(...M);
          }), b && await this.runPhase(w, "playing"), L;
        }, "mount")
      };
      x.context = x;
      const P = {
        componentId: a,
        title: i,
        kind: i,
        id: o,
        name: s,
        story: s,
        tags: d,
        ...this.callbacks,
        showError: /* @__PURE__ */ u((M) => (this.phase = "errored", this.callbacks.showError(M)), "showError"),
        showException: /* @__PURE__ */ u((M) => (this.phase = "errored", this.callbacks.showException(M)), "showException"),
        forceRemount: t || this.notYetRendered,
        storyContext: x,
        storyFn: /* @__PURE__ */ u(() => h(x), "storyFn"),
        unboundStoryFn: h
      };
      if (await this.runPhase(w, "loading", async () => {
        x.loaded = await l(x);
      }), w.aborted)
        return;
      const R = await p(x);
      if (this.store.addCleanupCallbacks(n, ...R), this.checkIfAborted(w) || (!_ && !b && await x.mount(), this.notYetRendered = !1, w.aborted))
        return;
      const N = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, C = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ u((M) => {
        M.error && C.add(M.error);
      }, "onError"), E = /* @__PURE__ */ u((M) => {
        M.reason && C.add(M.reason);
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && t && m && this.phase !== "errored") {
        window?.addEventListener?.("error", A), window?.addEventListener?.("unhandledrejection", E), this.disableKeyListeners = !0;
        try {
          if (b ? await m(x) : (x.mount = async () => {
            throw new w8({ playFunction: m.toString() });
          }, await this.runPhase(w, "playing", async () => m(x))), !_)
            throw new hve();
          this.checkIfAborted(w), !N && C.size > 0 ? await this.runPhase(w, "errored") : await this.runPhase(w, "played");
        } catch (M) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(w, "errored", async () => {
            this.channel.emit(AW, X1(M));
          }), this.story.parameters.throwPlayFunctionExceptions !== !1)
            throw M;
          console.error(M);
        }
        if (!N && C.size > 0 && this.channel.emit(
          $W,
          Array.from(C).map(X1)
        ), this.disableKeyListeners = !1, window?.removeEventListener?.("unhandledrejection", E), window?.removeEventListener?.("error", A), w.aborted)
          return;
      }
      await this.runPhase(w, "completing", async () => {
        bA() ? this.store.addCleanupCallbacks(n, vA()) : await wA(w);
      }), await this.runPhase(w, "completed", async () => {
        this.channel.emit(Vh, o);
      }), this.phase !== "errored" && await this.runPhase(w, "afterEach", async () => {
        await f(x);
      });
      const T = !N && C.size > 0, O = x.reporting.reports.some(
        (M) => M.status === "failed"
      ), k = T || O;
      await this.runPhase(
        w,
        "finished",
        async () => this.channel.emit(p0, {
          storyId: o,
          status: k ? "error" : "success",
          reporters: x.reporting.reports
        })
      );
    } catch (x) {
      this.phase = "errored", this.callbacks.showException(x), await this.runPhase(
        w,
        "finished",
        async () => this.channel.emit(p0, {
          storyId: o,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = !0;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: !0 });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let e = 0; e < 3; e += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((t) => setTimeout(t, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
u(gre, "StoryRender");
var Q1 = gre, { fetch: Bke } = xe, Hke = "./index.json", bre = class {
  constructor(e, t, r = Bn.getChannel(), n = !0) {
    this.importFn = e, this.getProjectAnnotations = t, this.channel = r, this.storyRenders = [], this.storeInitializationPromise = new Promise((o, a) => {
      this.resolveStoreInitializationPromise = o, this.rejectStoreInitializationPromise = a;
    }), n && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: /* @__PURE__ */ u((e, t) => {
          if (this.storyStoreValue)
            return EW("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[t];
          throw new pve();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      const e = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(e), await this.initializeWithProjectAnnotations(e);
      const t = globalThis?.navigator?.userAgent;
      await this.channel.emit(kW, { userAgent: t });
    } catch (e) {
      this.rejectStoreInitializationPromise(e);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(NW, this.onStoryIndexChanged.bind(this)), this.channel.on(XA, this.onUpdateGlobals.bind(this)), this.channel.on(QA, this.onUpdateArgs.bind(this)), this.channel.on(BW, this.onRequestArgTypesInfo.bind(this)), this.channel.on(KA, this.onResetArgs.bind(this)), this.channel.on(GA, this.onForceReRender.bind(this)), this.channel.on(Hh, this.onForceRemount.bind(this)), this.channel.on(FW, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      const e = await this.getProjectAnnotations();
      if (this.renderToCanvas = e.renderToCanvas, !this.renderToCanvas)
        throw new ive();
      return e;
    } catch (e) {
      throw this.renderPreviewEntryError("Error reading preview.js:", e), e;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(e) {
    this.projectAnnotationsBeforeInitialization = e;
    try {
      const t = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(t);
    } catch (t) {
      throw this.renderPreviewEntryError("Error loading story index:", t), t;
    }
  }
  async runBeforeAllHook(e) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await e.beforeAll?.();
    } catch (t) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", t), t;
    }
  }
  async getStoryIndexFromServer() {
    const e = await Bke(Hke);
    if (e.status === 200)
      return e.json();
    throw new sve({ text: await e.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(e) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new Lke(
      e,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "emitGlobals" });
    const e = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(OW, e);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = e;
    const t = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(t), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(t);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(t), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        const e = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(e);
          return;
        }
        await this.onStoriesChanged({ storyIndex: e });
      } catch (e) {
        throw this.renderPreviewEntryError("Error loading story index:", e), e;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e,
    storyIndex: t
  }) {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: e, storyIndex: t });
  }
  async onUpdateGlobals({
    globals: e,
    currentStory: t
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new ln({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(e), t) {
      const { initialGlobals: r, storyGlobals: n, userGlobals: o, globals: a } = this.storyStoreValue.getStoryContext(t);
      this.channel.emit(Od, {
        initialGlobals: r,
        userGlobals: o,
        storyGlobals: n,
        globals: a
      });
    } else {
      const { initialGlobals: r, globals: n } = this.storyStoreValue.userGlobals;
      this.channel.emit(Od, {
        initialGlobals: r,
        userGlobals: n,
        storyGlobals: {},
        globals: n
      });
    }
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onUpdateArgs({ storyId: e, updatedArgs: t }) {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(e, t), await Promise.all(
      this.storyRenders.filter((r) => r.id === e && !r.renderOptions.forceInitialArgs).map(
        (r) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r.story && r.story.usesMount ? r.remount() : r.rerender()
        )
      )
    ), this.channel.emit(RW, {
      storyId: e,
      args: this.storyStoreValue.args.get(e)
    });
  }
  async onRequestArgTypesInfo({ id: e, payload: t }) {
    try {
      await this.storeInitializationPromise;
      const r = await this.storyStoreValue?.loadStory(t);
      this.channel.emit(f0, {
        id: e,
        success: !0,
        payload: { argTypes: r?.argTypes || {} },
        error: null
      });
    } catch (r) {
      this.channel.emit(f0, {
        id: e,
        success: !1,
        error: r?.message
      });
    }
  }
  async onResetArgs({ storyId: e, argNames: t }) {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "onResetArgs" });
    const r = this.storyRenders.find((o) => o.id === e)?.story || await this.storyStoreValue.loadStory({ storyId: e }), n = (t || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(r.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(e))
      ])
    ]).reduce((o, a) => (o[a] = r.initialArgs[a], o), {});
    await this.onUpdateArgs({ storyId: e, updatedArgs: n });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e) => e.rerender()));
  }
  async onForceRemount({ storyId: e }) {
    await Promise.all(this.storyRenders.filter((t) => t.id === e).map((t) => t.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((e) => e.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(e, t, r, n) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new ln({
        methodName: "renderStoryToElement"
      });
    const o = new Q1(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      r,
      e.id,
      "docs",
      n,
      e
    );
    return o.renderToElement(t), this.storyRenders.push(o), async () => {
      await this.teardownRender(o);
    };
  }
  async teardownRender(e, { viewModeChanged: t } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== e), await e?.teardown?.({ viewModeChanged: t });
  }
  // API
  async loadStory({ storyId: e }) {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: e });
  }
  getStoryContext(e, { forceInitialArgs: t = !1 } = {}) {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(e, { forceInitialArgs: t });
  }
  async extract(e) {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(e);
  }
  // UTILITIES
  renderPreviewEntryError(e, t) {
    this.previewEntryError = t, wt.error(e), wt.error(t), this.channel.emit(SW, t);
  }
};
u(bre, "Preview");
var Vke = bre, vre = class {
  constructor(e, t, r, n) {
    this.channel = e, this.store = t, this.renderStoryToElement = r, this.storyIdByName = /* @__PURE__ */ u((o) => {
      const a = this.nameToStoryId.get(o);
      if (a)
        return a;
      throw new Error(`No story found with that name: ${o}`);
    }, "storyIdByName"), this.componentStories = /* @__PURE__ */ u(() => this.componentStoriesValue, "componentStories"), this.componentStoriesFromCSFFile = /* @__PURE__ */ u((o) => this.store.componentStoriesFromCSFFile({ csfFile: o }), "componentStoriesFromCSFFile"), this.storyById = /* @__PURE__ */ u((o) => {
      if (!o) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      const a = this.storyIdToCSFFile.get(o);
      if (!a)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${o}`);
      return this.store.storyFromCSFFile({ storyId: o, csfFile: a });
    }, "storyById"), this.getStoryContext = /* @__PURE__ */ u((o) => ({
      ...this.store.getStoryContext(o),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext"), this.loadStory = /* @__PURE__ */ u((o) => this.store.loadStory({ storyId: o }), "loadStory"), this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), n.forEach((o, a) => {
      this.referenceCSFFile(o);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(e) {
    this.exportsToCSFFile.set(e.moduleExports, e), this.exportsToCSFFile.set(e.moduleExports.default, e), this.store.componentStoriesFromCSFFile({ csfFile: e }).forEach((t) => {
      const r = e.stories[t.id];
      this.storyIdToCSFFile.set(r.id, e), this.exportToStory.set(r.moduleExport, t);
    });
  }
  attachCSFFile(e) {
    if (!this.exportsToCSFFile.has(e.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    this.attachedCSFFiles.has(e) || (this.attachedCSFFiles.add(e), this.store.componentStoriesFromCSFFile({ csfFile: e }).forEach((t) => {
      this.nameToStoryId.set(t.name, t.id), this.componentStoriesValue.push(t), this.primaryStory || (this.primaryStory = t);
    }));
  }
  referenceMeta(e, t) {
    const r = this.resolveModuleExport(e);
    if (r.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    t && this.attachCSFFile(r.csfFile);
  }
  get projectAnnotations() {
    const { projectAnnotations: e } = this.store;
    if (!e)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return e;
  }
  resolveAttachedModuleExportType(e) {
    if (e === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    const t = Array.from(this.attachedCSFFiles)[0];
    if (e === "meta")
      return { type: "meta", csfFile: t };
    const { component: r } = t.meta;
    if (!r)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: r };
  }
  resolveModuleExport(e) {
    const t = this.exportsToCSFFile.get(e);
    if (t)
      return { type: "meta", csfFile: t };
    const r = this.exportToStory.get(
      Mb(e) ? e.input : e
    );
    return r ? { type: "story", story: r } : { type: "component", component: e };
  }
  resolveOf(e, t = []) {
    let r;
    if (["component", "meta", "story"].includes(e)) {
      const n = e;
      r = this.resolveAttachedModuleExportType(n);
    } else
      r = this.resolveModuleExport(e);
    if (t.length && !t.includes(r.type)) {
      const n = r.type === "component" ? "component or unknown" : r.type;
      throw new Error(Be`Invalid value passed to the 'of' prop. The value was resolved to a '${n}' type but the only types for this block are: ${t.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (r.type) {
      case "component":
        return {
          ...r,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...r,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: r.csfFile })
        };
      case "story":
      default:
        return r;
    }
  }
};
u(vre, "DocsContext");
var wre = vre, _re = class {
  constructor(e, t, r, n) {
    this.channel = e, this.store = t, this.entry = r, this.callbacks = n, this.type = "docs", this.subtype = "csf", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = r.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    const { entryExports: e, csfFiles: t = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw Lb;
    const { importPath: r, title: n } = this.entry, o = this.store.processCSFFileWithCache(
      e,
      r,
      n
    ), a = Object.keys(o.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: o }), this.csfFiles = [o, ...t], this.preparing = !1;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.story && this.story === e.story);
  }
  docsContext(e) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    const t = new wre(
      this.channel,
      this.store,
      e,
      this.csfFiles
    );
    return this.csfFiles.forEach((r) => t.attachCSFFile(r)), t;
  }
  async renderToElement(e, t) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    const r = this.docsContext(t), { docs: n } = this.story.parameters || {};
    if (!n)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    const o = await n.renderer(), { render: a } = o, i = /* @__PURE__ */ u(async () => {
      try {
        await a(r, n, e), this.channel.emit(WA, this.id);
      } catch (s) {
        this.callbacks.showException(s);
      }
    }, "renderDocs");
    return this.rerender = async () => i(), this.teardownRender = async ({ viewModeChanged: s }) => {
      !s || !e || o.unmount(e);
    }, i();
  }
  async teardown({ viewModeChanged: e } = {}) {
    this.teardownRender?.({ viewModeChanged: e }), this.torndown = !0;
  }
};
u(_re, "CsfDocsRender");
var CI = _re, Ere = class {
  constructor(e, t, r, n) {
    this.channel = e, this.store = t, this.entry = r, this.callbacks = n, this.type = "docs", this.subtype = "mdx", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = r.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    const { entryExports: e, csfFiles: t = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw Lb;
    this.csfFiles = t, this.exports = e, this.preparing = !1;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.exports && this.exports === e.exports);
  }
  docsContext(e) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new wre(
      this.channel,
      this.store,
      e,
      this.csfFiles
    );
  }
  async renderToElement(e, t) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    const r = this.docsContext(t), { docs: n } = this.store.projectAnnotations.parameters ?? {};
    if (!n)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    const o = { ...n, page: this.exports.default }, a = await n.renderer(), { render: i } = a, s = /* @__PURE__ */ u(async () => {
      try {
        await i(r, o, e), this.channel.emit(WA, this.id);
      } catch (d) {
        this.callbacks.showException(d);
      }
    }, "renderDocs");
    return this.rerender = async () => s(), this.teardownRender = async ({ viewModeChanged: d } = {}) => {
      !d || !e || (a.unmount(e), this.torndown = !0);
    }, s();
  }
  async teardown({ viewModeChanged: e } = {}) {
    this.teardownRender?.({ viewModeChanged: e }), this.torndown = !0;
  }
};
u(Ere, "MdxDocsRender");
var kI = Ere, zke = globalThis;
function xre(e) {
  const t = e.composedPath && e.composedPath()[0] || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute("contenteditable") !== null;
}
u(xre, "focusInInput");
var Sre = "attached-mdx", Jke = "unattached-mdx";
function Tre({ tags: e }) {
  return e?.includes(Jke) || e?.includes(Sre);
}
u(Tre, "isMdxEntry");
function If(e) {
  return e.type === "story";
}
u(If, "isStoryRender");
function Are(e) {
  return e.type === "docs";
}
u(Are, "isDocsRender");
function $re(e) {
  return Are(e) && e.subtype === "csf";
}
u($re, "isCsfDocsRender");
var Cre = class extends Vke {
  constructor(e, t, r, n) {
    super(e, t, void 0, !1), this.importFn = e, this.getProjectAnnotations = t, this.selectionStore = r, this.view = n, this.initialize();
  }
  setupListeners() {
    super.setupListeners(), zke.onkeydown = this.onKeydown.bind(this), this.channel.on(YA, this.onSetCurrentStory.bind(this)), this.channel.on(UW, this.onUpdateQueryParams.bind(this)), this.channel.on(CW, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new ln({ methodName: "setInitialGlobals" });
    const { globals: e } = this.selectionStore.selectionSpecifier || {};
    e && this.storyStoreValue.userGlobals.updateFromPersisted(e), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(e) {
    return await super.initializeWithStoryIndex(e), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new ln({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier: e, args: t } = this.selectionStore.selectionSpecifier, r = this.storyStoreValue.storyIndex.entryFromSpecifier(e);
    if (!r) {
      e === "*" ? this.renderStoryLoadingException(e, new cve()) : this.renderStoryLoadingException(
        e,
        new uve({ storySpecifier: e.toString() })
      );
      return;
    }
    const { id: n, type: o } = r;
    this.selectionStore.setSelection({ storyId: n, viewMode: o }), this.channel.emit(DW, this.selectionStore.selection), this.channel.emit(u0, this.selectionStore.selection), await this.renderSelection({ persistedArgs: t });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: e }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e,
    storyIndex: t
  }) {
    await super.onStoriesChanged({ importFn: e, storyIndex: t }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(e) {
    if (!this.storyRenders.find((t) => t.disableKeyListeners) && !xre(e)) {
      const { altKey: t, ctrlKey: r, metaKey: n, shiftKey: o, key: a, code: i, keyCode: s } = e;
      this.channel.emit(PW, {
        event: { altKey: t, ctrlKey: r, metaKey: n, shiftKey: o, key: a, code: i, keyCode: s }
      });
    }
  }
  async onSetCurrentStory(e) {
    this.selectionStore.setSelection({ viewMode: "story", ...e }), await this.storeInitializationPromise, this.channel.emit(u0, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(e) {
    this.selectionStore.setQueryParams(e);
  }
  async onUpdateGlobals({ globals: e }) {
    const t = this.currentRender instanceof Q1 && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: e, currentStory: t }), (this.currentRender instanceof kI || this.currentRender instanceof CI) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId: e, updatedArgs: t }) {
    super.onUpdateArgs({ storyId: e, updatedArgs: t });
  }
  async onPreloadStories({ ids: e }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(e.map((t) => this.storyStoreValue?.loadEntry(t)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: e } = {}) {
    const { renderToCanvas: t } = this;
    if (!this.storyStoreValue || !t)
      throw new ln({ methodName: "renderSelection" });
    const { selection: r } = this.selectionStore;
    if (!r)
      throw new Error("Cannot call renderSelection as no selection was made");
    const { storyId: n } = r;
    let o;
    try {
      o = await this.storyStoreValue.storyIdToEntry(n);
    } catch (f) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(n, f);
      return;
    }
    const a = this.currentSelection?.storyId !== n, i = this.currentRender?.type !== o.type;
    o.type === "story" ? this.view.showPreparingStory({ immediate: i }) : this.view.showPreparingDocs({ immediate: i }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let s;
    o.type === "story" ? s = new Q1(
      this.channel,
      this.storyStoreValue,
      t,
      this.mainStoryCallbacks(n),
      n,
      "story"
    ) : Tre(o) ? s = new kI(
      this.channel,
      this.storyStoreValue,
      o,
      this.mainStoryCallbacks(n)
    ) : s = new CI(
      this.channel,
      this.storyStoreValue,
      o,
      this.mainStoryCallbacks(n)
    );
    const d = this.currentSelection;
    this.currentSelection = r;
    const l = this.currentRender;
    this.currentRender = s;
    try {
      await s.prepare();
    } catch (f) {
      l && await this.teardownRender(l), f !== Lb && this.renderStoryLoadingException(n, f);
      return;
    }
    const p = !a && l && !s.isEqual(l);
    if (e && If(s) && (uo(!!s.story), this.storyStoreValue.args.updateFromPersisted(s.story, e)), l && !l.torndown && !a && !p && !i) {
      this.currentRender = l, this.channel.emit(LW, n), this.view.showMain();
      return;
    }
    if (l && await this.teardownRender(l, { viewModeChanged: i }), d && (a || i) && this.channel.emit(jW, n), If(s)) {
      uo(!!s.story);
      const {
        parameters: f,
        initialArgs: h,
        argTypes: m,
        unmappedArgs: g,
        initialGlobals: w,
        userGlobals: _,
        storyGlobals: b,
        globals: x
      } = this.storyStoreValue.getStoryContext(s.story);
      this.channel.emit(MW, {
        id: n,
        parameters: f,
        initialArgs: h,
        argTypes: m,
        args: g
      }), this.channel.emit(Od, { userGlobals: _, storyGlobals: b, globals: x, initialGlobals: w });
    } else {
      let { parameters: f } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: h, globals: m } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(Od, {
        globals: m,
        initialGlobals: h,
        storyGlobals: {},
        userGlobals: m
      }), $re(s) || s.entry.tags?.includes(Sre)) {
        if (!s.csfFiles)
          throw new lve({ storyId: n });
        ({ parameters: f } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: s.csfFiles[0]
        }));
      }
      this.channel.emit(TW, {
        id: n,
        parameters: f
      });
    }
    If(s) ? (uo(!!s.story), this.storyRenders.push(s), this.currentRender.renderToElement(
      this.view.prepareForStory(s.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(e, { viewModeChanged: t = !1 } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== e), await e?.teardown?.({ viewModeChanged: t });
  }
  // UTILITIES
  mainStoryCallbacks(e) {
    return {
      showStoryDuringRender: /* @__PURE__ */ u(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: /* @__PURE__ */ u(() => this.view.showMain(), "showMain"),
      showError: /* @__PURE__ */ u((t) => this.renderError(e, t), "showError"),
      showException: /* @__PURE__ */ u((t) => this.renderException(e, t), "showException")
    };
  }
  renderPreviewEntryError(e, t) {
    super.renderPreviewEntryError(e, t), this.view.showErrorDisplay(t);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(d0);
  }
  renderStoryLoadingException(e, t) {
    wt.error(t), this.view.showErrorDisplay(t), this.channel.emit(d0, e);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(e, t) {
    const { name: r = "Error", message: n = String(t), stack: o } = t, a = this.currentRender?.renderId;
    this.channel.emit(qW, { name: r, message: n, stack: o }), this.channel.emit(ys, { newPhase: "errored", renderId: a, storyId: e }), this.view.showErrorDisplay(t), wt.error(`Error rendering story '${e}':`), wt.error(t);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(e, { title: t, description: r }) {
    const n = this.currentRender?.renderId;
    this.channel.emit(IW, { title: t, description: r }), this.channel.emit(ys, { newPhase: "errored", renderId: n, storyId: e }), this.view.showErrorDisplay({ message: t, stack: r }), wt.error(`Error rendering story ${t}: ${r}`);
  }
};
u(Cre, "PreviewWithSelection");
var Wke = Cre, Z1 = ar(xA(), 1), Gke = ar(xA(), 1), PI = /^[a-zA-Z0-9 _-]*$/, kre = /^-?[0-9]+(\.[0-9]+)?$/, Kke = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, Pre = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, eE = /* @__PURE__ */ u((e = "", t) => e === null || e === "" || !PI.test(e) ? !1 : t == null || t instanceof Date || typeof t == "number" || typeof t == "boolean" ? !0 : typeof t == "string" ? PI.test(t) || kre.test(t) || Kke.test(t) || Pre.test(t) : Array.isArray(t) ? t.every((r) => eE(e, r)) : Yr(t) ? Object.entries(t).every(([r, n]) => eE(r, n)) : !1, "validateArgs"), Yke = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: !0,
  arrayRepeat: !0,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(e) {
    if (e.startsWith("!")) {
      if (e === "!undefined")
        return;
      if (e === "!null")
        return null;
      if (e === "!true")
        return !0;
      if (e === "!false")
        return !1;
      if (e.startsWith("!date(") && e.endsWith(")"))
        return new Date(e.replaceAll(" ", "+").slice(6, -1));
      if (e.startsWith("!hex(") && e.endsWith(")"))
        return `#${e.slice(5, -1)}`;
      const t = e.slice(1).match(Pre);
      if (t)
        return e.startsWith("!rgba") || e.startsWith("!RGBA") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})` : e.startsWith("!hsla") || e.startsWith("!HSLA") ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})` : e.startsWith("!rgb") || e.startsWith("!RGB") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})` : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
    }
    return kre.test(e) ? Number(e) : e;
  }
}, OI = /* @__PURE__ */ u((e) => {
  const t = e.split(";").map((r) => r.replace("=", "~").replace(":", "="));
  return Object.entries((0, Gke.parse)(t.join(";"), Yke)).reduce((r, [n, o]) => eE(n, o) ? Object.assign(r, { [n]: o }) : (qt.warn(Be`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), r), {});
}, "parseArgsParam"), { history: Ore, document: Ua } = xe;
function Rre(e) {
  const t = (e || "").match(/^\/story\/(.+)/);
  if (!t)
    throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
u(Rre, "pathToId");
var jre = /* @__PURE__ */ u(({
  selection: e,
  extraParams: t
}) => {
  const r = Ua?.location.search.slice(1), { path: n, selectedKind: o, selectedStory: a, ...i } = (0, Z1.parse)(r);
  return `?${(0, Z1.stringify)({
    ...i,
    ...t,
    ...e && { id: e.storyId, viewMode: e.viewMode }
  })}`;
}, "getQueryString"), Xke = /* @__PURE__ */ u((e) => {
  if (!e)
    return;
  const t = jre({ selection: e }), { hash: r = "" } = Ua.location;
  Ua.title = e.storyId, Ore.replaceState({}, "", `${Ua.location.pathname}${t}${r}`);
}, "setPath"), Qke = /* @__PURE__ */ u((e) => e != null && typeof e == "object" && Array.isArray(e) === !1, "isObject"), od = /* @__PURE__ */ u((e) => {
  if (e !== void 0) {
    if (typeof e == "string")
      return e;
    if (Array.isArray(e))
      return od(e[0]);
    if (Qke(e))
      return od(
        Object.values(e).filter(Boolean)
      );
  }
}, "getFirstString"), Zke = /* @__PURE__ */ u(() => {
  if (typeof Ua < "u") {
    const e = Ua.location.search.slice(1), t = (0, Z1.parse)(e), r = typeof t.args == "string" ? OI(t.args) : void 0, n = typeof t.globals == "string" ? OI(t.globals) : void 0;
    let o = od(t.viewMode);
    (typeof o != "string" || !o.match(/docs|story/)) && (o = "story");
    const a = od(t.path), i = a ? Rre(a) : od(t.id);
    if (i)
      return { storySpecifier: i, args: r, globals: n, viewMode: o };
  }
  return null;
}, "getSelectionSpecifierFromPath"), Ire = class {
  constructor() {
    this.selectionSpecifier = Zke();
  }
  setSelection(e) {
    this.selection = e, Xke(this.selection);
  }
  setQueryParams(e) {
    const t = jre({ extraParams: e }), { hash: r = "" } = Ua.location;
    Ore.replaceState({}, "", `${Ua.location.pathname}${t}${r}`);
  }
};
u(Ire, "UrlStore");
var ePe = Ire, tPe = ar(Qve(), 1), rPe = ar(xA(), 1), { document: wr } = xe, RI = 100, Nre = /* @__PURE__ */ ((e) => (e.MAIN = "MAIN", e.NOPREVIEW = "NOPREVIEW", e.PREPARING_STORY = "PREPARING_STORY", e.PREPARING_DOCS = "PREPARING_DOCS", e.ERROR = "ERROR", e))(Nre || {}), Bv = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
}, Hv = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
}, jI = new tPe.default({
  escapeXML: !0
}), Mre = class {
  constructor() {
    if (this.testing = !1, typeof wr < "u") {
      const { __SPECIAL_TEST_PARAMETER__: e } = (0, rPe.parse)(wr.location.search.slice(1));
      switch (e) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = !0;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = !0;
          break;
        }
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(e) {
    return this.showStory(), this.applyLayout(e.parameters.layout), wr.documentElement.scrollTop = 0, wr.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return wr.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), wr.documentElement.scrollTop = 0, wr.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return wr.getElementById("storybook-docs");
  }
  applyLayout(e = "padded") {
    if (e === "none") {
      wr.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e);
    const t = Hv[e];
    wr.body.classList.remove(this.currentLayoutClass), wr.body.classList.add(t), this.currentLayoutClass = t;
  }
  checkIfLayoutExists(e) {
    Hv[e] || wt.warn(
      Be`
          The desired layout: ${e} is not a valid option.
          The possible options are: ${Object.keys(Hv).join(", ")}, none.
        `
    );
  }
  showMode(e) {
    clearTimeout(this.preparingTimeout), Object.keys(Nre).forEach((t) => {
      t === e ? wr.body.classList.add(Bv[t]) : wr.body.classList.remove(Bv[t]);
    });
  }
  showErrorDisplay({ message: e = "", stack: t = "" }) {
    let r = e, n = t;
    const o = e.split(`
`);
    o.length > 1 && ([r] = o, n = o.slice(1).join(`
`).replace(/^\n/, "")), wr.getElementById("error-message").innerHTML = jI.toHtml(r), wr.getElementById("error-stack").innerHTML = jI.toHtml(n), this.showMode(
      "ERROR"
      /* ERROR */
    );
  }
  showNoPreview() {
    this.testing || (this.showMode(
      "NOPREVIEW"
      /* NOPREVIEW */
    ), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e = !1 } = {}) {
    clearTimeout(this.preparingTimeout), e ? this.showMode(
      "PREPARING_STORY"
      /* PREPARING_STORY */
    ) : this.preparingTimeout = setTimeout(
      () => this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      ),
      RI
    );
  }
  showPreparingDocs({ immediate: e = !1 } = {}) {
    clearTimeout(this.preparingTimeout), e ? this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ) : this.preparingTimeout = setTimeout(() => this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ), RI);
  }
  showMain() {
    this.showMode(
      "MAIN"
      /* MAIN */
    );
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    wr.body.classList.add(Bv.MAIN);
  }
};
u(Mre, "WebView");
var nPe = Mre, oPe = class extends Wke {
  constructor(e, t) {
    super(e, t, new ePe(), new nPe()), this.importFn = e, this.getProjectAnnotations = t, xe.__STORYBOOK_PREVIEW__ = this;
  }
};
u(oPe, "PreviewWeb");
var { document: ns } = xe, aPe = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
], iPe = "script", II = "scripts-root";
function tE() {
  const e = ns.createEvent("Event");
  e.initEvent("DOMContentLoaded", !0, !0), ns.dispatchEvent(e);
}
u(tE, "simulateDOMContentLoaded");
function Dre(e, t, r) {
  const n = ns.createElement("script");
  n.type = e.type === "module" ? "module" : "text/javascript", e.src ? (n.onload = t, n.onerror = t, n.src = e.src) : n.textContent = e.innerText, r ? r.appendChild(n) : ns.head.appendChild(n), e.parentNode.removeChild(e), e.src || t();
}
u(Dre, "insertScript");
function _P(e, t, r = 0) {
  e[r](() => {
    r++, r === e.length ? t() : _P(e, t, r);
  });
}
u(_P, "insertScriptsSequentially");
function sPe(e) {
  let t = ns.getElementById(II);
  t ? t.innerHTML = "" : (t = ns.createElement("div"), t.id = II, ns.body.appendChild(t));
  const r = Array.from(e.querySelectorAll(iPe));
  if (r.length) {
    const n = [];
    r.forEach((o) => {
      const a = o.getAttribute("type");
      (!a || aPe.includes(a)) && n.push((i) => Dre(o, i, t));
    }), n.length && _P(n, tE, void 0);
  } else
    tE();
}
u(sPe, "simulatePageLoad");
async function lPe(e, t) {
  const r = t.parameters?.docs?.source?.transform, { id: n, unmappedArgs: o } = t, a = r && e ? r?.(e, t) : e, i = a ? await a : void 0;
  Bn.getChannel().emit(Jve, {
    id: n,
    source: i,
    args: o
  });
}
u(lPe, "emitTransformCode");
const Vv = {
  xs: {
    name: "xs: 375px",
    styles: { width: "375px", height: "667px" }
  },
  mobile: {
    name: "mobile: 719px",
    styles: { width: "719px", height: "1024px" }
  },
  sm: {
    name: "sm: 720px",
    styles: { width: "720px", height: "1024px" }
  },
  md: {
    name: "md: 960px",
    styles: { width: "960px", height: "768px" }
  },
  lg: {
    name: "lg: 1280px",
    styles: { width: "1280px", height: "720px" }
  },
  xl: {
    name: "xl: 1440px",
    styles: { width: "1440px", height: "810px" }
  },
  xxl: {
    name: "xxl: 1920px",
    styles: { width: "1920px", height: "1080px" }
  }
};
Object.keys(Vv).reduce(
  (e, t) => ({
    ...e,
    [t]: `${parseInt(Vv[t].styles.width, 10)}x${parseInt(Vv[t].styles.height, 10)}`
  }),
  {}
);
hke({
  name: "withScreenshot",
  parameterName: "screenshot",
  skipIfNoParametersOrOptions: !1,
  wrapper: (e, t, { parameters: r, options: n }) => {
    if (typeof process < "u" && (process == null ? void 0 : Fh.JEST_WORKER_ID) !== void 0)
      return e(t);
    const o = r || n;
    return Ube.triggerScreenshot(o, t), e(t);
  }
});
var Nm = /* @__PURE__ */ ((e) => (e.LTR = "ltr", e.RTL = "rtl", e))(Nm || {}), Br = /* @__PURE__ */ ((e) => (e.SEARCH = "epic-wf-nav-on-search", e.SEARCH_INPUT = "epic-wf-nav-on-input", e.SEARCH_KEYDOWN = "epic-wf-nav-search-on-keydown", e.SEARCH_ACTIVATED = "epic-wf-nav-search-activated", e.NAV_LINK_CLICK = "epic-wf-nav-link-on-click", e.PROPERTY_LOGO_CLICK = "epic-wf-prop-logo-on-click", e.LOCALE_LINK_CLICK = "epic-wf-locale-on-click", e.CTA_CLICK = "epic-wf-cta-on-click", e.ACCOUNT_LINK_CLICK = "epic-wf-account-link-on-click", e.DRAWER_TOGGLE = "epic-wf-drawer-on-toggle", e.IS_READY = "epic-wf-nav-is-ready", e.SEARCH_SET_INPUT_VALUE = "epic-wf-nav-set-input-value", e.SEARCH_SET_INPUT_STATE = "epic-wf-nav-set-input-state", e.SEARCH_CLEAR_INPUT_VALUE = "epic-wf-nav-clear-input-value", e.SEARCH_READY = "epic-wf-nav-search-ready", e.SEARCH_INPUT_FOCUSED = "epic-wf-nav-search-input-focus", e.SEARCH_INPUT_BLURED = "epic-wf-nav-search-input-blur", e.WALLET_BALANCE_CLICK = "epic-wf-nav-wallet-balance-click", e.REWARDS_BALANCE_CLICK = "epic-wf-nav-rewards-balance-click", e.VBUCKS_BALANCE_CLICK = "epic-wf-nav-vbucks-balance-click", e.ICON_CLICK = "epic-wf-nav-icon-click", e))(Br || {});
/*! typescript-cookie v1.0.6 | MIT */
const qre = (e) => encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape), Lre = (e) => encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent), EP = decodeURIComponent, xP = (e) => (e[0] === '"' && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent));
function cPe(e) {
  return e = Object.assign({}, e), typeof e.expires == "number" && (e.expires = new Date(Date.now() + e.expires * 864e5)), e.expires != null && (e.expires = e.expires.toUTCString()), Object.entries(e).filter(([t, r]) => r != null && r !== !1).map(([t, r]) => r === !0 ? `; ${t}` : `; ${t}=${r.split(";")[0]}`).join("");
}
function Fre(e, t, r) {
  const n = /(?:^|; )([^=]*)=([^;]*)/g, o = {};
  let a;
  for (; (a = n.exec(document.cookie)) != null; )
    try {
      const i = r(a[1]);
      if (o[i] = t(a[2], i), e === i)
        break;
    } catch {
    }
  return e != null ? o[e] : o;
}
const NI = Object.freeze({
  decodeName: EP,
  decodeValue: xP,
  encodeName: qre,
  encodeValue: Lre
}), SP = Object.freeze({
  path: "/"
});
function Ure(e, t, r = SP, { encodeValue: n = Lre, encodeName: o = qre } = {}) {
  return document.cookie = `${o(e)}=${n(t, e)}${cPe(r)}`;
}
function Bre(e, { decodeValue: t = xP, decodeName: r = EP } = {}) {
  return Fre(e, t, r);
}
function uPe({ decodeValue: e = xP, decodeName: t = EP } = {}) {
  return Fre(void 0, e, t);
}
function dPe(e, t = SP) {
  Ure(e, "", Object.assign({}, t, {
    expires: -1
  }));
}
function rE(e, t) {
  const r = {
    set: function(o, a, i) {
      return Ure(o, a, Object.assign({}, this.attributes, i), {
        encodeValue: this.converter.write
      });
    },
    get: function(o) {
      if (arguments.length === 0)
        return uPe(this.converter.read);
      if (o != null)
        return Bre(o, this.converter.read);
    },
    remove: function(o, a) {
      dPe(o, Object.assign({}, this.attributes, a));
    },
    withAttributes: function(o) {
      return rE(this.converter, Object.assign({}, this.attributes, o));
    },
    withConverter: function(o) {
      return rE(Object.assign({}, this.converter, o), this.attributes);
    }
  }, n = {
    attributes: { value: Object.freeze(t) },
    converter: { value: Object.freeze(e) }
  };
  return Object.create(r, n);
}
rE({ read: NI.decodeValue, write: NI.encodeValue }, SP);
const pPe = ({
  disabled: e,
  nav: t,
  validPropertyLogo: r
}) => {
  var n, o, a;
  const i = (l) => {
    Qi(l) || (t.flyoutOpen = !0);
  }, s = (l) => {
    !Qi(l) && t.flyoutOpen === !0 && (t.flyoutOpen = !1, t.flyoutMenuFocused = !1);
  }, d = (l) => {
    if (["Space", "Enter", "NumpadEnter"].includes(l.code)) {
      if (t.flyoutMenuFocused) return;
      l.preventDefault(), t.toggleFlyout(l);
    }
    (l.code === "Tab" || l.code === "ArrowDown" || l.code === "ArrowUp") && (t.flyoutMenuFocused = !0);
  };
  return he`
		<div class="global-header__flyout-wrapper ${r ? "hide-in-drawer" : null}">
			<epic-wf-nav-flyout-menu
				@pointerenter=${t.isMobile ? null : i}
				@pointerleave=${t.isMobile ? null : s}
				@epic-wf-nav-flyout-toggle=${t.toggleFlyout}
				@keydown=${d}
				.buttonLabel=${((n = t.navigationFlyout) == null ? void 0 : n.buttonLabel) || ""}
				.mobileFlyoutMenuHeading=${((o = t.navigationFlyout) == null ? void 0 : o.mobileFlyoutMenuHeading) || ""}
				.disabled=${!!e}
				.sections=${((a = t.navigationFlyout) == null ? void 0 : a.sections) || []}
				active=${!!t?.flyoutOpen}
			>
				<div class="friendly-box"></div>
			</epic-wf-nav-flyout-menu>
		</div>
	`;
};
function So(e, t, r, n) {
  var o = arguments.length, a = o < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n, i;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") a = Reflect.decorate(e, t, r, n);
  else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, r, a) : i(t, r)) || a);
  return o > 3 && a && Object.defineProperty(t, r, a), a;
}
function fPe(e, t) {
  if (typeof e != "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hPe(e) {
  var t = fPe(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function mPe(e, t, r) {
  return t = hPe(t), t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function MI(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function DI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MI(Object(r), !0).forEach(function(n) {
      mPe(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : MI(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function qI(e, t) {
  var r = {};
  for (var n in e)
    r[n] = t(e[n], n);
  return r;
}
var yPe = (e, t, r) => {
  for (var n of Object.keys(e)) {
    var o;
    if (e[n] !== ((o = t[n]) !== null && o !== void 0 ? o : r[n]))
      return !1;
  }
  return !0;
}, Fb = (e) => {
  var t = (r) => {
    var n = e.defaultClassName, o = DI(DI({}, e.defaultVariants), r);
    for (var a in o) {
      var i, s = (i = o[a]) !== null && i !== void 0 ? i : e.defaultVariants[a];
      if (s != null) {
        var d = s;
        typeof d == "boolean" && (d = d === !0 ? "true" : "false");
        var l = (
          // @ts-expect-error
          e.variantClassNames[a][d]
        );
        l && (n += " " + l);
      }
    }
    for (var [p, f] of e.compoundVariants)
      yPe(p, o, e.defaultVariants) && (n += " " + f);
    return n;
  };
  return t.variants = () => Object.keys(e.variantClassNames), t.classNames = {
    get base() {
      return e.defaultClassName.split(" ")[0];
    },
    get variants() {
      return qI(e.variantClassNames, (r) => qI(r, (n) => n.split(" ")[0]));
    }
  }, t;
}, gPe = ".eds_xd1k8g0{--eds_xd1k8g1:750ms;--eds_xd1k8g2:1000ms;--eds_xd1k8g3:cubic-bezier(0,0,1,1);--eds_xd1k8g4:cubic-bezier(0.45,0,0.55,1);--eds_xd1k8g5:rgba(0,0,0,0.7);--eds_xd1k8g6:#303034;--eds_xd1k8g7:#101014;--eds_xd1k8g8:#18181c;--eds_xd1k8g9:#202024;--eds_xd1k8ga:#404044;--eds_xd1k8gb:#202024;--eds_xd1k8gc:#28282c;--eds_xd1k8gd:#ffffff;--eds_xd1k8ge:#707074;--eds_xd1k8gf:#808084;--eds_xd1k8gg:#e6e6ea;--eds_xd1k8gh:#303034;--eds_xd1k8gi:#ff3f56;--eds_xd1k8gj:#ff6173;--eds_xd1k8gk:#707074;--eds_xd1k8gl:#aaaaae;--eds_xd1k8gm:#707074;--eds_xd1k8gn:#202024;--eds_xd1k8go:#26bbff;--eds_xd1k8gp:#61cdff;--eds_xd1k8gq:#26bbff;--eds_xd1k8gr:#303034;--eds_xd1k8gs:#404044;--eds_xd1k8gt:#606064;--eds_xd1k8gu:#404044;--eds_xd1k8gv:#606064;--eds_xd1k8gw:#707074;--eds_xd1k8gx:#303034;--eds_xd1k8gy:#e6e6ea;--eds_xd1k8gz:#101014;--eds_xd1k8g10:#101014;--eds_xd1k8g11:rgba(0,0,0,0);--eds_xd1k8g12:#404044;--eds_xd1k8g13:#505054;--eds_xd1k8g14:#28282c;--eds_xd1k8g15:rgba(0,0,0,0);--eds_xd1k8g16:#303034;--eds_xd1k8g17:rgba(0,0,0,0);--eds_xd1k8g18:#45c761;--eds_xd1k8g19:#ffc229;--eds_xd1k8g1a:#ff3f56;--eds_xd1k8g1b:#ff6173;--eds_xd1k8g1c:#ff3f56;--eds_xd1k8g1d:#707074;--eds_xd1k8g1e:rgba(0,0,0,0);--eds_xd1k8g1f:#e6e6ea;--eds_xd1k8g1g:#aaaaae;--eds_xd1k8g1h:#aaaaae;--eds_xd1k8g1i:#101014;--eds_xd1k8g1j:#26bbff;--eds_xd1k8g1k:#61cdff;--eds_xd1k8g1l:#e6e6ea;--eds_xd1k8g1m:#ffffff;--eds_xd1k8g1n:#26bbff;--eds_xd1k8g1o:#61cdff;--eds_xd1k8g1p:#45c761;--eds_xd1k8g1q:#ffc229;--eds_xd1k8g1r:#ff6173;--eds_xd1k8g1s:#101014;--eds_xd1k8g1t:#ffffff;--eds_xd1k8g1u:#ffffff;--eds_xd1k8g1v:#000000;--eds_xd1k8g1w:#101014;--eds_xd1k8g1x:#18181c;--eds_xd1k8g1y:#202024;--eds_xd1k8g1z:#28282c;--eds_xd1k8g20:#303034;--eds_xd1k8g21:#404044;--eds_xd1k8g22:#505054;--eds_xd1k8g23:#606064;--eds_xd1k8g24:#707074;--eds_xd1k8g25:#808084;--eds_xd1k8g26:#aaaaae;--eds_xd1k8g27:#e6e6ea;--eds_xd1k8g28:#26bbff;--eds_xd1k8g29:#61cdff;--eds_xd1k8g2a:#a9d34f;--eds_xd1k8g2b:#bfde7c;--eds_xd1k8g2c:#ffc229;--eds_xd1k8g2d:#ffd15c;--eds_xd1k8g2e:#ff3f56;--eds_xd1k8g2f:#ff6173;--eds_xd1k8g2g:#fe54ba;--eds_xd1k8g2h:#fe73c7;--eds_xd1k8g2i:#be3dff;--eds_xd1k8g2j:#d480ff;--eds_xd1k8g2k:#7371ff;--eds_xd1k8g2l:#aba9ff;--eds_xd1k8g2m:#43dac2;--eds_xd1k8g2n:#89e8d8;--eds_xd1k8g2o:#45c761;--eds_xd1k8g2p:#70d586;--eds_xd1k8g2q:#ff8e1f;--eds_xd1k8g2r:#ffb162;--eds_xd1k8g2s:#fd6535;--eds_xd1k8g2t:#fd7e56;--eds_xd1k8g2u:#b2715d;--eds_xd1k8g2v:#c8988a;--eds_xd1k8g2w:rgba(0,0,0,0);--eds_xd1k8g2x:#e6e6ea;--eds_xd1k8g2y:#aaaaae;--eds_xd1k8g2z:#aaaaae;--eds_xd1k8g30:#101014;--eds_xd1k8g31:#26bbff;--eds_xd1k8g32:#61cdff;--eds_xd1k8g33:#e6e6ea;--eds_xd1k8g34:#ffffff;--eds_xd1k8g35:#26bbff;--eds_xd1k8g36:#61cdff;--eds_xd1k8g37:#45c761;--eds_xd1k8g38:#ffc229;--eds_xd1k8g39:#ff6173;--eds_xd1k8g3a:#101014;--eds_xd1k8g3b:#ffffff;--eds_xd1k8g3c:Inter;--eds_xd1k8g3d:Inter Tight;--eds_xd1k8g3e:Recursive Mono;--eds_xd1k8g3f:400;--eds_xd1k8g3g:500;--eds_xd1k8g3h:700;--eds_xd1k8g3i:900;--eds_xd1k8g3j:0.4;--eds_xd1k8g3k:0.6;--eds_xd1k8g3l:0.8;--eds_xd1k8g3m:0px 1px 1px rgba(0,0,0,0.1),0px 2px 2px rgba(0,0,0,0.1),0px 4px 4px rgba(0,0,0,0.1),0px 6px 8px rgba(0,0,0,0.1),0px 8px 16px rgba(0,0,0,0.1);--eds_xd1k8g3n:0px 2px 1px rgba(0,0,0,0.1),0px 4px 2px rgba(0,0,0,0.1),0px 8px 4px rgba(0,0,0,0.1),0px 16px 8px rgba(0,0,0,0.1),0px 32px 16px rgba(0,0,0,0.1);--eds_xd1k8g3o:2px;--eds_xd1k8g3p:3px;--eds_xd1k8g3q:4px;--eds_xd1k8g3r:5px;--eds_xd1k8g3s:6px;--eds_xd1k8g3t:8px;--eds_xd1k8g3u:10px;--eds_xd1k8g3v:12px;--eds_xd1k8g3w:9999px;--eds_xd1k8g3x:1px;--eds_xd1k8g3y:2px;--eds_xd1k8g3z:0.125rem;--eds_xd1k8g40:0.25rem;--eds_xd1k8g41:0.375rem;--eds_xd1k8g42:0.5rem;--eds_xd1k8g43:0.625rem;--eds_xd1k8g44:0.75rem;--eds_xd1k8g45:0.875rem;--eds_xd1k8g46:1rem;--eds_xd1k8g47:1.25rem;--eds_xd1k8g48:1.5rem;--eds_xd1k8g49:1.75rem;--eds_xd1k8g4a:2rem;--eds_xd1k8g4b:2.5rem;--eds_xd1k8g4c:3rem;--eds_xd1k8g4d:3.5rem;--eds_xd1k8g4e:4rem;--eds_xd1k8g4f:5rem;--eds_xd1k8g4g:6rem;--eds_xd1k8g4h:8rem;--eds_xd1k8g4i:10rem;--eds_xd1k8g4j:2px;--eds_xd1k8g4k:4px;--eds_xd1k8g4l:6px;--eds_xd1k8g4m:8px;--eds_xd1k8g4n:10px;--eds_xd1k8g4o:12px;--eds_xd1k8g4p:14px;--eds_xd1k8g4q:16px;--eds_xd1k8g4r:20px;--eds_xd1k8g4s:24px;--eds_xd1k8g4t:28px;--eds_xd1k8g4u:32px;--eds_xd1k8g4v:40px;--eds_xd1k8g4w:48px;--eds_xd1k8g4x:56px;--eds_xd1k8g4y:64px;--eds_xd1k8g4z:80px;--eds_xd1k8g50:96px;--eds_xd1k8g51:128px;--eds_xd1k8g52:160px;--eds_xd1k8g53:0em;--eds_xd1k8g54:0.02em;--eds_xd1k8g55:0.1em;--eds_xd1k8g56:100%;--eds_xd1k8g57:125%;--eds_xd1k8g58:150%;--eds_xd1k8g59:165%;--eds_xd1k8g5a:0.75rem;--eds_xd1k8g5b:0.875rem;--eds_xd1k8g5c:1rem;--eds_xd1k8g5d:1.25rem;--eds_xd1k8g5e:1.5rem;--eds_xd1k8g5f:2rem;--eds_xd1k8g5g:2.5rem;--eds_xd1k8g5h:3.25rem;--eds_xd1k8g5i:4rem;--eds_xd1k8g5j:16px;}", bPe = "eds_xd1k8g0", vPe = ".eds_5a2e4c0{position:relative;overflow:hidden;display:grid;place-items:center;box-sizing:border-box;}.eds_5a2e4c1{display:grid;place-items:end;}.eds_5a2e4c2{background-color:inherit;border:none;outline:none;cursor:pointer;text-decoration:none;}.eds_5a2e4c3{display:inline-flex;align-items:center;max-width:fit-content;}.eds_5a2e4c2:focus-visible .eds_5a2e4c3{outline:none;}.eds_5a2e4c2:hover .eds_5a2e4c3{cursor:pointer;}.eds_5a2e4c4{width:100%;height:100%;background-size:cover;color:transparent;}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4c4{opacity:0.8;}.eds_5a2e4c5{display:none;}.eds_5a2e4c6{border-radius:var(--eds_xd1k8g3w);font-family:var(--eds_xd1k8g3c),sans-serif;font-weight:var(--eds_xd1k8g3g);line-height:var(--eds_xd1k8g54);color:var(--eds_xd1k8g2x);text-align:center;position:relative;display:grid;grid-area:stack;align-items:center;justify-content:center;overflow:hidden;}.eds_5a2e4c3.eds_5a2e4c2:focus-visible .eds_5a2e4c6{outline-offset:calc(var(--eds_xd1k8g40) - var(--eds_xd1k8g3y));outline-color:var(--eds_xd1k8gd);outline-width:var(--eds_xd1k8g3y);outline-style:solid;}.eds_5a2e4c7{width:var(--eds_xd1k8g4e);height:var(--eds_xd1k8g4e);font-size:var(--eds_xd1k8g5e);}.eds_5a2e4c8{width:var(--eds_xd1k8g4c);height:var(--eds_xd1k8g4c);font-size:18px;}.eds_5a2e4c9{width:var(--eds_xd1k8g4b);height:var(--eds_xd1k8g4b);font-size:var(--eds_xd1k8g5c);}.eds_5a2e4ca{width:var(--eds_xd1k8g4a);height:var(--eds_xd1k8g4a);font-size:var(--eds_xd1k8g5b);}.eds_5a2e4cb{width:var(--eds_xd1k8g48);height:var(--eds_xd1k8g48);font-size:var(--eds_xd1k8g5a);}.eds_5a2e4cc{background-color:var(--eds_xd1k8gs);color:var(--eds_xd1k8g2x);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cc{background-color:var(--eds_xd1k8gt);}.eds_5a2e4cd{background-color:var(--eds_xd1k8g2e);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cd{background-color:var(--eds_xd1k8g2f);}.eds_5a2e4ce{background-color:var(--eds_xd1k8g2g);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4ce{background-color:var(--eds_xd1k8g2h);}.eds_5a2e4cf{background-color:var(--eds_xd1k8g2i);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cf{background-color:var(--eds_xd1k8g2j);}.eds_5a2e4cg{background-color:var(--eds_xd1k8g2k);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cg{background-color:var(--eds_xd1k8g2l);}.eds_5a2e4ch{background-color:var(--eds_xd1k8go);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4ch{background-color:var(--eds_xd1k8gp);}.eds_5a2e4ci{background-color:var(--eds_xd1k8g2m);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4ci{background-color:var(--eds_xd1k8g2n);}.eds_5a2e4cj{background-color:var(--eds_xd1k8g2o);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cj{background-color:var(--eds_xd1k8g2p);}.eds_5a2e4ck{background-color:var(--eds_xd1k8g2a);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4ck{background-color:var(--eds_xd1k8g2b);}.eds_5a2e4cl{background-color:var(--eds_xd1k8g2c);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cl{background-color:var(--eds_xd1k8g2d);}.eds_5a2e4cm{background-color:var(--eds_xd1k8g2q);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cm{background-color:var(--eds_xd1k8g2r);}.eds_5a2e4cn{background-color:var(--eds_xd1k8g2s);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4cn{background-color:var(--eds_xd1k8g2t);}.eds_5a2e4co{background-color:var(--eds_xd1k8g2u);color:var(--eds_xd1k8g3a);}.eds_5a2e4c3.eds_5a2e4c2:hover .eds_5a2e4co{background-color:var(--eds_xd1k8g2v);}.eds_5a2e4cp{font-family:var(--eds_xd1k8g3c),sans-serif;font-weight:var(--eds_xd1k8g3f);line-height:var(--eds_xd1k8g59);letter-spacing:var(--eds_xd1k8g54);color:var(--eds_xd1k8g2x);}.eds_5a2e4cq{font-size:var(--eds_xd1k8g5c);padding-inline-start:var(--eds_xd1k8g46);}.eds_5a2e4cr{font-size:var(--eds_xd1k8g5c);padding-inline-start:var(--eds_xd1k8g45);}.eds_5a2e4cs{font-size:var(--eds_xd1k8g5c);padding-inline-start:var(--eds_xd1k8g44);}.eds_5a2e4ct{font-size:var(--eds_xd1k8g5b);padding-inline-start:var(--eds_xd1k8g43);}.eds_5a2e4cu{font-size:var(--eds_xd1k8g5a);padding-inline-start:var(--eds_xd1k8g42);}.eds_5a2e4cw{width:var(--eds_xd1k8g49);height:var(--eds_xd1k8g49);}.eds_5a2e4cx{width:var(--eds_xd1k8g48);height:var(--eds_xd1k8g48);}.eds_5a2e4cy{width:var(--eds_xd1k8g47);height:var(--eds_xd1k8g47);}.eds_5a2e4cz{width:var(--eds_xd1k8g47);height:var(--eds_xd1k8g47);}.eds_5a2e4c10{width:var(--eds_xd1k8g46);height:var(--eds_xd1k8g46);}", wPe = Fb({ defaultClassName: "eds_5a2e4c6", variantClassNames: { size: { "2xl": "eds_5a2e4c7", xl: "eds_5a2e4c8", lg: "eds_5a2e4c9", md: "eds_5a2e4ca", sm: "eds_5a2e4cb" }, color: { gray: "eds_5a2e4cc", red: "eds_5a2e4cd", pink: "eds_5a2e4ce", purple: "eds_5a2e4cf", indigo: "eds_5a2e4cg", blue: "eds_5a2e4ch", cyan: "eds_5a2e4ci", green: "eds_5a2e4cj", lime: "eds_5a2e4ck", yellow: "eds_5a2e4cl", amber: "eds_5a2e4cm", orange: "eds_5a2e4cn", brown: "eds_5a2e4co" } }, defaultVariants: {}, compoundVariants: [] }), _Pe = "eds_5a2e4c1";
Fb({ defaultClassName: "eds_5a2e4cv", variantClassNames: { size: { "2xl": "eds_5a2e4cw", xl: "eds_5a2e4cx", lg: "eds_5a2e4cy", md: "eds_5a2e4cz", sm: "eds_5a2e4c10" } }, defaultVariants: {}, compoundVariants: [] });
var EPe = Fb({ defaultClassName: "eds_5a2e4cp", variantClassNames: { size: { "2xl": "eds_5a2e4cq", xl: "eds_5a2e4cr", lg: "eds_5a2e4cs", md: "eds_5a2e4ct", sm: "eds_5a2e4cu" } }, defaultVariants: {}, compoundVariants: [] }), xPe = "eds_5a2e4c3", SPe = "eds_5a2e4c4", TPe = "eds_5a2e4c2", APe = ".eds_1admtkn0{border-radius:var(--eds_xd1k8g3w);border-color:var(--eds_xd1k8g7);border-style:solid;background-color:var(--eds_xd1k8g2a);display:inline-flex;isolation:isolate;grid-area:stack;box-sizing:border-box;}.eds_1admtkn1{width:calc(var(--eds_xd1k8g46) + (var(--eds_xd1k8g40) * 2));height:calc(var(--eds_xd1k8g46) + (var(--eds_xd1k8g40) * 2));border-width:var(--eds_xd1k8g40);}.eds_1admtkn2{width:calc(var(--eds_xd1k8g44) + 6px);height:calc(var(--eds_xd1k8g44) + 6px);border-width:3px;}.eds_1admtkn3{width:calc(var(--eds_xd1k8g43) + 5px);height:calc(var(--eds_xd1k8g43) + 5px);border-width:2.5px;}.eds_1admtkn4{width:calc(var(--eds_xd1k8g42) + (var(--eds_xd1k8g3y) * 2));height:calc(var(--eds_xd1k8g42) + (var(--eds_xd1k8g3y) * 2));border-width:var(--eds_xd1k8g3y);}.eds_1admtkn5{width:calc(var(--eds_xd1k8g41) + 3px);height:calc(var(--eds_xd1k8g41) + 3px);border-width:1.5px;}", $Pe = Fb({ defaultClassName: "eds_1admtkn0", variantClassNames: { size: { "2xl": "eds_1admtkn1", xl: "eds_1admtkn2", lg: "eds_1admtkn3", md: "eds_1admtkn4", sm: "eds_1admtkn5" } }, defaultVariants: {}, compoundVariants: [] });
let Sn = class extends Dm {
  constructor() {
    super(...arguments), this.onclick = null, this.size = "md", this.color = "gray";
  }
  render() {
    var t;
    const r = this.onclick != null || this.href != null, n = this.href ? Jb`a` : this.onclick ? Jb`button` : Jb`div`, o = Array.from(this.label && this.label.trim() || "")[0];
    return Fp`<${n}
      class=${Gre({
      [bPe]: !0,
      [xPe]: !0,
      [TPe]: r
    })}
      @click=${this.onclick}
      href=${(t = this.href) !== null && t !== void 0 ? t : Kre}
    >
      <span class=${_Pe}>
        <span
          class=${wPe({
      size: this.size,
      color: this.color
    })}
        >
          ${this.image ? Fp`<img class=${SPe} src=${this.image} />` : o}
        </span>
        ${this.badge ? Fp`<span
                class=${$Pe({ size: this.size })}
                aria-label=${this.badgeLabel}
              />` : ""}
      </span>
      ${this.hideLabel ? "" : Fp`<span class=${EPe({ size: this.size })}>
              ${this.label}
            </span>`}</${n}>`;
  }
};
Sn.styles = oE`
    ${Pu(gPe)}
    ${Pu(vPe)}
    ${Pu(APe)}
  `;
So([
  Te({ type: String })
], Sn.prototype, "label", void 0);
So([
  Te({ type: String })
], Sn.prototype, "image", void 0);
So([
  Te({ type: Function })
], Sn.prototype, "onclick", void 0);
So([
  Te({ type: String })
], Sn.prototype, "href", void 0);
So([
  Te({ type: String })
], Sn.prototype, "size", void 0);
So([
  Te({ type: String })
], Sn.prototype, "color", void 0);
So([
  Te({ type: Boolean })
], Sn.prototype, "badge", void 0);
So([
  Te({ type: String })
], Sn.prototype, "badgeLabel", void 0);
So([
  Te({ type: Boolean })
], Sn.prototype, "hideLabel", void 0);
Sn = So([
  eM("eds-avatar")
], Sn);
const CPe = (e, t, r = "nav-account-menu") => {
  var n, o;
  const a = (n = t.sections) == null ? void 0 : n.slice(0, 4);
  if (!a?.length)
    return he``;
  const i = e.getMappedHygraphLocale(e.locale || "");
  return he`
		<epic-wf-nav-vertical-menu id=${r}>
			<div class="avatar-wrapper margin-block-end-0">
				${e.isLoggedIn && e.displayName ? he`<eds-avatar label=${e.displayName} size="lg"></eds-avatar>` : ""}
			</div>
			${(o = e?.customAccountLinks) != null && o.length && Array.isArray(e.customAccountLinks) ? he`<epic-wf-menu-section .eyebrow=${!0} .headingDisabled=${!0}>
						<div slot="content">
							${e.customAccountLinks.map(
    (s) => he`
									<epic-wf-menu-item
										role="listitem"
										@click=${(d) => {
      e._mainAccountLinkClick(d, s);
    }}
										hrefTemplate=${jt({
      hrefTemplate: s.hrefTemplate || "",
      domain: e?.domain || "",
      locale: i
    })}
										locale=${i}
										label=${s.label || ""}
										endIcon=${s.endIcon || ""}
										endIconColor="secondary"
										labelBeforeStyle=${s.labelBeforeStyle || ""}
										labelAfterStyle=${s.labelAfterStyle || ""}
										labelStyle=${s.labelStyle || ""}
										domain=${e?.domain || ""}
									></epic-wf-menu-item>
								`
  )}
						</div>
					</epic-wf-menu-section>` : he``}
			${a.map((s, d) => !s.__typename || s.__typename === "NavAccountMenuSection" ? he`
						<epic-wf-menu-section .eyebrow=${!0} .headingDisabled=${!s?.heading}>
							<h4 slot="heading">${s.heading}</h4>

							<div slot="content">
								${s.items.map((l) => {
    if (!l.__typename || l.__typename === "NavMenuIconLink") {
      if (l.hidden) return he``;
      const p = {
        __typename: "NavLink",
        id: l.id,
        hrefTemplate: l.hrefTemplate,
        relativePath: l.relativePath,
        locale: l.locale,
        key: l.key,
        label: l.label || "",
        owner: l.owner
      }, f = p?.key || "", h = e.accountLinkOverrides[f] || {};
      return he`
											<epic-wf-menu-item
												@click=${(m) => {
        e._mainAccountLinkClick(m, p);
      }}
												label=${l.label || ""}
												hrefTemplate=${jt({
        hrefTemplate: l.hrefTemplate || "",
        domain: e?.domain || "",
        locale: i
      })}
												locale=${i}
												owner=${l.owner || ""}
												key=${l.key || ""}
												startIcon=${l.startIcon || ""}
												startIconColor=${s.brandColor || s.accentColor || ""}
												endIcon=${l.endIcon || ""}
												domain=${e?.domain || ""}
												labelStyle=${Ln(h?.labelStyle)}
												labelBeforeStyle=${Ln(h?.labelBeforeStyle)}
												labelAfterStyle=${Ln(h?.labelAfterStyle)}
											>
											</epic-wf-menu-item>
										`;
    }
    return he``;
  })}
								${e.signOutLink && d === a.length - 1 ? he`
											<epic-wf-menu-item
												@click=${(l) => {
    e._mainAccountLinkClick(l, e.signOutLink);
  }}
												label=${e.signOutLink.label || ""}
												locale=${i}
												hrefTemplate=${jt({
    hrefTemplate: e.signOutLinkHref || e.signOutLink.hrefTemplate || "",
    domain: e?.domain || "",
    locale: i
  })}
												startIcon="arrow_right_from_bracket"
												domain=${e?.domain || ""}
											>
											</epic-wf-menu-item>
										` : he``}
							</div>
						</epic-wf-menu-section>
					` : he``)}
		</epic-wf-nav-vertical-menu>
	`;
}, kPe = (e, t, r) => {
  var n;
  const o = (n = t.sections) == null ? void 0 : n.slice(0, 4), a = e.getMappedHygraphLocale(e.locale || "");
  return he`
		<epic-wf-nav-vertical-menu>
			${r ? he`<div class="menu-heading no-margin">${r}</div>` : ""}
			${o.map((i) => {
    if (i.__typename === "NavMenuSection")
      return he`
						<epic-wf-menu-section .eyebrow=${!0}>
							<h4 slot="heading">${i.heading}</h4>

							<div slot="content">
								${i.items.map((s) => {
        if (s.__typename === "NavMenuIconLink") {
          if (s.hidden) return he``;
          const d = {
            __typename: "NavLink",
            id: s.id,
            hrefTemplate: s.hrefTemplate,
            relativePath: s.relativePath,
            locale: s.locale,
            key: s.key,
            label: s.label || "",
            owner: s.owner
          };
          return he`
											<epic-wf-menu-item
												@click=${(l) => e._navLinkClick(l, d)}
												label=${s.label || ""}
												hrefTemplate=${s.hrefTemplate || ""}
												locale=${a}
												owner=${s.owner || ""}
												key=${s.key || ""}
												startIcon=${s.startIcon || ""}
												startIconColor=${i.brandColor || i.accentColor || ""}
												endIcon=${s.endIcon || ""}
												domain=${e?.domain || ""}
											>
											</epic-wf-menu-item>
										`;
        }
        return he``;
      })}
							</div>
						</epic-wf-menu-section>
					`;
    if (i.__typename === "NavMenuCtaSection") {
      const s = {
        __typename: "NavLink",
        id: i.id,
        hrefTemplate: i.hrefTemplate,
        relativePath: i.relativePath,
        locale: i.locale,
        key: i.key,
        label: i.label || "",
        owner: i.owner
      };
      return he`
						<epic-wf-menu-section .eyebrow=${!0}>
							<h4 slot="heading">${i.heading}</h4>

							<div slot="content">
								<epic-wf-description-cta
									@click=${(d) => e._navLinkClick(d, s)}
									description=${i.description || ""}
									label=${i.label || ""}
									hrefTemplate=${i.hrefTemplate || ""}
									locale=${a}
									owner=${i.owner || ""}
									key=${i.key || ""}
									.compact=${i.compact || !1}
									domain=${e?.domain || ""}
								>
								</epic-wf-description-cta>
							</div>
						</epic-wf-menu-section>
					`;
    }
    return he``;
  })}
		</epic-wf-nav-vertical-menu>
	`;
}, PPe = (e, t = "nav-account-menu", r = "Account") => {
  var n, o;
  return (o = (n = e?.accountMenu) == null ? void 0 : n.sections) != null && o.length && e.accountMenu.sections.length > 0 ? he`${CPe(e, e.accountMenu, t)}` : he`
		<epic-wf-simple-menu id=${t}>
			<div class="menu-heading"><h2>${r}</h2></div>
			<div class="avatar-wrapper">
				${e.isLoggedIn && e.displayName ? he`<eds-avatar label=${e.displayName} size="lg"></eds-avatar>` : ""}
			</div>
			<div class="menu-wrap" role="list">
				${e?.customAccountLinks && Array.isArray(e.customAccountLinks) ? e.customAccountLinks.map(
    (a) => he`
								<epic-wf-menu-item
									role="listitem"
									@click=${(i) => {
      e._mainAccountLinkClick(i, a);
    }}
									hrefTemplate=${a.hrefTemplate || ""}
									locale=${e.getMappedHygraphLocale(e.locale || "")}
									label=${a.label || ""}
									endIcon=${a.endIcon || ""}
									endIconColor="secondary"
									labelBeforeStyle=${a.labelBeforeStyle || ""}
									labelAfterStyle=${a.labelAfterStyle || ""}
									labelStyle=${a.labelStyle || ""}
									domain=${e?.domain || ""}
								></epic-wf-menu-item>
							`
  ) : null}
				${e.accountLinks.map((a) => {
    const i = a?.key || "", s = e.accountLinkOverrides[i] || {};
    return he`
						<epic-wf-menu-item
							role="listitem"
							@click=${(d) => {
      e._mainAccountLinkClick(d, a);
    }}
							hrefTemplate=${a.hrefTemplate || ""}
							locale=${e.getMappedHygraphLocale(e.locale || "")}
							label=${a.label || ""}
							endIcon=${a.endIcon || ""}
							endIconColor="secondary"
							domain=${e?.domain || ""}
							labelStyle=${Ln(s?.labelStyle)}
							labelBeforeStyle=${Ln(s?.labelBeforeStyle)}
							labelAfterStyle=${Ln(s?.labelAfterStyle)}
						></epic-wf-menu-item>
					`;
  })}
				${e.signOutLink ? he`
							<epic-wf-menu-item
								role="listitem"
								@click=${(a) => {
    e._mainAccountLinkClick(a, e.signOutLink);
  }}
								hrefTemplate=${e.signOutLinkHref || e.signOutLink.hrefTemplate || ""}
								locale=${e.getMappedHygraphLocale(e.locale || "")}
								label=${e.signOutLink.label || ""}
								endIcon=${e.signOutLink.endIcon || ""}
								endIconColor="secondary"
								domain=${e?.domain || ""}
							></epic-wf-menu-item>
						` : ""}
			</div>
		</epic-wf-simple-menu>
	`;
}, OPe = (e, t, r, n) => {
  var o;
  return he`
		<button
			@click=${t.onClick}
			aria-controls=${r}
			aria-expanded="${e.accountMenuOpen ? "true" : "false"}"
			aria-label="Account menu"
			class="dropdown__button"
			title=${e.displayName}
		>
			${n}
		</button>
		${PPe(e, r, ((o = e.commonStrings) == null ? void 0 : o.mobileAccountMenuHeading) || "")}
	`;
}, RPe = (e) => {
  var t, r, n;
  return he`
		<a
			class="dropdown__button secondary-cta"
			@click=${(o) => {
    e._mainAccountLinkClick(o, e.signInLink);
  }}
			href="${jt({
    domain: e.domain,
    locale: e.getMappedHygraphLocale(e.locale),
    hrefTemplate: e.signInLinkHref || ((t = e.signInLink) == null ? void 0 : t.hrefTemplate)
  })}"
			aria-label="${((r = e.signInLink) == null ? void 0 : r.label) || ""}"
		>
			<span class="label">${((n = e.signInLink) == null ? void 0 : n.label) || ""}</span>
		</a>
	`;
}, jPe = (e, t, r = "nav-account-menu") => {
  var n;
  if (!((n = e?.signInLink) != null && n.label))
    return he``;
  const o = he`<eds-avatar label=${e.displayName} .hideLabel=${e.isLargeDown} size="md"></eds-avatar>`;
  return he`
		<div
			@mouseleave=${t.onMouseLeave}
			@mouseover=${t.onMouseOver}
			class="dropdown dropdown--account ${e.accountMenuOpen ? "open" : ""}"
		>
			${e.isLoggedIn ? OPe(e, t, r, o) : RPe(e)}
		</div>
	`;
}, Hre = (e, t = {}) => {
  var r;
  if (!Array.isArray(e?.icons) || !((r = e?.icons) != null && r.length)) return he``;
  let n = e.icons;
  const o = n?.filter((a) => a.mobileTopLevel).slice(0, 2);
  return t.mobileTopLevel ? n = o : (e.isMobile && (n = n.filter((i) => !o.includes(i))), n = !!(e.vbucksBalance || e.rewardsBalance || e.walletBalance) ? n.slice(0, 3) : n.slice(0, 6)), he`
		<div class="icons" data-mobile-top-level=${Ln(t.mobileTopLevel)}>
			${n.map((a) => {
    const i = he`
					<epic-wf-eds-icon icon=${a.icon}></epic-wf-eds-icon>
					${fn(
      a.count,
      () => he`<span class="badge">${a.count && a.count > 99 ? "99+" : a.count}</span>`
    )}
				`, s = (l) => {
      e._iconClick(l, a);
    };
    let d;
    return a.hrefTemplate ? (d = jt({
      hrefTemplate: a.hrefTemplate,
      locale: e.getMappedHygraphLocale(e.locale),
      domain: e.domain
    }), he`<a class="icon" href=${d} @click=${s} title=${a.label}>${i}</a>`) : he`<button class="icon" @click=${s} title=${a.label}>${i}</button>`;
  })}
		</div>
	`;
};
var LI;
(function(e) {
  e.AltTextAsc = "altText_ASC", e.AltTextDesc = "altText_DESC", e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.FileNameAsc = "fileName_ASC", e.FileNameDesc = "fileName_DESC", e.HandleAsc = "handle_ASC", e.HandleDesc = "handle_DESC", e.HeightAsc = "height_ASC", e.HeightDesc = "height_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.MimeTypeAsc = "mimeType_ASC", e.MimeTypeDesc = "mimeType_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.SizeAsc = "size_ASC", e.SizeDesc = "size_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC", e.WidthAsc = "width_ASC", e.WidthDesc = "width_DESC";
})(LI || (LI = {}));
var FI;
(function(e) {
  e.AssetCreatePending = "ASSET_CREATE_PENDING", e.AssetErrorUpload = "ASSET_ERROR_UPLOAD", e.AssetUpdatePending = "ASSET_UPDATE_PENDING", e.AssetUploadComplete = "ASSET_UPLOAD_COMPLETE";
})(FI || (FI = {}));
var UI;
(function(e) {
  e.Epicgames = "epicgames", e.Fallguys = "fallguys", e.Fortnite = "fortnite", e.Rocketleague = "rocketleague", e.Twinmotion = "twinmotion";
})(UI || (UI = {}));
var BI;
(function(e) {
  e.Artstation = "artstation", e.Communities = "communities", e.Devportal = "devportal", e.Edc = "edc", e.Egs = "egs", e.Eos = "eos", e.Epicgames = "epicgames", e.Fab = "fab", e.Fallguys = "fallguys", e.Fortnite = "fortnite", e.Kws = "kws", e.Metahuman = "metahuman", e.Pcbs = "pcbs", e.Quixel = "quixel", e.Realitycapture = "realitycapture", e.Rocketleague = "rocketleague", e.Sac = "sac", e.Sideswipe = "sideswipe", e.Ssp = "ssp", e.Twinmotion = "twinmotion", e.Unrealengine = "unrealengine";
})(BI || (BI = {}));
var HI;
(function(e) {
  e.BackButtonAccessibleLabelAsc = "backButtonAccessibleLabel_ASC", e.BackButtonAccessibleLabelDesc = "backButtonAccessibleLabel_DESC", e.BackButtonLabelAsc = "backButtonLabel_ASC", e.BackButtonLabelDesc = "backButtonLabel_DESC", e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.MobileAccountMenuHeadingAsc = "mobileAccountMenuHeading_ASC", e.MobileAccountMenuHeadingDesc = "mobileAccountMenuHeading_DESC", e.MobileLanguageMenuHeadingAsc = "mobileLanguageMenuHeading_ASC", e.MobileLanguageMenuHeadingDesc = "mobileLanguageMenuHeading_DESC", e.MobileMainMenuHeadingAsc = "mobileMainMenuHeading_ASC", e.MobileMainMenuHeadingDesc = "mobileMainMenuHeading_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.RewardsBalanceAsc = "rewardsBalance_ASC", e.RewardsBalanceDesc = "rewardsBalance_DESC", e.SearchActivateLabelAsc = "searchActivateLabel_ASC", e.SearchActivateLabelDesc = "searchActivateLabel_DESC", e.SearchCancelLabelAsc = "searchCancelLabel_ASC", e.SearchCancelLabelDesc = "searchCancelLabel_DESC", e.SearchDeactivateLabelAsc = "searchDeactivateLabel_ASC", e.SearchDeactivateLabelDesc = "searchDeactivateLabel_DESC", e.SearchPlaceholderLabelAsc = "searchPlaceholderLabel_ASC", e.SearchPlaceholderLabelDesc = "searchPlaceholderLabel_DESC", e.SearchSubmitLabelAsc = "searchSubmitLabel_ASC", e.SearchSubmitLabelDesc = "searchSubmitLabel_DESC", e.SkipNavLabelAsc = "skipNavLabel_ASC", e.SkipNavLabelDesc = "skipNavLabel_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC", e.VbucksBalanceAsc = "vbucksBalance_ASC", e.VbucksBalanceDesc = "vbucksBalance_DESC", e.WalletBalanceAsc = "walletBalance_ASC", e.WalletBalanceDesc = "walletBalance_DESC";
})(HI || (HI = {}));
var VI;
(function(e) {
  e.AutoImage = "autoImage", e.Avif = "avif", e.Bmp = "bmp", e.Gif = "gif", e.Heic = "heic", e.Jpg = "jpg", e.Png = "png", e.Svg = "svg", e.Tiff = "tiff", e.Webp = "webp";
})(VI || (VI = {}));
var zI;
(function(e) {
  e.Amber = "amber", e.Blue = "blue", e.Brown = "brown", e.Cyan = "cyan", e.Green = "green", e.Indigo = "indigo", e.Lime = "lime", e.Orange = "orange", e.Pink = "pink", e.Purple = "purple", e.Red = "red", e.Yellow = "yellow";
})(zI || (zI = {}));
var nE;
(function(e) {
  e.ArrowRightFromBracket = "arrow_right_from_bracket", e.ArrowUpCircle = "arrow_up_circle", e.ArrowUpRightFromSquare = "arrow_up_right_from_square", e.Bell = "bell", e.Bookmark = "bookmark", e.BoxPlus = "box_plus", e.BrickWall = "brick_wall", e.Calendar = "calendar", e.ChartLineUpTrendXyAxis = "chart_line_up_trend_xy_axis", e.Check = "check", e.CircleLineRightDownCircleLineToLeftUp = "circle_line_right_down_circle_line_to_left_up", e.CirclesBottomLeftTopRight = "circles_bottom_left_top_right", e.ClockArrowRotateLeft = "clock_arrow_rotate_left", e.Cog = "cog", e.CombinedGeometricShapes = "combined_geometric_shapes", e.Compass = "compass", e.CreditCard = "credit_card", e.Cube = "cube", e.Discord = "discord", e.Display = "display", e.DollarSignCircle = "dollar_sign_circle", e.Envelope = "envelope", e.EpicGames = "epic_games", e.EpicRewardsFilled = "epic_rewards_filled", e.Fab = "fab", e.Facebook = "facebook", e.FileLines = "file_lines", e.Fortnite = "fortnite", e.Gamepad = "gamepad", e.Gift = "gift", e.GiftCard = "gift_card", e.Globe = "globe", e.GraduationCap = "graduation_cap", e.Heart = "heart", e.IdCard = "id_card", e.Image = "image", e.ImagePanorama = "image_panorama", e.ImagesStacked = "images_stacked", e.Instagram = "instagram", e.Layout_4 = "layout_4", e.LinesSquareStack = "lines_square_stack", e.Linkedin = "linkedin", e.Metahuman = "metahuman", e.Moon = "moon", e.MultipleShapes = "multiple_shapes", e.MusicNote = "music_note", e.Newspaper = "newspaper", e.NintendoSwitch = "nintendo_switch", e.Note = "note", e.PaintBrush = "paint_brush", e.Percent = "percent", e.PercentSeal = "percent_seal", e.Playstation = "playstation", e.PowerCord = "power_cord", e.QuestionCircle = "question_circle", e.Receipt = "receipt", e.Reddit = "reddit", e.Rocket = "rocket", e.Rss = "rss", e.ShoppingCartMinus = "shopping_cart_minus", e.Snapchat = "snapchat", e.Sparkle = "sparkle", e.SquareGrid_2x2 = "square_grid_2x2", e.SquareOnTiltedSquare = "square_on_tilted_square", e.Star = "star", e.Sticker = "sticker", e.Tag = "tag", e.TalkBubbleDots = "talk_bubble_dots", e.Template = "template", e.Tiktok = "tiktok", e.Trophy = "trophy", e.Twinmotion = "twinmotion", e.Twitch = "twitch", e.TwitterX = "twitter_x", e.Unity = "unity", e.UnrealEngine = "unreal_engine", e.User = "user", e.UserGroup = "user_group", e.UserLink = "user_link", e.VBucks = "v_bucks", e.Vk = "vk", e.Wallet = "wallet", e.Waveform = "waveform", e.Xbox = "xbox", e.Youtube = "youtube";
})(nE || (nE = {}));
var JI;
(function(e) {
  e.Asset = "Asset", e.CommonStrings = "CommonStrings", e.Footer = "Footer", e.FooterBottomLinks = "FooterBottomLinks", e.FooterButton = "FooterButton", e.FooterColumn = "FooterColumn", e.FooterCopyright = "FooterCopyright", e.FooterLink = "FooterLink", e.FooterPropertyLogo = "FooterPropertyLogo", e.FooterSocialIcon = "FooterSocialIcon", e.FooterTagsBrandIcon = "FooterTagsBrandIcon", e.FooterTagsLegal = "FooterTagsLegal", e.FooterTagsLegalCard = "FooterTagsLegalCard", e.FooterTagsLegalIcon = "FooterTagsLegalIcon", e.FooterTagsLegalItem = "FooterTagsLegalItem", e.LocaleOption = "LocaleOption", e.NavAccountMenu = "NavAccountMenu", e.NavAccountMenuSection = "NavAccountMenuSection", e.NavBrandStrings = "NavBrandStrings", e.NavFlyoutItem = "NavFlyoutItem", e.NavFlyoutSection = "NavFlyoutSection", e.NavImageCard = "NavImageCard", e.NavLink = "NavLink", e.NavMainLink = "NavMainLink", e.NavMegaMenu = "NavMegaMenu", e.NavMenuCtaSection = "NavMenuCtaSection", e.NavMenuIconLink = "NavMenuIconLink", e.NavMenuNewsSection = "NavMenuNewsSection", e.NavMenuSection = "NavMenuSection", e.NavPlatformAwareLink = "NavPlatformAwareLink", e.NavPropertyLogo = "NavPropertyLogo", e.NavSimpleMenu = "NavSimpleMenu", e.NavVerticalMenu = "NavVerticalMenu", e.Navigation = "Navigation", e.NavigationFlyout = "NavigationFlyout", e.ScheduledOperation = "ScheduledOperation", e.ScheduledRelease = "ScheduledRelease", e.SmartlingStatus = "SmartlingStatus", e.User = "User";
})(JI || (JI = {}));
var WI;
(function(e) {
  e.Artstation = "artstation", e.Communities = "communities", e.Createfn = "createfn", e.Devportal = "devportal", e.Edc = "edc", e.Egs = "egs", e.Eos = "eos", e.Fab = "fab", e.Fg = "fg", e.Fn = "fn", e.Realitycapture = "realitycapture", e.Realityscan = "realityscan", e.Rl = "rl", e.Sac = "sac", e.Sketch = "sketch", e.Ssp = "ssp", e.Superawesome = "superawesome", e.Tm = "tm", e.Ue = "ue";
})(WI || (WI = {}));
var GI;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.DummyLocalizationAsc = "dummyLocalization_ASC", e.DummyLocalizationDesc = "dummyLocalization_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(GI || (GI = {}));
var KI;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.EndIconAsc = "endIcon_ASC", e.EndIconDesc = "endIcon_DESC", e.HrefAsc = "href_ASC", e.HrefDesc = "href_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(KI || (KI = {}));
var YI;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.HeadingAsc = "heading_ASC", e.HeadingDesc = "heading_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InDevelopmentAsc = "inDevelopment_ASC", e.InDevelopmentDesc = "inDevelopment_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(YI || (YI = {}));
var XI;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.TextAsc = "text_ASC", e.TextDesc = "text_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(XI || (XI = {}));
var QI;
(function(e) {
  e.CountryCodesWhitelistAsc = "countryCodesWhitelist_ASC", e.CountryCodesWhitelistDesc = "countryCodesWhitelist_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.LocalesWhitelistAsc = "localesWhitelist_ASC", e.LocalesWhitelistDesc = "localesWhitelist_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(QI || (QI = {}));
var ZI;
(function(e) {
  e.BrandNameAsc = "brandName_ASC", e.BrandNameDesc = "brandName_DESC", e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.DummyLocalizationAsc = "dummyLocalization_ASC", e.DummyLocalizationDesc = "dummyLocalization_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InDevelopmentAsc = "inDevelopment_ASC", e.InDevelopmentDesc = "inDevelopment_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(ZI || (ZI = {}));
var eN;
(function(e) {
  e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.LogoAltAsc = "logoAlt_ASC", e.LogoAltDesc = "logoAlt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(eN || (eN = {}));
var tN;
(function(e) {
  e.HrefAsc = "href_ASC", e.HrefDesc = "href_DESC", e.IconAsc = "icon_ASC", e.IconDesc = "icon_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.LogoAltAsc = "logoAlt_ASC", e.LogoAltDesc = "logoAlt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(tN || (tN = {}));
var rN;
(function(e) {
  e.AspectRatioAsc = "aspectRatio_ASC", e.AspectRatioDesc = "aspectRatio_DESC", e.HrefAsc = "href_ASC", e.HrefDesc = "href_DESC", e.IconAsc = "icon_ASC", e.IconDesc = "icon_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.LogoAltAsc = "logoAlt_ASC", e.LogoAltDesc = "logoAlt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(rN || (rN = {}));
var nN;
(function(e) {
  e.CountryCodesAsc = "countryCodes_ASC", e.CountryCodesDesc = "countryCodes_DESC", e.DetailsBottomAsc = "detailsBottom_ASC", e.DetailsBottomDesc = "detailsBottom_DESC", e.DetailsTopAsc = "detailsTop_ASC", e.DetailsTopDesc = "detailsTop_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(nN || (nN = {}));
var oN;
(function(e) {
  e.HrefAsc = "href_ASC", e.HrefDesc = "href_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.LogoAltAsc = "logoAlt_ASC", e.LogoAltDesc = "logoAlt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(oN || (oN = {}));
var aN;
(function(e) {
  e.CountryCodesAsc = "countryCodes_ASC", e.CountryCodesDesc = "countryCodes_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.TitleHrefAsc = "titleHref_ASC", e.TitleHrefDesc = "titleHref_DESC", e.TitleAsc = "title_ASC", e.TitleDesc = "title_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(aN || (aN = {}));
var iN;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.DummyLocalizationAsc = "dummyLocalization_ASC", e.DummyLocalizationDesc = "dummyLocalization_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(iN || (iN = {}));
var sN;
(function(e) {
  e.Clip = "clip", e.Crop = "crop", e.Max = "max", e.Scale = "scale";
})(sN || (sN = {}));
var lN;
(function(e) {
  e.AllowProdPublish = "AllowProdPublish", e.DisableProdPublish = "DisableProdPublish";
})(lN || (lN = {}));
var cN;
(function(e) {
  e.Ar = "ar", e.Bg = "bg", e.Cs = "cs", e.Da = "da", e.De = "de", e.El = "el", e.En = "en", e.EsEs = "es_ES", e.EsMx = "es_MX", e.Fi = "fi", e.Fil = "fil", e.Fr = "fr", e.Hi = "hi", e.Hu = "hu", e.Id = "id", e.It = "it", e.Ja = "ja", e.Ko = "ko", e.Ms = "ms", e.Nl = "nl", e.No = "no", e.Pl = "pl", e.Pt = "pt", e.PtBr = "pt_BR", e.Ro = "ro", e.Ru = "ru", e.Sv = "sv", e.Th = "th", e.Tr = "tr", e.Uk = "uk", e.Vi = "vi", e.ZhCn = "zh_CN", e.ZhTw = "zh_TW";
})(cN || (cN = {}));
var uN;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.LangCodeAsc = "langCode_ASC", e.LangCodeDesc = "langCode_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(uN || (uN = {}));
var dN;
(function(e) {
  e.DummyLocalizedFieldAsc = "dummyLocalizedField_ASC", e.DummyLocalizedFieldDesc = "dummyLocalizedField_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(dN || (dN = {}));
var pN;
(function(e) {
  e.HeadingAsc = "heading_ASC", e.HeadingDesc = "heading_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.StartIconColorAsc = "startIconColor_ASC", e.StartIconColorDesc = "startIconColor_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(pN || (pN = {}));
var fN;
(function(e) {
  e.ComponentLabelAsc = "componentLabel_ASC", e.ComponentLabelDesc = "componentLabel_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.SearchInputLabelAsc = "searchInputLabel_ASC", e.SearchInputLabelDesc = "searchInputLabel_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(fN || (fN = {}));
var hN;
(function(e) {
  e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(hN || (hN = {}));
var mN;
(function(e) {
  e.HeadlineAsc = "headline_ASC", e.HeadlineDesc = "headline_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(mN || (mN = {}));
var yN;
(function(e) {
  e.DescriptionAsc = "description_ASC", e.DescriptionDesc = "description_DESC", e.EyebrowAsc = "eyebrow_ASC", e.EyebrowDesc = "eyebrow_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(yN || (yN = {}));
var gN;
(function(e) {
  e.EndIconAsc = "endIcon_ASC", e.EndIconDesc = "endIcon_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(gN || (gN = {}));
var bN;
(function(e) {
  e.CollapsibleAsc = "collapsible_ASC", e.CollapsibleDesc = "collapsible_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(bN || (bN = {}));
var vN;
(function(e) {
  e.DummyLocalizedFieldAsc = "dummyLocalizedField_ASC", e.DummyLocalizedFieldDesc = "dummyLocalizedField_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(vN || (vN = {}));
var wN;
(function(e) {
  e.AccentColorAsc = "accentColor_ASC", e.AccentColorDesc = "accentColor_DESC", e.DescriptionAsc = "description_ASC", e.DescriptionDesc = "description_DESC", e.ExpandAsc = "expand_ASC", e.ExpandDesc = "expand_DESC", e.HeadingAsc = "heading_ASC", e.HeadingDesc = "heading_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC", e.VariantAsc = "variant_ASC", e.VariantDesc = "variant_DESC";
})(wN || (wN = {}));
var _N;
(function(e) {
  e.EndIconAsc = "endIcon_ASC", e.EndIconDesc = "endIcon_DESC", e.HiddenAsc = "hidden_ASC", e.HiddenDesc = "hidden_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.StartIconAsc = "startIcon_ASC", e.StartIconDesc = "startIcon_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(_N || (_N = {}));
var EN;
(function(e) {
  e.HeadingAsc = "heading_ASC", e.HeadingDesc = "heading_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(EN || (EN = {}));
var xN;
(function(e) {
  e.AccentColorAsc = "accentColor_ASC", e.AccentColorDesc = "accentColor_DESC", e.BrandColorAsc = "brandColor_ASC", e.BrandColorDesc = "brandColor_DESC", e.ExpandAsc = "expand_ASC", e.ExpandDesc = "expand_DESC", e.HeadingAsc = "heading_ASC", e.HeadingDesc = "heading_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.StartIconColorAsc = "startIconColor_ASC", e.StartIconColorDesc = "startIconColor_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC", e.VariantAsc = "variant_ASC", e.VariantDesc = "variant_DESC";
})(xN || (xN = {}));
var SN;
(function(e) {
  e.Default = "default", e.Thin = "thin";
})(SN || (SN = {}));
var TN;
(function(e) {
  e.AndroidHrefAsc = "androidHref_ASC", e.AndroidHrefDesc = "androidHref_DESC", e.DefaultHrefAsc = "defaultHref_ASC", e.DefaultHrefDesc = "defaultHref_DESC", e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.IosHrefAsc = "iosHref_ASC", e.IosHrefDesc = "iosHref_DESC", e.KeyAsc = "key_ASC", e.KeyDesc = "key_DESC", e.LabelAsc = "label_ASC", e.LabelDesc = "label_DESC", e.MacHrefAsc = "macHref_ASC", e.MacHrefDesc = "macHref_DESC", e.MobileLabelAsc = "mobileLabel_ASC", e.MobileLabelDesc = "mobileLabel_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC", e.WindowsHrefAsc = "windowsHref_ASC", e.WindowsHrefDesc = "windowsHref_DESC";
})(TN || (TN = {}));
var AN;
(function(e) {
  e.HrefTemplateAsc = "hrefTemplate_ASC", e.HrefTemplateDesc = "hrefTemplate_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.LogoAltAsc = "logoAlt_ASC", e.LogoAltDesc = "logoAlt_DESC", e.OwnerAsc = "owner_ASC", e.OwnerDesc = "owner_DESC", e.RelativePathAsc = "relativePath_ASC", e.RelativePathDesc = "relativePath_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(AN || (AN = {}));
var $N;
(function(e) {
  e.DummyLocalizedFieldAsc = "dummyLocalizedField_ASC", e.DummyLocalizedFieldDesc = "dummyLocalizedField_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})($N || ($N = {}));
var CN;
(function(e) {
  e.DummyLocalizedFieldAsc = "dummyLocalizedField_ASC", e.DummyLocalizedFieldDesc = "dummyLocalizedField_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(CN || (CN = {}));
var kN;
(function(e) {
  e.ButtonLabelAsc = "buttonLabel_ASC", e.ButtonLabelDesc = "buttonLabel_DESC", e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InDevelopmentAsc = "inDevelopment_ASC", e.InDevelopmentDesc = "inDevelopment_DESC", e.MobileFlyoutMenuHeadingAsc = "mobileFlyoutMenuHeading_ASC", e.MobileFlyoutMenuHeadingDesc = "mobileFlyoutMenuHeading_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(kN || (kN = {}));
var PN;
(function(e) {
  e.BrandNameAsc = "brandName_ASC", e.BrandNameDesc = "brandName_DESC", e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.InDevelopmentAsc = "inDevelopment_ASC", e.InDevelopmentDesc = "inDevelopment_DESC", e.InternalDescriptionAsc = "internalDescription_ASC", e.InternalDescriptionDesc = "internalDescription_DESC", e.LargeCondensedLabelAsc = "largeCondensedLabel_ASC", e.LargeCondensedLabelDesc = "largeCondensedLabel_DESC", e.PriorityAsc = "priority_ASC", e.PriorityDesc = "priority_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(PN || (PN = {}));
var ON;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.DescriptionAsc = "description_ASC", e.DescriptionDesc = "description_DESC", e.ErrorMessageAsc = "errorMessage_ASC", e.ErrorMessageDesc = "errorMessage_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.StatusAsc = "status_ASC", e.StatusDesc = "status_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(ON || (ON = {}));
var RN;
(function(e) {
  e.Canceled = "CANCELED", e.Completed = "COMPLETED", e.Failed = "FAILED", e.InProgress = "IN_PROGRESS", e.Pending = "PENDING";
})(RN || (RN = {}));
var jN;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.DescriptionAsc = "description_ASC", e.DescriptionDesc = "description_DESC", e.ErrorMessageAsc = "errorMessage_ASC", e.ErrorMessageDesc = "errorMessage_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.IsActiveAsc = "isActive_ASC", e.IsActiveDesc = "isActive_DESC", e.IsImplicitAsc = "isImplicit_ASC", e.IsImplicitDesc = "isImplicit_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.ReleaseAtAsc = "releaseAt_ASC", e.ReleaseAtDesc = "releaseAt_DESC", e.StatusAsc = "status_ASC", e.StatusDesc = "status_DESC", e.TitleAsc = "title_ASC", e.TitleDesc = "title_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(jN || (jN = {}));
var IN;
(function(e) {
  e.Completed = "COMPLETED", e.Failed = "FAILED", e.InProgress = "IN_PROGRESS", e.Pending = "PENDING";
})(IN || (IN = {}));
var NN;
(function(e) {
  e.Resubmitted = "resubmitted", e.Submitted = "submitted", e.Translated = "translated";
})(NN || (NN = {}));
var MN;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.SubmittedAtAsc = "submittedAt_ASC", e.SubmittedAtDesc = "submittedAt_DESC", e.SyncedAtAsc = "syncedAt_ASC", e.SyncedAtDesc = "syncedAt_DESC", e.TranslationStatusAsc = "translationStatus_ASC", e.TranslationStatusDesc = "translationStatus_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(MN || (MN = {}));
var DN;
(function(e) {
  e.Draft = "DRAFT", e.Gamedev = "GAMEDEV", e.Published = "PUBLISHED";
})(DN || (DN = {}));
var qN;
(function(e) {
  e.Base = "BASE", e.Combined = "COMBINED", e.Localization = "LOCALIZATION";
})(qN || (qN = {}));
var LN;
(function(e) {
  e.AppToken = "APP_TOKEN", e.Member = "MEMBER", e.Pat = "PAT", e.Public = "PUBLIC", e.Webhook = "WEBHOOK";
})(LN || (LN = {}));
var FN;
(function(e) {
  e.CreatedAtAsc = "createdAt_ASC", e.CreatedAtDesc = "createdAt_DESC", e.IdAsc = "id_ASC", e.IdDesc = "id_DESC", e.IsActiveAsc = "isActive_ASC", e.IsActiveDesc = "isActive_DESC", e.KindAsc = "kind_ASC", e.KindDesc = "kind_DESC", e.NameAsc = "name_ASC", e.NameDesc = "name_DESC", e.PictureAsc = "picture_ASC", e.PictureDesc = "picture_DESC", e.PublishedAtAsc = "publishedAt_ASC", e.PublishedAtDesc = "publishedAt_DESC", e.UpdatedAtAsc = "updatedAt_ASC", e.UpdatedAtDesc = "updatedAt_DESC";
})(FN || (FN = {}));
var UN;
(function(e) {
  e.And = "AND", e.Not = "NOT", e.Or = "OR", e.Contains = "contains", e.ContainsAll = "contains_all", e.ContainsNone = "contains_none", e.ContainsSome = "contains_some", e.DescendantsOf = "descendants_of", e.EndsWith = "ends_with", e.Eq = "eq", e.EqNot = "eq_not", e.Gt = "gt", e.Gte = "gte", e.In = "in", e.JsonPathExists = "json_path_exists", e.JsonValueRecursive = "json_value_recursive", e.Lt = "lt", e.Lte = "lte", e.NotContains = "not_contains", e.NotEndsWith = "not_ends_with", e.NotIn = "not_in", e.NotStartsWith = "not_starts_with", e.RelationalEvery = "relational_every", e.RelationalNone = "relational_none", e.RelationalSingle = "relational_single", e.RelationalSome = "relational_some", e.Search = "search", e.StartsWith = "starts_with", e.UnionEmpty = "union_empty", e.UnionEvery = "union_every", e.UnionNone = "union_none", e.UnionSingle = "union_single", e.UnionSome = "union_some";
})(UN || (UN = {}));
var BN;
(function(e) {
  e.Enum = "enum", e.Relation = "relation", e.RichText = "richText", e.RichTextWithEmbeds = "richTextWithEmbeds", e.Scalar = "scalar", e.Union = "union", e.Virtual = "virtual";
})(BN || (BN = {}));
var HN;
(function(e) {
  e.Create = "create", e.Delete = "delete", e.DeleteMany = "deleteMany", e.Publish = "publish", e.PublishMany = "publishMany", e.SchedulePublish = "schedulePublish", e.ScheduleUnpublish = "scheduleUnpublish", e.Unpublish = "unpublish", e.UnpublishMany = "unpublishMany", e.Update = "update", e.UpdateMany = "updateMany", e.Upsert = "upsert";
})(HN || (HN = {}));
var VN;
(function(e) {
  e.Asc = "asc", e.Desc = "desc";
})(VN || (VN = {}));
var zN;
(function(e) {
  e.Many = "many", e.One = "one";
})(zN || (zN = {}));
var JN;
(function(e) {
  e.Create = "create", e.Update = "update";
})(JN || (JN = {}));
var WN;
(function(e) {
  e.Regular = "regular", e.Union = "union";
})(WN || (WN = {}));
var GN;
(function(e) {
  e.Base = "base", e.Combined = "combined", e.Localization = "localization";
})(GN || (GN = {}));
const IPe = (e) => {
  try {
    return window && window.location && window.location.href ? new URL(window.location.href) : new URL(e);
  } catch (t) {
    return console.warn("getCurrentUrl() Failed to parse current URL", t), null;
  }
}, NPe = (e, t) => e?.search ? e.search.substring(1).split("&").filter((n) => {
  const o = n.split("="), a = t ? !t.includes(o[0]) : !0;
  return o[0] !== "lang" && a;
}) : [], MPe = (e, t, r) => {
  const n = [...t];
  return e && n.push(...NPe(e, r)), n.length > 0 ? `?${n.join("&")}` : "";
}, DPe = (e, t = "nav-locale-menu", r = "Language") => {
  let n = e.localeOptions || [];
  if (typeof e.localeOptions == "string")
    try {
      n = JSON.parse(e.localeOptions);
    } catch {
      n = [];
    }
  const o = n.sort((a, i) => a.label < i.label ? -1 : a.label > i.label ? 1 : 0);
  return he`
		<epic-wf-simple-menu id=${t}>
			<div class="menu-heading"><h2>${r}</h2></div>
			<div class="menu-wrap" role="list">
				${o.map((a) => {
    const i = e.getMappedHygraphLocale(a.langCode), s = e.getMappedHygraphLocale(e.locale);
    if (e.blackListLangCodes && e.blackListLangCodes.includes(i)) return;
    const d = IPe(e.domain), l = e.locale === a.langCode || s === a.langCode || s.toLowerCase() === a.langCode.toLowerCase(), f = [`${e.langUrlParam || "lang"}=${i}`], h = e.localeHrefTemplate || MPe(d, f, [e.langUrlParam]);
    return he`
						<epic-wf-menu-item
							role="listitem"
							@click=${(m) => {
      e._localeLinkClick(m, a);
    }}
							hrefTemplate=${Ln(l ? void 0 : h)}
							startIcon=${Ln(l ? nE.Check : void 0)}
							startIconColor="blue"
							.noInteraction=${l}
							data-show-icon-lg-up="true"
							label=${a.label || ""}
							domain=${e?.domain || ""}
							lang=${i}
							locale=${i}
							startIconPadding=${4}
						>
							${Ln(l ? void 0 : he`<span slot="pre-label" style="width: 1.25rem;"></span>`)}
						</epic-wf-menu-item>
					`;
  })}
			</div>
		</epic-wf-simple-menu>
	`;
}, qPe = (e, t, r = "nav-locale-menu") => {
  var n, o;
  return he`
		<div
			@mouseleave=${t.onMouseLeave}
			@mouseover=${t.onMouseOver}
			class="dropdown dropdown--locale ${e.localeMenuOpen ? "open" : ""}"
		>
			<button
				@click=${t.onClick}
				aria-controls=${r}
				aria-expanded="${e.localeMenuOpen ? "true" : "false"}"
				aria-label="Locale menu"
				title=${((n = e.commonStrings) == null ? void 0 : n.mobileLanguageMenuHeading) || ""}
				class="dropdown__button"
			>
				<span aria-hidden="true" class="icon-wrapper">${v(e.globeIcon)}</span>
			</button>
			${DPe(e, r, ((o = e.commonStrings) == null ? void 0 : o.mobileLanguageMenuHeading) || "")}
		</div>
	`;
}, LPe = (e) => {
  var t, r, n, o, a, i;
  return he`
		<epic-wf-search-box
			mode=${!e.disableSearch && e.activeSearch && !e.isSmallDown ? "static" : "normal"}
			?opened=${e.searchOpen}
			?isMobile=${e.isMobile}
			@epic-wf-nav-search-activated=${e.toggleSearch}
			@epic-wf-nav-on-search=${e._onSearch}
			.initSearchValue=${e.initSearchValue}
			.activateSearchLabel=${((t = e.commonStrings) == null ? void 0 : t.searchActivateLabel) || ""}
			.cancelLabel=${((r = e.commonStrings) == null ? void 0 : r.searchCancelLabel) || ""}
			.deactivateSearchLabel=${((n = e.commonStrings) == null ? void 0 : n.searchDeactivateLabel) || ""}
			.inputLabel=${((o = e.brandStrings) == null ? void 0 : o.searchInputLabel) || ""}
			.placeholderLabel=${((a = e.commonStrings) == null ? void 0 : a.searchPlaceholderLabel) || ""}
			.submitLabel=${((i = e.commonStrings) == null ? void 0 : i.searchSubmitLabel) || ""}
		></epic-wf-search-box>
	`;
}, FPe = (e) => {
  let t = 0, r = !0;
  return e.vbucksBalance && t++, e.rewardsBalance && t++, e.walletBalance && t++, t === 0 ? he`` : (t === 1 && (r = !1), he`
		<div class="balances">
			${fn(
    e.vbucksBalance,
    () => {
      var n;
      return he`<epic-wf-balance-pill
						id="epic-nav-vbucks-balance"
						balance=${e.vbucksBalance}
						icon="v_bucks"
						gradient="blue"
						label=${((n = e?.commonStrings) == null ? void 0 : n.vbucksBalance) || "V-Bucks balance"}
						domain=${e.domain}
						locale=${e.getMappedHygraphLocale(e.locale)}
						hrefTemplate=${e.vbucksBalanceHref}
						.collapsible=${r}
						@click=${(o) => {
        e._vbucksBalanceClick(o, {
          id: "vbucks",
          hrefTemplate: e.vbucksBalanceHref || ""
        });
      }}
					></epic-wf-balance-pill>`;
    }
  )}
			${fn(
    e.rewardsBalance,
    () => {
      var n;
      return he`<epic-wf-balance-pill
						id="epic-nav-rewards-balance"
						balance=${e.rewardsBalance}
						icon="epic_rewards_filled"
						gradient="purple"
						label=${((n = e?.commonStrings) == null ? void 0 : n.rewardsBalance) || "Rewards balance"}
						domain=${e.domain}
						locale=${e.getMappedHygraphLocale(e.locale)}
						hrefTemplate=${e.rewardsBalanceHref}
						.collapsible=${r}
						@click=${(o) => {
        e._rewardsBalanceClick(o, {
          id: "rewards",
          hrefTemplate: e.rewardsBalanceHref || ""
        });
      }}
					></epic-wf-balance-pill>`;
    }
  )}
			${fn(
    e.walletBalance,
    () => {
      var n;
      return he`<epic-wf-balance-pill
						id="epic-nav-account-balance"
						balance=${e.walletBalance}
						icon="card_holder_filled"
						gradient="green"
						label=${((n = e?.commonStrings) == null ? void 0 : n.walletBalance) || "Account balance"}
						domain=${e.domain}
						locale=${e.getMappedHygraphLocale(e.locale)}
						hrefTemplate=${e.walletBalanceHref}
						.collapsible=${r}
						@click=${(o) => {
        e._walletBalanceClick(o, {
          id: "wallet",
          hrefTemplate: e.walletBalanceHref || ""
        });
      }}
					></epic-wf-balance-pill>`;
    }
  )}
		</div>
	`);
}, UPe = (e) => {
  var t;
  const r = {
    onClick: e._mainAccountMenuClick
  }, n = {
    onClick: e._mainLocaleMenuClick
  }, o = !!(e.walletBalance || e.rewardsBalance || e.vbucksBalance), a = !!((t = e?.icons) != null && t.length);
  return he`
		<div class="tools">
			${fn(!e.disableSearch, () => LPe(e))} ${fn(a, () => Hre(e))}
			${fn(!e.disableLocale, () => qPe(e, n))}
			${fn(o, () => FPe(e))}
			${fn(!e.disableUser, () => jPe(e, r))}
		</div>
	`;
}, BPe = (e) => UPe(e);
class HPe extends Dm {
  /**
   * Fired when `lit-media-query` changes detects a change
   * in the media query (from `true` to `false` and vice versa).
   *
   * @event changed
   * @param {boolean} value If media query is being fulfilled or not.
   */
  static get properties() {
    return {
      /**
       * Media query to be watched by the element.
       *
       * Can be modified at run time by setting a new value.
       */
      query: { type: String },
      _match: { type: Boolean }
    };
  }
  constructor() {
    super(), this.query = "(max-width:460px)", this._match = !1, this.boundResizeHandler = this._handleRisize.bind(this);
  }
  render() {
    return he`
      <style>
        :host {
          display: none;
        }
      </style>
    `;
  }
  firstUpdated() {
    this._initialMediaQueryCheck();
  }
  connectedCallback() {
    super.connectedCallback(), typeof window.visualViewport < "u" ? window.visualViewport.addEventListener("resize", this.boundResizeHandler) : window.addEventListener("resize", this.boundResizeHandler), window.screen && typeof window.screen.orientation < "u" ? window.screen.orientation.addEventListener("change", this.boundResizeHandler) : window.addEventListener("orientationchange", this.boundResizeHandler);
  }
  disconnectedCallback() {
    typeof window.visualViewport < "u" ? window.visualViewport.removeEventListener(
      "resize",
      this.boundResizeHandler
    ) : window.removeEventListener("resize", this.boundResizeHandler), window.screen && typeof window.screen.orientation < "u" ? window.screen.orientation.removeEventListener("change", this.boundResizeHandler) : window.removeEventListener("orientationchange", this.boundResizeHandler), super.disconnectedCallback();
  }
  _initialMediaQueryCheck() {
    window.matchMedia(this.query).matches ? this.dispatchEvent(
      new CustomEvent("changed", {
        detail: {
          value: !0
        },
        composed: !0,
        bubbles: !0
      })
    ) : this.dispatchEvent(
      new CustomEvent("changed", {
        detail: {
          value: !1
        },
        composed: !0,
        bubbles: !0
      })
    );
  }
  _handleRisize() {
    window.matchMedia(this.query).matches ? this._match === !1 && (this.dispatchEvent(
      new CustomEvent("changed", {
        detail: {
          value: !0
        },
        composed: !0,
        bubbles: !0
      })
    ), this._match = !0) : this._match === !0 && (this.dispatchEvent(
      new CustomEvent("changed", {
        detail: {
          value: !1
        },
        composed: !0,
        bubbles: !0
      })
    ), this._match = !1);
  }
}
window.customElements.get("lit-media-query") || customElements.define("lit-media-query", HPe);
const VPe = 'svg{fill:currentColor}svg[viewBox="0 0 24 24"]{inline-size:1.5rem;block-size:1.5rem}svg[viewBox="0 0 20 20"]{inline-size:1.25rem;block-size:1.25rem}svg{color:var(--color-icon-primary, #ffffff)}.visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.dropdown{display:flex}@media (min-width: 720px){.dropdown{position:relative}}.dropdown--locale .dropdown__button{padding-block:.25rem;padding-inline:.25rem}.dropdown--locale epic-wf-menu-item{--link-inline-padding: .5rem}.dropdown__button{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none;display:flex;position:relative;z-index:1;text-wrap:nowrap}.dropdown__button>*{pointer-events:none}.dropdown__button:not([disabled]){cursor:pointer}.dropdown__button:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}.dropdown__button svg{transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.dropdown__button:not([aria-expanded=true])~epic-wf-simple-menu,.dropdown__button:not([aria-expanded=true])~epic-wf-nav-vertical-menu{opacity:0;pointer-events:none;visibility:hidden}.dropdown__button eds-avatar{overflow-wrap:normal}@media (min-width: 720px){.dropdown__button eds-avatar{max-width:max(12.5rem,10vw);overflow:hidden;transition:opacity var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.dropdown__button:hover svg{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}.dropdown__button:hover eds-avatar{opacity:.75}}@media (min-width: 720px){.dropdown epic-wf-simple-menu,.dropdown epic-wf-nav-vertical-menu{transform:translate(calc(-100% * var(--transform-direction)))}.dropdown.dropdown--account button{outline-offset:.25rem}.dropdown.dropdown--locale epic-wf-simple-menu,.dropdown.dropdown--account epic-wf-simple-menu,.dropdown.dropdown--account epic-wf-nav-vertical-menu{min-width:13.75rem}}.dropdown.dropdown--account a.secondary-cta{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));--link-block-padding: .25rem;--link-inline-padding: .75rem;border-radius:.375rem;background-color:var(--color-fill-primary-default, #26bbff);margin:0;text-align:center;font-weight:500;font-weight:400;background-color:var(--color-fill-secondary-default, rgba(255, 255, 255, .15))}.dropdown.dropdown--account a.secondary-cta>*{pointer-events:none}.dropdown.dropdown--account a.secondary-cta:not([disabled]){cursor:pointer}.dropdown.dropdown--account a.secondary-cta:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){.dropdown.dropdown--account a.secondary-cta{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){.dropdown.dropdown--account a.secondary-cta{--link-inline-padding-fallback: .75rem}}.dropdown.dropdown--account a.secondary-cta .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){.dropdown.dropdown--account a.secondary-cta .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}.dropdown.dropdown--account a.secondary-cta:hover,.dropdown.dropdown--account a.secondary-cta.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.dropdown.dropdown--account a.secondary-cta:focus-visible{border-radius:.875rem}@media (min-width: 720px){.dropdown.dropdown--account a.secondary-cta.parent:hover,.dropdown.dropdown--account a.secondary-cta.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}.dropdown.dropdown--account a.secondary-cta:focus-visible{outline-color:#fff;outline-offset:.125rem}.dropdown.dropdown--account a.secondary-cta:hover{background-color:var(--color-fill-primary-hover, #72d3ff)}.dropdown.dropdown--account a.secondary-cta .label{font-family:Inter,sans-serif;font-style:normal;font-weight:500;line-height:100%;letter-spacing:.02em;font-size:.875rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;justify-content:center;color:var(--color-text-on-accent, #000000);line-height:1.5rem}@media (max-width: 719.9px){.dropdown.dropdown--account a.secondary-cta{--link-block-padding: .5rem;--link-inline-padding: .75rem;flex:1}.dropdown.dropdown--account a.secondary-cta .label{line-height:1rem}}.dropdown.dropdown--account a.secondary-cta:hover{background-color:var(--color-fill-secondary-hover, rgba(255, 255, 255, .35))}.dropdown.dropdown--account a.secondary-cta .label{color:var(--color-text-primary, #ffffff)}@media (max-width: 719.9px){.dropdown epic-wf-simple-menu,.dropdown epic-wf-nav-vertical-menu{transition-duration:.3s;transition-property:opacity transform;transition-timing-function:cubic-bezier(.65,0,.35,1);transform:translate(0)}}@media (min-width: 720px){.dropdown epic-wf-simple-menu,.dropdown epic-wf-nav-vertical-menu{position:absolute;inset-block-start:2.25rem;inset-inline-start:2.5rem}}.tools{align-items:center;box-sizing:border-box;display:flex;gap:1rem;justify-content:flex-end;z-index:4}@media (max-width: 719.9px){.tools{height:2.75rem}}@media (max-width: 1279.9px){.tools{gap:.5rem}}@media (min-width: 720px){.tools{flex-grow:1;position:relative}}.tools .balances{display:flex;gap:1rem}@media (max-width: 1279.9px){.tools .balances{gap:.5rem}}@media (max-width: 719.9px){.tools .balances{gap:.25rem}}.tools .icons{display:flex;gap:1rem}@media (max-width: 1279.9px){.tools .icons{gap:.5rem}}@media (max-width: 719.9px){.tools .icons{gap:.25rem}}.tools .icons epic-wf-eds-icon{width:24px;transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.tools .icons .icon{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;text-decoration:none;-webkit-user-select:none;user-select:none;box-sizing:border-box;position:relative;height:32px;width:32px;padding:4px}.tools .icons .icon>*{pointer-events:none}.tools .icons .icon:not([disabled]){cursor:pointer}.tools .icons .icon:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}.tools .icons .icon:hover epic-wf-eds-icon{fill:var(--color-text-secondary, rgba(255, 255, 255, .65))}.tools .icons .icon:hover .badge{background:#26bbff}.tools .icons .badge{display:flex;height:16px;min-width:16px;padding:1px 4px;justify-content:center;align-items:center;position:absolute;top:-4px;right:-4px;border-radius:9999px;box-sizing:border-box;background:#61cdff;font-family:Inter,sans-serif;font-size:.625rem;font-weight:700;line-height:130%;letter-spacing:.025em;transition:background var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));color:#000}@media (prefers-reduced-motion: reduce){*,:before,:after{animation-delay:-1ms!important;animation-duration:0s!important;transition-delay:1ms!important;transition-duration:0s!important}}:host{--header-height: 4.5rem;display:flex;width:100%;height:var(--header-height);font-family:Inter,sans-serif}:host([sticky=true]),:host([sticky=""]){position:sticky;top:0;z-index:var(--header-z-index, 9000)}.global-header{--drawer-main-cta-height: 5.875rem;--drawer-toolbar-height: 3.25rem;--header-padding-block: 1.25rem;--header-padding-inline: 1.25rem;--drawer-padding-inline: 4rem;--drawer-padding-block-end: 4rem;--drawer-padding-block-start: 4rem;--transform-direction: 1;align-items:center;box-sizing:border-box;column-gap:.75rem;display:flex;height:var(--header-height);padding-block:var(--header-padding-block);padding-inline:var(--header-padding-inline);position:relative;-webkit-tap-highlight-color:transparent;width:100%;z-index:var(--header-z-index, 9000)}@media (max-width: 719.9px){.global-header{--header-padding-block: 0px;--header-padding-inline: 1rem;--drawer-padding-inline: 1rem;--drawer-padding-block-end: 1rem;--drawer-padding-block-start: 1rem}}@media (min-width: 720px){.global-header{--header-padding-inline: 1.5rem}.global-header .main-nav.active-search{max-width:max-content}.global-header .main-nav.active-search+.toolbar{flex-grow:1}}.global-header[data-mobile-drawer-open=true]{background:var(--color-background-default, #101014)}.global-header[data-mobile-drawer-open=true] .main-nav,.global-header[data-mobile-drawer-open=true] .toolbar{background-color:var(--color-background-default, #101014)}@media (max-width: 719.9px){.global-header{--flyout-toggle-width: -70px}}@media (max-width: 719.9px){.global-header{--flyout-toggle-width: -58px}}@media (min-width: 1280px){.global-header{column-gap:1.75rem}}.global-header.rtl{--transform-direction: -1}.global-header[data-mobile-cta-hidden=true],.global-header[data-mobile-top-cta=true]{--drawer-main-cta-height: 0px}@media (max-width: 719.9px){.global-header[data-property-logo-valid=false] .global-header__nav{justify-content:flex-end}}@media (max-width: 350px){.global-header[data-property-logo-icon-valid=false] .mobile-top-cta{display:none}}@media (min-width: 350.1px) and (max-width: 959.9px){.global-header[data-property-logo-icon-valid=false][data-mobile-top-cta=true] .main-cta{display:none}}@media (max-width: 719.9px){.global-header[data-property-logo-icon-valid=true][data-mobile-top-cta=true] .main-cta{display:none}}.global-header__flyout-wrapper{align-items:center;display:flex;flex-shrink:0;gap:.75rem}.global-header__flyout-wrapper epic-wf-nav-flyout-menu:not([active=true]) .friendly-box{opacity:0;pointer-events:none;visibility:hidden}@media (min-width: 720px){.global-header__flyout-wrapper{gap:1rem}}@media (max-width: 719.9px){.global-header__flyout-wrapper{transition-duration:.3s;transition-property:opacity;transition-timing-function:cubic-bezier(.65,0,.35,1)}}@media (max-width: 719.9px){.global-header epic-wf-property-logo{transition-duration:.3s;transition-property:transform;transition-timing-function:cubic-bezier(.65,0,.35,1)}}.global-header__drawer{align-items:center;box-sizing:border-box;column-gap:1rem;display:flex;flex-grow:1;min-width:0}@media (max-width: 719.9px){.global-header__drawer{transition-duration:.3s;transition-property:background-color opacity;transition-timing-function:cubic-bezier(.65,0,.35,1);align-items:stretch;flex-direction:column-reverse;height:calc(100vh - var(--header-height) - var(--top-offset, 0px));inset-block-start:var(--header-height);inset-inline-start:0;justify-content:start;overflow:hidden;position:absolute;transform:translate(0);width:100%;z-index:10}@supports (height: 100dvh){.global-header__drawer{height:calc(100dvh - var(--header-height) - var(--top-offset, 0px))}}}.global-header__nav{align-items:center;display:flex;flex-grow:1;column-gap:1.5rem;row-gap:2rem;justify-content:space-between;min-width:0}@media (max-width: 1279.9px){.global-header__nav{column-gap:.5rem}}.global-header .bg-filter{background:var(--color-background-transparent-default, rgba(16, 16, 20, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));position:absolute;overflow:hidden;z-index:-1;content:"";display:block;inset:0}.global-header[data-mobile-drawer-open=true] .bg-filter{display:none}.skip-nav{margin:0;position:absolute;inset-block-start:.75rem;inset-inline-start:.75rem;z-index:var(--skipnav-z-index, 9001)}@media (min-width: 720px){.skip-nav{inset-block-start:1.25rem;inset-inline-start:1.25rem}}.skip-nav:not(:focus):not(:focus-within){border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.mobile-toolbar{display:flex;align-items:center;gap:.375rem}@media (min-width: 720px){.mobile-toolbar{display:none}}@media (min-width: 720px){.mobile-toolbar .mobile-top-cta{display:none}}.toolbar{align-items:stretch;column-gap:1.5rem;display:flex;flex-direction:column-reverse;flex:1;position:relative;z-index:1}@media (max-width: 719.9px){.toolbar{transition-duration:.3s;transition-property:transform;transition-timing-function:cubic-bezier(.65,0,.35,1);padding-block:.25rem;padding-inline:var(--header-padding-inline)}}@media (min-width: 720px){.toolbar{align-items:center;flex-direction:row;flex-grow:0}}.toolbar__back-wrapper{transition-duration:.3s;transition-property:opacity transform;transition-timing-function:cubic-bezier(.65,0,.35,1);align-items:flex-start;background-color:var(--color-background-default, #101014);display:flex;flex-direction:column;inset:0;justify-content:center;max-width:100%;padding-block:inherit;padding-inline:inherit;position:absolute;transform:translate(0);width:calc(100vw - var(--header-padding-inline) * 2);z-index:4}@media (min-width: 720px){.toolbar__back-wrapper{display:none}}.toolbar .back-button{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));color:var(--color-text-primary, #ffffff);margin:0;width:auto}.toolbar .back-button>*{pointer-events:none}.toolbar .back-button:not([disabled]){cursor:pointer}.toolbar .back-button:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){.toolbar .back-button{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){.toolbar .back-button{--link-inline-padding-fallback: .75rem}}.toolbar .back-button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){.toolbar .back-button .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}.toolbar .back-button:hover,.toolbar .back-button.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.toolbar .back-button:focus-visible{border-radius:.875rem}@media (min-width: 720px){.toolbar .back-button.parent:hover,.toolbar .back-button.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}.toolbar .back-button:hover{background-color:inherit}.toolbar .back-button .icon-wrapper{margin-inline-end:.375rem}.avatar-wrapper{margin-block-end:1.25rem}.avatar-wrapper.margin-block-end-0{margin-block-end:0}@media (min-width: 720px){.avatar-wrapper{display:none}}@media (max-width: 719.9px){.main-cta{transition-duration:.3s;transition-property:opacity;transition-timing-function:cubic-bezier(.65,0,.35,1);background:var(--color-background-transparent-default, rgba(16, 16, 20, .7));-webkit-backdrop-filter:var(--effect-material-blur, blur(50px));backdrop-filter:var(--effect-material-blur, blur(50px));box-shadow:var(--shadow-top-md, 0px -2px 1px rgba(0, 0, 0, .1), 0px -4px 2px rgba(0, 0, 0, .1), 0px -8px 4px rgba(0, 0, 0, .1), 0px -16px 8px rgba(0, 0, 0, .1), 0px -32px 16px rgba(0, 0, 0, .1));display:flex;inset-block-end:0;inset-inline:0;justify-content:center;overflow:hidden;padding-inline:4rem;padding-block:1.5rem;position:absolute;z-index:3}[data-mobile-cta-hidden=true] .main-cta{display:none}[data-dropdown-open=true] .main-cta,[data-mobile-subdrawer-open=true] .main-cta{opacity:0;pointer-events:none}}@media (max-width: 719.9px){.main-cta{padding:1rem}}@media (max-width: 719.9px){.main-cta epic-wf-cta-button{transition-duration:.3s;transition-property:transform;transition-timing-function:cubic-bezier(.65,0,.35,1);max-width:21.375rem;height:3rem;display:flex;justify-content:center;width:100%}}@media (max-width: 719.9px){[data-dropdown-open=false][data-mobile-subdrawer-open=false] .toolbar__back-wrapper{opacity:0;pointer-events:none;visibility:hidden;transform:translate(calc(1rem * var(--transform-direction)))}}.main-nav{scrollbar-color:dark;z-index:1;flex-grow:1;min-width:0;overflow:hidden}@media (max-width: 719.9px){.main-nav{transition-duration:.3s;transition-property:padding transform;transition-timing-function:cubic-bezier(.65,0,.35,1);height:100%;overflow-y:auto;padding-block-end:max(var(--drawer-padding-block-end),var(--drawer-main-cta-height));padding-block-start:var(--drawer-padding-block-start);padding-inline:var(--drawer-padding-inline)}}@media (min-width: 720px) and (max-width: 959.9px){.main-nav[data-search-open=true]{display:none}.main-nav[data-search-open=true]~.toolbar{flex-grow:1}.main-nav[data-search-open=true]~.toolbar epic-wf-search-box{flex-grow:1}}@media (min-width: 720px){.main-nav{transition-duration:.3s;transition-property:opacity;transition-timing-function:cubic-bezier(.65,0,.35,1);align-items:center;display:flex}.main-nav[data-search-open=true] .main-nav~.toolbar{flex-grow:1}}.main-nav__list-item{--main-nav-mobile-offset: -2.5rem;align-items:center;display:flex;width:100%}@media (max-width: 719.9px){.main-nav__list-item{align-items:flex-start;transition-duration:.3s;transition-property:transform;transition-timing-function:cubic-bezier(.65,0,.35,1)}}.main-nav__list-item epic-wf-condensed-menu{margin-inline-start:-3.75rem}@media (min-width: 720px){.main-nav__list-item epic-wf-simple-menu,.main-nav__list-item epic-wf-nav-vertical-menu{margin-inline-start:-.5rem}}@media (min-width: 720px){.main-nav__list-item epic-wf-nav-mega-menu{max-width:20rem;z-index:1}}@media (min-width: 960px){.main-nav__list-item epic-wf-nav-mega-menu{max-width:50rem;inset-inline-start:1.125rem;inset-inline-end:1.25rem}}@media (min-width: 1280px){.main-nav__list-item epic-wf-nav-mega-menu{max-width:initial;inset-inline-start:1.125rem;inset-inline-end:1.25rem}}@media (min-width: 1440px){.main-nav__list-item epic-wf-nav-mega-menu{inset-inline-start:6.125rem}}@media (min-width: 720px){.main-nav__list-item epic-wf-simple-menu,.main-nav__list-item epic-wf-nav-mega-menu,.main-nav__list-item epic-wf-nav-vertical-menu,.main-nav__list-item epic-wf-condensed-menu{inset-block-start:3.8125rem;position:absolute}}.main-nav__list-item epic-wf-main-link:not([active=true])~epic-wf-simple-menu,.main-nav__list-item epic-wf-main-link:not([active=true])~epic-wf-nav-mega-menu,.main-nav__list-item epic-wf-main-link:not([active=true])~epic-wf-nav-vertical-menu,.main-nav__list-item epic-wf-main-link:not([active=true])~epic-wf-condensed-menu,.main-nav__list-item epic-wf-main-link:not([active=true]) .friendly-box{opacity:0;pointer-events:none;visibility:hidden}@media (min-width: 720px){.main-nav__list-item epic-wf-main-link[tabindex="-1"]{pointer-events:none}}@media (max-width: 719.9px){epic-wf-simple-menu,epic-wf-nav-mega-menu,epic-wf-nav-vertical-menu{transition-duration:.3s;transition-property:opacity transform;transition-timing-function:cubic-bezier(.65,0,.35,1);background-color:var(--color-background-default, #101014);box-shadow:none;box-sizing:border-box;display:flex;flex-direction:column;height:calc(100vh - (var(--header-height) + var(--drawer-toolbar-height) + var(--top-offset, 0px)));inset-block-start:var(--drawer-toolbar-height);inset-inline:0;max-width:100%;overflow-y:auto;padding-block-end:var(--drawer-padding-block-end);padding-block-start:var(--drawer-padding-block-start);padding-inline:var(--drawer-padding-inline);position:absolute;scrollbar-color:dark;transform:translate(calc(1rem * var(--transform-direction)));width:100vw;z-index:4}@supports (height: 100dvh){epic-wf-simple-menu,epic-wf-nav-mega-menu,epic-wf-nav-vertical-menu{height:calc(100dvh - (var(--header-height) + var(--drawer-toolbar-height) + var(--top-offset, 0px)))}}}@media (max-width: 719.9px){epic-wf-simple-menu epic-wf-menu-item{width:100%}}@media (max-width: 719.9px){epic-wf-nav-mega-menu,epic-wf-nav-vertical-menu{row-gap:2rem}}.icon-wrapper{display:flex}.friendly-box{margin-block-start:-.375rem;height:2.5rem;inset-block-start:100%;inset-inline-start:50%;position:absolute;transform:translate(calc(-50% * var(--transform-direction)));min-width:5.625rem;width:100%;z-index:4}@media (max-width: 719.9px){.friendly-box{display:none}}.main-nav__list-item:hover .friendly-box:before,.main-nav__list-item:hover .friendly-box:after{content:"";position:absolute;height:2rem;width:4rem;transform-origin:top;z-index:-1}@media (max-width: 719.9px){.main-nav__list-item:hover .friendly-box:before,.main-nav__list-item:hover .friendly-box:after{display:none}}.main-nav__list-item:hover .friendly-box:before{transform:rotate(calc(-35deg * var(--transform-direction)));inset-inline-start:-3.5rem}.main-nav__list-item:hover .friendly-box:after{transform:rotate(calc(35deg * var(--transform-direction)));inset-inline-end:-3.5rem}.menu-toggle{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none;padding:.75rem;margin:-.75rem;margin-inline-start:auto}.menu-toggle>*{pointer-events:none}.menu-toggle:not([disabled]){cursor:pointer}.menu-toggle:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (min-width: 720px){.menu-toggle{display:none}}.menu-toggle svg{display:block;width:1.5rem;height:1.5rem;fill:var(--color-text-primary, #ffffff)}@media (max-width: 719.9px){[data-mobile-drawer-open=false][data-mobile-drawer-has-opened=true] .main-nav{overflow-y:hidden}[data-mobile-drawer-open=true] .main-nav .main-nav__list[data-mobile-child-menu-open=true]{overflow-y:hidden;scroll-behavior:auto}[data-mobile-drawer-open=true] .main-nav .main-nav__list[data-mobile-child-menu-open=true]>.menu-heading{visibility:hidden}[data-mobile-drawer-open=true] .main-nav .main-nav__list[data-mobile-child-menu-open=true] .main-nav__list-item[data-is-active=false]{visibility:hidden}[data-mobile-drawer-open=true] .global-header__flyout-wrapper.hide-in-drawer{opacity:0;pointer-events:none}[data-mobile-drawer-open=true] epic-wf-property-logo{transform:translate(calc(var(--flyout-toggle-width) * var(--transform-direction)))}[data-mobile-drawer-open=true][data-mobile-drawer-has-opened=false] .global-header__drawer{pointer-events:none}[data-mobile-drawer-open=true][data-mobile-drawer-has-opened=false] .main-nav{overflow-y:hidden}[data-mobile-drawer-open=true] .toolbar{transform:translateY(0)}[data-mobile-drawer-open=true] .main-cta epic-wf-cta-button{transform:translateY(0)}[data-mobile-drawer-open=true][data-search-open=true]{--search-box-width: 100%}[data-mobile-drawer-open=true][data-search-open=true] .dropdown,[data-mobile-drawer-open=true][data-search-open=true] .icons,[data-mobile-drawer-open=true][data-search-open=true] .balances{display:none}[data-dropdown-open=true] epic-wf-simple-menu,[data-dropdown-open=true] epic-wf-nav-mega-menu,[data-dropdown-open=true] epic-wf-nav-vertical-menu,[data-mobile-subdrawer-open=true] epic-wf-simple-menu,[data-mobile-subdrawer-open=true] epic-wf-nav-mega-menu,[data-mobile-subdrawer-open=true] epic-wf-nav-vertical-menu{transform:translate(0)}[data-mobile-drawer-open=false] epic-wf-property-logo{transform:translate(0)}[data-mobile-drawer-open=false] .global-header__drawer{opacity:0;pointer-events:none;visibility:hidden;background-color:transparent}[data-mobile-drawer-open=false] .main-nav{padding-block-start:2.5rem;transform:translateY(calc(var(--drawer-main-cta-height) * -1))}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(1){transform:translateY(calc(var(--main-nav-mobile-offset) * 1));z-index:1}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(2){transform:translateY(calc(var(--main-nav-mobile-offset) * 2));z-index:2}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(3){transform:translateY(calc(var(--main-nav-mobile-offset) * 3));z-index:3}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(4){transform:translateY(calc(var(--main-nav-mobile-offset) * 4));z-index:4}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(5){transform:translateY(calc(var(--main-nav-mobile-offset) * 5));z-index:5}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(6){transform:translateY(calc(var(--main-nav-mobile-offset) * 6));z-index:6}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(7){transform:translateY(calc(var(--main-nav-mobile-offset) * 7));z-index:7}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(8){transform:translateY(calc(var(--main-nav-mobile-offset) * 8));z-index:8}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(9){transform:translateY(calc(var(--main-nav-mobile-offset) * 9));z-index:9}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(10){transform:translateY(calc(var(--main-nav-mobile-offset) * 10));z-index:10}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(11){transform:translateY(calc(var(--main-nav-mobile-offset) * 11));z-index:11}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(12){transform:translateY(calc(var(--main-nav-mobile-offset) * 12));z-index:12}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(13){transform:translateY(calc(var(--main-nav-mobile-offset) * 13));z-index:13}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(14){transform:translateY(calc(var(--main-nav-mobile-offset) * 14));z-index:14}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(15){transform:translateY(calc(var(--main-nav-mobile-offset) * 15));z-index:15}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(16){transform:translateY(calc(var(--main-nav-mobile-offset) * 16));z-index:16}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(17){transform:translateY(calc(var(--main-nav-mobile-offset) * 17));z-index:17}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(18){transform:translateY(calc(var(--main-nav-mobile-offset) * 18));z-index:18}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(19){transform:translateY(calc(var(--main-nav-mobile-offset) * 19));z-index:19}[data-mobile-drawer-open=false] .main-nav__list-item:nth-child(20){transform:translateY(calc(var(--main-nav-mobile-offset) * 20));z-index:20}[data-mobile-drawer-open=false] .toolbar{transform:translateY(calc(-.375rem - 100%))}[data-mobile-drawer-open=false] .main-cta epic-wf-cta-button{transform:translateY(100%)}}.menu-heading{display:none}.menu-heading h2{margin:0;font-weight:inherit;font-size:inherit}@media (max-width: 719.9px){.menu-heading{display:unset;font-family:Inter,sans-serif;font-style:normal;font-size:2rem;font-weight:900;line-height:100%;letter-spacing:-.07rem;color:var(--color-text-primary, #ffffff);align-self:start;padding-inline:.5rem;margin-block-end:2rem}.menu-heading.no-margin{margin-block-end:0}.main-nav__list-item--condensed{opacity:0;pointer-events:none;visibility:hidden;display:none}}.menu-wrap{display:flex;flex-direction:column;width:100%}@media (min-width: 720px){.main-nav.items-visible-0 .main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-1 #epic-wf-nav-main-link-0~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-2 #epic-wf-nav-main-link-1~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-3 #epic-wf-nav-main-link-2~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-4 #epic-wf-nav-main-link-3~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-5 #epic-wf-nav-main-link-4~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-6 #epic-wf-nav-main-link-5~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-7 #epic-wf-nav-main-link-6~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-8 #epic-wf-nav-main-link-7~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-9 #epic-wf-nav-main-link-8~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-10 #epic-wf-nav-main-link-9~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-11 #epic-wf-nav-main-link-10~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-12 #epic-wf-nav-main-link-11~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-13 #epic-wf-nav-main-link-12~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-14 #epic-wf-nav-main-link-13~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-15 #epic-wf-nav-main-link-14~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-16 #epic-wf-nav-main-link-15~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-17 #epic-wf-nav-main-link-16~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-18 #epic-wf-nav-main-link-17~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-19 #epic-wf-nav-main-link-18~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav.items-visible-20 #epic-wf-nav-main-link-19~.main-nav__list-item:not(.main-nav__list-item--condensed){display:none}.main-nav__list-item{flex-shrink:0;width:auto;height:4.5rem}.main-nav__list-item--condensed{opacity:1;visibility:unset}.main-nav__list-item--condensed.hidden{opacity:0;pointer-events:none;visibility:hidden;display:none}.main-nav__list-filler{opacity:0;pointer-events:none;visibility:hidden;display:flex;flex:1 1 0%}.menu-heading{opacity:0;pointer-events:none;visibility:hidden;display:none}.menu-wrap{padding-block:.5rem;padding-inline:.5rem;margin-block:-.5rem;margin-inline:-.5rem;overflow-y:auto;overflow-x:hidden;overscroll-behavior:contain;color-scheme:var(--eg-global-nav-color-scheme, dark);overflow-wrap:anywhere}.menu-wrap::-webkit-scrollbar{width:16px}.menu-wrap::-webkit-scrollbar-track{margin-block:8px}.menu-wrap::-webkit-scrollbar-thumb{background:transparent;box-shadow:0 0 0 6px var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15)) inset;border:4px solid transparent;border-radius:100px}}';
function zPe(e, t, r, n) {
  t ? e.type.includes("pointer") || n._trapSubFocus(
    e,
    hn,
    Zs,
    e.target,
    () => n._untrapSubFocus(),
    (o) => {
      o.preventDefault(), o.stopImmediatePropagation(), r();
    }
  ) : n._isSubFocusTrapped && n._untrapSubFocus();
}
const JPe = (e, t, r) => {
  const n = (i) => {
    const s = e.moreOpened;
    e.closeMenusAndInput({ closeSearch: !0 }), e.moreOpened = !s, e.moreOpened ? e._trapFocus(i, hn, bf, () => {
    }) : e._untrapFocus();
  };
  return he`
		<li
			@pointerenter=${(i) => {
    if (!Qi(i)) {
      e.closeMenusAndInput();
      const s = i.currentTarget, d = s?.firstElementChild;
      d && (e._trapFocus(
        d,
        hn,
        () => s,
        () => {
        }
      ), e.moreOpened = !0);
    }
  }}
			@pointerleave=${(i) => {
    Qi(i) || (e._untrapFocus(), e.moreOpened = !1);
  }}
			class="main-nav__list-item main-nav__list-item--condensed ${r > -1 && r < t?.length ? "" : "hidden"}"
		>
			<epic-wf-main-link
				.rtl=${e.dir === Nm.RTL}
				.isParent=${!0}
				@click=${n}
				active=${e.moreOpened}
				hasMenu=${!0}
				label=${e?.largeCondensedLabel || "More"}
				domain=${e?.domain || ""}
				locale=${e.getMappedHygraphLocale(e.locale)}
			>
				<div class="friendly-box"></div>
			</epic-wf-main-link>
			<epic-wf-condensed-menu
				.getMappedHygraphLocale=${e.getMappedHygraphLocale.bind(e)}
				.mainLinks=${t || []}
				.onLinkClick=${e._navLinkClick.bind(e)}
				.onSubmenu=${(i, s, d) => zPe(i, s, d, e)}
				.rtl=${e.dir === Nm.RTL}
				.keysShown=${r}
				domain=${e?.domain || ""}
				locale=${e.getMappedHygraphLocale(e.locale)}
			></epic-wf-condensed-menu>
		</li>
	`;
}, WPe = (e, t, r) => {
  var n, o, a, i;
  const s = (n = t.sections) == null ? void 0 : n.slice(0, 4), d = (a = (o = t.news) == null ? void 0 : o.cards) == null ? void 0 : a.slice(0, 3);
  return he`
		<epic-wf-nav-mega-menu>
			${r ? he`<div class="menu-heading no-margin">${r}</div>` : ""}
			<epic-wf-nav-mega-menu-main-section>
				${s.map((l) => {
    if (l.__typename === "NavMenuSection")
      return he`
							<epic-wf-menu-section
								class="${l.expand ? "expand" : ""}"
								data-columns="${s.length}"
							>
								<h3 slot="heading">${l.heading}</h3>

								<div slot="content" class="wrap">
									${l.items.map((p) => {
        if (p.hidden) return he``;
        if (p.__typename === "NavMenuIconLink") {
          const f = {
            __typename: "NavLink",
            id: p.id,
            hrefTemplate: p.hrefTemplate,
            relativePath: p.relativePath,
            locale: p.locale,
            key: p.key,
            label: p.label || "",
            owner: p.owner
          };
          return he`
												<epic-wf-menu-item
													@click=${(h) => e._navLinkClick(h, f)}
													label=${p.label || ""}
													hrefTemplate=${p.hrefTemplate || ""}
													owner=${p.owner || ""}
													key=${p.key || ""}
													startIcon=${p.startIcon || ""}
													startIconColor=${l.brandColor || l.accentColor || ""}
													endIcon=${p.endIcon || ""}
													locale=${e.getMappedHygraphLocale(e.locale || "")}
													domain=${e?.domain || ""}
												>
												</epic-wf-menu-item>
											`;
        }
        return he``;
      })}
								</div>
							</epic-wf-menu-section>
						`;
    if (l.__typename === "NavMenuCtaSection") {
      const p = {
        __typename: "NavLink",
        id: l.id,
        hrefTemplate: l.hrefTemplate,
        relativePath: l.relativePath,
        locale: l.locale,
        key: l.key,
        label: l.label || "",
        owner: l.owner
      };
      return he`
							<epic-wf-menu-section
								class="${l.expand ? "expand" : ""}"
								data-columns="${s.length}"
							>
								<h3 slot="heading">${l.heading}</h3>

								<div slot="content" class="wrap">
									<epic-wf-description-cta
										@click=${(f) => e._navLinkClick(f, p)}
										label=${l.label || ""}
										description=${l.description || ""}
										hrefTemplate=${l.hrefTemplate || ""}
										locale=${e.getMappedHygraphLocale(e.locale || "")}
										owner=${l.owner || ""}
										key=${l.key || ""}
										.compact=${l.compact || !1}
									>
									</epic-wf-description-cta>
								</div>
							</epic-wf-menu-section>
						`;
    }
    return he``;
  })}
			</epic-wf-nav-mega-menu-main-section>

			<epic-wf-nav-mega-menu-news-section>
				${Ln(
    d?.length ? he`
								<epic-wf-menu-section>
									${(i = t.news) != null && i.heading ? he`<h3 slot="heading">${t.news.heading}</h3>` : ""}
									<div slot="content" class="row">
										${d.map((l) => {
      const p = {
        __typename: "NavLink",
        id: l.id,
        hrefTemplate: l.hrefTemplate,
        relativePath: l.relativePath,
        locale: l.locale,
        key: l.key,
        label: l.eyebrow || "",
        owner: l.owner
      };
      return he`
												<epic-wf-image-card
													@click=${(f) => e._navLinkClick(f, p)}
													.image=${l.image || {}}
													eyebrow=${l.eyebrow || ""}
													description=${l.description || ""}
													hrefTemplate=${l.hrefTemplate || ""}
													owner=${l.owner || ""}
													key=${l.key || ""}
													locale=${e.getMappedHygraphLocale(l.locale || "")}
													domain=${e?.domain || ""}
												></epic-wf-image-card>
											`;
    })}
									</div>
								</epic-wf-menu-section>
							` : void 0
  )}
			</epic-wf-nav-mega-menu-news-section>
		</epic-wf-nav-mega-menu>
	`;
}, GPe = (e, t, r) => {
  var n;
  return he`
		<epic-wf-simple-menu>
			<div class="menu-heading"><h2>${r || ((n = e.commonStrings) == null ? void 0 : n.mobileMainMenuHeading)}</h2></div>
			<div class="menu-wrap" role="list">
				${t?.links.map(
    (o) => he`
						<epic-wf-menu-item
							role="listitem"
							@click=${(a) => e._navLinkClick(a, o)}
							hrefTemplate=${o.hrefTemplate || ""}
							locale=${e.getMappedHygraphLocale(e.locale || "")}
							label=${o.label || ""}
							domain=${e?.domain || ""}
							endIcon=${o.endIcon || ""}
						></epic-wf-menu-item>
					`
  )}
			</div>
		</epic-wf-simple-menu>
	`;
}, KPe = (e, t, r) => {
  if (!t.__typename) return he``;
  switch (t.__typename) {
    case "NavSimpleMenu":
      return he`${GPe(e, t, r)}`;
    case "NavMegaMenu":
      return he`${WPe(e, t, r)}`;
    case "NavVerticalMenu":
      return he`${kPe(e, t, r)}`;
    default:
      return he``;
  }
};
let zv = !1;
const YPe = (e, t, r) => {
  const n = Q_(t), o = !!t?.hrefTemplate, a = (l, p) => {
    const f = {
      __typename: "NavLink",
      id: t.id,
      hrefTemplate: t.hrefTemplate,
      relativePath: t.relativePath,
      locale: t.locale,
      key: t.key,
      label: t.label || "",
      owner: t.owner
    };
    if (!n)
      return e._navLinkClick(l, f);
    if (t.hrefTemplate)
      if (Qi(l) || zv || e.isMobile)
        l.preventDefault();
      else
        return e._navLinkClick(l, f);
    e.closeDropdownsAndSearch({ closeSearch: !0 }), e.activeMainLinkIndex === p ? e.activeMainLinkIndex = -1 : e.activeMainLinkIndex = p, zv = !1;
  }, i = (l, p) => {
    if (!Qi(l)) {
      const f = l.currentTarget, h = f?.firstElementChild;
      n && h && (e.closeDropdownsAndSearch(), e.drawerOpen ? e._trapSubFocus(
        h,
        hn,
        bf,
        h,
        () => e._untrapSubFocus(),
        (m) => {
          m.preventDefault(), m.stopImmediatePropagation(), e._backClick();
        }
      ) : e._trapFocus(h, hn, () => f)), e.activeMainLinkIndex = p;
    }
  }, s = (l) => {
    Qi(l) || (e.closeDropdownsAndSearch(), e.drawerOpen ? e._untrapSubFocus() : e._untrapFocus(), e.activeMainLinkIndex = -1);
  }, d = (l, p, f = !1) => {
    if (["Space", "Enter", "NumpadEnter"].includes(l.code) && !(["Enter", "NumpadEnter"].includes(l.code) && f && !(n && e.isMobile))) {
      if (l.preventDefault(), e.activeMainLinkIndex === p) {
        e.closeMenusAndInput({ closeSearch: !0 }), e.drawerOpen ? e._untrapSubFocus() : e._untrapFocus();
        return;
      }
      e.closeDropdownsAndSearch({ closeSearch: !0 }), e.activeMainLinkIndex = p, e.drawerOpen ? e._trapSubFocus(
        l,
        hn,
        bf,
        l.target,
        () => e._untrapSubFocus(),
        (h) => {
          h.preventDefault(), h.stopImmediatePropagation(), e._backClick();
        }
      ) : e._trapFocus(l, hn, bf);
    }
  };
  return he`
		<li
			@pointerenter=${e.isMobile ? null : (l) => i(l, r)}
			@pointerleave=${e.isMobile ? null : (l) => s(l)}
			class="main-nav__list-item"
			id="epic-wf-nav-main-link-${r}"
			data-key=${t?.key || ""}
			data-is-active=${e.activeMainLinkIndex === r}
		>
			<epic-wf-main-link
				.rtl=${e.dir === Nm.RTL}
				.isParent=${!0}
				.isMobile=${e.isMobile}
				@click=${(l) => {
    if (l.detail === 0) {
      const p = new KeyboardEvent("keydown", { code: "Enter" });
      d(p, r, o);
    } else
      a(l, r);
  }}
				@touchend=${() => zv = !0}
				@keydown=${n ? (l) => d(l, r, o) : null}
				active=${e.activeMainLinkIndex === r}
				hasMenu=${n}
				hrefTemplate=${t?.hrefTemplate || ""}
				key=${t?.key || ""}
				label=${t?.label || ""}
				locale=${e.getMappedHygraphLocale(e?.locale || "")}
				domain=${e?.domain || ""}
				owner=${t?.owner || ""}
			>
				${n ? he`<div class="friendly-box"></div>` : ""}
			</epic-wf-main-link>
			${n ? t.menu && KPe(e, t.menu, t?.label || "") : ""}
		</li>
	`;
}, XPe = (e, t, r) => {
  var n;
  return !t || !Array.isArray(t) || !t.length ? he`` : he`<epic-wf-nav-main-menu>
		<ul
			class="main-nav__list"
			slot="list"
			data-mobile-child-menu-open=${e.isMobile && e.activeMainLinkIndex !== -1}
		>
			<li class="menu-heading"><h2>${((n = e.commonStrings) == null ? void 0 : n.mobileMainMenuHeading) || "Menu"}</h2></li>
			${t.map((o, a) => YPe(e, o, a))}
			${JPe(e, t, r)}
			<li class="main-nav__list-filler"><epic-wf-nav-main-menu-filler></epic-wf-nav-main-menu-filler></li>
		</ul>
	</epic-wf-nav-main-menu>`;
};
let Vre = !1, Jv = 0;
const QPe = () => {
  if (document) {
    const e = document.createElement("style");
    e.innerHTML = `
			.wf-nav-open {
				height: 100vh;
				overflow: hidden;
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
			}

			@supports (height: 100dvh) {
				.wf-nav-open {
					height: 100dvh;
				}
			}
			
			.epic-wf {
				--eg-global-nav-height: 4.5rem;
			}
		`, document.body.appendChild(e), Vre = !0;
  }
}, ZPe = (e) => {
  Vre || QPe(), e === !0 ? document.body.classList.contains("wf-nav-open") || (Jv = window.scrollY, document.body.style.transform = `translateY(-${Jv}px)`, document.body.classList.add("wf-nav-open"), requestAnimationFrame(() => {
    document.body.classList.contains("wf-nav-open") && (document.body.style.transform = "");
  })) : requestAnimationFrame(() => {
    document.body.classList.contains("wf-nav-open") && (document.body.classList.remove("wf-nav-open"), window.scrollTo(0, Jv));
  });
}, eOe = async () => {
  const e = document?.documentElement;
  e && e.classList && !e.classList.contains("epic-wf") && e.classList.add("epic-wf");
}, tOe = (e, t, r) => e.map((o) => {
  var a, i;
  const { hrefTemplate: s, menu: d, ...l } = o, p = jt({
    hrefTemplate: s,
    domain: t,
    locale: r
  }), f = Object.assign({}, d);
  return o.menu && (f.__typename === "NavSimpleMenu" ? f.links = f.links.map((h) => ({
    ...h,
    hrefTemplate: jt({
      hrefTemplate: h.hrefTemplate,
      domain: t,
      locale: r
    })
  })) : f.__typename === "NavMegaMenu" ? (f.sections.forEach((h) => {
    h.__typename === "NavMenuSection" ? h.items = h.items.map((m) => m.__typename === "NavMenuIconLink" ? {
      ...m,
      hrefTemplate: jt({
        hrefTemplate: m.hrefTemplate,
        domain: t,
        locale: r
      })
    } : m) : h.__typename === "NavMenuCtaSection" && (h.hrefTemplate = jt({
      hrefTemplate: h.hrefTemplate,
      domain: t,
      locale: r
    }));
  }), (a = f.news) != null && a.cards && (f.news.cards = (i = f.news) == null ? void 0 : i.cards.map((h) => ({
    ...h,
    hrefTemplate: jt({
      hrefTemplate: h.hrefTemplate,
      domain: t,
      locale: r
    })
  })))) : f.__typename === "NavVerticalMenu" && f.sections.forEach((h) => {
    h.__typename === "NavMenuSection" ? h.items = h.items.map((m) => m.__typename === "NavMenuIconLink" ? {
      ...m,
      hrefTemplate: jt({
        hrefTemplate: m.hrefTemplate,
        domain: t,
        locale: r
      })
    } : m) : h.__typename === "NavMenuCtaSection" && (h.hrefTemplate = jt({
      hrefTemplate: h.hrefTemplate,
      domain: t,
      locale: r
    }));
  })), {
    ...l,
    menu: f,
    hrefTemplate: p
  };
}), Nf = 300, KN = $J.md + Nf, rOe = 364, nOe = (e) => !e || e >= KN ? Nf : e < $J.md - 16 ? 0 : e > 0 ? Nf - Math.floor((KN - e) / 2) : Nf, YN = function(e = 0, t, r = 0, n = 2) {
  const o = Math.floor(e), a = Math.ceil(r);
  let i = Math.ceil(a + n), s = 0;
  for (const d of t) {
    if (!d.value) continue;
    const l = Math.ceil(n + d.value);
    if (i + l > o) {
      if (s === t.length - 1 && i + l - a <= o)
        return t.length;
      break;
    }
    i += l, s++;
  }
  return s;
};
var Mm = typeof navigator < "u" && typeof window < "u";
if (Mm && typeof nw < "u")
  try {
    nw.Window.get();
  } catch {
    Mm = !1;
  }
var Us = Mm ? navigator.userAgent : void 0, ke = { gui: Mm };
ke.node = typeof process < "u" && !!process.versions && !!process.versions.node;
ke.pwa = ke.gui && window.matchMedia("(display-mode: standalone)").matches && document.head.querySelector('[rel="manifest"]') !== null;
ke.uwp = typeof Windows < "u" && typeof MSApp < "u";
ke.nwjs = !!(ke.node && process.versions.nw);
ke.electron = !!(ke.node && process.versions.electron);
ke.cordova = !!(ke.gui && window.cordova);
ke.packaged = ke.uwp || ke.nwjs || ke.electron || ke.cordova;
ke.web = !ke.node && !ke.packaged;
ke.browser = ke.web;
ke.website = ke.web && !ke.pwa;
ke.worker = !ke.gui && typeof self < "u" && self.importScripts !== void 0;
ke.serviceWorker = ke.worker && !!navigator.serviceWorker.controller || !1;
ke.android = ke.gui ? Us.includes("Android") : !1;
ke.chromeos = ke.gui ? Us.includes("CrOS") : !1;
ke.tizen = ke.gui ? Us.includes("Tizen") : !1;
ke.ios = ke.gui && /iPad|iPhone|iPod/.test(Us) && !window.MSStream || !1;
ke.linuxBased = ke.android || ke.tizen;
ke.windows = ke.node ? process.platform === "win32" : Us.includes("Windows");
ke.macos = ke.node ? process.platform === "darwin" : Us.includes("Macintosh");
ke.linux = ke.node ? process.platform === "linux" : Us.includes("Linux") && !ke.linuxBased && !ke.macos;
const oOe = (e, t, r) => {
  if (e?.hrefTemplate)
    return e.hrefTemplate;
  let n = e?.defaultHref || "";
  if (ke.android && e?.androidHref ? n = e.androidHref : ke.ios && e?.iosHref ? n = e.iosHref : ke.windows && e?.windowsHref ? n = e.windowsHref : ke.macos && e?.macHref && (n = e.macHref), r && n) {
    const o = new URL(n, t || location.origin);
    Object.entries(r).map((a) => o.searchParams.append(...a)), n = o.toString();
  }
  return n || "";
}, XN = (e) => (ke.android || ke.ios) && e?.mobileLabel ? e?.mobileLabel : e?.label || "";
var aOe = Object.defineProperty, iOe = Object.getOwnPropertyDescriptor, ve = (e, t, r, n) => {
  for (var o = n > 1 ? void 0 : n ? iOe(t, r) : t, a = e.length - 1, i; a >= 0; a--)
    (i = e[a]) && (o = (n ? i(t, r, o) : i(o)) || o);
  return n && o && aOe(t, r, o), o;
};
const sOe = {
  "zh-hans": "zh-CN",
  "zh-hant": "zh-TW"
};
let me = class extends Dm {
  constructor() {
    super(...arguments), this.allPageData = {}, this._locale = "", this._propertyValuesInit = "", this.isReady = !1, this.isControllersInit = !1, this.chevronLeftIcon = "", this.chevronRightIcon = "", this.linesHorizontalIcon = "", this.xMarkIcon = "", this.globeIcon = "", this._initAttributeLocaleOptions = null, this.hygraphLocaleMapping = {}, this.isMobile = !1, this._isMobile = "(max-width: 719.9px)", this.isNotMobile = !0, this._isNotMobile = "(min-width: 720px)", this.isSmallDown = !0, this._isSmallDown = "(max-width: 959.9px)", this.isLargeDown = !0, this._isLargeDown = "(max-width: 1279.9px)", this.epicSID = Bre("_epicSID"), this.flyoutOpen = !1, this.flyoutMenuFocused = !1, this.drawerOpen = !1, this.submenuOpen = !1, this.largeCondensedLabel = "", this.brandStrings = {}, this.commonStrings = {}, this.navigationFlyout = {}, this.id = "", this.domain = "", this.propertyLogo = {}, this.mainLinks = new Array(), this.accountLinks = new Array(), this.accountMenu = {}, this.customAccountLinks = new Array(), this.localeOptions = new Array(), this.blackListLangCodes = new Array(), this.signInLink = {}, this.signOutLink = {}, this._platformCtaButton = {}, this.activeMainLinkIndex = -1, this._moreOpened = !1, this.localeMenuOpen = !1, this.accountMenuOpen = !1, this.searchOpen = !1, this.isLoggedIn = !1, this.displayName = "", this.disableSearch = !1, this.disableLocale = !1, this.disableUser = !1, this.disableCtaButton = !1, this.disableCtaButtonOnMobile = !1, this.enableMobileTopCta = !1, this.topOffsetPixels = 0, this.langUrlParam = "lang", this.localeHrefTemplate = "", this.signInLinkHref = "", this.signOutLinkHref = "", this.sticky = !0, this.accountLinkOverrides = {}, this.skipNavContentId = "", this.skipNavLabel = "Skip to main content", this.propertyLogoWidth = 0, this.walletBalance = "", this.walletBalanceHref = "", this.rewardsBalance = "", this.rewardsBalanceHref = "", this.vbucksBalance = "", this.vbucksBalanceHref = "", this.icons = new Array(), this._focusTrap = new qR(), this._subFocusTrap = new qR(), this._navItemsControllers = [], this._navItemsWidth = [], this._navItemsVisible = this._getMaxItems(), this._navMainMenuWidth = 0, this._navMainMenuOffsetInlineEnd = 0, this._navMainMenuMoreWidth = 0, this._navMainMenuFillerWidth = 0, this._navWidth = 0, this._throttleTimer = null, this._lastResizeTime = 0, this._throttleDelay = 20, this._navWidthProcessed = 0, this._navWidthLastMax = 0, this._navWidthDelta = 10, this._navWidthShouldRecalculate = () => {
      var e;
      return this._navWidthLastMax === this.maxNavItemsVisible && this._navItemsVisible > 0 && this._navItemsVisible !== ((e = this._navItems) == null ? void 0 : e.length) && Math.abs(this._navWidthProcessed - this._navWidth) < this._navWidthDelta;
    }, this._drawerAnimationTimerId = void 0;
  }
  /**
   * Load an icon using static imports
   */
  async loadIcon(e) {
    if (me.iconCache.has(e))
      return me.iconCache.get(e);
    try {
      let t;
      switch (e) {
        case "chevron-left":
          t = await import("./tokens-shared-DI5D0LMK.mjs").then((n) => n.c);
          break;
        case "chevron-right":
          t = await import("./tokens-shared-DI5D0LMK.mjs").then((n) => n.a);
          break;
        case "lines-horizontal":
          t = await import("./tokens-shared-DI5D0LMK.mjs").then((n) => n.l);
          break;
        case "x-mark":
          t = await import("./tokens-shared-DI5D0LMK.mjs").then((n) => n.x);
          break;
        case "globe":
          t = await import("./tokens-shared-DI5D0LMK.mjs").then((n) => n.d);
          break;
        default:
          return console.warn(`Unknown icon: ${e}`), "";
      }
      const r = t.default;
      return me.iconCache.set(e, r), r;
    } catch (t) {
      return console.warn(`Failed to load icon: ${e}`, t), "";
    }
  }
  /**
   * Load the icons that are commonly used in the navigation
   */
  async loadRequiredIcons() {
    try {
      const [e, t, r, n, o] = await Promise.all([
        this.loadIcon("chevron-left"),
        this.loadIcon("chevron-right"),
        this.loadIcon("lines-horizontal"),
        this.loadIcon("x-mark"),
        this.loadIcon("globe")
      ]);
      this.chevronLeftIcon = e, this.chevronRightIcon = t, this.linesHorizontalIcon = r, this.xMarkIcon = n, this.globeIcon = o;
    } catch (e) {
      console.warn("Failed to load navigation icons:", e);
    }
  }
  connectedCallback() {
    super.connectedCallback(), this._initAttributeLocaleOptions = this.getAttribute("localeOptions"), addEventListener("click", this._bodyClick.bind(this)), eOe(), this._propertyValuesInit || this.updatePropertyValues("en"), this.loadRequiredIcons(), setTimeout(() => {
      this.isReady = !0, this.dispatchEvent(
        new CustomEvent(Br.IS_READY, {
          bubbles: !0,
          composed: !0
        })
      );
    }, 350);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), removeEventListener("click", this._bodyClick.bind(this));
  }
  _bodyClick(e) {
    const t = this.shadowRoot;
    t && (e.composedPath().includes(t) || (this.accountMenuOpen || this.flyoutOpen || this.localeMenuOpen || this.moreOpened || this.activeMainLinkIndex !== -1) && this.closeMenusAndInput());
  }
  _onSearch(e) {
    this.drawerOpen && (this.closeDrawer(), this._untrapFocus());
  }
  getReverseLocale(e) {
    if (!e) return;
    const r = Object.fromEntries(
      Object.entries(this.hygraphLocaleMapping || {}).map((n) => {
        const o = n[1] || "";
        return [o?.toLowerCase() || o, n[0]];
      })
    )[e.toLowerCase()];
    return r || sOe[e.toLowerCase()];
  }
  set locale(e) {
    if (!e || this.locale === e) return;
    const r = this.getReverseLocale(e) || e, n = this._locale;
    this._locale = r, n !== r && this._propertyValuesInit !== r && this.updatePropertyValues(r);
  }
  get locale() {
    return this._locale;
  }
  getMappedHygraphLocale(e) {
    return this.hygraphLocaleMapping && typeof this.hygraphLocaleMapping[e] < "u" ? this.hygraphLocaleMapping[e] : e;
  }
  async updatePropertyValues(e) {
    var t, r, n;
    if (!e) return;
    const o = e.replace(/-/g, "_"), a = ((t = this.allPageData) == null ? void 0 : t[o]) || {}, { id: i, ...s } = a;
    if (s && Object.keys(s).length)
      Object.assign(this, s), this._propertyValuesInit = e;
    else if ((r = this.allPageData) != null && r.en) {
      const d = (n = this.allPageData) == null ? void 0 : n.en, { id: l, ...p } = d;
      Object.assign(this, p), this._propertyValuesInit = "en";
    }
    if (this._initAttributeLocaleOptions)
      try {
        this.localeOptions = JSON.parse(this._initAttributeLocaleOptions), console.log("Reset localeOptions", this.localeOptions);
      } catch {
      }
  }
  _handleIsMobile(e) {
    var t;
    const r = ((t = e?.detail) == null ? void 0 : t.value) || !1;
    r !== this.isMobile && r && (this.drawer.style.setProperty("display", "none"), setTimeout(() => {
      this.drawer.style.setProperty("display", "");
    }, 0.4)), this.isMobile = r, this.isNotMobile && this.isMobile && (this.isNotMobile = !1), this._throttledCalculations();
  }
  _handleIsNotMobile(e) {
    var t;
    this.isNotMobile = ((t = e?.detail) == null ? void 0 : t.value) || !1, this.isNotMobile && this.isMobile && (this.isMobile = !1), this.closeDrawer(), this._throttledCalculations();
  }
  _handleIsSmallDown(e) {
    var t;
    this.isSmallDown = ((t = e?.detail) == null ? void 0 : t.value) || !1;
  }
  _handleIsLargeDown(e) {
    var t;
    this.isLargeDown = ((t = e?.detail) == null ? void 0 : t.value) || !1;
  }
  set platformCtaButton(e) {
    const t = this._platformCtaButton;
    this._platformCtaButton = {
      ...e
    }, this.requestUpdate("platformCtaButton", t);
  }
  get platformCtaButton() {
    return this._platformCtaButton;
  }
  get moreOpened() {
    return this._moreOpened;
  }
  set moreOpened(e) {
    this.moreOpened !== e && (this._moreOpened = e, e || this._onMoreClosed());
  }
  _onMoreClosed() {
    this._untrapFocus(), this._isSubFocusTrapped && this._untrapSubFocus();
  }
  _getMaxItems() {
    var e, t, r, n;
    return this.maxNavItemsVisible && ((e = this._navItems) != null && e.length) ? Math.min(this.maxNavItemsVisible, (t = this._navItems) == null ? void 0 : t.length) : (r = this._navItems) != null && r.length ? (n = this._navItems) == null ? void 0 : n.length : -1;
  }
  updated(e) {
    var t, r;
    if ((t = this._navItems) != null && t.length && this._navMainMenu && this._navMainMenuMore && this._navMainMenuFiller) {
      if (this._navMainMenuMoreController) {
        this._throttledCalculations();
        return;
      }
      this.isControllersInit = !1, new Xc(this, {
        callback: ([n]) => {
          var o, a, i, s, d;
          return this._throttledCalculations(), (o = n?.contentRect) != null && o.width ? (((a = n?.contentRect) == null ? void 0 : a.width) > 0 && this._navWidth !== ((i = n?.contentRect) == null ? void 0 : i.width) && (this._navWidth = (s = n?.contentRect) == null ? void 0 : s.width), (d = n?.contentRect) == null ? void 0 : d.width) : this._navWidth || 0;
        }
      }), (r = this._navItems) == null || r.forEach((n, o) => {
        this._navItemsControllers[o] = new Xc(n, {
          callback: ([a]) => {
            var i, s, d, l;
            return this._throttledCalculations(), (i = a?.contentRect) != null && i.width ? (((s = a?.contentRect) == null ? void 0 : s.width) > 0 && this._navItemsWidth[o] !== ((d = a?.contentRect) == null ? void 0 : d.width) && (this._navItemsWidth[o] = (l = a?.contentRect) == null ? void 0 : l.width), this._navItemsWidth[o]) : this._navItemsWidth[o] || 0;
          }
        });
      }), this._navItemsVisible = this._getMaxItems(), new Xc(this._navMainMenu, {
        callback: ([n]) => {
          var o, a, i;
          return this._throttledCalculations(), (o = n?.contentRect) != null && o.width ? (((a = n?.contentRect) == null ? void 0 : a.width) !== this._navMainMenuWidth && (this._navMainMenuWidth = (i = n?.contentRect) == null ? void 0 : i.width), this._navMainMenuWidth) : this._navMainMenuWidth || 0;
        }
      }), this._navMainMenuMoreController = new Xc(this._navMainMenuMore, {
        callback: ([n]) => {
          var o, a, i, s;
          return this._throttledCalculations(), ((o = n?.contentRect) == null ? void 0 : o.width) > 0 && ((a = n?.contentRect) == null ? void 0 : a.width) !== this._navMainMenuMoreWidth && (this._navMainMenuMoreWidth = (i = n?.contentRect) == null ? void 0 : i.width), (s = n?.contentRect) == null ? void 0 : s.width;
        }
      }), this._navMainMenuFillerController = new Xc(this._navMainMenuFiller, {
        callback: ([n]) => {
          var o, a, i;
          return this._throttledCalculations(), ((o = n?.contentRect) == null ? void 0 : o.width) !== this._navMainMenuFillerWidth && (this._navMainMenuFillerWidth = (a = n?.contentRect) == null ? void 0 : a.width), (i = n?.contentRect) == null ? void 0 : i.width;
        }
      }), this.isConnected && !this.isControllersInit && setTimeout(() => {
        this.isControllersInit = !0;
      }, 350);
    }
  }
  _throttledCalculations() {
    const e = Date.now(), t = e - this._lastResizeTime - this._throttleDelay;
    if (t >= 0) {
      window.setTimeout(() => this._mainMenucalculations()), this._lastResizeTime = e;
      return;
    }
    this._throttleTimer && window.clearTimeout(this._throttleTimer), this._throttleTimer = window.setTimeout(() => this._throttledCalculations(), Math.max(0, -t));
  }
  _calculateMenuOffsetInlineEnd() {
    if (!this._navMainMenu) return;
    const e = this.dir === Pn.RTL ? this._navMainMenu.offsetLeft : window.innerWidth - this._navMainMenu.offsetLeft - this._navMainMenu.offsetWidth;
    (typeof this._navMainMenuOffsetInlineEnd != "number" || Math.abs(this._navMainMenuOffsetInlineEnd - e) > 10) && (this._navMainMenuOffsetInlineEnd = e);
  }
  _mainMenucalculations() {
    var e, t, r, n, o, a, i, s;
    if (this.isMobile) {
      this._navWidthProcessed = 0, this._navWidthLastMax = 0, this._navItemsVisible = ((e = this._navItems) == null ? void 0 : e.length) || -1;
      return;
    }
    if (typeof ((t = this._navMainMenuFillerController) == null ? void 0 : t.value) != "number" && (!((r = this._navItemsControllers) != null && r.length) || !((n = this._navItemsControllers[0]) != null && n.value))) {
      this._throttledCalculations();
      return;
    }
    if (this._navWidthShouldRecalculate())
      return;
    this._calculateMenuOffsetInlineEnd();
    let d = 0;
    if (!this.disableSearch && this.activeSearch && ((o = this._navMainMenuSearchBox) != null && o.offsetWidth)) {
      const x = nOe(this._navWidth), P = Math.floor(this._navMainMenuSearchBox.offsetWidth);
      P > x && (d = P - x);
    }
    const l = Math.ceil(this._navMainMenuMoreWidth || ((a = this._navMainMenuMore) == null ? void 0 : a.offsetWidth) || 0), p = Math.floor(this._navMainMenuWidth + d), f = 4, h = Math.max(Math.ceil(rOe - this._navMainMenuOffsetInlineEnd), 0) + 16 + f, m = p - h, g = YN(m - f / 2, this._navItemsControllers, l, 2), w = YN(m + f / 2, this._navItemsControllers, l, 2), _ = Math.max(Math.min(g, this._getMaxItems()), 0), b = Math.max(_ - 1, 0);
    if (!((i = this._navItemsControllers[b]) != null && i.value)) {
      this._throttledCalculations();
      return;
    }
    this._navItemsVisible !== _ && (this._navItemsVisible >= g && this._navItemsVisible <= w && _ >= g && _ <= w || (_ === ((s = this._navItems) == null ? void 0 : s.length) && this.moreOpened && (this.moreOpened = !1), Math.abs(this._navItemsVisible - _) < 2 && (this._navWidthProcessed = this._navWidth, this._navWidthLastMax = this.maxNavItemsVisible || 0), this._navItemsVisible = _));
  }
  getMainLinks() {
    return tOe(this.mainLinks, this.domain, this.getMappedHygraphLocale(this.locale));
  }
  /**
   * Public function to allow an additional links to be inserted at an index.
   * Multiple near simultaneous calls may cause rendering race conditions. Please only call once.
   * @param newMainLink
   * @param index
   * @returns
   */
  spliceMainLinks(e, t) {
    if (!this.isReady || !this.isControllersInit) {
      setTimeout(() => {
        this.spliceMainLinks(e, t);
      }, 150);
      return;
    }
    (!this.mainLinks || !Array.isArray(this.mainLinks)) && console.error("spliceMainLinks() navigation.mainLinks is invalid!"), e.length || console.warn("spliceMainLinks() newMainLinks invalid");
    let r = t === void 0 ? this.mainLinks.length : t;
    this._navMainMenuMoreController = void 0;
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      if (!o.id || !o.locale || !o.label) {
        console.error("spliceMainLinks() mainLink requires [id, locale, label]", o);
        continue;
      }
      if (this.mainLinks.filter((i) => i.id && i.id === o.id).length) {
        console.error("spliceMainLinks() mainLink id already exists", o);
        continue;
      }
      this.mainLinks.splice(r, 0, o), r++;
    }
    this.requestUpdate();
  }
  getAccountLinks() {
    return this.accountLinks;
  }
  closeDropdowns() {
    this.accountMenuOpen = !1, this.flyoutOpen = !1, this.flyoutMenuFocused = !1, this.localeMenuOpen = !1, this.moreOpened = !1;
  }
  closeSearch() {
    this.searchOpen = !1;
  }
  closeMainLinkMenus() {
    this.activeMainLinkIndex = -1;
  }
  closeDropdownsAndSearch({ closeSearch: e } = {}) {
    this.closeDropdowns(), (e || this.isMobile) && this.closeSearch();
  }
  closeMenusAndInput({ closeSearch: e } = {}) {
    this.closeDropdownsAndSearch({ closeSearch: e }), this.closeMainLinkMenus();
  }
  closeDrawer() {
    this.drawerOpen && this.dispatchEvent(
      new CustomEvent(Br.DRAWER_TOGGLE, {
        detail: { opened: !1 },
        bubbles: !0,
        composed: !0
      })
    ), this.drawerOpen = !1;
  }
  closeAll() {
    this.closeDrawer(), this.closeMenusAndInput();
  }
  toggleDrawer(e) {
    this.drawerOpen = !this.drawerOpen, this._drawerAnimationTimerId !== void 0 && clearTimeout(this._drawerAnimationTimerId), this.drawerOpen ? (this.closeMenusAndInput(), this._trapFocus(e, hn, Zs)) : this._untrapFocus(), this._drawerAnimationTimerId = window.setTimeout(this._onDrawerAnimationTimeout.bind(this), 300), this.dispatchEvent(
      new CustomEvent(Br.DRAWER_TOGGLE, {
        detail: { opened: this.drawerOpen },
        bubbles: !0,
        composed: !0
      })
    );
  }
  toggleFlyout(e) {
    const t = this.flyoutOpen;
    if (this.flyoutOpen = !t, this.flyoutOpen) {
      const r = e.target;
      if (r && r.shadowRoot) {
        const n = r.shadowRoot, o = n.querySelector("#nav-flyout-toggle"), a = n.querySelector("#nav-flyout-menu");
        o && a && this._trapFocus(
          e,
          () => a,
          () => o,
          () => this._untrapFocus()
        );
      }
    } else
      this._untrapFocus(), this.closeMenusAndInput();
  }
  toggleSearch(e) {
    var t;
    if (this.closeMenusAndInput({ closeSearch: !0 }), e?.detail && (this.searchOpen = ((t = e.detail) == null ? void 0 : t.activated) || !1, this.drawerOpen))
      if (this.searchOpen) {
        const r = e.composedPath();
        if (r.length > 0) {
          const n = r[0];
          this._trapSubFocus(
            e,
            (o) => n,
            () => n,
            n,
            () => {
            },
            (o) => {
            }
          );
        }
      } else
        this._untrapSubFocus();
  }
  _untrapAllFocusTraps() {
    this.drawerOpen ? (this._untrapSubFocus(), this._untrapFocus()) : this._untrapFocus();
  }
  _handleEscape(e) {
    e.key === "Escape" && (this.accountMenuOpen || this.activeMainLinkIndex > -1 || this.flyoutOpen || this.localeMenuOpen || this.moreOpened || this.searchOpen ? this.closeMenusAndInput({ closeSearch: !0 }) : this.closeDrawer());
  }
  _navLinkClick(e, t, r) {
    this._untrapAllFocusTraps(), r || this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.NAV_LINK_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _localeLinkClick(e, t) {
    if (this._untrapAllFocusTraps(), this.closeAll(), t) {
      const r = this.getMappedHygraphLocale(t.langCode);
      this.dispatchEvent(
        new CustomEvent(Br.LOCALE_LINK_CLICK, {
          detail: { originalEvent: e, link: { ...t, mappedLangCode: r } },
          bubbles: !0,
          composed: !0
        })
      );
    }
  }
  _mainLogoClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.PROPERTY_LOGO_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _mainAccountLinkClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.ACCOUNT_LINK_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _mainCtaClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.CTA_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _mainLocaleMenuClick(e) {
    const t = this.localeMenuOpen;
    this.closeMenusAndInput({ closeSearch: !0 }), this.localeMenuOpen = !t, this.localeMenuOpen ? this.drawerOpen ? this._trapSubFocus(
      e,
      hn,
      Zs,
      e.target,
      () => {
      },
      (r) => {
        this.closeMenusAndInput({ closeSearch: !0 }), this._untrapSubFocus();
      }
    ) : this._trapFocus(e, hn, Zs, () => {
    }) : this._untrapFocus();
  }
  _mainAccountMenuClick(e) {
    const t = this.accountMenuOpen;
    this.closeMenusAndInput({ closeSearch: !0 }), this.accountMenuOpen = !t, this.accountMenuOpen ? this.drawerOpen ? this._trapSubFocus(
      e,
      hn,
      Zs,
      e.target,
      () => {
      },
      (r) => {
        this.closeMenusAndInput({ closeSearch: !0 }), this._untrapSubFocus();
      }
    ) : this._trapFocus(e, hn, Zs, () => {
    }) : this._untrapFocus();
  }
  _walletBalanceClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.WALLET_BALANCE_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _rewardsBalanceClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.REWARDS_BALANCE_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _vbucksBalanceClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.VBUCKS_BALANCE_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _iconClick(e, t) {
    this._untrapAllFocusTraps(), this.closeAll(), t && (t.hrefTemplate && (t.hrefTemplate = jt({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Br.ICON_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  onDrawerAnimationEnd(e) {
    e.propertyName === "opacity" && (this._updateMobileDrawerState(), this._drawerAnimationTimerId !== void 0 && (clearTimeout(this._drawerAnimationTimerId), this._drawerAnimationTimerId = void 0));
  }
  // Jira ticket - MW-5076
  // This function's purpose is to correct the property mobile-drawer-has-opened and
  // mobile-drawer-has-closed values in case the transitionend event did not fired
  // and therefore, did not call the onDrawerAnimationEnd function (above).
  //
  // This function is called via a timer created in toggleDrawer() and should not be
  // called directly.
  _onDrawerAnimationTimeout() {
    this._updateMobileDrawerState(), this._drawerAnimationTimerId = void 0;
  }
  // Jira ticket - MW-5076
  // Update the drawer state, in specific, the data-mobile-drawer-has-opened and
  // data-mobile-drawer-has-closed attributes of the drawer tag (<div[#id='mobile-drawer']>).
  //
  // The attribute values will only be updated if they are incorrect based on the state
  // drawerOpen.  Not setting attribute values blindly will prevent the navigation from
  // re-rendering due to attribute updates, even though the value updated didn't change.
  _updateMobileDrawerState() {
    this.drawerOpen ? (this.header.getAttribute("data-mobile-drawer-has-opened") !== "true" && this.header.setAttribute("data-mobile-drawer-has-opened", "true"), this.header.getAttribute("data-mobile-drawer-has-closed") !== "false" && this.header.setAttribute("data-mobile-drawer-has-closed", "false")) : (this.header.getAttribute("data-mobile-drawer-has-opened") !== "false" && this.header.setAttribute("data-mobile-drawer-has-opened", "false"), this.header.getAttribute("data-mobile-drawer-has-closed") !== "true" && this.header.setAttribute("data-mobile-drawer-has-closed", "true"));
  }
  _backClick() {
    this.closeMenusAndInput();
  }
  _trapFocus(e, t, r, n, o) {
    const a = e instanceof Event ? e.target : e;
    this._trapFocusIn(
      a,
      this._focusTrap,
      t,
      r,
      this,
      n,
      o
    );
  }
  _untrapFocus() {
    this._untrapFocusIn(this._focusTrap);
  }
  _trapSubFocus(e, t, r, n, o, a) {
    const i = e instanceof Event ? e.target : e;
    this._trapFocusIn(
      i,
      this._subFocusTrap,
      t,
      r,
      n,
      o,
      a
    );
  }
  _untrapSubFocus() {
    this._untrapFocusIn(this._subFocusTrap);
  }
  get _isSubFocusTrapped() {
    return this._subFocusTrap.active;
  }
  _trapFocusIn(e, t, r, n, o, a, i) {
    if (e) {
      const s = r(e);
      if (s) {
        const d = n(e);
        t.trapFocusIn(s, {
          returnFocusTo: d,
          fallbackFocus: o,
          onDeactivate: a ?? this.closeDropdowns.bind(this),
          onEscapeDeactivates: i ?? this._handleEscape.bind(this)
        });
      }
    }
  }
  _untrapFocusIn(e) {
    e.untrapFocus();
  }
  render() {
    var e, t, r, n, o, a, i, s, d, l, p, f, h, m, g, w, _, b, x, P;
    (!this.localeOptions || !this.localeOptions.length) && this.disableLocale === !1 && (this.disableLocale = !0);
    const R = this.drawerOpen && this.activeMainLinkIndex > -1, N = !!((e = this.propertyLogo) != null && e.logo && ((r = (t = this.propertyLogo) == null ? void 0 : t.logo) != null && r.url)), C = !!((n = this.propertyLogo) != null && n.iconOnlyLogo && ((a = (o = this.propertyLogo) == null ? void 0 : o.iconOnlyLogo) != null && a.url)), A = N || C, E = ((s = (i = this.propertyLogo) == null ? void 0 : i.logo) == null ? void 0 : s.url) || ((l = (d = this.propertyLogo) == null ? void 0 : d.iconOnlyLogo) == null ? void 0 : l.url) || "";
    ZPe(this.drawerOpen), A && this.propertyLogoWidth === 0 && console.error("`propertyLogoWidth` not set, but is required to render the logo. Layout shift will occur!");
    const T = this.epicSID ? { trackingId: this.epicSID } : void 0, O = {
      ...this.platformCtaButton,
      defaultHref: jt({
        hrefTemplate: oOe(this.platformCtaButton, this.domain, T),
        locale: this.getMappedHygraphLocale(this.locale),
        domain: this.domain
      })
    }, k = !!(!this.disableCtaButton && O?.label), M = !!(this.enableMobileTopCta && this.isMobile && !this.disableCtaButtonOnMobile && k), L = !!(this.isMobile && ((p = this.icons) != null && p.some(($) => $.mobileTopLevel)));
    return (this.dir === "" || this.dir === Pn.LTR) && UR(this.locale) ? (this.dir = Pn.RTL, this.setAttribute("dir", Pn.RTL)) : this.dir === Pn.RTL && !UR(this.locale) && (this.dir = Pn.LTR, this.setAttribute("dir", Pn.LTR)), he`
			${A ? he`<link rel="preload" fetchpriority="high" as="image" href="${E}" />` : ""}
			${this.skipNavContentId ? he`<epic-wf-cta-button
						class="skip-nav"
						href="#${this.skipNavContentId}"
						id="skip-nav"
						label=${((f = this.commonStrings) == null ? void 0 : f.skipNavLabel) || this.skipNavLabel}
						target="_self"
					></epic-wf-cta-button>` : null}

			<header
				class="global-header ${this.dir === Pn.RTL ? Pn.RTL : ""}"
				data-dropdown-open=${this.accountMenuOpen || this.localeMenuOpen}
				data-flyout-open=${this.flyoutOpen}
				data-mobile-cta-hidden=${!k || this.disableCtaButtonOnMobile}
				data-mobile-top-cta=${M}
				data-mobile-drawer-open=${this.drawerOpen}
				data-mobile-drawer-has-opened="false"
				data-mobile-drawer-has-closed="true"
				data-mobile-subdrawer-open=${R}
				data-search-open=${this.searchOpen}
				data-property-logo-valid=${A}
				data-property-logo-icon-valid=${C}
				id="global-header"
				style=${this.topOffsetPixels > 0 ? `--top-offset: ${this.topOffsetPixels}px` : ""}
			>
				<div class="bg-filter"></div>
				${pPe({ disabled: !A && this.drawerOpen, nav: this, validPropertyLogo: A })}

				<nav aria-label="${((h = this.brandStrings) == null ? void 0 : h.componentLabel) || ""}" class="global-header__nav">
					${A ? he`
								<epic-wf-property-logo
									@click=${($) => {
      this._mainLogoClick($, this.propertyLogo);
    }}
									.logo=${((m = this.propertyLogo) == null ? void 0 : m.logo) || {}}
									.iconOnlyLogo=${((g = this.propertyLogo) == null ? void 0 : g.iconOnlyLogo) || {}}
									logoAlt=${((w = this.propertyLogo) == null ? void 0 : w.logoAlt) || ""}
									hrefTemplate=${((_ = this.propertyLogo) == null ? void 0 : _.hrefTemplate) || ""}
									locale=${this.getMappedHygraphLocale(this.locale || "")}
									width=${this.propertyLogoWidth}
									domain=${this.domain || ""}
									?validMobileTopCta=${M}
								></epic-wf-property-logo>
							` : null}

					<div class="mobile-toolbar">
						${fn(
      L,
      () => he`<div class="tools">${Hre(this, { mobileTopLevel: !0 })}</div>`
    )}
						${fn(
      M,
      () => he`
								<div class="mobile-top-cta">
									<epic-wf-cta-button
										?small=${!0}
										@click=${($) => {
        this._mainCtaClick($, O);
      }}
										domain=${this.domain}
										href=${O?.defaultHref || ""}
										label=${XN(O)}
										locale=${this.getMappedHygraphLocale(this.locale)}
									></epic-wf-cta-button>
								</div>
							`
    )}

						<button
							@click=${this.toggleDrawer}
							aria-controls="mobile-drawer"
							aria-expanded=${this.drawerOpen}
							aria-label=${((b = this.commonStrings) == null ? void 0 : b.mobileMainMenuHeading) || "Menu"}
							class="menu-toggle"
							id="mobile-drawer-toggle"
						>
							${this.drawerOpen ? v(this.xMarkIcon) : v(this.linesHorizontalIcon)}
						</button>
					</div>
					<div @transitionend=${this.onDrawerAnimationEnd} class="global-header__drawer" id="mobile-drawer">
						<div
							class="main-nav items-visible-${this._navItemsVisible} ${!this.disableSearch && this.activeSearch && !this.isSmallDown ? "active-search" : "normal-search"}"
							data-search-open=${this.searchOpen}
							style="--items-visible:${this._navItemsVisible}"
						>
							${XPe(this, this.mainLinks, this._navItemsVisible)}
						</div>

						<div class="toolbar">
							${BPe(this)}

							<div class="toolbar__back-wrapper">
								<button
									@click=${this._backClick}
									aria-label="${((x = this.commonStrings) == null ? void 0 : x.backButtonAccessibleLabel) || ""}"
									class="back-button"
								>
									<span aria-hidden="true" class="icon-wrapper">
										${this.dir === Pn.RTL ? v(this.chevronRightIcon) : v(this.chevronLeftIcon)}
									</span>
									<span class="label">${((P = this.commonStrings) == null ? void 0 : P.backButtonLabel) || ""}</span>
								</button>
							</div>
						</div>

						${fn(
      k,
      () => he`
								<div class="main-cta">
									<epic-wf-cta-button
										@click=${($) => {
        this._mainCtaClick($, O);
      }}
										domain=${this.domain}
										href=${O?.defaultHref || ""}
										label=${XN(O)}
										locale=${this.getMappedHygraphLocale(this.locale)}
									></epic-wf-cta-button>
								</div>
							`
    )}
					</div>
				</nav>
				<lit-media-query .query="${this._isMobile}" @changed="${this._handleIsMobile}"></lit-media-query>
				<lit-media-query .query="${this._isNotMobile}" @changed="${this._handleIsNotMobile}"></lit-media-query>
				<lit-media-query .query="${this._isSmallDown}" @changed="${this._handleIsSmallDown}"></lit-media-query>
				<lit-media-query .query="${this._isLargeDown}" @changed="${this._handleIsLargeDown}"></lit-media-query>
			</header>
		`;
  }
};
me.styles = oE`
		${Pu(VPe)}
	`;
me.iconCache = /* @__PURE__ */ new Map();
ve([
  nr()
], me.prototype, "chevronLeftIcon", 2);
ve([
  nr()
], me.prototype, "chevronRightIcon", 2);
ve([
  nr()
], me.prototype, "linesHorizontalIcon", 2);
ve([
  nr()
], me.prototype, "xMarkIcon", 2);
ve([
  nr()
], me.prototype, "globeIcon", 2);
ve([
  Te()
], me.prototype, "locale", 1);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "hygraphLocaleMapping", 2);
ve([
  vc("#mobile-drawer")
], me.prototype, "drawer", 2);
ve([
  vc("#global-header")
], me.prototype, "header", 2);
ve([
  nr()
], me.prototype, "isMobile", 2);
ve([
  nr()
], me.prototype, "isNotMobile", 2);
ve([
  nr()
], me.prototype, "isSmallDown", 2);
ve([
  nr()
], me.prototype, "isLargeDown", 2);
ve([
  Te({ type: String })
], me.prototype, "epicSID", 2);
ve([
  nr()
], me.prototype, "flyoutOpen", 2);
ve([
  nr()
], me.prototype, "flyoutMenuFocused", 2);
ve([
  nr()
], me.prototype, "drawerOpen", 2);
ve([
  nr()
], me.prototype, "submenuOpen", 2);
ve([
  Te()
], me.prototype, "largeCondensedLabel", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "brandStrings", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "commonStrings", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "navigationFlyout", 2);
ve([
  Te({ type: String, attribute: !1 })
], me.prototype, "id", 2);
ve([
  Te()
], me.prototype, "domain", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "propertyLogo", 2);
ve([
  Te({ type: Array, converter: xr })
], me.prototype, "mainLinks", 2);
ve([
  Te({ type: Array, converter: xr })
], me.prototype, "accountLinks", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "accountMenu", 2);
ve([
  Te({ type: Array, converter: xr })
], me.prototype, "customAccountLinks", 2);
ve([
  Te({ type: Array, converter: xr })
], me.prototype, "localeOptions", 2);
ve([
  Te({ type: Array, converter: xr })
], me.prototype, "blackListLangCodes", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "signInLink", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "signOutLink", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "platformCtaButton", 1);
ve([
  nr()
], me.prototype, "activeMainLinkIndex", 2);
ve([
  nr()
], me.prototype, "moreOpened", 1);
ve([
  nr()
], me.prototype, "localeMenuOpen", 2);
ve([
  nr()
], me.prototype, "accountMenuOpen", 2);
ve([
  nr()
], me.prototype, "searchOpen", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "isLoggedIn", 2);
ve([
  Te()
], me.prototype, "displayName", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "disableSearch", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "disableLocale", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "disableUser", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "disableCtaButton", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "disableCtaButtonOnMobile", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "enableMobileTopCta", 2);
ve([
  Te({ type: Number, converter: gA })
], me.prototype, "topOffsetPixels", 2);
ve([
  Te()
], me.prototype, "langUrlParam", 2);
ve([
  Te()
], me.prototype, "localeHrefTemplate", 2);
ve([
  Te()
], me.prototype, "signInLinkHref", 2);
ve([
  Te()
], me.prototype, "signOutLinkHref", 2);
ve([
  Te({ type: Boolean, converter: da, reflect: !0 })
], me.prototype, "sticky", 2);
ve([
  Te({ type: Object, converter: xr })
], me.prototype, "accountLinkOverrides", 2);
ve([
  Te()
], me.prototype, "skipNavContentId", 2);
ve([
  Te()
], me.prototype, "skipNavLabel", 2);
ve([
  Te({ type: Number, converter: gA })
], me.prototype, "propertyLogoWidth", 2);
ve([
  Te({ type: Number, converter: gA })
], me.prototype, "maxNavItemsVisible", 2);
ve([
  Te({ type: Boolean, converter: da })
], me.prototype, "activeSearch", 2);
ve([
  Te()
], me.prototype, "walletBalance", 2);
ve([
  Te()
], me.prototype, "walletBalanceHref", 2);
ve([
  Te()
], me.prototype, "rewardsBalance", 2);
ve([
  Te()
], me.prototype, "rewardsBalanceHref", 2);
ve([
  Te()
], me.prototype, "vbucksBalance", 2);
ve([
  Te()
], me.prototype, "vbucksBalanceHref", 2);
ve([
  Te({ type: Array, converter: xr })
], me.prototype, "icons", 2);
ve([
  Te({ type: String })
], me.prototype, "initSearchValue", 2);
ve([
  Yre(".main-nav__list-item:not(.main-nav__list-item--condensed) > epic-wf-main-link")
], me.prototype, "_navItems", 2);
ve([
  nr({ hasChanged: (e, t) => e !== t })
], me.prototype, "_navItemsVisible", 2);
ve([
  vc("epic-wf-nav-main-menu")
], me.prototype, "_navMainMenu", 2);
ve([
  vc("epic-wf-nav-main-menu-filler")
], me.prototype, "_navMainMenuFiller", 2);
ve([
  vc("epic-wf-search-box")
], me.prototype, "_navMainMenuSearchBox", 2);
ve([
  vc(".main-nav__list-item.main-nav__list-item--condensed > epic-wf-main-link")
], me.prototype, "_navMainMenuMore", 2);
me = ve([
  eM("epic-wf-navigation")
], me);
export {
  me as N,
  VPe as s
};
