import { r as Tt, i as St, n as ne, a as Pt, x as ae, t as Lt, m as Ek, o as d, b as ha, c as xk } from "./lit-shared-CFTGSJeC.mjs";
import { c as Tk } from "./tokens-shared-D-QolYXQ.mjs";
var yr = /* @__PURE__ */ ((e) => (e.LTR = "ltr", e.RTL = "rtl", e))(yr || {});
const Gd = ({ hrefTemplate: e = "", domain: t = "", locale: r = "" }) => {
  if (!e)
    return "";
  const n = r?.replace(/_/g, "-");
  let a = e;
  return t ? a = a.replace(/({|%7B)domain(}|%7D)/gi, t || "") : a = a.replace(/\/?({|%7B)domain(}|%7D)/gi, t || ""), n ? a = a.replace(/({|%7B)locale(}|%7D)/gi, n || "") : a = a.replace(/\/?({|%7B)locale(}|%7D)/gi, n || ""), a;
};
var Fi = { NODE_ENV: "production" };
const Sk = (e, t) => !!(e && e === "true"), st = (e) => {
  if (e && typeof e == "string")
    try {
      return JSON.parse(e);
    } catch {
      console.warn("jsonConverter could not parse", e);
    }
  return e;
}, Pk = ["ar", "ar-ar", "ar-AR"], fy = (e) => !e || typeof e != "string" ? !1 : Pk.includes(e);
var Bo = {}, ht = {}, my;
function Ok() {
  if (my) return ht;
  my = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.pickupWithVariantKey = ht.extractVariantKeys = ht.mergeScreenshotOptions = ht.createBaseScreenshotOptions = ht.expandViewportsOption = void 0;
  const e = {
    waitAssets: !0,
    waitImages: !1,
    waitFor: "",
    fullPage: !0,
    skip: !1,
    focus: "",
    hover: "",
    click: "",
    variants: {},
    omitBackground: !1,
    captureBeyondViewport: !0,
    clip: null,
    forwardConsoleLogs: !1,
    trace: !1
  };
  function t(s) {
    if (!s.viewports)
      return s;
    const { viewports: l } = s, c = { ...s };
    delete c.viewports;
    const u = Array.isArray(l) ? l : Object.keys(l);
    if (!u.length)
      return s;
    const p = (m) => Array.isArray(l) ? m : l[m], f = { ...s.variants };
    return u.slice(1).forEach((m) => f[m] = { viewport: p(m) }), c.viewport = p(u[0]), c.variants = f, u.length > 1 && (c.defaultVariantSuffix = u[0]), c;
  }
  ht.expandViewportsOption = t;
  function r({ delay: s, disableWaitAssets: l, viewports: c }) {
    return c.length > 1 ? {
      ...e,
      delay: s,
      waitAssets: !l,
      viewport: c[0],
      variants: c.slice(1).reduce((u, p) => ({ ...u, [p]: { viewport: p } }), {}),
      defaultVariantSuffix: c[0]
    } : {
      ...e,
      delay: s,
      waitAssets: !l,
      viewport: c[0],
      defaultVariantSuffix: ""
    };
  }
  ht.createBaseScreenshotOptions = r;
  function n(s, l) {
    const c = Object.assign({}, s, l);
    return !s.viewport || typeof s.viewport == "string" ? l.viewport && (c.viewport = l.viewport) : l.viewport && (typeof l.viewport == "object" ? c.viewport = {
      ...s.viewport,
      ...l.viewport
    } : c.viewport = l.viewport), s.variants && (c.variants = n(s.variants, l.variants || {})), c;
  }
  ht.mergeScreenshotOptions = n;
  function a({ variants: s, defaultVariantSuffix: l }) {
    if (!s)
      return [null, []];
    let c;
    const u = Object.keys(s).reduce((p, f) => {
      const m = [], y = (g, v = []) => {
        if (l && l === g)
          return m.push([g, ...v]), !0;
        if (!s[g])
          return c = {
            type: "notFound",
            from: v[0],
            to: g
          }, !1;
        if (v.find((E) => E === g))
          return c = {
            type: "circular",
            refs: [g, ...v]
          }, !1;
        const _ = s[g].extends, b = Array.isArray(_) ? _ : typeof _ == "string" ? [_] : [];
        return b.length ? b.every((E) => y(E, [g, ...v])) : (m.push([g, ...v]), !0);
      };
      return y(f), [...p, ...m.map((g) => ({ isDefault: !1, keys: g }))];
    }, []);
    return c ? [c, []] : [null, u];
  }
  ht.extractVariantKeys = a;
  function i(s, l) {
    if (l.isDefault)
      return s;
    const c = Object.assign({}, s), u = c.variants || {};
    delete c.variants;
    const p = l.keys[0] && l.keys[0] === s.defaultVariantSuffix ? 1 : 0;
    return l.keys.slice(p).reduce((f, m) => n(f, u[m]), c);
  }
  return ht.pickupWithVariantKey = i, ht;
}
var hy;
function Ck() {
  if (hy) return Bo;
  hy = 1, Object.defineProperty(Bo, "__esModule", { value: !0 }), Bo.triggerScreenshot = void 0;
  const e = /* @__PURE__ */ Ok();
  function t(f) {
    const m = window;
    if (m.emitCapture)
      return f(m);
  }
  function r(f) {
    const { searchParams: m } = new URL(f), y = m.get("id"), g = m.get("selectedKind"), v = m.get("selectedStory");
    if (y)
      return y;
    if (g && v)
      return `${g}/${v}`;
    throw new Error();
  }
  function n(f = 0) {
    return new Promise((m) => setTimeout(m, f));
  }
  function a(f) {
    if (!f)
      return Promise.resolve();
    if (typeof f == "string") {
      const m = window[f];
      return typeof m != "function" ? Promise.resolve() : Promise.resolve().then(() => m());
    } else return typeof f == "function" ? f() : Promise.resolve();
  }
  function i(f) {
    return new Promise((m) => f.requestIdleCallback(m, { timeout: 3e3 }));
  }
  function s(f, m, y) {
    m && (f.optionStore || (f.optionStore = {}), f.optionStore[m] || (f.optionStore[m] = []), f.optionStore[m].push(y));
  }
  function l(f, m) {
    if (!f.optionStore || !f.optionStore[m])
      return null;
    const y = f.optionStore[m];
    return delete f.optionStore[m], y;
  }
  function c(f = {}, m) {
    let y;
    m && m.id ? y = m.id : m && m.story && m.kind ? y = m.kind + "/" + m.story : y = r(location.href), t((g) => s(g, y, f));
  }
  function u() {
    t(async (f) => {
      await f.waitBrowserMetricsStable();
      const [m, y] = await Promise.all([
        f.getBaseScreenshotOptions(),
        // Options set via CLI
        f.getCurrentVariantKey()
        // Variant key for this capturing process
      ]), g = r(location.href), v = l(f, g);
      if (!v)
        return;
      const _ = v.reduce((E, C) => (0, e.mergeScreenshotOptions)(E, (0, e.expandViewportsOption)(C)), m), b = (0, e.pickupWithVariantKey)(_, y);
      if (b.skip)
        return f.emitCapture(b, g);
      await n(b.delay), await a(b.waitFor), await i(f), await f.emitCapture(b, g);
    });
  }
  function p(f, m) {
    c(f, m), Promise.resolve().then(u);
  }
  return Bo.triggerScreenshot = p, Bo;
}
var Ak = Ck(), Rk = Object.create, $s = Object.defineProperty, kk = Object.getOwnPropertyDescriptor, lb = Object.getOwnPropertyNames, Ik = Object.getPrototypeOf, jk = Object.prototype.hasOwnProperty, o = (e, t) => $s(e, "name", { value: t, configurable: !0 }), yi = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
}), F = (e, t) => function() {
  return t || (0, e[lb(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Ua = (e, t) => {
  for (var r in t)
    $s(e, r, { get: t[r], enumerable: !0 });
}, Nk = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let a of lb(t))
      !jk.call(e, a) && a !== r && $s(e, a, { get: () => t[a], enumerable: !(n = kk(t, a)) || n.enumerable });
  return e;
}, Ye = (e, t, r) => (r = e != null ? Rk(Ik(e)) : {}, Nk(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? $s(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), qk = 5e3;
function Kd() {
  try {
    return (
      // @ts-expect-error This property exists in Vitest browser mode
      !!globalThis.__vitest_browser__ || !!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
    );
  } catch {
    return !1;
  }
}
o(Kd, "isTestEnvironment");
function Yd(e = !0) {
  if (!("document" in globalThis && "createElement" in globalThis.document))
    return () => {
    };
  const t = document.createElement("style");
  t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`, document.head.appendChild(t);
  const r = document.createElement("style");
  return r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? "reverse" : "normal"} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`, document.head.appendChild(r), document.body.clientHeight, document.head.removeChild(t), () => {
    r.parentNode?.removeChild(r);
  };
}
o(Yd, "pauseAnimations");
async function Xd(e) {
  if (!("document" in globalThis && "getAnimations" in globalThis.document && "querySelectorAll" in globalThis.document))
    return;
  let t = !1;
  await Promise.race([
    // After 50ms, retrieve any running animations and wait for them to finish
    // If new animations are created while waiting, we'll wait for them too
    new Promise((r) => {
      setTimeout(() => {
        const n = [globalThis.document, ...Qd(globalThis.document)], a = /* @__PURE__ */ o(async () => {
          if (t || e?.aborted)
            return;
          const i = n.flatMap((s) => s?.getAnimations?.() || []).filter((s) => s.playState === "running" && !ub(s));
          i.length > 0 && (await Promise.all(i.map((s) => s.finished)), await a());
        }, "checkAnimationsFinished");
        a().then(r);
      }, 100);
    }),
    // If animations don't finish within the timeout, continue without waiting
    new Promise(
      (r) => setTimeout(() => {
        t = !0, r(void 0);
      }, qk)
    )
  ]);
}
o(Xd, "waitForAnimations");
function Qd(e) {
  return [e, ...e.querySelectorAll("*")].reduce((t, r) => ("shadowRoot" in r && r.shadowRoot && t.push(r.shadowRoot, ...Qd(r.shadowRoot)), t), []);
}
o(Qd, "getShadowRoots");
function ub(e) {
  if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
    const t = getComputedStyle(e.effect.target, e.effect.pseudoElement), r = t.animationName?.split(", ").indexOf(e.animationName);
    return t.animationIterationCount.split(", ")[r] === "infinite";
  }
  return !1;
}
o(ub, "isInfiniteAnimation");
var cb = F({
  "../node_modules/picoquery/lib/string-util.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeString = n;
    var t = Array.from({ length: 256 }, (a, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()), r = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
    ]);
    function n(a) {
      const i = a.length;
      if (i === 0)
        return "";
      let s = "", l = 0, c = 0;
      e: for (; c < i; c++) {
        let u = a.charCodeAt(c);
        for (; u < 128; ) {
          if (r[u] !== 1 && (l < c && (s += a.slice(l, c)), l = c + 1, s += t[u]), ++c === i)
            break e;
          u = a.charCodeAt(c);
        }
        if (l < c && (s += a.slice(l, c)), u < 2048) {
          l = c + 1, s += t[192 | u >> 6] + t[128 | u & 63];
          continue;
        }
        if (u < 55296 || u >= 57344) {
          l = c + 1, s += t[224 | u >> 12] + t[128 | u >> 6 & 63] + t[128 | u & 63];
          continue;
        }
        if (++c, c >= i)
          throw new Error("URI malformed");
        const p = a.charCodeAt(c) & 1023;
        l = c + 1, u = 65536 + ((u & 1023) << 10 | p), s += t[240 | u >> 18] + t[128 | u >> 12 & 63] + t[128 | u >> 6 & 63] + t[128 | u & 63];
      }
      return l === 0 ? a : l < i ? s + a.slice(l) : s;
    }
    o(n, "encodeString");
  }
}), Zd = F({
  "../node_modules/picoquery/lib/shared.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0;
    var t = cb(), r = /* @__PURE__ */ o((i) => {
      switch (typeof i) {
        case "string":
          return (0, t.encodeString)(i);
        case "bigint":
        case "boolean":
          return "" + i;
        case "number":
          if (Number.isFinite(i))
            return i < 1e21 ? "" + i : (0, t.encodeString)("" + i);
          break;
      }
      return i instanceof Date ? (0, t.encodeString)(i.toISOString()) : "";
    }, "defaultValueSerializer");
    e.defaultValueSerializer = r;
    var n = /* @__PURE__ */ o((i) => i instanceof Date, "defaultShouldSerializeObject");
    e.defaultShouldSerializeObject = n;
    var a = /* @__PURE__ */ o((i) => i, "identityFunc");
    e.defaultOptions = {
      nesting: !0,
      nestingSyntax: "dot",
      arrayRepeat: !1,
      arrayRepeatSyntax: "repeat",
      delimiter: 38,
      valueDeserializer: a,
      valueSerializer: e.defaultValueSerializer,
      keyDeserializer: a,
      shouldSerializeObject: e.defaultShouldSerializeObject
    };
  }
}), db = F({
  "../node_modules/picoquery/lib/object-util.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getDeepObject = a, e.stringifyObject = p;
    var t = Zd(), r = cb();
    function n(f) {
      return f === "__proto__" || f === "constructor" || f === "prototype";
    }
    o(n, "isPrototypeKey");
    function a(f, m, y, g, v) {
      if (n(m))
        return f;
      const _ = f[m];
      return typeof _ == "object" && _ !== null ? _ : !g && (v || typeof y == "number" || typeof y == "string" && y * 0 === 0 && y.indexOf(".") === -1) ? f[m] = [] : f[m] = {};
    }
    o(a, "getDeepObject");
    var i = 20, s = "[]", l = "[", c = "]", u = ".";
    function p(f, m, y = 0, g, v) {
      const { nestingSyntax: _ = t.defaultOptions.nestingSyntax, arrayRepeat: b = t.defaultOptions.arrayRepeat, arrayRepeatSyntax: E = t.defaultOptions.arrayRepeatSyntax, nesting: C = t.defaultOptions.nesting, delimiter: k = t.defaultOptions.delimiter, valueSerializer: N = t.defaultOptions.valueSerializer, shouldSerializeObject: O = t.defaultOptions.shouldSerializeObject } = m, S = typeof k == "number" ? String.fromCharCode(k) : k, w = v === !0 && b, T = _ === "dot" || _ === "js" && !v;
      if (y > i)
        return "";
      let M = "", R = !0, D = !1;
      for (const J in f) {
        const P = f[J];
        if (P === void 0)
          continue;
        let q;
        g ? (q = g, w ? E === "bracket" && (q += s) : T ? (q += u, q += J) : (q += l, q += J, q += c)) : q = J, R || (M += S), typeof P == "object" && P !== null && !O(P) ? (D = P.pop !== void 0, (C || b && D) && (M += p(P, m, y + 1, q, D))) : (M += (0, r.encodeString)(q), M += "=", M += N(P, J)), R && (R = !1);
      }
      return M;
    }
    o(p, "stringifyObject");
  }
}), Mk = F({
  "../node_modules/picoquery/lib/decode-uri-component.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeURIComponent = a;
    var t = 12, r = 0, n = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function a(l) {
      let c = l.indexOf("%");
      if (c === -1)
        return l;
      const u = l.length;
      let p = "", f = 0, m = 0, y = c, g = t;
      for (; c > -1 && c < u; ) {
        const v = s(l[c + 1], 4), _ = s(l[c + 2], 0), b = v | _, E = n[b];
        if (g = n[256 + g + E], m = m << 6 | b & n[364 + E], g === t)
          p += l.slice(f, y), p += m <= 65535 ? String.fromCharCode(m) : String.fromCharCode(55232 + (m >> 10), 56320 + (m & 1023)), m = 0, f = c + 3, c = y = l.indexOf("%", f);
        else {
          if (g === r)
            return null;
          if (c += 3, c < u && l.charCodeAt(c) === 37)
            continue;
          return null;
        }
      }
      return p + l.slice(f);
    }
    o(a, "decodeURIComponent");
    var i = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    function s(l, c) {
      const u = i[l];
      return u === void 0 ? 255 : u << c;
    }
    o(s, "hexCodeToInt");
  }
}), $k = F({
  "../node_modules/picoquery/lib/parse.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.numberValueDeserializer = e.numberKeyDeserializer = void 0, e.parse = u;
    var t = db(), r = Zd(), n = Mk(), a = /* @__PURE__ */ o((p) => {
      const f = Number(p);
      return Number.isNaN(f) ? p : f;
    }, "numberKeyDeserializer");
    e.numberKeyDeserializer = a;
    var i = /* @__PURE__ */ o((p) => {
      const f = Number(p);
      return Number.isNaN(f) ? p : f;
    }, "numberValueDeserializer");
    e.numberValueDeserializer = i;
    var s = /\+/g, l = /* @__PURE__ */ o(function() {
    }, "Empty");
    l.prototype = /* @__PURE__ */ Object.create(null);
    function c(p, f, m, y, g) {
      let v = p.substring(f, m);
      return y && (v = v.replace(s, " ")), g && (v = (0, n.decodeURIComponent)(v) || v), v;
    }
    o(c, "computeKeySlice");
    function u(p, f) {
      const { valueDeserializer: m = r.defaultOptions.valueDeserializer, keyDeserializer: y = r.defaultOptions.keyDeserializer, arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax, nesting: v = r.defaultOptions.nesting, arrayRepeat: _ = r.defaultOptions.arrayRepeat, nestingSyntax: b = r.defaultOptions.nestingSyntax, delimiter: E = r.defaultOptions.delimiter } = f ?? {}, C = typeof E == "string" ? E.charCodeAt(0) : E, k = b === "js", N = new l();
      if (typeof p != "string")
        return N;
      const O = p.length;
      let S = "", w = -1, T = -1, M = -1, R = N, D, J = "", P = "", q = !1, $ = !1, H = !1, z = !1, Z = !1, oe = !1, ie = 0, Y = -1, be = -1, we = -1;
      for (let le = 0; le < O + 1; le++) {
        if (ie = le !== O ? p.charCodeAt(le) : C, ie === C) {
          if (oe = T > w, oe || (T = le), M !== T - 1 && (P = c(p, M + 1, Y > -1 ? Y : T, H, q), J = y(P), D !== void 0 && (R = (0, t.getDeepObject)(R, D, J, k && Z, void 0))), oe || J !== "") {
            oe && (S = p.slice(T + 1, le), z && (S = S.replace(s, " ")), $ && (S = (0, n.decodeURIComponent)(S) || S));
            const X = m(S, J);
            if (_) {
              const Re = R[J];
              Re === void 0 ? Y > -1 ? R[J] = [X] : R[J] = X : Re.pop ? Re.push(X) : R[J] = [Re, X];
            } else
              R[J] = X;
          }
          S = "", w = le, T = le, q = !1, $ = !1, H = !1, z = !1, Z = !1, Y = -1, M = le, R = N, D = void 0, J = "";
        } else ie === 93 ? (_ && g === "bracket" && we === 91 && (Y = be), v && (b === "index" || k) && T <= w && (M !== be && (P = c(p, M + 1, le, H, q), J = y(P), D !== void 0 && (R = (0, t.getDeepObject)(R, D, J, void 0, void 0)), D = J, H = !1, q = !1), M = le, Z = !1)) : ie === 46 ? v && (b === "dot" || k) && T <= w && (M !== be && (P = c(p, M + 1, le, H, q), J = y(P), D !== void 0 && (R = (0, t.getDeepObject)(R, D, J, k)), D = J, H = !1, q = !1), Z = !0, M = le) : ie === 91 ? v && (b === "index" || k) && T <= w && (M !== be && (P = c(p, M + 1, le, H, q), J = y(P), k && D !== void 0 && (R = (0, t.getDeepObject)(R, D, J, k)), D = J, H = !1, q = !1, Z = !1), M = le) : ie === 61 ? T <= w ? T = le : $ = !0 : ie === 43 ? T > w ? z = !0 : H = !0 : ie === 37 && (T > w ? $ = !0 : q = !0);
        be = le, we = ie;
      }
      return N;
    }
    o(u, "parse");
  }
}), Lk = F({
  "../node_modules/picoquery/lib/stringify.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringify = r;
    var t = db();
    function r(n, a) {
      if (n === null || typeof n != "object")
        return "";
      const i = a ?? {};
      return (0, t.stringifyObject)(n, i);
    }
    o(r, "stringify");
  }
}), ep = F({
  "../node_modules/picoquery/lib/main.js"(e) {
    var t = e && e.__createBinding || (Object.create ? function(i, s, l, c) {
      c === void 0 && (c = l);
      var u = Object.getOwnPropertyDescriptor(s, l);
      (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: /* @__PURE__ */ o(function() {
        return s[l];
      }, "get") }), Object.defineProperty(i, c, u);
    } : function(i, s, l, c) {
      c === void 0 && (c = l), i[c] = s[l];
    }), r = e && e.__exportStar || function(i, s) {
      for (var l in i) l !== "default" && !Object.prototype.hasOwnProperty.call(s, l) && t(s, i, l);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.stringify = e.parse = void 0;
    var n = $k();
    Object.defineProperty(e, "parse", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return n.parse;
    }, "get") });
    var a = Lk();
    Object.defineProperty(e, "stringify", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return a.stringify;
    }, "get") }), r(Zd(), e);
  }
});
function _t(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null ? Object.prototype.toString.call(e) === "[object Object]" : !1;
}
o(_t, "isPlainObject");
function pb(e) {
  return e == null || typeof e != "object" && typeof e != "function";
}
o(pb, "isPrimitive");
function fb(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
o(fb, "isTypedArray");
function Bi(e) {
  return Object.getOwnPropertySymbols(e).filter((t) => Object.prototype.propertyIsEnumerable.call(e, t));
}
o(Bi, "getSymbols");
function Ui(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
o(Ui, "getTag");
var mb = "[object RegExp]", hb = "[object String]", yb = "[object Number]", gb = "[object Boolean]", Yu = "[object Arguments]", bb = "[object Symbol]", vb = "[object Date]", wb = "[object Map]", _b = "[object Set]", Eb = "[object Array]", Dk = "[object Function]", xb = "[object ArrayBuffer]", Ei = "[object Object]", Fk = "[object Error]", Tb = "[object DataView]", Sb = "[object Uint8Array]", Pb = "[object Uint8ClampedArray]", Ob = "[object Uint16Array]", Cb = "[object Uint32Array]", Bk = "[object BigUint64Array]", Ab = "[object Int8Array]", Rb = "[object Int16Array]", kb = "[object Int32Array]", Uk = "[object BigInt64Array]", Ib = "[object Float32Array]", jb = "[object Float64Array]";
function oo(e, t) {
  const r = {}, n = Object.keys(e);
  for (let a = 0; a < n.length; a++) {
    const i = n[a], s = e[i];
    r[i] = t(s, i, e);
  }
  return r;
}
o(oo, "mapValues");
function tp(e) {
  return e === "__proto__";
}
o(tp, "isUnsafeProperty");
function Xu(e) {
  return typeof e == "object" && e !== null;
}
o(Xu, "isObjectLike");
function Qu(e, t, r) {
  const n = Object.keys(t);
  for (let a = 0; a < n.length; a++) {
    const i = n[a];
    if (tp(i))
      continue;
    const s = t[i], l = e[i], c = r(l, s, i, e, t);
    c !== void 0 ? e[i] = c : Array.isArray(s) ? e[i] = Qu(l ?? [], s, r) : Xu(l) && Xu(s) ? e[i] = Qu(l ?? {}, s, r) : (l === void 0 || s !== void 0) && (e[i] = s);
  }
  return e;
}
o(Qu, "mergeWith");
function Hk(e, t) {
  const r = {};
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    Object.hasOwn(e, a) && (r[a] = e[a]);
  }
  return r;
}
o(Hk, "pick");
function Nb(e, t) {
  const r = {}, n = Object.keys(e);
  for (let a = 0; a < n.length; a++) {
    const i = n[a], s = e[i];
    t(s, i) && (r[i] = s);
  }
  return r;
}
o(Nb, "pickBy");
function un(e, t, r, n = /* @__PURE__ */ new Map(), a = void 0) {
  const i = a?.(e, t, r, n);
  if (i !== void 0)
    return i;
  if (pb(e))
    return e;
  if (n.has(e))
    return n.get(e);
  if (Array.isArray(e)) {
    const s = new Array(e.length);
    n.set(e, s);
    for (let l = 0; l < e.length; l++)
      s[l] = un(e[l], l, r, n, a);
    return Object.hasOwn(e, "index") && (s.index = e.index), Object.hasOwn(e, "input") && (s.input = e.input), s;
  }
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof RegExp) {
    const s = new RegExp(e.source, e.flags);
    return s.lastIndex = e.lastIndex, s;
  }
  if (e instanceof Map) {
    const s = /* @__PURE__ */ new Map();
    n.set(e, s);
    for (const [l, c] of e)
      s.set(l, un(c, l, r, n, a));
    return s;
  }
  if (e instanceof Set) {
    const s = /* @__PURE__ */ new Set();
    n.set(e, s);
    for (const l of e)
      s.add(un(l, void 0, r, n, a));
    return s;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(e))
    return e.subarray();
  if (fb(e)) {
    const s = new (Object.getPrototypeOf(e)).constructor(e.length);
    n.set(e, s);
    for (let l = 0; l < e.length; l++)
      s[l] = un(e[l], l, r, n, a);
    return s;
  }
  if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
    return e.slice(0);
  if (e instanceof DataView) {
    const s = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
    return n.set(e, s), Fn(s, e, r, n, a), s;
  }
  if (typeof File < "u" && e instanceof File) {
    const s = new File([e], e.name, {
      type: e.type
    });
    return n.set(e, s), Fn(s, e, r, n, a), s;
  }
  if (e instanceof Blob) {
    const s = new Blob([e], { type: e.type });
    return n.set(e, s), Fn(s, e, r, n, a), s;
  }
  if (e instanceof Error) {
    const s = new e.constructor();
    return n.set(e, s), s.message = e.message, s.name = e.name, s.stack = e.stack, s.cause = e.cause, Fn(s, e, r, n, a), s;
  }
  if (typeof e == "object" && qb(e)) {
    const s = Object.create(Object.getPrototypeOf(e));
    return n.set(e, s), Fn(s, e, r, n, a), s;
  }
  return e;
}
o(un, "cloneDeepWithImpl");
function Fn(e, t, r = e, n, a) {
  const i = [...Object.keys(t), ...Bi(t)];
  for (let s = 0; s < i.length; s++) {
    const l = i[s], c = Object.getOwnPropertyDescriptor(e, l);
    (c == null || c.writable) && (e[l] = un(t[l], l, r, n, a));
  }
}
o(Fn, "copyProperties");
function qb(e) {
  switch (Ui(e)) {
    case Yu:
    case Eb:
    case xb:
    case Tb:
    case gb:
    case vb:
    case Ib:
    case jb:
    case Ab:
    case Rb:
    case kb:
    case wb:
    case yb:
    case Ei:
    case mb:
    case _b:
    case hb:
    case bb:
    case Sb:
    case Pb:
    case Ob:
    case Cb:
      return !0;
    default:
      return !1;
  }
}
o(qb, "isCloneableObject");
function Mb(e) {
  return un(e, void 0, e, /* @__PURE__ */ new Map(), void 0);
}
o(Mb, "cloneDeep");
function Jn(e, t) {
  const r = Object.keys(t);
  for (let n = 0; n < r.length; n++) {
    const a = r[n];
    if (tp(a))
      continue;
    const i = t[a], s = e[a];
    Array.isArray(i) ? Array.isArray(s) ? e[a] = Jn(s, i) : e[a] = Jn([], i) : _t(i) ? _t(s) ? e[a] = Jn(s, i) : e[a] = Jn({}, i) : (s === void 0 || i !== void 0) && (e[a] = i);
  }
  return e;
}
o(Jn, "merge");
function Vk(e, t) {
  return Jn(Mb(e), t);
}
o(Vk, "toMerged");
function Zu({
  code: e,
  category: t
}) {
  const r = String(e).padStart(4, "0");
  return `SB_${t}_${r}`;
}
o(Zu, "parseErrorCode");
function ec(e) {
  if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e))
    return e;
  try {
    const t = new URL(e);
    return t.searchParams.set("ref", "error"), t.toString();
  } catch {
    return e;
  }
}
o(ec, "appendErrorRef");
var $b = class Lb extends Error {
  constructor(t) {
    super(Lb.getFullMessage(t)), this.data = {}, this.fromStorybook = !0, this.category = t.category, this.documentation = t.documentation ?? !1, this.code = t.code;
  }
  get fullErrorCode() {
    return Zu({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    const t = this.constructor.name;
    return `${this.fullErrorCode} (${t})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: t,
    code: r,
    category: n,
    message: a
  }) {
    let i;
    return t === !0 ? i = `https://storybook.js.org/error/${Zu({ code: r, category: n })}?ref=error` : typeof t == "string" ? i = ec(t) : Array.isArray(t) && (i = `
${t.map((s) => `	- ${ec(s)}`).join(`
`)}`), `${a}${i != null ? `

More info: ${i}
` : ""}`;
  }
};
o($b, "StorybookError");
var Ve = $b;
function ye(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  var n = Array.from(typeof e == "string" ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var a = n.reduce(function(l, c) {
    var u = c.match(/\n([\t ]+|(?!\s).)/g);
    return u ? l.concat(u.map(function(p) {
      var f, m;
      return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && m !== void 0 ? m : 0;
    })) : l;
  }, []);
  if (a.length) {
    var i = new RegExp(`
[	 ]{` + Math.min.apply(Math, a) + "}", "g");
    n = n.map(function(l) {
      return l.replace(i, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var s = n[0];
  return t.forEach(function(l, c) {
    var u = s.match(/(?:^|\n)( *)$/), p = u ? u[1] : "", f = l;
    typeof l == "string" && l.includes(`
`) && (f = String(l).split(`
`).map(function(m, y) {
      return y === 0 ? m : "" + p + m;
    }).join(`
`)), s += f + n[c + 1];
  }), s;
}
o(ye, "dedent");
var Db = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 1,
      message: ye`
        Couldn't find story matching id '${e.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${e.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
    }), this.data = e;
  }
};
o(Db, "MissingStoryAfterHmrError");
var Jk = Db, Fb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 2,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function",
      message: ye`
        We detected that you use an implicit action arg while ${e.phase} of your story.  
        ${e.deprecated ? `
This is deprecated and won't work in Storybook 8 anymore.
` : ""}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${e.name}: fn()
          }`
    }), this.data = e;
  }
};
o(Fb, "ImplicitActionsDuringRendering");
var zk = Fb, Bb = class extends Ve {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 3,
      message: ye`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
    });
  }
};
o(Bb, "CalledExtractOnStoreError");
var Wk = Bb, Ub = class extends Ve {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 4,
      message: ye`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field"
    });
  }
};
o(Ub, "MissingRenderToCanvasError");
var Gk = Ub, Hb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 5,
      message: ye`
        Called \`Preview.${e.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${e.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
    }), this.data = e;
  }
};
o(Hb, "CalledPreviewMethodBeforeInitializationError");
var kt = Hb, Vb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 6,
      message: ye`
        Error fetching \`/index.json\`:
        
        ${e.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
    }), this.data = e;
  }
};
o(Vb, "StoryIndexFetchError");
var Kk = Vb, Jb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 7,
      message: ye`
        Tried to render docs entry ${e.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
    }), this.data = e;
  }
};
o(Jb, "MdxFileWithNoCsfReferencesError");
var Yk = Jb, zb = class extends Ve {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 8,
      message: ye`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
    });
  }
};
o(zb, "EmptyIndexError");
var Xk = zb, Wb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 9,
      message: ye`
        Couldn't find story matching '${e.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
    }), this.data = e;
  }
};
o(Wb, "NoStoryMatchError");
var Qk = Wb, Gb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 10,
      message: ye`
        Couldn't find story matching id '${e.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
    }), this.data = e;
  }
};
o(Gb, "MissingStoryFromCsfFileError");
var Zk = Gb, Kb = class extends Ve {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 11,
      message: ye`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
    });
  }
};
o(Kb, "StoryStoreAccessedBeforeInitializationError");
var e1 = Kb, Yb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 12,
      message: ye`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${e.playFunction}`
    }), this.data = e;
  }
};
o(Yb, "MountMustBeDestructuredError");
var Xb = Yb, Qb = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 14,
      message: ye`
        No render function available for storyId '${e.id}'
      `
    }), this.data = e;
  }
};
o(Qb, "NoRenderFunctionError");
var t1 = Qb, Zb = class extends Ve {
  constructor() {
    super({
      category: "PREVIEW_API",
      code: 15,
      message: ye`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          // ðŸ‘ˆ mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
    });
  }
};
o(Zb, "NoStoryMountedError");
var r1 = Zb, n1 = class extends Ve {
  constructor(e) {
    super({
      category: "PREVIEW_API",
      code: 16,
      message: `Status has typeId "${e.status.typeId}" but was added to store with typeId "${e.typeId}". Full status: ${JSON.stringify(
        e.status,
        null,
        2
      )}`
    }), this.data = e;
  }
};
o(n1, "StatusTypeIdMismatchError");
var o1 = class extends Ve {
  constructor() {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 1,
      documentation: "https://storybook.js.org/docs/get-started/nextjs#faq",
      message: ye`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
    });
  }
};
o(o1, "NextJsSharpError");
var a1 = class extends Ve {
  constructor(e) {
    super({
      category: "FRAMEWORK_NEXTJS",
      code: 2,
      message: ye`
        Tried to access router mocks from "${e.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
    }), this.data = e;
  }
};
o(a1, "NextjsRouterMocksNotAvailable");
var i1 = class extends Ve {
  constructor(e) {
    super({
      category: "DOCS-TOOLS",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/issues/26606",
      message: ye`
        There was a failure when generating detailed ArgTypes in ${e.language} for:
        ${JSON.stringify(e.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
    }), this.data = e;
  }
};
o(i1, "UnknownArgTypesError");
var s1 = class extends Ve {
  constructor(e) {
    super({
      category: "ADDON_VITEST",
      code: 1,
      // TODO: Add documentation about viewports support
      // documentation: '',
      message: ye`
        Encountered an unsupported value "${e.value}" when setting the viewport ${e.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
    }), this.data = e;
  }
};
o(s1, "UnsupportedViewportDimensionError");
var l1 = class extends Ve {
  constructor() {
    super({
      category: "ADDON_A11Y",
      code: 1,
      documentation: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
      message: 'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
    });
  }
};
o(l1, "ElementA11yParameterError");
var u1 = F({
  "../node_modules/jsdoc-type-pratt-parser/dist/index.js"(e, t) {
    (function(r, n) {
      typeof e == "object" && typeof t < "u" ? n(e) : typeof define == "function" && define.amd ? define(["exports"], n) : (r = typeof globalThis < "u" ? globalThis : r || self, n(r.jtpp = {}));
    })(e, function(r) {
      function n(h) {
        return h.text !== void 0 && h.text !== "" ? `'${h.type}' with value '${h.text}'` : `'${h.type}'`;
      }
      o(n, "tokenToString");
      const a = class ev extends Error {
        constructor(x) {
          super(`No parslet found for token: ${n(x)}`), this.token = x, Object.setPrototypeOf(this, ev.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      o(a, "NoParsletFoundError");
      let i = a;
      const s = class tv extends Error {
        constructor(x) {
          super(`The parsing ended early. The next token was: ${n(x)}`), this.token = x, Object.setPrototypeOf(this, tv.prototype);
        }
        getToken() {
          return this.token;
        }
      };
      o(s, "EarlyEndOfParseError");
      let l = s;
      const c = class rv extends Error {
        constructor(x, j) {
          let V = `Unexpected type: '${x.type}'.`;
          j !== void 0 && (V += ` Message: ${j}`), super(V), Object.setPrototypeOf(this, rv.prototype);
        }
      };
      o(c, "UnexpectedTypeError");
      let u = c;
      function p(h) {
        return (x) => x.startsWith(h) ? { type: h, text: h } : null;
      }
      o(p, "makePunctuationRule");
      function f(h) {
        let x = 0, j;
        const V = h[0];
        let G = !1;
        if (V !== "'" && V !== '"')
          return null;
        for (; x < h.length; ) {
          if (x++, j = h[x], !G && j === V) {
            x++;
            break;
          }
          G = !G && j === "\\";
        }
        if (j !== V)
          throw new Error("Unterminated String");
        return h.slice(0, x);
      }
      o(f, "getQuoted");
      const m = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), y = new RegExp("[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u");
      function g(h) {
        let x = h[0];
        if (!m.test(x))
          return null;
        let j = 1;
        do {
          if (x = h[j], !y.test(x))
            break;
          j++;
        } while (j < h.length);
        return h.slice(0, j);
      }
      o(g, "getIdentifier");
      const v = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
      function _(h) {
        var x, j;
        return (j = (x = v.exec(h)) === null || x === void 0 ? void 0 : x[0]) !== null && j !== void 0 ? j : null;
      }
      o(_, "getNumber");
      const b = /* @__PURE__ */ o((h) => {
        const x = g(h);
        return x == null ? null : {
          type: "Identifier",
          text: x
        };
      }, "identifierRule");
      function E(h) {
        return (x) => {
          if (!x.startsWith(h))
            return null;
          const j = x[h.length];
          return j !== void 0 && y.test(j) ? null : {
            type: h,
            text: h
          };
        };
      }
      o(E, "makeKeyWordRule");
      const C = /* @__PURE__ */ o((h) => {
        const x = f(h);
        return x == null ? null : {
          type: "StringValue",
          text: x
        };
      }, "stringValueRule"), k = /* @__PURE__ */ o((h) => h.length > 0 ? null : {
        type: "EOF",
        text: ""
      }, "eofRule"), N = /* @__PURE__ */ o((h) => {
        const x = _(h);
        return x === null ? null : {
          type: "Number",
          text: x
        };
      }, "numberRule"), O = [
        k,
        p("=>"),
        p("("),
        p(")"),
        p("{"),
        p("}"),
        p("["),
        p("]"),
        p("|"),
        p("&"),
        p("<"),
        p(">"),
        p(","),
        p(";"),
        p("*"),
        p("?"),
        p("!"),
        p("="),
        p(":"),
        p("..."),
        p("."),
        p("#"),
        p("~"),
        p("/"),
        p("@"),
        E("undefined"),
        E("null"),
        E("function"),
        E("this"),
        E("new"),
        E("module"),
        E("event"),
        E("extends"),
        E("external"),
        E("infer"),
        E("typeof"),
        E("keyof"),
        E("readonly"),
        E("import"),
        E("is"),
        E("in"),
        E("asserts"),
        N,
        b,
        C
      ], S = /^\s*\n\s*/, w = class xi {
        static create(x) {
          const j = this.read(x);
          x = j.text;
          const V = this.read(x);
          return x = V.text, new xi(x, void 0, j.token, V.token);
        }
        constructor(x, j, V, G) {
          this.text = "", this.text = x, this.previous = j, this.current = V, this.next = G;
        }
        static read(x, j = !1) {
          j = j || S.test(x), x = x.trim();
          for (const V of O) {
            const G = V(x);
            if (G !== null) {
              const te = Object.assign(Object.assign({}, G), { startOfLine: j });
              return x = x.slice(te.text.length), { text: x, token: te };
            }
          }
          throw new Error("Unexpected Token " + x);
        }
        advance() {
          const x = xi.read(this.text);
          return new xi(x.text, this.current, this.next, x.token);
        }
      };
      o(w, "Lexer");
      let T = w;
      function M(h) {
        if (h === void 0)
          throw new Error("Unexpected undefined");
        if (h.type === "JsdocTypeKeyValue" || h.type === "JsdocTypeParameterList" || h.type === "JsdocTypeProperty" || h.type === "JsdocTypeReadonlyProperty" || h.type === "JsdocTypeObjectField" || h.type === "JsdocTypeJsdocObjectField" || h.type === "JsdocTypeIndexSignature" || h.type === "JsdocTypeMappedType" || h.type === "JsdocTypeTypeParameter")
          throw new u(h);
        return h;
      }
      o(M, "assertRootResult");
      function R(h) {
        return h.type === "JsdocTypeKeyValue" ? J(h) : M(h);
      }
      o(R, "assertPlainKeyValueOrRootResult");
      function D(h) {
        return h.type === "JsdocTypeName" ? h : J(h);
      }
      o(D, "assertPlainKeyValueOrNameResult");
      function J(h) {
        if (h.type !== "JsdocTypeKeyValue")
          throw new u(h);
        return h;
      }
      o(J, "assertPlainKeyValueResult");
      function P(h) {
        var x;
        if (h.type === "JsdocTypeVariadic") {
          if (((x = h.element) === null || x === void 0 ? void 0 : x.type) === "JsdocTypeName")
            return h;
          throw new u(h);
        }
        if (h.type !== "JsdocTypeNumber" && h.type !== "JsdocTypeName")
          throw new u(h);
        return h;
      }
      o(P, "assertNumberOrVariadicNameResult");
      function q(h) {
        if (h.type === "JsdocTypeTuple" || h.type === "JsdocTypeGeneric" && h.meta.brackets === "square")
          return h;
        throw new u(h);
      }
      o(q, "assertArrayOrTupleResult");
      function $(h) {
        return h.type === "JsdocTypeIndexSignature" || h.type === "JsdocTypeMappedType";
      }
      o($, "isSquaredProperty");
      var H;
      (function(h) {
        h[h.ALL = 0] = "ALL", h[h.PARAMETER_LIST = 1] = "PARAMETER_LIST", h[h.OBJECT = 2] = "OBJECT", h[h.KEY_VALUE = 3] = "KEY_VALUE", h[h.INDEX_BRACKETS = 4] = "INDEX_BRACKETS", h[h.UNION = 5] = "UNION", h[h.INTERSECTION = 6] = "INTERSECTION", h[h.PREFIX = 7] = "PREFIX", h[h.INFIX = 8] = "INFIX", h[h.TUPLE = 9] = "TUPLE", h[h.SYMBOL = 10] = "SYMBOL", h[h.OPTIONAL = 11] = "OPTIONAL", h[h.NULLABLE = 12] = "NULLABLE", h[h.KEY_OF_TYPE_OF = 13] = "KEY_OF_TYPE_OF", h[h.FUNCTION = 14] = "FUNCTION", h[h.ARROW = 15] = "ARROW", h[h.ARRAY_BRACKETS = 16] = "ARRAY_BRACKETS", h[h.GENERIC = 17] = "GENERIC", h[h.NAME_PATH = 18] = "NAME_PATH", h[h.PARENTHESIS = 19] = "PARENTHESIS", h[h.SPECIAL_TYPES = 20] = "SPECIAL_TYPES";
      })(H || (H = {}));
      const z = class {
        constructor(h, x, j) {
          this.grammar = h, typeof x == "string" ? this._lexer = T.create(x) : this._lexer = x, this.baseParser = j;
        }
        get lexer() {
          return this._lexer;
        }
        /**
         * Parses a given string and throws an error if the parse ended before the end of the string.
         */
        parse() {
          const h = this.parseType(H.ALL);
          if (this.lexer.current.type !== "EOF")
            throw new l(this.lexer.current);
          return h;
        }
        /**
         * Parses with the current lexer and asserts that the result is a {@link RootResult}.
         */
        parseType(h) {
          return M(this.parseIntermediateType(h));
        }
        /**
         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
         * to parse the state in the infix step.
         */
        parseIntermediateType(h) {
          const x = this.tryParslets(null, h);
          if (x === null)
            throw new i(this.lexer.current);
          return this.parseInfixIntermediateType(x, h);
        }
        /**
         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
         * a result.
         */
        parseInfixIntermediateType(h, x) {
          let j = this.tryParslets(h, x);
          for (; j !== null; )
            h = j, j = this.tryParslets(h, x);
          return h;
        }
        /**
         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
         */
        tryParslets(h, x) {
          for (const j of this.grammar) {
            const V = j(this, x, h);
            if (V !== null)
              return V;
          }
          return null;
        }
        /**
         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
         * advanced.
         */
        consume(h) {
          return Array.isArray(h) || (h = [h]), h.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), !0) : !1;
        }
        acceptLexerState(h) {
          this._lexer = h.lexer;
        }
      };
      o(z, "Parser");
      let Z = z;
      function oe(h) {
        return h === "}" || h === "EOF" || h === "|" || h === "," || h === ")" || h === ">";
      }
      o(oe, "isQuestionMarkUnknownType");
      const ie = /* @__PURE__ */ o((h, x, j) => {
        const V = h.lexer.current.type, G = h.lexer.next.type;
        return j == null && V === "?" && !oe(G) || j != null && V === "?" ? (h.consume("?"), j == null ? {
          type: "JsdocTypeNullable",
          element: h.parseType(H.NULLABLE),
          meta: {
            position: "prefix"
          }
        } : {
          type: "JsdocTypeNullable",
          element: M(j),
          meta: {
            position: "suffix"
          }
        }) : null;
      }, "nullableParslet");
      function Y(h) {
        const x = /* @__PURE__ */ o((j, V, G) => {
          const te = j.lexer.current.type, ue = j.lexer.next.type;
          if (G === null) {
            if ("parsePrefix" in h && h.accept(te, ue))
              return h.parsePrefix(j);
          } else if ("parseInfix" in h && h.precedence > V && h.accept(te, ue))
            return h.parseInfix(j, G);
          return null;
        }, "parslet");
        return Object.defineProperty(x, "name", {
          value: h.name
        }), x;
      }
      o(Y, "composeParslet");
      const be = Y({
        name: "optionalParslet",
        accept: /* @__PURE__ */ o((h) => h === "=", "accept"),
        precedence: H.OPTIONAL,
        parsePrefix: /* @__PURE__ */ o((h) => (h.consume("="), {
          type: "JsdocTypeOptional",
          element: h.parseType(H.OPTIONAL),
          meta: {
            position: "prefix"
          }
        }), "parsePrefix"),
        parseInfix: /* @__PURE__ */ o((h, x) => (h.consume("="), {
          type: "JsdocTypeOptional",
          element: M(x),
          meta: {
            position: "suffix"
          }
        }), "parseInfix")
      }), we = Y({
        name: "numberParslet",
        accept: /* @__PURE__ */ o((h) => h === "Number", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          const x = parseFloat(h.lexer.current.text);
          return h.consume("Number"), {
            type: "JsdocTypeNumber",
            value: x
          };
        }, "parsePrefix")
      }), le = Y({
        name: "parenthesisParslet",
        accept: /* @__PURE__ */ o((h) => h === "(", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          if (h.consume("("), h.consume(")"))
            return {
              type: "JsdocTypeParameterList",
              elements: []
            };
          const x = h.parseIntermediateType(H.ALL);
          if (!h.consume(")"))
            throw new Error("Unterminated parenthesis");
          return x.type === "JsdocTypeParameterList" ? x : x.type === "JsdocTypeKeyValue" ? {
            type: "JsdocTypeParameterList",
            elements: [x]
          } : {
            type: "JsdocTypeParenthesis",
            element: M(x)
          };
        }, "parsePrefix")
      }), X = Y({
        name: "specialTypesParslet",
        accept: /* @__PURE__ */ o((h, x) => h === "?" && oe(x) || h === "null" || h === "undefined" || h === "*", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          if (h.consume("null"))
            return {
              type: "JsdocTypeNull"
            };
          if (h.consume("undefined"))
            return {
              type: "JsdocTypeUndefined"
            };
          if (h.consume("*"))
            return {
              type: "JsdocTypeAny"
            };
          if (h.consume("?"))
            return {
              type: "JsdocTypeUnknown"
            };
          throw new Error("Unacceptable token: " + h.lexer.current.text);
        }, "parsePrefix")
      }), Re = Y({
        name: "notNullableParslet",
        accept: /* @__PURE__ */ o((h) => h === "!", "accept"),
        precedence: H.NULLABLE,
        parsePrefix: /* @__PURE__ */ o((h) => (h.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: h.parseType(H.NULLABLE),
          meta: {
            position: "prefix"
          }
        }), "parsePrefix"),
        parseInfix: /* @__PURE__ */ o((h, x) => (h.consume("!"), {
          type: "JsdocTypeNotNullable",
          element: M(x),
          meta: {
            position: "suffix"
          }
        }), "parseInfix")
      });
      function Pe({ allowTrailingComma: h }) {
        return Y({
          name: "parameterListParslet",
          accept: /* @__PURE__ */ o((x) => x === ",", "accept"),
          precedence: H.PARAMETER_LIST,
          parseInfix: /* @__PURE__ */ o((x, j) => {
            const V = [
              R(j)
            ];
            x.consume(",");
            do
              try {
                const G = x.parseIntermediateType(H.PARAMETER_LIST);
                V.push(R(G));
              } catch (G) {
                if (G instanceof i)
                  break;
                throw G;
              }
            while (x.consume(","));
            if (V.length > 0 && V.slice(0, -1).some((G) => G.type === "JsdocTypeVariadic"))
              throw new Error("Only the last parameter may be a rest parameter");
            return {
              type: "JsdocTypeParameterList",
              elements: V
            };
          }, "parseInfix")
        });
      }
      o(Pe, "createParameterListParslet");
      const lt = Y({
        name: "genericParslet",
        accept: /* @__PURE__ */ o((h, x) => h === "<" || h === "." && x === "<", "accept"),
        precedence: H.GENERIC,
        parseInfix: /* @__PURE__ */ o((h, x) => {
          const j = h.consume(".");
          h.consume("<");
          const V = [];
          let G = !1;
          if (h.consume("infer")) {
            G = !0;
            const te = h.parseIntermediateType(H.SYMBOL);
            if (te.type !== "JsdocTypeName")
              throw new u(te, "A typescript asserts always has to have a name on the left side.");
            V.push(te);
          } else
            do
              V.push(h.parseType(H.PARAMETER_LIST));
            while (h.consume(","));
          if (!h.consume(">"))
            throw new Error("Unterminated generic parameter list");
          return Object.assign(Object.assign({ type: "JsdocTypeGeneric", left: M(x), elements: V }, G ? { infer: !0 } : {}), { meta: {
            brackets: "angle",
            dot: j
          } });
        }, "parseInfix")
      }), rt = Y({
        name: "unionParslet",
        accept: /* @__PURE__ */ o((h) => h === "|", "accept"),
        precedence: H.UNION,
        parseInfix: /* @__PURE__ */ o((h, x) => {
          h.consume("|");
          const j = [];
          do
            j.push(h.parseType(H.UNION));
          while (h.consume("|"));
          return {
            type: "JsdocTypeUnion",
            elements: [M(x), ...j]
          };
        }, "parseInfix")
      }), L = [
        ie,
        be,
        we,
        le,
        X,
        Re,
        Pe({
          allowTrailingComma: !0
        }),
        lt,
        rt,
        be
      ];
      function K({ allowSquareBracketsOnAnyType: h, allowJsdocNamePaths: x, pathGrammar: j }) {
        return /* @__PURE__ */ o(function(V, G, te) {
          if (te == null || G >= H.NAME_PATH)
            return null;
          const ue = V.lexer.current.type, Me = V.lexer.next.type;
          if (!(ue === "." && Me !== "<" || ue === "[" && (h || te.type === "JsdocTypeName") || x && (ue === "~" || ue === "#")))
            return null;
          let De, nt = !1;
          V.consume(".") ? De = "property" : V.consume("[") ? (De = "property-brackets", nt = !0) : V.consume("~") ? De = "inner" : (V.consume("#"), De = "instance");
          const fr = j !== null ? new Z(j, V.lexer, V) : V, Bt = fr.parseIntermediateType(H.NAME_PATH);
          V.acceptLexerState(fr);
          let Fo;
          switch (Bt.type) {
            case "JsdocTypeName":
              Fo = {
                type: "JsdocTypeProperty",
                value: Bt.value,
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeNumber":
              Fo = {
                type: "JsdocTypeProperty",
                value: Bt.value.toString(10),
                meta: {
                  quote: void 0
                }
              };
              break;
            case "JsdocTypeStringValue":
              Fo = {
                type: "JsdocTypeProperty",
                value: Bt.value,
                meta: {
                  quote: Bt.meta.quote
                }
              };
              break;
            case "JsdocTypeSpecialNamePath":
              if (Bt.specialType === "event")
                Fo = Bt;
              else
                throw new u(Bt, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
              break;
            default:
              throw new u(Bt, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
          }
          if (nt && !V.consume("]")) {
            const py = V.lexer.current;
            throw new Error(`Unterminated square brackets. Next token is '${py.type}' with text '${py.text}'`);
          }
          return {
            type: "JsdocTypeNamePath",
            left: M(te),
            right: Fo,
            pathType: De
          };
        }, "namePathParslet");
      }
      o(K, "createNamePathParslet");
      function Q({ allowedAdditionalTokens: h }) {
        return Y({
          name: "nameParslet",
          accept: /* @__PURE__ */ o((x) => x === "Identifier" || x === "this" || x === "new" || h.includes(x), "accept"),
          parsePrefix: /* @__PURE__ */ o((x) => {
            const { type: j, text: V } = x.lexer.current;
            return x.consume(j), {
              type: "JsdocTypeName",
              value: V
            };
          }, "parsePrefix")
        });
      }
      o(Q, "createNameParslet");
      const se = Y({
        name: "stringValueParslet",
        accept: /* @__PURE__ */ o((h) => h === "StringValue", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          const x = h.lexer.current.text;
          return h.consume("StringValue"), {
            type: "JsdocTypeStringValue",
            value: x.slice(1, -1),
            meta: {
              quote: x[0] === "'" ? "single" : "double"
            }
          };
        }, "parsePrefix")
      });
      function re({ pathGrammar: h, allowedTypes: x }) {
        return Y({
          name: "specialNamePathParslet",
          accept: /* @__PURE__ */ o((j) => x.includes(j), "accept"),
          parsePrefix: /* @__PURE__ */ o((j) => {
            const V = j.lexer.current.type;
            if (j.consume(V), !j.consume(":"))
              return {
                type: "JsdocTypeName",
                value: V
              };
            let G, te = j.lexer.current;
            if (j.consume("StringValue"))
              G = {
                type: "JsdocTypeSpecialNamePath",
                value: te.text.slice(1, -1),
                specialType: V,
                meta: {
                  quote: te.text[0] === "'" ? "single" : "double"
                }
              };
            else {
              let De = "";
              const nt = ["Identifier", "@", "/"];
              for (; nt.some((fr) => j.consume(fr)); )
                De += te.text, te = j.lexer.current;
              G = {
                type: "JsdocTypeSpecialNamePath",
                value: De,
                specialType: V,
                meta: {
                  quote: void 0
                }
              };
            }
            const ue = new Z(h, j.lexer, j), Me = ue.parseInfixIntermediateType(G, H.ALL);
            return j.acceptLexerState(ue), M(Me);
          }, "parsePrefix")
        });
      }
      o(re, "createSpecialNamePathParslet");
      const he = [
        Q({
          allowedAdditionalTokens: ["external", "module"]
        }),
        se,
        we,
        K({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: null
        })
      ], ce = [
        ...he,
        re({
          allowedTypes: ["event"],
          pathGrammar: he
        })
      ];
      function Ce(h) {
        let x;
        if (h.type === "JsdocTypeParameterList")
          x = h.elements;
        else if (h.type === "JsdocTypeParenthesis")
          x = [h.element];
        else
          throw new u(h);
        return x.map((j) => R(j));
      }
      o(Ce, "getParameters");
      function Xe(h) {
        const x = Ce(h);
        if (x.some((j) => j.type === "JsdocTypeKeyValue"))
          throw new Error("No parameter should be named");
        return x;
      }
      o(Xe, "getUnnamedParameters");
      function mt({ allowNamedParameters: h, allowNoReturnType: x, allowWithoutParenthesis: j, allowNewAsFunctionKeyword: V }) {
        return Y({
          name: "functionParslet",
          accept: /* @__PURE__ */ o((G, te) => G === "function" || V && G === "new" && te === "(", "accept"),
          parsePrefix: /* @__PURE__ */ o((G) => {
            const te = G.consume("new");
            G.consume("function");
            const ue = G.lexer.current.type === "(";
            if (!ue) {
              if (!j)
                throw new Error("function is missing parameter list");
              return {
                type: "JsdocTypeName",
                value: "function"
              };
            }
            let Me = {
              type: "JsdocTypeFunction",
              parameters: [],
              arrow: !1,
              constructor: te,
              parenthesis: ue
            };
            const De = G.parseIntermediateType(H.FUNCTION);
            if (h === void 0)
              Me.parameters = Xe(De);
            else {
              if (te && De.type === "JsdocTypeFunction" && De.arrow)
                return Me = De, Me.constructor = !0, Me;
              Me.parameters = Ce(De);
              for (const nt of Me.parameters)
                if (nt.type === "JsdocTypeKeyValue" && !h.includes(nt.key))
                  throw new Error(`only allowed named parameters are ${h.join(", ")} but got ${nt.type}`);
            }
            if (G.consume(":"))
              Me.returnType = G.parseType(H.PREFIX);
            else if (!x)
              throw new Error("function is missing return type");
            return Me;
          }, "parsePrefix")
        });
      }
      o(mt, "createFunctionParslet");
      function Ct({ allowPostfix: h, allowEnclosingBrackets: x }) {
        return Y({
          name: "variadicParslet",
          accept: /* @__PURE__ */ o((j) => j === "...", "accept"),
          precedence: H.PREFIX,
          parsePrefix: /* @__PURE__ */ o((j) => {
            j.consume("...");
            const V = x && j.consume("[");
            try {
              const G = j.parseType(H.PREFIX);
              if (V && !j.consume("]"))
                throw new Error("Unterminated variadic type. Missing ']'");
              return {
                type: "JsdocTypeVariadic",
                element: M(G),
                meta: {
                  position: "prefix",
                  squareBrackets: V
                }
              };
            } catch (G) {
              if (G instanceof i) {
                if (V)
                  throw new Error("Empty square brackets for variadic are not allowed.");
                return {
                  type: "JsdocTypeVariadic",
                  meta: {
                    position: void 0,
                    squareBrackets: !1
                  }
                };
              } else
                throw G;
            }
          }, "parsePrefix"),
          parseInfix: h ? (j, V) => (j.consume("..."), {
            type: "JsdocTypeVariadic",
            element: M(V),
            meta: {
              position: "suffix",
              squareBrackets: !1
            }
          }) : void 0
        });
      }
      o(Ct, "createVariadicParslet");
      const ct = Y({
        name: "symbolParslet",
        accept: /* @__PURE__ */ o((h) => h === "(", "accept"),
        precedence: H.SYMBOL,
        parseInfix: /* @__PURE__ */ o((h, x) => {
          if (x.type !== "JsdocTypeName")
            throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
          h.consume("(");
          const j = {
            type: "JsdocTypeSymbol",
            value: x.value
          };
          if (!h.consume(")")) {
            const V = h.parseIntermediateType(H.SYMBOL);
            if (j.element = P(V), !h.consume(")"))
              throw new Error("Symbol does not end after value");
          }
          return j;
        }, "parseInfix")
      }), cr = Y({
        name: "arrayBracketsParslet",
        precedence: H.ARRAY_BRACKETS,
        accept: /* @__PURE__ */ o((h, x) => h === "[" && x === "]", "accept"),
        parseInfix: /* @__PURE__ */ o((h, x) => (h.consume("["), h.consume("]"), {
          type: "JsdocTypeGeneric",
          left: {
            type: "JsdocTypeName",
            value: "Array"
          },
          elements: [
            M(x)
          ],
          meta: {
            brackets: "square",
            dot: !1
          }
        }), "parseInfix")
      });
      function Dt({ objectFieldGrammar: h, allowKeyTypes: x }) {
        return Y({
          name: "objectParslet",
          accept: /* @__PURE__ */ o((j) => j === "{", "accept"),
          parsePrefix: /* @__PURE__ */ o((j) => {
            j.consume("{");
            const V = {
              type: "JsdocTypeObject",
              meta: {
                separator: "comma"
              },
              elements: []
            };
            if (!j.consume("}")) {
              let G;
              const te = new Z(h, j.lexer, j);
              for (; ; ) {
                te.acceptLexerState(j);
                let ue = te.parseIntermediateType(H.OBJECT);
                j.acceptLexerState(te), ue === void 0 && x && (ue = j.parseIntermediateType(H.OBJECT));
                let Me = !1;
                if (ue.type === "JsdocTypeNullable" && (Me = !0, ue = ue.element), ue.type === "JsdocTypeNumber" || ue.type === "JsdocTypeName" || ue.type === "JsdocTypeStringValue") {
                  let De;
                  ue.type === "JsdocTypeStringValue" && (De = ue.meta.quote), V.elements.push({
                    type: "JsdocTypeObjectField",
                    key: ue.value.toString(),
                    right: void 0,
                    optional: Me,
                    readonly: !1,
                    meta: {
                      quote: De
                    }
                  });
                } else if (ue.type === "JsdocTypeObjectField" || ue.type === "JsdocTypeJsdocObjectField")
                  V.elements.push(ue);
                else
                  throw new u(ue);
                if (j.lexer.current.startOfLine)
                  G = "linebreak", j.consume(",") || j.consume(";");
                else if (j.consume(","))
                  G = "comma";
                else if (j.consume(";"))
                  G = "semicolon";
                else
                  break;
                if (j.lexer.current.type === "}")
                  break;
              }
              if (V.meta.separator = G ?? "comma", G === "linebreak" && (V.meta.propertyIndent = "  "), !j.consume("}"))
                throw new Error("Unterminated record type. Missing '}'");
            }
            return V;
          }, "parsePrefix")
        });
      }
      o(Dt, "createObjectParslet");
      function Ft({ allowSquaredProperties: h, allowKeyTypes: x, allowReadonly: j, allowOptional: V }) {
        return Y({
          name: "objectFieldParslet",
          precedence: H.KEY_VALUE,
          accept: /* @__PURE__ */ o((G) => G === ":", "accept"),
          parseInfix: /* @__PURE__ */ o((G, te) => {
            var ue;
            let Me = !1, De = !1;
            V && te.type === "JsdocTypeNullable" && (Me = !0, te = te.element), j && te.type === "JsdocTypeReadonlyProperty" && (De = !0, te = te.element);
            const nt = (ue = G.baseParser) !== null && ue !== void 0 ? ue : G;
            if (nt.acceptLexerState(G), te.type === "JsdocTypeNumber" || te.type === "JsdocTypeName" || te.type === "JsdocTypeStringValue" || $(te)) {
              if ($(te) && !h)
                throw new u(te);
              nt.consume(":");
              let fr;
              te.type === "JsdocTypeStringValue" && (fr = te.meta.quote);
              const Bt = nt.parseType(H.KEY_VALUE);
              return G.acceptLexerState(nt), {
                type: "JsdocTypeObjectField",
                key: $(te) ? te : te.value.toString(),
                right: Bt,
                optional: Me,
                readonly: De,
                meta: {
                  quote: fr
                }
              };
            } else {
              if (!x)
                throw new u(te);
              nt.consume(":");
              const fr = nt.parseType(H.KEY_VALUE);
              return G.acceptLexerState(nt), {
                type: "JsdocTypeJsdocObjectField",
                left: M(te),
                right: fr
              };
            }
          }, "parseInfix")
        });
      }
      o(Ft, "createObjectFieldParslet");
      function $n({ allowOptional: h, allowVariadic: x }) {
        return Y({
          name: "keyValueParslet",
          precedence: H.KEY_VALUE,
          accept: /* @__PURE__ */ o((j) => j === ":", "accept"),
          parseInfix: /* @__PURE__ */ o((j, V) => {
            let G = !1, te = !1;
            if (h && V.type === "JsdocTypeNullable" && (G = !0, V = V.element), x && V.type === "JsdocTypeVariadic" && V.element !== void 0 && (te = !0, V = V.element), V.type !== "JsdocTypeName")
              throw new u(V);
            j.consume(":");
            const ue = j.parseType(H.KEY_VALUE);
            return {
              type: "JsdocTypeKeyValue",
              key: V.value,
              right: ue,
              optional: G,
              variadic: te
            };
          }, "parseInfix")
        });
      }
      o($n, "createKeyValueParslet");
      const ci = [
        ...L,
        mt({
          allowWithoutParenthesis: !0,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        se,
        re({
          allowedTypes: ["module", "external", "event"],
          pathGrammar: ce
        }),
        Ct({
          allowEnclosingBrackets: !0,
          allowPostfix: !0
        }),
        Q({
          allowedAdditionalTokens: ["keyof"]
        }),
        ct,
        cr,
        K({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: ce
        })
      ], cu = [
        ...ci,
        Dt({
          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
          // we leave out the object type deliberately
          objectFieldGrammar: [
            Q({
              allowedAdditionalTokens: ["typeof", "module", "in"]
            }),
            Ft({
              allowSquaredProperties: !1,
              allowKeyTypes: !0,
              allowOptional: !1,
              allowReadonly: !1
            }),
            ...ci
          ],
          allowKeyTypes: !0
        }),
        $n({
          allowOptional: !0,
          allowVariadic: !0
        })
      ], di = Y({
        name: "typeOfParslet",
        accept: /* @__PURE__ */ o((h) => h === "typeof", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => (h.consume("typeof"), {
          type: "JsdocTypeTypeof",
          element: h.parseType(H.KEY_OF_TYPE_OF)
        }), "parsePrefix")
      }), du = [
        Q({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        ie,
        be,
        se,
        we,
        Ft({
          allowSquaredProperties: !1,
          allowKeyTypes: !1,
          allowOptional: !1,
          allowReadonly: !1
        })
      ], pu = [
        ...L,
        Dt({
          allowKeyTypes: !1,
          objectFieldGrammar: du
        }),
        Q({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        di,
        mt({
          allowWithoutParenthesis: !1,
          allowNamedParameters: ["this", "new"],
          allowNoReturnType: !0,
          allowNewAsFunctionKeyword: !1
        }),
        Ct({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        // additional name parslet is needed for some special cases
        Q({
          allowedAdditionalTokens: ["keyof"]
        }),
        re({
          allowedTypes: ["module"],
          pathGrammar: ce
        }),
        K({
          allowSquareBracketsOnAnyType: !1,
          allowJsdocNamePaths: !0,
          pathGrammar: ce
        }),
        $n({
          allowOptional: !1,
          allowVariadic: !1
        }),
        ct
      ], fu = Y({
        name: "assertsParslet",
        accept: /* @__PURE__ */ o((h) => h === "asserts", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          h.consume("asserts");
          const x = h.parseIntermediateType(H.SYMBOL);
          if (x.type !== "JsdocTypeName")
            throw new u(x, "A typescript asserts always has to have a name on the left side.");
          return h.consume("is") ? {
            type: "JsdocTypeAsserts",
            left: x,
            right: M(h.parseIntermediateType(H.INFIX))
          } : {
            type: "JsdocTypeAssertsPlain",
            element: x
          };
        }, "parsePrefix")
      });
      function pi({ allowQuestionMark: h }) {
        return Y({
          name: "tupleParslet",
          accept: /* @__PURE__ */ o((x) => x === "[", "accept"),
          parsePrefix: /* @__PURE__ */ o((x) => {
            x.consume("[");
            const j = {
              type: "JsdocTypeTuple",
              elements: []
            };
            if (x.consume("]"))
              return j;
            const V = x.parseIntermediateType(H.ALL);
            if (V.type === "JsdocTypeParameterList" ? V.elements[0].type === "JsdocTypeKeyValue" ? j.elements = V.elements.map(J) : j.elements = V.elements.map(M) : V.type === "JsdocTypeKeyValue" ? j.elements = [J(V)] : j.elements = [M(V)], !x.consume("]"))
              throw new Error("Unterminated '['");
            if (j.elements.some((G) => G.type === "JsdocTypeUnknown"))
              throw new Error("Question mark in tuple not allowed");
            return j;
          }, "parsePrefix")
        });
      }
      o(pi, "createTupleParslet");
      const mu = Y({
        name: "keyOfParslet",
        accept: /* @__PURE__ */ o((h) => h === "keyof", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => (h.consume("keyof"), {
          type: "JsdocTypeKeyof",
          element: M(h.parseType(H.KEY_OF_TYPE_OF))
        }), "parsePrefix")
      }), hu = Y({
        name: "importParslet",
        accept: /* @__PURE__ */ o((h) => h === "import", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          if (h.consume("import"), !h.consume("("))
            throw new Error("Missing parenthesis after import keyword");
          const x = h.parseType(H.PREFIX);
          if (x.type !== "JsdocTypeStringValue")
            throw new Error("Only string values are allowed as paths for imports");
          if (!h.consume(")"))
            throw new Error("Missing closing parenthesis after import keyword");
          return {
            type: "JsdocTypeImport",
            element: x
          };
        }, "parsePrefix")
      }), yu = Y({
        name: "readonlyPropertyParslet",
        accept: /* @__PURE__ */ o((h) => h === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => (h.consume("readonly"), {
          type: "JsdocTypeReadonlyProperty",
          element: h.parseIntermediateType(H.KEY_VALUE)
        }), "parsePrefix")
      }), gu = Y({
        name: "arrowFunctionParslet",
        precedence: H.ARROW,
        accept: /* @__PURE__ */ o((h) => h === "=>", "accept"),
        parseInfix: /* @__PURE__ */ o((h, x) => (h.consume("=>"), {
          type: "JsdocTypeFunction",
          parameters: Ce(x).map(D),
          arrow: !0,
          constructor: !1,
          parenthesis: !0,
          returnType: h.parseType(H.OBJECT)
        }), "parseInfix")
      }), bu = Y({
        name: "genericArrowFunctionParslet",
        accept: /* @__PURE__ */ o((h) => h === "<", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          const x = [];
          h.consume("<");
          do {
            let V, G = h.parseIntermediateType(H.SYMBOL);
            if (G.type === "JsdocTypeOptional" && (G = G.element, V = h.parseType(H.SYMBOL)), G.type !== "JsdocTypeName")
              throw new u(G);
            let te;
            h.consume("extends") && (te = h.parseType(H.SYMBOL), te.type === "JsdocTypeOptional" && (te = te.element, V = h.parseType(H.SYMBOL)));
            const ue = {
              type: "JsdocTypeTypeParameter",
              name: G
            };
            if (te !== void 0 && (ue.constraint = te), V !== void 0 && (ue.defaultValue = V), x.push(ue), h.consume(">"))
              break;
          } while (h.consume(","));
          const j = h.parseIntermediateType(H.SYMBOL);
          return j.typeParameters = x, j;
        }, "parsePrefix")
      }), vu = Y({
        name: "intersectionParslet",
        accept: /* @__PURE__ */ o((h) => h === "&", "accept"),
        precedence: H.INTERSECTION,
        parseInfix: /* @__PURE__ */ o((h, x) => {
          h.consume("&");
          const j = [];
          do
            j.push(h.parseType(H.INTERSECTION));
          while (h.consume("&"));
          return {
            type: "JsdocTypeIntersection",
            elements: [M(x), ...j]
          };
        }, "parseInfix")
      }), wu = Y({
        name: "predicateParslet",
        precedence: H.INFIX,
        accept: /* @__PURE__ */ o((h) => h === "is", "accept"),
        parseInfix: /* @__PURE__ */ o((h, x) => {
          if (x.type !== "JsdocTypeName")
            throw new u(x, "A typescript predicate always has to have a name on the left side.");
          return h.consume("is"), {
            type: "JsdocTypePredicate",
            left: x,
            right: M(h.parseIntermediateType(H.INFIX))
          };
        }, "parseInfix")
      }), _u = Y({
        name: "objectSquareBracketPropertyParslet",
        accept: /* @__PURE__ */ o((h) => h === "[", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => {
          if (h.baseParser === void 0)
            throw new Error("Only allowed inside object grammar");
          h.consume("[");
          const x = h.lexer.current.text;
          h.consume("Identifier");
          let j;
          if (h.consume(":")) {
            const V = h.baseParser;
            V.acceptLexerState(h), j = {
              type: "JsdocTypeIndexSignature",
              key: x,
              right: V.parseType(H.INDEX_BRACKETS)
            }, h.acceptLexerState(V);
          } else if (h.consume("in")) {
            const V = h.baseParser;
            V.acceptLexerState(h), j = {
              type: "JsdocTypeMappedType",
              key: x,
              right: V.parseType(H.ARRAY_BRACKETS)
            }, h.acceptLexerState(V);
          } else
            throw new Error("Missing ':' or 'in' inside square bracketed property.");
          if (!h.consume("]"))
            throw new Error("Unterminated square brackets");
          return j;
        }, "parsePrefix")
      }), Eu = Y({
        name: "readonlyArrayParslet",
        accept: /* @__PURE__ */ o((h) => h === "readonly", "accept"),
        parsePrefix: /* @__PURE__ */ o((h) => (h.consume("readonly"), {
          type: "JsdocTypeReadonlyArray",
          element: q(h.parseIntermediateType(H.ALL))
        }), "parsePrefix")
      }), xu = Y({
        name: "conditionalParslet",
        precedence: H.INFIX,
        accept: /* @__PURE__ */ o((h) => h === "extends", "accept"),
        parseInfix: /* @__PURE__ */ o((h, x) => {
          h.consume("extends");
          const j = h.parseType(H.KEY_OF_TYPE_OF).element, V = h.parseType(H.INFIX);
          return h.consume(":"), {
            type: "JsdocTypeConditional",
            checksType: M(x),
            extendsType: j,
            trueType: V,
            falseType: h.parseType(H.INFIX)
          };
        }, "parseInfix")
      }), Tu = [
        yu,
        Q({
          allowedAdditionalTokens: ["typeof", "module", "keyof", "event", "external", "in"]
        }),
        ie,
        be,
        se,
        we,
        Ft({
          allowSquaredProperties: !0,
          allowKeyTypes: !1,
          allowOptional: !0,
          allowReadonly: !0
        }),
        _u
      ], Su = [
        ...L,
        Dt({
          allowKeyTypes: !1,
          objectFieldGrammar: Tu
        }),
        Eu,
        di,
        mu,
        hu,
        se,
        mt({
          allowWithoutParenthesis: !0,
          allowNoReturnType: !1,
          allowNamedParameters: ["this", "new", "args"],
          allowNewAsFunctionKeyword: !0
        }),
        pi({
          allowQuestionMark: !1
        }),
        Ct({
          allowEnclosingBrackets: !1,
          allowPostfix: !1
        }),
        fu,
        xu,
        Q({
          allowedAdditionalTokens: ["event", "external", "in"]
        }),
        re({
          allowedTypes: ["module"],
          pathGrammar: ce
        }),
        cr,
        gu,
        bu,
        K({
          allowSquareBracketsOnAnyType: !0,
          allowJsdocNamePaths: !1,
          pathGrammar: ce
        }),
        vu,
        wu,
        $n({
          allowVariadic: !0,
          allowOptional: !0
        })
      ];
      function Lo(h, x) {
        switch (x) {
          case "closure":
            return new Z(pu, h).parse();
          case "jsdoc":
            return new Z(cu, h).parse();
          case "typescript":
            return new Z(Su, h).parse();
        }
      }
      o(Lo, "parse");
      function fi(h, x = ["typescript", "closure", "jsdoc"]) {
        let j;
        for (const V of x)
          try {
            return Lo(h, V);
          } catch (G) {
            j = G;
          }
        throw j;
      }
      o(fi, "tryParse");
      function W(h, x) {
        const j = h[x.type];
        if (j === void 0)
          throw new Error(`In this set of transform rules exists no rule for type ${x.type}.`);
        return j(x, (V) => W(h, V));
      }
      o(W, "transform");
      function ke(h) {
        throw new Error("This transform is not available. Are you trying the correct parsing mode?");
      }
      o(ke, "notAvailableTransform");
      function Ir(h) {
        const x = {
          params: []
        };
        for (const j of h.parameters)
          j.type === "JsdocTypeKeyValue" ? j.key === "this" ? x.this = j.right : j.key === "new" ? x.new = j.right : x.params.push(j) : x.params.push(j);
        return x;
      }
      o(Ir, "extractSpecialParams");
      function Do(h, x, j) {
        return h === "prefix" ? j + x : x + j;
      }
      o(Do, "applyPosition");
      function dr(h, x) {
        switch (x) {
          case "double":
            return `"${h}"`;
          case "single":
            return `'${h}'`;
          case void 0:
            return h;
        }
      }
      o(dr, "quote");
      function Pu() {
        return {
          JsdocTypeParenthesis: /* @__PURE__ */ o((h, x) => `(${h.element !== void 0 ? x(h.element) : ""})`, "JsdocTypeParenthesis"),
          JsdocTypeKeyof: /* @__PURE__ */ o((h, x) => `keyof ${x(h.element)}`, "JsdocTypeKeyof"),
          JsdocTypeFunction: /* @__PURE__ */ o((h, x) => {
            var j;
            if (h.arrow) {
              if (h.returnType === void 0)
                throw new Error("Arrow function needs a return type.");
              let V = `${h.typeParameters !== void 0 ? `<${(j = h.typeParameters.map(x).join(", ")) !== null && j !== void 0 ? j : ""}>` : ""}(${h.parameters.map(x).join(", ")}) => ${x(h.returnType)}`;
              return h.constructor && (V = "new " + V), V;
            } else {
              let V = h.constructor ? "new" : "function";
              return h.parenthesis && (V += `(${h.parameters.map(x).join(", ")})`, h.returnType !== void 0 && (V += `: ${x(h.returnType)}`)), V;
            }
          }, "JsdocTypeFunction"),
          JsdocTypeName: /* @__PURE__ */ o((h) => h.value, "JsdocTypeName"),
          JsdocTypeTuple: /* @__PURE__ */ o((h, x) => `[${h.elements.map(x).join(", ")}]`, "JsdocTypeTuple"),
          JsdocTypeVariadic: /* @__PURE__ */ o((h, x) => h.meta.position === void 0 ? "..." : Do(h.meta.position, x(h.element), "..."), "JsdocTypeVariadic"),
          JsdocTypeNamePath: /* @__PURE__ */ o((h, x) => {
            const j = x(h.left), V = x(h.right);
            switch (h.pathType) {
              case "inner":
                return `${j}~${V}`;
              case "instance":
                return `${j}#${V}`;
              case "property":
                return `${j}.${V}`;
              case "property-brackets":
                return `${j}[${V}]`;
            }
          }, "JsdocTypeNamePath"),
          JsdocTypeStringValue: /* @__PURE__ */ o((h) => dr(h.value, h.meta.quote), "JsdocTypeStringValue"),
          JsdocTypeAny: /* @__PURE__ */ o(() => "*", "JsdocTypeAny"),
          JsdocTypeGeneric: /* @__PURE__ */ o((h, x) => {
            if (h.meta.brackets === "square") {
              const j = h.elements[0], V = x(j);
              return j.type === "JsdocTypeUnion" || j.type === "JsdocTypeIntersection" ? `(${V})[]` : `${V}[]`;
            } else
              return `${x(h.left)}${h.meta.dot ? "." : ""}<${h.infer === !0 ? "infer " : ""}${h.elements.map(x).join(", ")}>`;
          }, "JsdocTypeGeneric"),
          JsdocTypeImport: /* @__PURE__ */ o((h, x) => `import(${x(h.element)})`, "JsdocTypeImport"),
          JsdocTypeObjectField: /* @__PURE__ */ o((h, x) => {
            let j = "";
            return h.readonly && (j += "readonly "), typeof h.key == "string" ? j += dr(h.key, h.meta.quote) : j += x(h.key), h.optional && (j += "?"), h.right === void 0 ? j : j + `: ${x(h.right)}`;
          }, "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ o((h, x) => `${x(h.left)}: ${x(h.right)}`, "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ o((h, x) => {
            let j = h.key;
            return h.optional && (j += "?"), h.variadic && (j = "..." + j), h.right === void 0 ? j : j + `: ${x(h.right)}`;
          }, "JsdocTypeKeyValue"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ o((h) => `${h.specialType}:${dr(h.value, h.meta.quote)}`, "JsdocTypeSpecialNamePath"),
          JsdocTypeNotNullable: /* @__PURE__ */ o((h, x) => Do(h.meta.position, x(h.element), "!"), "JsdocTypeNotNullable"),
          JsdocTypeNull: /* @__PURE__ */ o(() => "null", "JsdocTypeNull"),
          JsdocTypeNullable: /* @__PURE__ */ o((h, x) => Do(h.meta.position, x(h.element), "?"), "JsdocTypeNullable"),
          JsdocTypeNumber: /* @__PURE__ */ o((h) => h.value.toString(), "JsdocTypeNumber"),
          JsdocTypeObject: /* @__PURE__ */ o((h, x) => {
            var j, V;
            return `{${(h.meta.separator === "linebreak" && h.elements.length > 1 ? `
` + ((j = h.meta.propertyIndent) !== null && j !== void 0 ? j : "") : "") + h.elements.map(x).join(h.meta.separator === "comma" ? ", " : h.meta.separator === "linebreak" ? `
` + ((V = h.meta.propertyIndent) !== null && V !== void 0 ? V : "") : "; ") + (h.meta.separator === "linebreak" && h.elements.length > 1 ? `
` : "")}}`;
          }, "JsdocTypeObject"),
          JsdocTypeOptional: /* @__PURE__ */ o((h, x) => Do(h.meta.position, x(h.element), "="), "JsdocTypeOptional"),
          JsdocTypeSymbol: /* @__PURE__ */ o((h, x) => `${h.value}(${h.element !== void 0 ? x(h.element) : ""})`, "JsdocTypeSymbol"),
          JsdocTypeTypeof: /* @__PURE__ */ o((h, x) => `typeof ${x(h.element)}`, "JsdocTypeTypeof"),
          JsdocTypeUndefined: /* @__PURE__ */ o(() => "undefined", "JsdocTypeUndefined"),
          JsdocTypeUnion: /* @__PURE__ */ o((h, x) => h.elements.map(x).join(" | "), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ o(() => "?", "JsdocTypeUnknown"),
          JsdocTypeIntersection: /* @__PURE__ */ o((h, x) => h.elements.map(x).join(" & "), "JsdocTypeIntersection"),
          JsdocTypeProperty: /* @__PURE__ */ o((h) => dr(h.value, h.meta.quote), "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ o((h, x) => `${x(h.left)} is ${x(h.right)}`, "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ o((h, x) => `[${h.key}: ${x(h.right)}]`, "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ o((h, x) => `[${h.key} in ${x(h.right)}]`, "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ o((h, x) => `asserts ${x(h.left)} is ${x(h.right)}`, "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ o((h, x) => `readonly ${x(h.element)}`, "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ o((h, x) => `asserts ${x(h.element)}`, "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ o((h, x) => `${x(h.checksType)} extends ${x(h.extendsType)} ? ${x(h.trueType)} : ${x(h.falseType)}`, "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ o((h, x) => `${x(h.name)}${h.constraint !== void 0 ? ` extends ${x(h.constraint)}` : ""}${h.defaultValue !== void 0 ? ` = ${x(h.defaultValue)}` : ""}`, "JsdocTypeTypeParameter")
        };
      }
      o(Pu, "stringifyRules");
      const bk = Pu();
      function ay(h) {
        return W(bk, h);
      }
      o(ay, "stringify");
      const vk = [
        "null",
        "true",
        "false",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
      ];
      function pr(h) {
        const x = {
          type: "NameExpression",
          name: h
        };
        return vk.includes(h) && (x.reservedWord = !0), x;
      }
      o(pr, "makeName");
      const wk = {
        JsdocTypeOptional: /* @__PURE__ */ o((h, x) => {
          const j = x(h.element);
          return j.optional = !0, j;
        }, "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ o((h, x) => {
          const j = x(h.element);
          return j.nullable = !0, j;
        }, "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ o((h, x) => {
          const j = x(h.element);
          return j.nullable = !1, j;
        }, "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ o((h, x) => {
          if (h.element === void 0)
            throw new Error("dots without value are not allowed in catharsis mode");
          const j = x(h.element);
          return j.repeatable = !0, j;
        }, "JsdocTypeVariadic"),
        JsdocTypeAny: /* @__PURE__ */ o(() => ({
          type: "AllLiteral"
        }), "JsdocTypeAny"),
        JsdocTypeNull: /* @__PURE__ */ o(() => ({
          type: "NullLiteral"
        }), "JsdocTypeNull"),
        JsdocTypeStringValue: /* @__PURE__ */ o((h) => pr(dr(h.value, h.meta.quote)), "JsdocTypeStringValue"),
        JsdocTypeUndefined: /* @__PURE__ */ o(() => ({
          type: "UndefinedLiteral"
        }), "JsdocTypeUndefined"),
        JsdocTypeUnknown: /* @__PURE__ */ o(() => ({
          type: "UnknownLiteral"
        }), "JsdocTypeUnknown"),
        JsdocTypeFunction: /* @__PURE__ */ o((h, x) => {
          const j = Ir(h), V = {
            type: "FunctionType",
            params: j.params.map(x)
          };
          return j.this !== void 0 && (V.this = x(j.this)), j.new !== void 0 && (V.new = x(j.new)), h.returnType !== void 0 && (V.result = x(h.returnType)), V;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ o((h, x) => ({
          type: "TypeApplication",
          applications: h.elements.map((j) => x(j)),
          expression: x(h.left)
        }), "JsdocTypeGeneric"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ o((h) => pr(h.specialType + ":" + dr(h.value, h.meta.quote)), "JsdocTypeSpecialNamePath"),
        JsdocTypeName: /* @__PURE__ */ o((h) => h.value !== "function" ? pr(h.value) : {
          type: "FunctionType",
          params: []
        }, "JsdocTypeName"),
        JsdocTypeNumber: /* @__PURE__ */ o((h) => pr(h.value.toString()), "JsdocTypeNumber"),
        JsdocTypeObject: /* @__PURE__ */ o((h, x) => {
          const j = {
            type: "RecordType",
            fields: []
          };
          for (const V of h.elements)
            V.type !== "JsdocTypeObjectField" && V.type !== "JsdocTypeJsdocObjectField" ? j.fields.push({
              type: "FieldType",
              key: x(V),
              value: void 0
            }) : j.fields.push(x(V));
          return j;
        }, "JsdocTypeObject"),
        JsdocTypeObjectField: /* @__PURE__ */ o((h, x) => {
          if (typeof h.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          return {
            type: "FieldType",
            key: pr(dr(h.key, h.meta.quote)),
            value: h.right === void 0 ? void 0 : x(h.right)
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ o((h, x) => ({
          type: "FieldType",
          key: x(h.left),
          value: x(h.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeUnion: /* @__PURE__ */ o((h, x) => ({
          type: "TypeUnion",
          elements: h.elements.map((j) => x(j))
        }), "JsdocTypeUnion"),
        JsdocTypeKeyValue: /* @__PURE__ */ o((h, x) => ({
          type: "FieldType",
          key: pr(h.key),
          value: h.right === void 0 ? void 0 : x(h.right)
        }), "JsdocTypeKeyValue"),
        JsdocTypeNamePath: /* @__PURE__ */ o((h, x) => {
          const j = x(h.left);
          let V;
          h.right.type === "JsdocTypeSpecialNamePath" ? V = x(h.right).name : V = dr(h.right.value, h.right.meta.quote);
          const G = h.pathType === "inner" ? "~" : h.pathType === "instance" ? "#" : ".";
          return pr(`${j.name}${G}${V}`);
        }, "JsdocTypeNamePath"),
        JsdocTypeSymbol: /* @__PURE__ */ o((h) => {
          let x = "", j = h.element, V = !1;
          return j?.type === "JsdocTypeVariadic" && (j.meta.position === "prefix" ? x = "..." : V = !0, j = j.element), j?.type === "JsdocTypeName" ? x += j.value : j?.type === "JsdocTypeNumber" && (x += j.value.toString()), V && (x += "..."), pr(`${h.value}(${x})`);
        }, "JsdocTypeSymbol"),
        JsdocTypeParenthesis: /* @__PURE__ */ o((h, x) => x(M(h.element)), "JsdocTypeParenthesis"),
        JsdocTypeMappedType: ke,
        JsdocTypeIndexSignature: ke,
        JsdocTypeImport: ke,
        JsdocTypeKeyof: ke,
        JsdocTypeTuple: ke,
        JsdocTypeTypeof: ke,
        JsdocTypeIntersection: ke,
        JsdocTypeProperty: ke,
        JsdocTypePredicate: ke,
        JsdocTypeAsserts: ke,
        JsdocTypeReadonlyArray: ke,
        JsdocTypeAssertsPlain: ke,
        JsdocTypeConditional: ke,
        JsdocTypeTypeParameter: ke
      };
      function iy(h) {
        return W(wk, h);
      }
      o(iy, "catharsisTransform");
      function jr(h) {
        switch (h) {
          case void 0:
            return "none";
          case "single":
            return "single";
          case "double":
            return "double";
        }
      }
      o(jr, "getQuoteStyle");
      function sy(h) {
        switch (h) {
          case "inner":
            return "INNER_MEMBER";
          case "instance":
            return "INSTANCE_MEMBER";
          case "property":
            return "MEMBER";
          case "property-brackets":
            return "MEMBER";
        }
      }
      o(sy, "getMemberType");
      function mi(h, x) {
        return x.length === 2 ? {
          type: h,
          left: x[0],
          right: x[1]
        } : {
          type: h,
          left: x[0],
          right: mi(h, x.slice(1))
        };
      }
      o(mi, "nestResults");
      const _k = {
        JsdocTypeOptional: /* @__PURE__ */ o((h, x) => ({
          type: "OPTIONAL",
          value: x(h.element),
          meta: {
            syntax: h.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
          }
        }), "JsdocTypeOptional"),
        JsdocTypeNullable: /* @__PURE__ */ o((h, x) => ({
          type: "NULLABLE",
          value: x(h.element),
          meta: {
            syntax: h.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
          }
        }), "JsdocTypeNullable"),
        JsdocTypeNotNullable: /* @__PURE__ */ o((h, x) => ({
          type: "NOT_NULLABLE",
          value: x(h.element),
          meta: {
            syntax: h.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeVariadic: /* @__PURE__ */ o((h, x) => {
          const j = {
            type: "VARIADIC",
            meta: {
              syntax: h.meta.position === "prefix" ? "PREFIX_DOTS" : h.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
            }
          };
          return h.element !== void 0 && (j.value = x(h.element)), j;
        }, "JsdocTypeVariadic"),
        JsdocTypeName: /* @__PURE__ */ o((h) => ({
          type: "NAME",
          name: h.value
        }), "JsdocTypeName"),
        JsdocTypeTypeof: /* @__PURE__ */ o((h, x) => ({
          type: "TYPE_QUERY",
          name: x(h.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeTuple: /* @__PURE__ */ o((h, x) => ({
          type: "TUPLE",
          entries: h.elements.map(x)
        }), "JsdocTypeTuple"),
        JsdocTypeKeyof: /* @__PURE__ */ o((h, x) => ({
          type: "KEY_QUERY",
          value: x(h.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeImport: /* @__PURE__ */ o((h) => ({
          type: "IMPORT",
          path: {
            type: "STRING_VALUE",
            quoteStyle: jr(h.element.meta.quote),
            string: h.element.value
          }
        }), "JsdocTypeImport"),
        JsdocTypeUndefined: /* @__PURE__ */ o(() => ({
          type: "NAME",
          name: "undefined"
        }), "JsdocTypeUndefined"),
        JsdocTypeAny: /* @__PURE__ */ o(() => ({
          type: "ANY"
        }), "JsdocTypeAny"),
        JsdocTypeFunction: /* @__PURE__ */ o((h, x) => {
          const j = Ir(h), V = {
            type: h.arrow ? "ARROW" : "FUNCTION",
            params: j.params.map((G) => {
              if (G.type === "JsdocTypeKeyValue") {
                if (G.right === void 0)
                  throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
                return {
                  type: "NAMED_PARAMETER",
                  name: G.key,
                  typeName: x(G.right)
                };
              } else
                return x(G);
            }),
            new: null,
            returns: null
          };
          return j.this !== void 0 ? V.this = x(j.this) : h.arrow || (V.this = null), j.new !== void 0 && (V.new = x(j.new)), h.returnType !== void 0 && (V.returns = x(h.returnType)), V;
        }, "JsdocTypeFunction"),
        JsdocTypeGeneric: /* @__PURE__ */ o((h, x) => {
          const j = {
            type: "GENERIC",
            subject: x(h.left),
            objects: h.elements.map(x),
            meta: {
              syntax: h.meta.brackets === "square" ? "SQUARE_BRACKET" : h.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
            }
          };
          return h.meta.brackets === "square" && h.elements[0].type === "JsdocTypeFunction" && !h.elements[0].parenthesis && (j.objects[0] = {
            type: "NAME",
            name: "function"
          }), j;
        }, "JsdocTypeGeneric"),
        JsdocTypeObjectField: /* @__PURE__ */ o((h, x) => {
          if (typeof h.key != "string")
            throw new Error("Index signatures and mapped types are not supported");
          if (h.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: h.key,
              quoteStyle: jr(h.meta.quote),
              value: null,
              readonly: !1
            };
          let j = x(h.right);
          return h.optional && (j = {
            type: "OPTIONAL",
            value: j,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: h.key.toString(),
            quoteStyle: jr(h.meta.quote),
            value: j,
            readonly: !1
          };
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: /* @__PURE__ */ o(() => {
          throw new Error("Keys may not be typed in jsdoctypeparser.");
        }, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: /* @__PURE__ */ o((h, x) => {
          if (h.right === void 0)
            return {
              type: "RECORD_ENTRY",
              key: h.key,
              quoteStyle: "none",
              value: null,
              readonly: !1
            };
          let j = x(h.right);
          return h.optional && (j = {
            type: "OPTIONAL",
            value: j,
            meta: {
              syntax: "SUFFIX_KEY_QUESTION_MARK"
            }
          }), {
            type: "RECORD_ENTRY",
            key: h.key,
            quoteStyle: "none",
            value: j,
            readonly: !1
          };
        }, "JsdocTypeKeyValue"),
        JsdocTypeObject: /* @__PURE__ */ o((h, x) => {
          const j = [];
          for (const V of h.elements)
            (V.type === "JsdocTypeObjectField" || V.type === "JsdocTypeJsdocObjectField") && j.push(x(V));
          return {
            type: "RECORD",
            entries: j
          };
        }, "JsdocTypeObject"),
        JsdocTypeSpecialNamePath: /* @__PURE__ */ o((h) => {
          if (h.specialType !== "module")
            throw new Error(`jsdoctypeparser does not support type ${h.specialType} at this point.`);
          return {
            type: "MODULE",
            value: {
              type: "FILE_PATH",
              quoteStyle: jr(h.meta.quote),
              path: h.value
            }
          };
        }, "JsdocTypeSpecialNamePath"),
        JsdocTypeNamePath: /* @__PURE__ */ o((h, x) => {
          let j = !1, V, G;
          h.right.type === "JsdocTypeSpecialNamePath" && h.right.specialType === "event" ? (j = !0, V = h.right.value, G = jr(h.right.meta.quote)) : (V = h.right.value, G = jr(h.right.meta.quote));
          const te = {
            type: sy(h.pathType),
            owner: x(h.left),
            name: V,
            quoteStyle: G,
            hasEventPrefix: j
          };
          if (te.owner.type === "MODULE") {
            const ue = te.owner;
            return te.owner = te.owner.value, ue.value = te, ue;
          } else
            return te;
        }, "JsdocTypeNamePath"),
        JsdocTypeUnion: /* @__PURE__ */ o((h, x) => mi("UNION", h.elements.map(x)), "JsdocTypeUnion"),
        JsdocTypeParenthesis: /* @__PURE__ */ o((h, x) => ({
          type: "PARENTHESIS",
          value: x(M(h.element))
        }), "JsdocTypeParenthesis"),
        JsdocTypeNull: /* @__PURE__ */ o(() => ({
          type: "NAME",
          name: "null"
        }), "JsdocTypeNull"),
        JsdocTypeUnknown: /* @__PURE__ */ o(() => ({
          type: "UNKNOWN"
        }), "JsdocTypeUnknown"),
        JsdocTypeStringValue: /* @__PURE__ */ o((h) => ({
          type: "STRING_VALUE",
          quoteStyle: jr(h.meta.quote),
          string: h.value
        }), "JsdocTypeStringValue"),
        JsdocTypeIntersection: /* @__PURE__ */ o((h, x) => mi("INTERSECTION", h.elements.map(x)), "JsdocTypeIntersection"),
        JsdocTypeNumber: /* @__PURE__ */ o((h) => ({
          type: "NUMBER_VALUE",
          number: h.value.toString()
        }), "JsdocTypeNumber"),
        JsdocTypeSymbol: ke,
        JsdocTypeProperty: ke,
        JsdocTypePredicate: ke,
        JsdocTypeMappedType: ke,
        JsdocTypeIndexSignature: ke,
        JsdocTypeAsserts: ke,
        JsdocTypeReadonlyArray: ke,
        JsdocTypeAssertsPlain: ke,
        JsdocTypeConditional: ke,
        JsdocTypeTypeParameter: ke
      };
      function ly(h) {
        return W(_k, h);
      }
      o(ly, "jtpTransform");
      function uy() {
        return {
          JsdocTypeIntersection: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeIntersection",
            elements: h.elements.map(x)
          }), "JsdocTypeIntersection"),
          JsdocTypeGeneric: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeGeneric",
            left: x(h.left),
            elements: h.elements.map(x),
            meta: {
              dot: h.meta.dot,
              brackets: h.meta.brackets
            }
          }), "JsdocTypeGeneric"),
          JsdocTypeNullable: /* @__PURE__ */ o((h) => h, "JsdocTypeNullable"),
          JsdocTypeUnion: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeUnion",
            elements: h.elements.map(x)
          }), "JsdocTypeUnion"),
          JsdocTypeUnknown: /* @__PURE__ */ o((h) => h, "JsdocTypeUnknown"),
          JsdocTypeUndefined: /* @__PURE__ */ o((h) => h, "JsdocTypeUndefined"),
          JsdocTypeTypeof: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeTypeof",
            element: x(h.element)
          }), "JsdocTypeTypeof"),
          JsdocTypeSymbol: /* @__PURE__ */ o((h, x) => {
            const j = {
              type: "JsdocTypeSymbol",
              value: h.value
            };
            return h.element !== void 0 && (j.element = x(h.element)), j;
          }, "JsdocTypeSymbol"),
          JsdocTypeOptional: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeOptional",
            element: x(h.element),
            meta: {
              position: h.meta.position
            }
          }), "JsdocTypeOptional"),
          JsdocTypeObject: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: h.elements.map(x)
          }), "JsdocTypeObject"),
          JsdocTypeNumber: /* @__PURE__ */ o((h) => h, "JsdocTypeNumber"),
          JsdocTypeNull: /* @__PURE__ */ o((h) => h, "JsdocTypeNull"),
          JsdocTypeNotNullable: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeNotNullable",
            element: x(h.element),
            meta: {
              position: h.meta.position
            }
          }), "JsdocTypeNotNullable"),
          JsdocTypeSpecialNamePath: /* @__PURE__ */ o((h) => h, "JsdocTypeSpecialNamePath"),
          JsdocTypeObjectField: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeObjectField",
            key: h.key,
            right: h.right === void 0 ? void 0 : x(h.right),
            optional: h.optional,
            readonly: h.readonly,
            meta: h.meta
          }), "JsdocTypeObjectField"),
          JsdocTypeJsdocObjectField: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeJsdocObjectField",
            left: x(h.left),
            right: x(h.right)
          }), "JsdocTypeJsdocObjectField"),
          JsdocTypeKeyValue: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeKeyValue",
            key: h.key,
            right: h.right === void 0 ? void 0 : x(h.right),
            optional: h.optional,
            variadic: h.variadic
          }), "JsdocTypeKeyValue"),
          JsdocTypeImport: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeImport",
            element: x(h.element)
          }), "JsdocTypeImport"),
          JsdocTypeAny: /* @__PURE__ */ o((h) => h, "JsdocTypeAny"),
          JsdocTypeStringValue: /* @__PURE__ */ o((h) => h, "JsdocTypeStringValue"),
          JsdocTypeNamePath: /* @__PURE__ */ o((h) => h, "JsdocTypeNamePath"),
          JsdocTypeVariadic: /* @__PURE__ */ o((h, x) => {
            const j = {
              type: "JsdocTypeVariadic",
              meta: {
                position: h.meta.position,
                squareBrackets: h.meta.squareBrackets
              }
            };
            return h.element !== void 0 && (j.element = x(h.element)), j;
          }, "JsdocTypeVariadic"),
          JsdocTypeTuple: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeTuple",
            elements: h.elements.map(x)
          }), "JsdocTypeTuple"),
          JsdocTypeName: /* @__PURE__ */ o((h) => h, "JsdocTypeName"),
          JsdocTypeFunction: /* @__PURE__ */ o((h, x) => {
            const j = {
              type: "JsdocTypeFunction",
              arrow: h.arrow,
              parameters: h.parameters.map(x),
              constructor: h.constructor,
              parenthesis: h.parenthesis
            };
            return h.returnType !== void 0 && (j.returnType = x(h.returnType)), j;
          }, "JsdocTypeFunction"),
          JsdocTypeKeyof: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeKeyof",
            element: x(h.element)
          }), "JsdocTypeKeyof"),
          JsdocTypeParenthesis: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeParenthesis",
            element: x(h.element)
          }), "JsdocTypeParenthesis"),
          JsdocTypeProperty: /* @__PURE__ */ o((h) => h, "JsdocTypeProperty"),
          JsdocTypePredicate: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypePredicate",
            left: x(h.left),
            right: x(h.right)
          }), "JsdocTypePredicate"),
          JsdocTypeIndexSignature: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeIndexSignature",
            key: h.key,
            right: x(h.right)
          }), "JsdocTypeIndexSignature"),
          JsdocTypeMappedType: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeMappedType",
            key: h.key,
            right: x(h.right)
          }), "JsdocTypeMappedType"),
          JsdocTypeAsserts: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeAsserts",
            left: x(h.left),
            right: x(h.right)
          }), "JsdocTypeAsserts"),
          JsdocTypeReadonlyArray: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeReadonlyArray",
            element: x(h.element)
          }), "JsdocTypeReadonlyArray"),
          JsdocTypeAssertsPlain: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeAssertsPlain",
            element: x(h.element)
          }), "JsdocTypeAssertsPlain"),
          JsdocTypeConditional: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeConditional",
            checksType: x(h.checksType),
            extendsType: x(h.extendsType),
            trueType: x(h.trueType),
            falseType: x(h.falseType)
          }), "JsdocTypeConditional"),
          JsdocTypeTypeParameter: /* @__PURE__ */ o((h, x) => ({
            type: "JsdocTypeTypeParameter",
            name: x(h.name),
            constraint: h.constraint !== void 0 ? x(h.constraint) : void 0,
            defaultValue: h.defaultValue !== void 0 ? x(h.defaultValue) : void 0
          }), "JsdocTypeTypeParameter")
        };
      }
      o(uy, "identityTransformRules");
      const cy = {
        JsdocTypeAny: [],
        JsdocTypeFunction: ["parameters", "returnType"],
        JsdocTypeGeneric: ["left", "elements"],
        JsdocTypeImport: [],
        JsdocTypeIndexSignature: ["right"],
        JsdocTypeIntersection: ["elements"],
        JsdocTypeKeyof: ["element"],
        JsdocTypeKeyValue: ["right"],
        JsdocTypeMappedType: ["right"],
        JsdocTypeName: [],
        JsdocTypeNamePath: ["left", "right"],
        JsdocTypeNotNullable: ["element"],
        JsdocTypeNull: [],
        JsdocTypeNullable: ["element"],
        JsdocTypeNumber: [],
        JsdocTypeObject: ["elements"],
        JsdocTypeObjectField: ["right"],
        JsdocTypeJsdocObjectField: ["left", "right"],
        JsdocTypeOptional: ["element"],
        JsdocTypeParenthesis: ["element"],
        JsdocTypeSpecialNamePath: [],
        JsdocTypeStringValue: [],
        JsdocTypeSymbol: ["element"],
        JsdocTypeTuple: ["elements"],
        JsdocTypeTypeof: ["element"],
        JsdocTypeUndefined: [],
        JsdocTypeUnion: ["elements"],
        JsdocTypeUnknown: [],
        JsdocTypeVariadic: ["element"],
        JsdocTypeProperty: [],
        JsdocTypePredicate: ["left", "right"],
        JsdocTypeAsserts: ["left", "right"],
        JsdocTypeReadonlyArray: ["element"],
        JsdocTypeAssertsPlain: ["element"],
        JsdocTypeConditional: ["checksType", "extendsType", "trueType", "falseType"],
        JsdocTypeTypeParameter: ["name", "constraint", "defaultValue"]
      };
      function hi(h, x, j, V, G) {
        V?.(h, x, j);
        const te = cy[h.type];
        for (const ue of te) {
          const Me = h[ue];
          if (Me !== void 0)
            if (Array.isArray(Me))
              for (const De of Me)
                hi(De, h, ue, V, G);
            else
              hi(Me, h, ue, V, G);
        }
        G?.(h, x, j);
      }
      o(hi, "_traverse");
      function dy(h, x, j) {
        hi(h, void 0, void 0, x, j);
      }
      o(dy, "traverse"), r.catharsisTransform = iy, r.identityTransformRules = uy, r.jtpTransform = ly, r.parse = Lo, r.stringify = ay, r.stringifyRules = Pu, r.transform = W, r.traverse = dy, r.tryParse = fi, r.visitorKeys = cy;
    });
  }
}), c1 = ["null", "undefined"];
function Ls(e) {
  return c1.some((t) => t === e);
}
o(Ls, "isDefaultValueBlacklisted");
var d1 = /* @__PURE__ */ o((e) => {
  if (!e)
    return "";
  if (typeof e == "string")
    return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, "str");
function rp(e) {
  return !!e.__docgenInfo;
}
o(rp, "hasDocgen");
function p1(e) {
  return e != null && Object.keys(e).length > 0;
}
o(p1, "isValidDocgenSection");
function f1(e, t) {
  return rp(e) ? e.__docgenInfo[t] : null;
}
o(f1, "getDocgenSection");
function nv(e) {
  return rp(e) ? d1(e.__docgenInfo.description) : "";
}
o(nv, "getDocgenDescription");
var Br;
(function(e) {
  e.start = "/**", e.nostart = "/***", e.delim = "*", e.end = "*/";
})(Br = Br || (Br = {}));
function ov(e) {
  return /^\s+$/.test(e);
}
o(ov, "isSpace");
function av(e) {
  const t = e.match(/\r+$/);
  return t == null ? ["", e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
o(av, "splitCR");
function mn(e) {
  const t = e.match(/^\s+/);
  return t == null ? ["", e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
o(mn, "splitSpace");
function iv(e) {
  return e.split(/\n/);
}
o(iv, "splitLines");
function sv(e = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: !1, description: "", problems: [], source: [] }, e);
}
o(sv, "seedSpec");
function lv(e = {}) {
  return Object.assign({ start: "", delimiter: "", postDelimiter: "", tag: "", postTag: "", name: "", postName: "", type: "", postType: "", description: "", end: "", lineEnd: "" }, e);
}
o(lv, "seedTokens");
var m1 = /^@\S+/;
function uv({ fence: e = "```" } = {}) {
  const t = cv(e), r = /* @__PURE__ */ o((n, a) => t(n) ? !a : a, "toggleFence");
  return /* @__PURE__ */ o(function(n) {
    const a = [[]];
    let i = !1;
    for (const s of n)
      m1.test(s.tokens.description) && !i ? a.push([s]) : a[a.length - 1].push(s), i = r(s.tokens.description, i);
    return a;
  }, "parseBlock");
}
o(uv, "getParser");
function cv(e) {
  return typeof e == "string" ? (t) => t.split(e).length % 2 === 0 : e;
}
o(cv, "getFencer");
function dv({ startLine: e = 0, markers: t = Br } = {}) {
  let r = null, n = e;
  return /* @__PURE__ */ o(function(a) {
    let i = a;
    const s = lv();
    if ([s.lineEnd, i] = av(i), [s.start, i] = mn(i), r === null && i.startsWith(t.start) && !i.startsWith(t.nostart) && (r = [], s.delimiter = i.slice(0, t.start.length), i = i.slice(t.start.length), [s.postDelimiter, i] = mn(i)), r === null)
      return n++, null;
    const l = i.trimRight().endsWith(t.end);
    if (s.delimiter === "" && i.startsWith(t.delim) && !i.startsWith(t.end) && (s.delimiter = t.delim, i = i.slice(t.delim.length), [s.postDelimiter, i] = mn(i)), l) {
      const c = i.trimRight();
      s.end = i.slice(c.length - t.end.length), i = c.slice(0, -t.end.length);
    }
    if (s.description = i, r.push({ number: n, source: a, tokens: s }), n++, l) {
      const c = r.slice();
      return r = null, c;
    }
    return null;
  }, "parseSource");
}
o(dv, "getParser");
function pv({ tokenizers: e }) {
  return /* @__PURE__ */ o(function(t) {
    var r;
    let n = sv({ source: t });
    for (const a of e)
      if (n = a(n), !((r = n.problems[n.problems.length - 1]) === null || r === void 0) && r.critical)
        break;
    return n;
  }, "parseSpec");
}
o(pv, "getParser");
function fv() {
  return (e) => {
    const { tokens: t } = e.source[0], r = t.description.match(/\s*(@(\S+))(\s*)/);
    return r === null ? (e.problems.push({
      code: "spec:tag:prefix",
      message: 'tag should start with "@" symbol',
      line: e.source[0].number,
      critical: !0
    }), e) : (t.tag = r[1], t.postTag = r[3], t.description = t.description.slice(r[0].length), e.tag = r[2], e);
  };
}
o(fv, "tagTokenizer");
function mv(e = "compact") {
  const t = hv(e);
  return (r) => {
    let n = 0, a = [];
    for (const [l, { tokens: c }] of r.source.entries()) {
      let u = "";
      if (l === 0 && c.description[0] !== "{")
        return r;
      for (const p of c.description)
        if (p === "{" && n++, p === "}" && n--, u += p, n === 0)
          break;
      if (a.push([c, u]), n === 0)
        break;
    }
    if (n !== 0)
      return r.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: r.source[0].number,
        critical: !0
      }), r;
    const i = [], s = a[0][0].postDelimiter.length;
    for (const [l, [c, u]] of a.entries())
      c.type = u, l > 0 && (c.type = c.postDelimiter.slice(s) + u, c.postDelimiter = c.postDelimiter.slice(0, s)), [c.postType, c.description] = mn(c.description.slice(u.length)), i.push(c.type);
    return i[0] = i[0].slice(1), i[i.length - 1] = i[i.length - 1].slice(0, -1), r.type = t(i), r;
  };
}
o(mv, "typeTokenizer");
var h1 = /* @__PURE__ */ o((e) => e.trim(), "trim");
function hv(e) {
  return e === "compact" ? (t) => t.map(h1).join("") : e === "preserve" ? (t) => t.join(`
`) : e;
}
o(hv, "getJoiner");
var y1 = /* @__PURE__ */ o((e) => e && e.startsWith('"') && e.endsWith('"'), "isQuoted");
function yv() {
  const e = /* @__PURE__ */ o((t, { tokens: r }, n) => r.type === "" ? t : n, "typeEnd");
  return (t) => {
    const { tokens: r } = t.source[t.source.reduce(e, 0)], n = r.description.trimLeft(), a = n.split('"');
    if (a.length > 1 && a[0] === "" && a.length % 2 === 1)
      return t.name = a[1], r.name = `"${a[1]}"`, [r.postName, r.description] = mn(n.slice(r.name.length)), t;
    let i = 0, s = "", l = !1, c;
    for (const p of n) {
      if (i === 0 && ov(p))
        break;
      p === "[" && i++, p === "]" && i--, s += p;
    }
    if (i !== 0)
      return t.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: t.source[0].number,
        critical: !0
      }), t;
    const u = s;
    if (s[0] === "[" && s[s.length - 1] === "]") {
      l = !0, s = s.slice(1, -1);
      const p = s.split("=");
      if (s = p[0].trim(), p[1] !== void 0 && (c = p.slice(1).join("=").trim()), s === "")
        return t.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: t.source[0].number,
          critical: !0
        }), t;
      if (c === "")
        return t.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: t.source[0].number,
          critical: !0
        }), t;
      if (!y1(c) && /=(?!>)/.test(c))
        return t.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: t.source[0].number,
          critical: !0
        }), t;
    }
    return t.optional = l, t.name = s, r.name = u, c !== void 0 && (t.default = c), [r.postName, r.description] = mn(n.slice(r.name.length)), t;
  };
}
o(yv, "nameTokenizer");
function gv(e = "compact", t = Br) {
  const r = np(e);
  return (n) => (n.description = r(n.source, t), n);
}
o(gv, "descriptionTokenizer");
function np(e) {
  return e === "compact" ? bv : e === "preserve" ? vv : e;
}
o(np, "getJoiner");
function bv(e, t = Br) {
  return e.map(({ tokens: { description: r } }) => r.trim()).filter((r) => r !== "").join(" ");
}
o(bv, "compactJoiner");
var g1 = /* @__PURE__ */ o((e, { tokens: t }, r) => t.type === "" ? e : r, "lineNo"), b1 = /* @__PURE__ */ o(({ tokens: e }) => (e.delimiter === "" ? e.start : e.postDelimiter.slice(1)) + e.description, "getDescription");
function vv(e, t = Br) {
  if (e.length === 0)
    return "";
  e[0].tokens.description === "" && e[0].tokens.delimiter === t.start && (e = e.slice(1));
  const r = e[e.length - 1];
  return r !== void 0 && r.tokens.description === "" && r.tokens.end.endsWith(t.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(g1, 0)), e.map(b1).join(`
`);
}
o(vv, "preserveJoiner");
function wv({ startLine: e = 0, fence: t = "```", spacing: r = "compact", markers: n = Br, tokenizers: a = [
  fv(),
  mv(r),
  yv(),
  gv(r)
] } = {}) {
  if (e < 0 || e % 1 > 0)
    throw new Error("Invalid startLine");
  const i = dv({ startLine: e, markers: n }), s = uv({ fence: t }), l = pv({ tokenizers: a }), c = np(r);
  return function(u) {
    const p = [];
    for (const f of iv(u)) {
      const m = i(f);
      if (m === null)
        continue;
      const y = s(m), g = y.slice(1).map(l);
      p.push({
        description: c(y[0], n),
        tags: g,
        source: m,
        problems: g.reduce((v, _) => v.concat(_.problems), [])
      });
    }
    return p;
  };
}
o(wv, "getParser");
function _v(e) {
  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.lineEnd;
}
o(_v, "join");
function v1() {
  return (e) => e.source.map(({ tokens: t }) => _v(t)).join(`
`);
}
o(v1, "getStringifier");
function Ev(e, t = {}) {
  return wv(t)(e);
}
o(Ev, "parse");
var op = Ye(u1(), 1);
function xv(e) {
  return e != null && e.includes("@");
}
o(xv, "containsJsDoc");
function Tv(e) {
  const t = `/**
` + (e ?? "").split(`
`).map((n) => ` * ${n}`).join(`
`) + `
*/`, r = Ev(t, {
    spacing: "preserve"
  });
  if (!r || r.length === 0)
    throw new Error("Cannot parse JSDoc tags.");
  return r[0];
}
o(Tv, "parse");
var w1 = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
}, _1 = /* @__PURE__ */ o((e, t = w1) => {
  if (!xv(e))
    return {
      includesJsDoc: !1,
      ignore: !1
    };
  const r = Tv(e), n = Sv(r, t.tags);
  return n.ignore ? {
    includesJsDoc: !0,
    ignore: !0
  } : {
    includesJsDoc: !0,
    ignore: !1,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: r.description.trim(),
    extractedTags: n
  };
}, "parseJsDoc");
function Sv(e, t) {
  const r = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: !1
  };
  for (const n of e.tags)
    if (!(t !== void 0 && !t.includes(n.tag)))
      if (n.tag === "ignore") {
        r.ignore = !0;
        break;
      } else
        switch (n.tag) {
          // arg & argument are aliases for param.
          case "param":
          case "arg":
          case "argument": {
            const a = Ov(n);
            a != null && (r.params == null && (r.params = []), r.params.push(a));
            break;
          }
          case "deprecated": {
            const a = Cv(n);
            a != null && (r.deprecated = a);
            break;
          }
          case "returns": {
            const a = Av(n);
            a != null && (r.returns = a);
            break;
          }
        }
  return r;
}
o(Sv, "extractJsDocTags");
function Pv(e) {
  return e.replace(/[\.-]$/, "");
}
o(Pv, "normaliseParamName");
function Ov(e) {
  if (!e.name || e.name === "-")
    return null;
  const t = sp(e.type);
  return {
    name: e.name,
    type: t,
    description: ip(e.description),
    getPrettyName: /* @__PURE__ */ o(() => Pv(e.name), "getPrettyName"),
    getTypeName: /* @__PURE__ */ o(() => t ? lp(t) : null, "getTypeName")
  };
}
o(Ov, "extractParam");
function Cv(e) {
  return e.name ? ap(e.name, e.description) : null;
}
o(Cv, "extractDeprecated");
function ap(e, t) {
  const r = e === "" ? t : `${e} ${t}`;
  return ip(r);
}
o(ap, "joinNameAndDescription");
function ip(e) {
  const t = e.replace(/^- /g, "").trim();
  return t === "" ? null : t;
}
o(ip, "normaliseDescription");
function Av(e) {
  const t = sp(e.type);
  return t ? {
    type: t,
    description: ap(e.name, e.description),
    getTypeName: /* @__PURE__ */ o(() => lp(t), "getTypeName")
  } : null;
}
o(Av, "extractReturns");
var Zr = (0, op.stringifyRules)(), E1 = Zr.JsdocTypeObject;
Zr.JsdocTypeAny = () => "any";
Zr.JsdocTypeObject = (e, t) => `(${E1(e, t)})`;
Zr.JsdocTypeOptional = (e, t) => t(e.element);
Zr.JsdocTypeNullable = (e, t) => t(e.element);
Zr.JsdocTypeNotNullable = (e, t) => t(e.element);
Zr.JsdocTypeUnion = (e, t) => e.elements.map(t).join("|");
function sp(e) {
  try {
    return (0, op.parse)(e, "typescript");
  } catch {
    return null;
  }
}
o(sp, "extractType");
function lp(e) {
  return (0, op.transform)(Zr, e);
}
o(lp, "extractTypeName");
var x1 = 90, T1 = 50;
function up(e) {
  return e.length > x1;
}
o(up, "isTooLongForTypeSummary");
function Rv(e) {
  return e.length > T1;
}
o(Rv, "isTooLongForDefaultValueSummary");
function Ke(e, t) {
  return e === t ? { summary: e } : { summary: e, detail: t };
}
o(Ke, "createSummaryValue");
function S1(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Ls(r))
      return Rv(r) ? Ke(t?.name, r) : Ke(r);
  }
  return null;
}
o(S1, "createDefaultValue");
function cp({ name: e, value: t, elements: r, raw: n }) {
  return t ?? (r != null ? r.map(cp).join(" | ") : n ?? e);
}
o(cp, "generateUnionElement");
function kv({ name: e, raw: t, elements: r }) {
  return r != null ? Ke(r.map(cp).join(" | ")) : t != null ? Ke(t.replace(/^\|\s*/, "")) : Ke(e);
}
o(kv, "generateUnion");
function Iv({ type: e, raw: t }) {
  return t != null ? Ke(t) : Ke(e);
}
o(Iv, "generateFuncSignature");
function jv({ type: e, raw: t }) {
  return t != null ? up(t) ? Ke(e, t) : Ke(t) : Ke(e);
}
o(jv, "generateObjectSignature");
function Nv(e) {
  const { type: t } = e;
  return t === "object" ? jv(e) : Iv(e);
}
o(Nv, "generateSignature");
function qv({ name: e, raw: t }) {
  return t != null ? up(t) ? Ke(e, t) : Ke(t) : Ke(e);
}
o(qv, "generateDefault");
function P1(e) {
  if (e == null)
    return null;
  switch (e.name) {
    case "union":
      return kv(e);
    case "signature":
      return Nv(e);
    default:
      return qv(e);
  }
}
o(P1, "createType");
function O1({ defaultValue: e }) {
  if (e != null) {
    const { value: t } = e;
    if (!Ls(t))
      return Ke(t);
  }
  return null;
}
o(O1, "createDefaultValue");
function C1({ tsType: e, required: t }) {
  if (e == null)
    return null;
  let r = e.name;
  return t || (r = r.replace(" | undefined", "")), Ke(
    ["Array", "Record", "signature"].includes(e.name) ? e.raw : r
  );
}
o(C1, "createType");
function Mv(e) {
  return e != null ? Ke(e.name) : null;
}
o(Mv, "createType");
function $v(e) {
  const { computed: t, func: r } = e;
  return typeof t > "u" && typeof r > "u";
}
o($v, "isReactDocgenTypescript");
function Lv(e) {
  return e ? e.name === "string" ? !0 : e.name === "enum" ? Array.isArray(e.value) && e.value.every(
    ({ value: t }) => typeof t == "string" && t[0] === '"' && t[t.length - 1] === '"'
  ) : !1 : !1;
}
o(Lv, "isStringValued");
function Dv(e, t) {
  if (e != null) {
    const { value: r } = e;
    if (!Ls(r))
      return $v(e) && Lv(t) ? Ke(JSON.stringify(r)) : Ke(r);
  }
  return null;
}
o(Dv, "createDefaultValue");
function A1(e, t, r) {
  const { description: n, required: a, defaultValue: i } = r;
  return {
    name: e,
    type: Mv(t),
    required: a,
    description: n,
    defaultValue: Dv(i, t)
  };
}
o(A1, "createBasicPropDef");
function R1(e, t) {
  if (t?.includesJsDoc) {
    const { description: r, extractedTags: n } = t;
    r != null && (e.description = t.description);
    const a = {
      ...n,
      params: n?.params?.map(
        (i) => ({
          name: i.getPrettyName(),
          description: i.description
        })
      )
    };
    Object.values(a).filter(Boolean).length > 0 && (e.jsDocTags = a);
  }
  return e;
}
o(R1, "applyJsDocResult");
function k1(e, t, r, n) {
  const a = _1(t.description);
  return a.includesJsDoc && a.ignore ? null : {
    propDef: n(e, t, a),
    jsDocTags: a.extractedTags,
    docgenInfo: t,
    typeSystem: r
  };
}
o(k1, "extractProp");
function I1(e) {
  return e != null ? nv(e) : "";
}
o(I1, "extractComponentDescription");
var Wr = /* @__PURE__ */ o((...e) => {
  const t = {}, r = e.filter(Boolean), n = r.reduce((a, i) => (Object.entries(i).forEach(([s, l]) => {
    const c = a[s];
    Array.isArray(l) || typeof c > "u" ? a[s] = l : _t(l) && _t(c) ? t[s] = !0 : typeof l < "u" && (a[s] = l);
  }), a), {});
  return Object.keys(t).forEach((a) => {
    const i = r.filter(Boolean).map((s) => s[a]).filter((s) => typeof s < "u");
    i.every((s) => _t(s)) ? n[a] = Wr(...i) : n[a] = i[i.length - 1];
  }), n;
}, "combineParameters"), j1 = "storybook/docs", N1 = `${j1}/snippet-rendered`;
function Fv() {
}
o(Fv, "noop");
function Bv(e, t) {
  return e === t || Number.isNaN(e) && Number.isNaN(t);
}
o(Bv, "eq");
function Uv(e, t, r) {
  return zn(e, t, void 0, void 0, void 0, void 0, r);
}
o(Uv, "isEqualWith");
function zn(e, t, r, n, a, i, s) {
  const l = s(e, t, r, n, a, i);
  if (l !== void 0)
    return l;
  if (typeof e == typeof t)
    switch (typeof e) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return e === t;
      case "number":
        return e === t || Object.is(e, t);
      case "function":
        return e === t;
      case "object":
        return Xn(e, t, i, s);
    }
  return Xn(e, t, i, s);
}
o(zn, "isEqualWithImpl");
function Xn(e, t, r, n) {
  if (Object.is(e, t))
    return !0;
  let a = Ui(e), i = Ui(t);
  if (a === Yu && (a = Ei), i === Yu && (i = Ei), a !== i)
    return !1;
  switch (a) {
    case hb:
      return e.toString() === t.toString();
    case yb: {
      const c = e.valueOf(), u = t.valueOf();
      return Bv(c, u);
    }
    case gb:
    case vb:
    case bb:
      return Object.is(e.valueOf(), t.valueOf());
    case mb:
      return e.source === t.source && e.flags === t.flags;
    case Dk:
      return e === t;
  }
  r = r ?? /* @__PURE__ */ new Map();
  const s = r.get(e), l = r.get(t);
  if (s != null && l != null)
    return s === t;
  r.set(e, t), r.set(t, e);
  try {
    switch (a) {
      case wb: {
        if (e.size !== t.size)
          return !1;
        for (const [c, u] of e.entries())
          if (!t.has(c) || !zn(u, t.get(c), c, e, t, r, n))
            return !1;
        return !0;
      }
      case _b: {
        if (e.size !== t.size)
          return !1;
        const c = Array.from(e.values()), u = Array.from(t.values());
        for (let p = 0; p < c.length; p++) {
          const f = c[p], m = u.findIndex((y) => zn(f, y, void 0, e, t, r, n));
          if (m === -1)
            return !1;
          u.splice(m, 1);
        }
        return !0;
      }
      case Eb:
      case Sb:
      case Pb:
      case Ob:
      case Cb:
      case Bk:
      case Ab:
      case Rb:
      case kb:
      case Uk:
      case Ib:
      case jb: {
        if (typeof Buffer < "u" && Buffer.isBuffer(e) !== Buffer.isBuffer(t) || e.length !== t.length)
          return !1;
        for (let c = 0; c < e.length; c++)
          if (!zn(e[c], t[c], c, e, t, r, n))
            return !1;
        return !0;
      }
      case xb:
        return e.byteLength !== t.byteLength ? !1 : Xn(new Uint8Array(e), new Uint8Array(t), r, n);
      case Tb:
        return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset ? !1 : Xn(new Uint8Array(e), new Uint8Array(t), r, n);
      case Fk:
        return e.name === t.name && e.message === t.message;
      case Ei: {
        if (!(Xn(e.constructor, t.constructor, r, n) || _t(e) && _t(t)))
          return !1;
        const c = [...Object.keys(e), ...Bi(e)], u = [...Object.keys(t), ...Bi(t)];
        if (c.length !== u.length)
          return !1;
        for (let p = 0; p < c.length; p++) {
          const f = c[p], m = e[f];
          if (!Object.hasOwn(t, f))
            return !1;
          const y = t[f];
          if (!zn(m, y, f, e, t, r, n))
            return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    r.delete(e), r.delete(t);
  }
}
o(Xn, "areObjectsEqual");
function Hv(e, t) {
  return Uv(e, t, Fv);
}
o(Hv, "isEqual");
var q1 = "Invariant failed";
function nr(e, t) {
  if (!e)
    throw new Error(q1);
}
o(nr, "invariant");
var Vv = F({
  "../node_modules/entities/lib/maps/entities.json"(e, t) {
    t.exports = { Aacute: "Ã", aacute: "Ã¡", Abreve: "Ä‚", abreve: "Äƒ", ac: "âˆ¾", acd: "âˆ¿", acE: "âˆ¾Ì³", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", Acy: "Ð", acy: "Ð°", AElig: "Ã†", aelig: "Ã¦", af: "â¡", Afr: "ð”„", afr: "ð”ž", Agrave: "Ã€", agrave: "Ã ", alefsym: "â„µ", aleph: "â„µ", Alpha: "Î‘", alpha: "Î±", Amacr: "Ä€", amacr: "Ä", amalg: "â¨¿", amp: "&", AMP: "&", andand: "â©•", And: "â©“", and: "âˆ§", andd: "â©œ", andslope: "â©˜", andv: "â©š", ang: "âˆ ", ange: "â¦¤", angle: "âˆ ", angmsdaa: "â¦¨", angmsdab: "â¦©", angmsdac: "â¦ª", angmsdad: "â¦«", angmsdae: "â¦¬", angmsdaf: "â¦­", angmsdag: "â¦®", angmsdah: "â¦¯", angmsd: "âˆ¡", angrt: "âˆŸ", angrtvb: "âŠ¾", angrtvbd: "â¦", angsph: "âˆ¢", angst: "Ã…", angzarr: "â¼", Aogon: "Ä„", aogon: "Ä…", Aopf: "ð”¸", aopf: "ð•’", apacir: "â©¯", ap: "â‰ˆ", apE: "â©°", ape: "â‰Š", apid: "â‰‹", apos: "'", ApplyFunction: "â¡", approx: "â‰ˆ", approxeq: "â‰Š", Aring: "Ã…", aring: "Ã¥", Ascr: "ð’œ", ascr: "ð’¶", Assign: "â‰”", ast: "*", asymp: "â‰ˆ", asympeq: "â‰", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", awconint: "âˆ³", awint: "â¨‘", backcong: "â‰Œ", backepsilon: "Ï¶", backprime: "â€µ", backsim: "âˆ½", backsimeq: "â‹", Backslash: "âˆ–", Barv: "â«§", barvee: "âŠ½", barwed: "âŒ…", Barwed: "âŒ†", barwedge: "âŒ…", bbrk: "âŽµ", bbrktbrk: "âŽ¶", bcong: "â‰Œ", Bcy: "Ð‘", bcy: "Ð±", bdquo: "â€ž", becaus: "âˆµ", because: "âˆµ", Because: "âˆµ", bemptyv: "â¦°", bepsi: "Ï¶", bernou: "â„¬", Bernoullis: "â„¬", Beta: "Î’", beta: "Î²", beth: "â„¶", between: "â‰¬", Bfr: "ð”…", bfr: "ð”Ÿ", bigcap: "â‹‚", bigcirc: "â—¯", bigcup: "â‹ƒ", bigodot: "â¨€", bigoplus: "â¨", bigotimes: "â¨‚", bigsqcup: "â¨†", bigstar: "â˜…", bigtriangledown: "â–½", bigtriangleup: "â–³", biguplus: "â¨„", bigvee: "â‹", bigwedge: "â‹€", bkarow: "â¤", blacklozenge: "â§«", blacksquare: "â–ª", blacktriangle: "â–´", blacktriangledown: "â–¾", blacktriangleleft: "â—‚", blacktriangleright: "â–¸", blank: "â£", blk12: "â–’", blk14: "â–‘", blk34: "â–“", block: "â–ˆ", bne: "=âƒ¥", bnequiv: "â‰¡âƒ¥", bNot: "â«­", bnot: "âŒ", Bopf: "ð”¹", bopf: "ð•“", bot: "âŠ¥", bottom: "âŠ¥", bowtie: "â‹ˆ", boxbox: "â§‰", boxdl: "â”", boxdL: "â••", boxDl: "â•–", boxDL: "â•—", boxdr: "â”Œ", boxdR: "â•’", boxDr: "â•“", boxDR: "â•”", boxh: "â”€", boxH: "â•", boxhd: "â”¬", boxHd: "â•¤", boxhD: "â•¥", boxHD: "â•¦", boxhu: "â”´", boxHu: "â•§", boxhU: "â•¨", boxHU: "â•©", boxminus: "âŠŸ", boxplus: "âŠž", boxtimes: "âŠ ", boxul: "â”˜", boxuL: "â•›", boxUl: "â•œ", boxUL: "â•", boxur: "â””", boxuR: "â•˜", boxUr: "â•™", boxUR: "â•š", boxv: "â”‚", boxV: "â•‘", boxvh: "â”¼", boxvH: "â•ª", boxVh: "â•«", boxVH: "â•¬", boxvl: "â”¤", boxvL: "â•¡", boxVl: "â•¢", boxVL: "â•£", boxvr: "â”œ", boxvR: "â•ž", boxVr: "â•Ÿ", boxVR: "â• ", bprime: "â€µ", breve: "Ë˜", Breve: "Ë˜", brvbar: "Â¦", bscr: "ð’·", Bscr: "â„¬", bsemi: "â", bsim: "âˆ½", bsime: "â‹", bsolb: "â§…", bsol: "\\", bsolhsub: "âŸˆ", bull: "â€¢", bullet: "â€¢", bump: "â‰Ž", bumpE: "âª®", bumpe: "â‰", Bumpeq: "â‰Ž", bumpeq: "â‰", Cacute: "Ä†", cacute: "Ä‡", capand: "â©„", capbrcup: "â©‰", capcap: "â©‹", cap: "âˆ©", Cap: "â‹’", capcup: "â©‡", capdot: "â©€", CapitalDifferentialD: "â……", caps: "âˆ©ï¸€", caret: "â", caron: "Ë‡", Cayleys: "â„­", ccaps: "â©", Ccaron: "ÄŒ", ccaron: "Ä", Ccedil: "Ã‡", ccedil: "Ã§", Ccirc: "Äˆ", ccirc: "Ä‰", Cconint: "âˆ°", ccups: "â©Œ", ccupssm: "â©", Cdot: "ÄŠ", cdot: "Ä‹", cedil: "Â¸", Cedilla: "Â¸", cemptyv: "â¦²", cent: "Â¢", centerdot: "Â·", CenterDot: "Â·", cfr: "ð” ", Cfr: "â„­", CHcy: "Ð§", chcy: "Ñ‡", check: "âœ“", checkmark: "âœ“", Chi: "Î§", chi: "Ï‡", circ: "Ë†", circeq: "â‰—", circlearrowleft: "â†º", circlearrowright: "â†»", circledast: "âŠ›", circledcirc: "âŠš", circleddash: "âŠ", CircleDot: "âŠ™", circledR: "Â®", circledS: "â“ˆ", CircleMinus: "âŠ–", CirclePlus: "âŠ•", CircleTimes: "âŠ—", cir: "â—‹", cirE: "â§ƒ", cire: "â‰—", cirfnint: "â¨", cirmid: "â«¯", cirscir: "â§‚", ClockwiseContourIntegral: "âˆ²", CloseCurlyDoubleQuote: "â€", CloseCurlyQuote: "â€™", clubs: "â™£", clubsuit: "â™£", colon: ":", Colon: "âˆ·", Colone: "â©´", colone: "â‰”", coloneq: "â‰”", comma: ",", commat: "@", comp: "âˆ", compfn: "âˆ˜", complement: "âˆ", complexes: "â„‚", cong: "â‰…", congdot: "â©­", Congruent: "â‰¡", conint: "âˆ®", Conint: "âˆ¯", ContourIntegral: "âˆ®", copf: "ð•”", Copf: "â„‚", coprod: "âˆ", Coproduct: "âˆ", copy: "Â©", COPY: "Â©", copysr: "â„—", CounterClockwiseContourIntegral: "âˆ³", crarr: "â†µ", cross: "âœ—", Cross: "â¨¯", Cscr: "ð’ž", cscr: "ð’¸", csub: "â«", csube: "â«‘", csup: "â«", csupe: "â«’", ctdot: "â‹¯", cudarrl: "â¤¸", cudarrr: "â¤µ", cuepr: "â‹ž", cuesc: "â‹Ÿ", cularr: "â†¶", cularrp: "â¤½", cupbrcap: "â©ˆ", cupcap: "â©†", CupCap: "â‰", cup: "âˆª", Cup: "â‹“", cupcup: "â©Š", cupdot: "âŠ", cupor: "â©…", cups: "âˆªï¸€", curarr: "â†·", curarrm: "â¤¼", curlyeqprec: "â‹ž", curlyeqsucc: "â‹Ÿ", curlyvee: "â‹Ž", curlywedge: "â‹", curren: "Â¤", curvearrowleft: "â†¶", curvearrowright: "â†·", cuvee: "â‹Ž", cuwed: "â‹", cwconint: "âˆ²", cwint: "âˆ±", cylcty: "âŒ­", dagger: "â€ ", Dagger: "â€¡", daleth: "â„¸", darr: "â†“", Darr: "â†¡", dArr: "â‡“", dash: "â€", Dashv: "â«¤", dashv: "âŠ£", dbkarow: "â¤", dblac: "Ë", Dcaron: "ÄŽ", dcaron: "Ä", Dcy: "Ð”", dcy: "Ð´", ddagger: "â€¡", ddarr: "â‡Š", DD: "â……", dd: "â…†", DDotrahd: "â¤‘", ddotseq: "â©·", deg: "Â°", Del: "âˆ‡", Delta: "Î”", delta: "Î´", demptyv: "â¦±", dfisht: "â¥¿", Dfr: "ð”‡", dfr: "ð”¡", dHar: "â¥¥", dharl: "â‡ƒ", dharr: "â‡‚", DiacriticalAcute: "Â´", DiacriticalDot: "Ë™", DiacriticalDoubleAcute: "Ë", DiacriticalGrave: "`", DiacriticalTilde: "Ëœ", diam: "â‹„", diamond: "â‹„", Diamond: "â‹„", diamondsuit: "â™¦", diams: "â™¦", die: "Â¨", DifferentialD: "â…†", digamma: "Ï", disin: "â‹²", div: "Ã·", divide: "Ã·", divideontimes: "â‹‡", divonx: "â‹‡", DJcy: "Ð‚", djcy: "Ñ’", dlcorn: "âŒž", dlcrop: "âŒ", dollar: "$", Dopf: "ð”»", dopf: "ð••", Dot: "Â¨", dot: "Ë™", DotDot: "âƒœ", doteq: "â‰", doteqdot: "â‰‘", DotEqual: "â‰", dotminus: "âˆ¸", dotplus: "âˆ”", dotsquare: "âŠ¡", doublebarwedge: "âŒ†", DoubleContourIntegral: "âˆ¯", DoubleDot: "Â¨", DoubleDownArrow: "â‡“", DoubleLeftArrow: "â‡", DoubleLeftRightArrow: "â‡”", DoubleLeftTee: "â«¤", DoubleLongLeftArrow: "âŸ¸", DoubleLongLeftRightArrow: "âŸº", DoubleLongRightArrow: "âŸ¹", DoubleRightArrow: "â‡’", DoubleRightTee: "âŠ¨", DoubleUpArrow: "â‡‘", DoubleUpDownArrow: "â‡•", DoubleVerticalBar: "âˆ¥", DownArrowBar: "â¤“", downarrow: "â†“", DownArrow: "â†“", Downarrow: "â‡“", DownArrowUpArrow: "â‡µ", DownBreve: "Ì‘", downdownarrows: "â‡Š", downharpoonleft: "â‡ƒ", downharpoonright: "â‡‚", DownLeftRightVector: "â¥", DownLeftTeeVector: "â¥ž", DownLeftVectorBar: "â¥–", DownLeftVector: "â†½", DownRightTeeVector: "â¥Ÿ", DownRightVectorBar: "â¥—", DownRightVector: "â‡", DownTeeArrow: "â†§", DownTee: "âŠ¤", drbkarow: "â¤", drcorn: "âŒŸ", drcrop: "âŒŒ", Dscr: "ð’Ÿ", dscr: "ð’¹", DScy: "Ð…", dscy: "Ñ•", dsol: "â§¶", Dstrok: "Ä", dstrok: "Ä‘", dtdot: "â‹±", dtri: "â–¿", dtrif: "â–¾", duarr: "â‡µ", duhar: "â¥¯", dwangle: "â¦¦", DZcy: "Ð", dzcy: "ÑŸ", dzigrarr: "âŸ¿", Eacute: "Ã‰", eacute: "Ã©", easter: "â©®", Ecaron: "Äš", ecaron: "Ä›", Ecirc: "ÃŠ", ecirc: "Ãª", ecir: "â‰–", ecolon: "â‰•", Ecy: "Ð­", ecy: "Ñ", eDDot: "â©·", Edot: "Ä–", edot: "Ä—", eDot: "â‰‘", ee: "â…‡", efDot: "â‰’", Efr: "ð”ˆ", efr: "ð”¢", eg: "âªš", Egrave: "Ãˆ", egrave: "Ã¨", egs: "âª–", egsdot: "âª˜", el: "âª™", Element: "âˆˆ", elinters: "â§", ell: "â„“", els: "âª•", elsdot: "âª—", Emacr: "Ä’", emacr: "Ä“", empty: "âˆ…", emptyset: "âˆ…", EmptySmallSquare: "â—»", emptyv: "âˆ…", EmptyVerySmallSquare: "â–«", emsp13: "â€„", emsp14: "â€…", emsp: "â€ƒ", ENG: "ÅŠ", eng: "Å‹", ensp: "â€‚", Eogon: "Ä˜", eogon: "Ä™", Eopf: "ð”¼", eopf: "ð•–", epar: "â‹•", eparsl: "â§£", eplus: "â©±", epsi: "Îµ", Epsilon: "Î•", epsilon: "Îµ", epsiv: "Ïµ", eqcirc: "â‰–", eqcolon: "â‰•", eqsim: "â‰‚", eqslantgtr: "âª–", eqslantless: "âª•", Equal: "â©µ", equals: "=", EqualTilde: "â‰‚", equest: "â‰Ÿ", Equilibrium: "â‡Œ", equiv: "â‰¡", equivDD: "â©¸", eqvparsl: "â§¥", erarr: "â¥±", erDot: "â‰“", escr: "â„¯", Escr: "â„°", esdot: "â‰", Esim: "â©³", esim: "â‰‚", Eta: "Î—", eta: "Î·", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", euro: "â‚¬", excl: "!", exist: "âˆƒ", Exists: "âˆƒ", expectation: "â„°", exponentiale: "â…‡", ExponentialE: "â…‡", fallingdotseq: "â‰’", Fcy: "Ð¤", fcy: "Ñ„", female: "â™€", ffilig: "ï¬ƒ", fflig: "ï¬€", ffllig: "ï¬„", Ffr: "ð”‰", ffr: "ð”£", filig: "ï¬", FilledSmallSquare: "â—¼", FilledVerySmallSquare: "â–ª", fjlig: "fj", flat: "â™­", fllig: "ï¬‚", fltns: "â–±", fnof: "Æ’", Fopf: "ð”½", fopf: "ð•—", forall: "âˆ€", ForAll: "âˆ€", fork: "â‹”", forkv: "â«™", Fouriertrf: "â„±", fpartint: "â¨", frac12: "Â½", frac13: "â…“", frac14: "Â¼", frac15: "â…•", frac16: "â…™", frac18: "â…›", frac23: "â…”", frac25: "â…–", frac34: "Â¾", frac35: "â…—", frac38: "â…œ", frac45: "â…˜", frac56: "â…š", frac58: "â…", frac78: "â…ž", frasl: "â„", frown: "âŒ¢", fscr: "ð’»", Fscr: "â„±", gacute: "Çµ", Gamma: "Î“", gamma: "Î³", Gammad: "Ïœ", gammad: "Ï", gap: "âª†", Gbreve: "Äž", gbreve: "ÄŸ", Gcedil: "Ä¢", Gcirc: "Äœ", gcirc: "Ä", Gcy: "Ð“", gcy: "Ð³", Gdot: "Ä ", gdot: "Ä¡", ge: "â‰¥", gE: "â‰§", gEl: "âªŒ", gel: "â‹›", geq: "â‰¥", geqq: "â‰§", geqslant: "â©¾", gescc: "âª©", ges: "â©¾", gesdot: "âª€", gesdoto: "âª‚", gesdotol: "âª„", gesl: "â‹›ï¸€", gesles: "âª”", Gfr: "ð”Š", gfr: "ð”¤", gg: "â‰«", Gg: "â‹™", ggg: "â‹™", gimel: "â„·", GJcy: "Ðƒ", gjcy: "Ñ“", gla: "âª¥", gl: "â‰·", glE: "âª’", glj: "âª¤", gnap: "âªŠ", gnapprox: "âªŠ", gne: "âªˆ", gnE: "â‰©", gneq: "âªˆ", gneqq: "â‰©", gnsim: "â‹§", Gopf: "ð”¾", gopf: "ð•˜", grave: "`", GreaterEqual: "â‰¥", GreaterEqualLess: "â‹›", GreaterFullEqual: "â‰§", GreaterGreater: "âª¢", GreaterLess: "â‰·", GreaterSlantEqual: "â©¾", GreaterTilde: "â‰³", Gscr: "ð’¢", gscr: "â„Š", gsim: "â‰³", gsime: "âªŽ", gsiml: "âª", gtcc: "âª§", gtcir: "â©º", gt: ">", GT: ">", Gt: "â‰«", gtdot: "â‹—", gtlPar: "â¦•", gtquest: "â©¼", gtrapprox: "âª†", gtrarr: "â¥¸", gtrdot: "â‹—", gtreqless: "â‹›", gtreqqless: "âªŒ", gtrless: "â‰·", gtrsim: "â‰³", gvertneqq: "â‰©ï¸€", gvnE: "â‰©ï¸€", Hacek: "Ë‡", hairsp: "â€Š", half: "Â½", hamilt: "â„‹", HARDcy: "Ðª", hardcy: "ÑŠ", harrcir: "â¥ˆ", harr: "â†”", hArr: "â‡”", harrw: "â†­", Hat: "^", hbar: "â„", Hcirc: "Ä¤", hcirc: "Ä¥", hearts: "â™¥", heartsuit: "â™¥", hellip: "â€¦", hercon: "âŠ¹", hfr: "ð”¥", Hfr: "â„Œ", HilbertSpace: "â„‹", hksearow: "â¤¥", hkswarow: "â¤¦", hoarr: "â‡¿", homtht: "âˆ»", hookleftarrow: "â†©", hookrightarrow: "â†ª", hopf: "ð•™", Hopf: "â„", horbar: "â€•", HorizontalLine: "â”€", hscr: "ð’½", Hscr: "â„‹", hslash: "â„", Hstrok: "Ä¦", hstrok: "Ä§", HumpDownHump: "â‰Ž", HumpEqual: "â‰", hybull: "âƒ", hyphen: "â€", Iacute: "Ã", iacute: "Ã­", ic: "â£", Icirc: "ÃŽ", icirc: "Ã®", Icy: "Ð˜", icy: "Ð¸", Idot: "Ä°", IEcy: "Ð•", iecy: "Ðµ", iexcl: "Â¡", iff: "â‡”", ifr: "ð”¦", Ifr: "â„‘", Igrave: "ÃŒ", igrave: "Ã¬", ii: "â…ˆ", iiiint: "â¨Œ", iiint: "âˆ­", iinfin: "â§œ", iiota: "â„©", IJlig: "Ä²", ijlig: "Ä³", Imacr: "Äª", imacr: "Ä«", image: "â„‘", ImaginaryI: "â…ˆ", imagline: "â„", imagpart: "â„‘", imath: "Ä±", Im: "â„‘", imof: "âŠ·", imped: "Æµ", Implies: "â‡’", incare: "â„…", in: "âˆˆ", infin: "âˆž", infintie: "â§", inodot: "Ä±", intcal: "âŠº", int: "âˆ«", Int: "âˆ¬", integers: "â„¤", Integral: "âˆ«", intercal: "âŠº", Intersection: "â‹‚", intlarhk: "â¨—", intprod: "â¨¼", InvisibleComma: "â£", InvisibleTimes: "â¢", IOcy: "Ð", iocy: "Ñ‘", Iogon: "Ä®", iogon: "Ä¯", Iopf: "ð•€", iopf: "ð•š", Iota: "Î™", iota: "Î¹", iprod: "â¨¼", iquest: "Â¿", iscr: "ð’¾", Iscr: "â„", isin: "âˆˆ", isindot: "â‹µ", isinE: "â‹¹", isins: "â‹´", isinsv: "â‹³", isinv: "âˆˆ", it: "â¢", Itilde: "Ä¨", itilde: "Ä©", Iukcy: "Ð†", iukcy: "Ñ–", Iuml: "Ã", iuml: "Ã¯", Jcirc: "Ä´", jcirc: "Äµ", Jcy: "Ð™", jcy: "Ð¹", Jfr: "ð”", jfr: "ð”§", jmath: "È·", Jopf: "ð•", jopf: "ð•›", Jscr: "ð’¥", jscr: "ð’¿", Jsercy: "Ðˆ", jsercy: "Ñ˜", Jukcy: "Ð„", jukcy: "Ñ”", Kappa: "Îš", kappa: "Îº", kappav: "Ï°", Kcedil: "Ä¶", kcedil: "Ä·", Kcy: "Ðš", kcy: "Ðº", Kfr: "ð”Ž", kfr: "ð”¨", kgreen: "Ä¸", KHcy: "Ð¥", khcy: "Ñ…", KJcy: "ÐŒ", kjcy: "Ñœ", Kopf: "ð•‚", kopf: "ð•œ", Kscr: "ð’¦", kscr: "ð“€", lAarr: "â‡š", Lacute: "Ä¹", lacute: "Äº", laemptyv: "â¦´", lagran: "â„’", Lambda: "Î›", lambda: "Î»", lang: "âŸ¨", Lang: "âŸª", langd: "â¦‘", langle: "âŸ¨", lap: "âª…", Laplacetrf: "â„’", laquo: "Â«", larrb: "â‡¤", larrbfs: "â¤Ÿ", larr: "â†", Larr: "â†ž", lArr: "â‡", larrfs: "â¤", larrhk: "â†©", larrlp: "â†«", larrpl: "â¤¹", larrsim: "â¥³", larrtl: "â†¢", latail: "â¤™", lAtail: "â¤›", lat: "âª«", late: "âª­", lates: "âª­ï¸€", lbarr: "â¤Œ", lBarr: "â¤Ž", lbbrk: "â²", lbrace: "{", lbrack: "[", lbrke: "â¦‹", lbrksld: "â¦", lbrkslu: "â¦", Lcaron: "Ä½", lcaron: "Ä¾", Lcedil: "Ä»", lcedil: "Ä¼", lceil: "âŒˆ", lcub: "{", Lcy: "Ð›", lcy: "Ð»", ldca: "â¤¶", ldquo: "â€œ", ldquor: "â€ž", ldrdhar: "â¥§", ldrushar: "â¥‹", ldsh: "â†²", le: "â‰¤", lE: "â‰¦", LeftAngleBracket: "âŸ¨", LeftArrowBar: "â‡¤", leftarrow: "â†", LeftArrow: "â†", Leftarrow: "â‡", LeftArrowRightArrow: "â‡†", leftarrowtail: "â†¢", LeftCeiling: "âŒˆ", LeftDoubleBracket: "âŸ¦", LeftDownTeeVector: "â¥¡", LeftDownVectorBar: "â¥™", LeftDownVector: "â‡ƒ", LeftFloor: "âŒŠ", leftharpoondown: "â†½", leftharpoonup: "â†¼", leftleftarrows: "â‡‡", leftrightarrow: "â†”", LeftRightArrow: "â†”", Leftrightarrow: "â‡”", leftrightarrows: "â‡†", leftrightharpoons: "â‡‹", leftrightsquigarrow: "â†­", LeftRightVector: "â¥Ž", LeftTeeArrow: "â†¤", LeftTee: "âŠ£", LeftTeeVector: "â¥š", leftthreetimes: "â‹‹", LeftTriangleBar: "â§", LeftTriangle: "âŠ²", LeftTriangleEqual: "âŠ´", LeftUpDownVector: "â¥‘", LeftUpTeeVector: "â¥ ", LeftUpVectorBar: "â¥˜", LeftUpVector: "â†¿", LeftVectorBar: "â¥’", LeftVector: "â†¼", lEg: "âª‹", leg: "â‹š", leq: "â‰¤", leqq: "â‰¦", leqslant: "â©½", lescc: "âª¨", les: "â©½", lesdot: "â©¿", lesdoto: "âª", lesdotor: "âªƒ", lesg: "â‹šï¸€", lesges: "âª“", lessapprox: "âª…", lessdot: "â‹–", lesseqgtr: "â‹š", lesseqqgtr: "âª‹", LessEqualGreater: "â‹š", LessFullEqual: "â‰¦", LessGreater: "â‰¶", lessgtr: "â‰¶", LessLess: "âª¡", lesssim: "â‰²", LessSlantEqual: "â©½", LessTilde: "â‰²", lfisht: "â¥¼", lfloor: "âŒŠ", Lfr: "ð”", lfr: "ð”©", lg: "â‰¶", lgE: "âª‘", lHar: "â¥¢", lhard: "â†½", lharu: "â†¼", lharul: "â¥ª", lhblk: "â–„", LJcy: "Ð‰", ljcy: "Ñ™", llarr: "â‡‡", ll: "â‰ª", Ll: "â‹˜", llcorner: "âŒž", Lleftarrow: "â‡š", llhard: "â¥«", lltri: "â—º", Lmidot: "Ä¿", lmidot: "Å€", lmoustache: "âŽ°", lmoust: "âŽ°", lnap: "âª‰", lnapprox: "âª‰", lne: "âª‡", lnE: "â‰¨", lneq: "âª‡", lneqq: "â‰¨", lnsim: "â‹¦", loang: "âŸ¬", loarr: "â‡½", lobrk: "âŸ¦", longleftarrow: "âŸµ", LongLeftArrow: "âŸµ", Longleftarrow: "âŸ¸", longleftrightarrow: "âŸ·", LongLeftRightArrow: "âŸ·", Longleftrightarrow: "âŸº", longmapsto: "âŸ¼", longrightarrow: "âŸ¶", LongRightArrow: "âŸ¶", Longrightarrow: "âŸ¹", looparrowleft: "â†«", looparrowright: "â†¬", lopar: "â¦…", Lopf: "ð•ƒ", lopf: "ð•", loplus: "â¨­", lotimes: "â¨´", lowast: "âˆ—", lowbar: "_", LowerLeftArrow: "â†™", LowerRightArrow: "â†˜", loz: "â—Š", lozenge: "â—Š", lozf: "â§«", lpar: "(", lparlt: "â¦“", lrarr: "â‡†", lrcorner: "âŒŸ", lrhar: "â‡‹", lrhard: "â¥­", lrm: "â€Ž", lrtri: "âŠ¿", lsaquo: "â€¹", lscr: "ð“", Lscr: "â„’", lsh: "â†°", Lsh: "â†°", lsim: "â‰²", lsime: "âª", lsimg: "âª", lsqb: "[", lsquo: "â€˜", lsquor: "â€š", Lstrok: "Å", lstrok: "Å‚", ltcc: "âª¦", ltcir: "â©¹", lt: "<", LT: "<", Lt: "â‰ª", ltdot: "â‹–", lthree: "â‹‹", ltimes: "â‹‰", ltlarr: "â¥¶", ltquest: "â©»", ltri: "â—ƒ", ltrie: "âŠ´", ltrif: "â—‚", ltrPar: "â¦–", lurdshar: "â¥Š", luruhar: "â¥¦", lvertneqq: "â‰¨ï¸€", lvnE: "â‰¨ï¸€", macr: "Â¯", male: "â™‚", malt: "âœ ", maltese: "âœ ", Map: "â¤…", map: "â†¦", mapsto: "â†¦", mapstodown: "â†§", mapstoleft: "â†¤", mapstoup: "â†¥", marker: "â–®", mcomma: "â¨©", Mcy: "Ðœ", mcy: "Ð¼", mdash: "â€”", mDDot: "âˆº", measuredangle: "âˆ¡", MediumSpace: "âŸ", Mellintrf: "â„³", Mfr: "ð”", mfr: "ð”ª", mho: "â„§", micro: "Âµ", midast: "*", midcir: "â«°", mid: "âˆ£", middot: "Â·", minusb: "âŠŸ", minus: "âˆ’", minusd: "âˆ¸", minusdu: "â¨ª", MinusPlus: "âˆ“", mlcp: "â«›", mldr: "â€¦", mnplus: "âˆ“", models: "âŠ§", Mopf: "ð•„", mopf: "ð•ž", mp: "âˆ“", mscr: "ð“‚", Mscr: "â„³", mstpos: "âˆ¾", Mu: "Îœ", mu: "Î¼", multimap: "âŠ¸", mumap: "âŠ¸", nabla: "âˆ‡", Nacute: "Åƒ", nacute: "Å„", nang: "âˆ âƒ’", nap: "â‰‰", napE: "â©°Ì¸", napid: "â‰‹Ì¸", napos: "Å‰", napprox: "â‰‰", natural: "â™®", naturals: "â„•", natur: "â™®", nbsp: "Â ", nbump: "â‰ŽÌ¸", nbumpe: "â‰Ì¸", ncap: "â©ƒ", Ncaron: "Å‡", ncaron: "Åˆ", Ncedil: "Å…", ncedil: "Å†", ncong: "â‰‡", ncongdot: "â©­Ì¸", ncup: "â©‚", Ncy: "Ð", ncy: "Ð½", ndash: "â€“", nearhk: "â¤¤", nearr: "â†—", neArr: "â‡—", nearrow: "â†—", ne: "â‰ ", nedot: "â‰Ì¸", NegativeMediumSpace: "â€‹", NegativeThickSpace: "â€‹", NegativeThinSpace: "â€‹", NegativeVeryThinSpace: "â€‹", nequiv: "â‰¢", nesear: "â¤¨", nesim: "â‰‚Ì¸", NestedGreaterGreater: "â‰«", NestedLessLess: "â‰ª", NewLine: `
`, nexist: "âˆ„", nexists: "âˆ„", Nfr: "ð”‘", nfr: "ð”«", ngE: "â‰§Ì¸", nge: "â‰±", ngeq: "â‰±", ngeqq: "â‰§Ì¸", ngeqslant: "â©¾Ì¸", nges: "â©¾Ì¸", nGg: "â‹™Ì¸", ngsim: "â‰µ", nGt: "â‰«âƒ’", ngt: "â‰¯", ngtr: "â‰¯", nGtv: "â‰«Ì¸", nharr: "â†®", nhArr: "â‡Ž", nhpar: "â«²", ni: "âˆ‹", nis: "â‹¼", nisd: "â‹º", niv: "âˆ‹", NJcy: "ÐŠ", njcy: "Ñš", nlarr: "â†š", nlArr: "â‡", nldr: "â€¥", nlE: "â‰¦Ì¸", nle: "â‰°", nleftarrow: "â†š", nLeftarrow: "â‡", nleftrightarrow: "â†®", nLeftrightarrow: "â‡Ž", nleq: "â‰°", nleqq: "â‰¦Ì¸", nleqslant: "â©½Ì¸", nles: "â©½Ì¸", nless: "â‰®", nLl: "â‹˜Ì¸", nlsim: "â‰´", nLt: "â‰ªâƒ’", nlt: "â‰®", nltri: "â‹ª", nltrie: "â‹¬", nLtv: "â‰ªÌ¸", nmid: "âˆ¤", NoBreak: "â ", NonBreakingSpace: "Â ", nopf: "ð•Ÿ", Nopf: "â„•", Not: "â«¬", not: "Â¬", NotCongruent: "â‰¢", NotCupCap: "â‰­", NotDoubleVerticalBar: "âˆ¦", NotElement: "âˆ‰", NotEqual: "â‰ ", NotEqualTilde: "â‰‚Ì¸", NotExists: "âˆ„", NotGreater: "â‰¯", NotGreaterEqual: "â‰±", NotGreaterFullEqual: "â‰§Ì¸", NotGreaterGreater: "â‰«Ì¸", NotGreaterLess: "â‰¹", NotGreaterSlantEqual: "â©¾Ì¸", NotGreaterTilde: "â‰µ", NotHumpDownHump: "â‰ŽÌ¸", NotHumpEqual: "â‰Ì¸", notin: "âˆ‰", notindot: "â‹µÌ¸", notinE: "â‹¹Ì¸", notinva: "âˆ‰", notinvb: "â‹·", notinvc: "â‹¶", NotLeftTriangleBar: "â§Ì¸", NotLeftTriangle: "â‹ª", NotLeftTriangleEqual: "â‹¬", NotLess: "â‰®", NotLessEqual: "â‰°", NotLessGreater: "â‰¸", NotLessLess: "â‰ªÌ¸", NotLessSlantEqual: "â©½Ì¸", NotLessTilde: "â‰´", NotNestedGreaterGreater: "âª¢Ì¸", NotNestedLessLess: "âª¡Ì¸", notni: "âˆŒ", notniva: "âˆŒ", notnivb: "â‹¾", notnivc: "â‹½", NotPrecedes: "âŠ€", NotPrecedesEqual: "âª¯Ì¸", NotPrecedesSlantEqual: "â‹ ", NotReverseElement: "âˆŒ", NotRightTriangleBar: "â§Ì¸", NotRightTriangle: "â‹«", NotRightTriangleEqual: "â‹­", NotSquareSubset: "âŠÌ¸", NotSquareSubsetEqual: "â‹¢", NotSquareSuperset: "âŠÌ¸", NotSquareSupersetEqual: "â‹£", NotSubset: "âŠ‚âƒ’", NotSubsetEqual: "âŠˆ", NotSucceeds: "âŠ", NotSucceedsEqual: "âª°Ì¸", NotSucceedsSlantEqual: "â‹¡", NotSucceedsTilde: "â‰¿Ì¸", NotSuperset: "âŠƒâƒ’", NotSupersetEqual: "âŠ‰", NotTilde: "â‰", NotTildeEqual: "â‰„", NotTildeFullEqual: "â‰‡", NotTildeTilde: "â‰‰", NotVerticalBar: "âˆ¤", nparallel: "âˆ¦", npar: "âˆ¦", nparsl: "â«½âƒ¥", npart: "âˆ‚Ì¸", npolint: "â¨”", npr: "âŠ€", nprcue: "â‹ ", nprec: "âŠ€", npreceq: "âª¯Ì¸", npre: "âª¯Ì¸", nrarrc: "â¤³Ì¸", nrarr: "â†›", nrArr: "â‡", nrarrw: "â†Ì¸", nrightarrow: "â†›", nRightarrow: "â‡", nrtri: "â‹«", nrtrie: "â‹­", nsc: "âŠ", nsccue: "â‹¡", nsce: "âª°Ì¸", Nscr: "ð’©", nscr: "ð“ƒ", nshortmid: "âˆ¤", nshortparallel: "âˆ¦", nsim: "â‰", nsime: "â‰„", nsimeq: "â‰„", nsmid: "âˆ¤", nspar: "âˆ¦", nsqsube: "â‹¢", nsqsupe: "â‹£", nsub: "âŠ„", nsubE: "â«…Ì¸", nsube: "âŠˆ", nsubset: "âŠ‚âƒ’", nsubseteq: "âŠˆ", nsubseteqq: "â«…Ì¸", nsucc: "âŠ", nsucceq: "âª°Ì¸", nsup: "âŠ…", nsupE: "â«†Ì¸", nsupe: "âŠ‰", nsupset: "âŠƒâƒ’", nsupseteq: "âŠ‰", nsupseteqq: "â«†Ì¸", ntgl: "â‰¹", Ntilde: "Ã‘", ntilde: "Ã±", ntlg: "â‰¸", ntriangleleft: "â‹ª", ntrianglelefteq: "â‹¬", ntriangleright: "â‹«", ntrianglerighteq: "â‹­", Nu: "Î", nu: "Î½", num: "#", numero: "â„–", numsp: "â€‡", nvap: "â‰âƒ’", nvdash: "âŠ¬", nvDash: "âŠ­", nVdash: "âŠ®", nVDash: "âŠ¯", nvge: "â‰¥âƒ’", nvgt: ">âƒ’", nvHarr: "â¤„", nvinfin: "â§ž", nvlArr: "â¤‚", nvle: "â‰¤âƒ’", nvlt: "<âƒ’", nvltrie: "âŠ´âƒ’", nvrArr: "â¤ƒ", nvrtrie: "âŠµâƒ’", nvsim: "âˆ¼âƒ’", nwarhk: "â¤£", nwarr: "â†–", nwArr: "â‡–", nwarrow: "â†–", nwnear: "â¤§", Oacute: "Ã“", oacute: "Ã³", oast: "âŠ›", Ocirc: "Ã”", ocirc: "Ã´", ocir: "âŠš", Ocy: "Ðž", ocy: "Ð¾", odash: "âŠ", Odblac: "Å", odblac: "Å‘", odiv: "â¨¸", odot: "âŠ™", odsold: "â¦¼", OElig: "Å’", oelig: "Å“", ofcir: "â¦¿", Ofr: "ð”’", ofr: "ð”¬", ogon: "Ë›", Ograve: "Ã’", ograve: "Ã²", ogt: "â§", ohbar: "â¦µ", ohm: "Î©", oint: "âˆ®", olarr: "â†º", olcir: "â¦¾", olcross: "â¦»", oline: "â€¾", olt: "â§€", Omacr: "ÅŒ", omacr: "Å", Omega: "Î©", omega: "Ï‰", Omicron: "ÎŸ", omicron: "Î¿", omid: "â¦¶", ominus: "âŠ–", Oopf: "ð•†", oopf: "ð• ", opar: "â¦·", OpenCurlyDoubleQuote: "â€œ", OpenCurlyQuote: "â€˜", operp: "â¦¹", oplus: "âŠ•", orarr: "â†»", Or: "â©”", or: "âˆ¨", ord: "â©", order: "â„´", orderof: "â„´", ordf: "Âª", ordm: "Âº", origof: "âŠ¶", oror: "â©–", orslope: "â©—", orv: "â©›", oS: "â“ˆ", Oscr: "ð’ª", oscr: "â„´", Oslash: "Ã˜", oslash: "Ã¸", osol: "âŠ˜", Otilde: "Ã•", otilde: "Ãµ", otimesas: "â¨¶", Otimes: "â¨·", otimes: "âŠ—", Ouml: "Ã–", ouml: "Ã¶", ovbar: "âŒ½", OverBar: "â€¾", OverBrace: "âž", OverBracket: "âŽ´", OverParenthesis: "âœ", para: "Â¶", parallel: "âˆ¥", par: "âˆ¥", parsim: "â«³", parsl: "â«½", part: "âˆ‚", PartialD: "âˆ‚", Pcy: "ÐŸ", pcy: "Ð¿", percnt: "%", period: ".", permil: "â€°", perp: "âŠ¥", pertenk: "â€±", Pfr: "ð”“", pfr: "ð”­", Phi: "Î¦", phi: "Ï†", phiv: "Ï•", phmmat: "â„³", phone: "â˜Ž", Pi: "Î ", pi: "Ï€", pitchfork: "â‹”", piv: "Ï–", planck: "â„", planckh: "â„Ž", plankv: "â„", plusacir: "â¨£", plusb: "âŠž", pluscir: "â¨¢", plus: "+", plusdo: "âˆ”", plusdu: "â¨¥", pluse: "â©²", PlusMinus: "Â±", plusmn: "Â±", plussim: "â¨¦", plustwo: "â¨§", pm: "Â±", Poincareplane: "â„Œ", pointint: "â¨•", popf: "ð•¡", Popf: "â„™", pound: "Â£", prap: "âª·", Pr: "âª»", pr: "â‰º", prcue: "â‰¼", precapprox: "âª·", prec: "â‰º", preccurlyeq: "â‰¼", Precedes: "â‰º", PrecedesEqual: "âª¯", PrecedesSlantEqual: "â‰¼", PrecedesTilde: "â‰¾", preceq: "âª¯", precnapprox: "âª¹", precneqq: "âªµ", precnsim: "â‹¨", pre: "âª¯", prE: "âª³", precsim: "â‰¾", prime: "â€²", Prime: "â€³", primes: "â„™", prnap: "âª¹", prnE: "âªµ", prnsim: "â‹¨", prod: "âˆ", Product: "âˆ", profalar: "âŒ®", profline: "âŒ’", profsurf: "âŒ“", prop: "âˆ", Proportional: "âˆ", Proportion: "âˆ·", propto: "âˆ", prsim: "â‰¾", prurel: "âŠ°", Pscr: "ð’«", pscr: "ð“…", Psi: "Î¨", psi: "Ïˆ", puncsp: "â€ˆ", Qfr: "ð””", qfr: "ð”®", qint: "â¨Œ", qopf: "ð•¢", Qopf: "â„š", qprime: "â—", Qscr: "ð’¬", qscr: "ð“†", quaternions: "â„", quatint: "â¨–", quest: "?", questeq: "â‰Ÿ", quot: '"', QUOT: '"', rAarr: "â‡›", race: "âˆ½Ì±", Racute: "Å”", racute: "Å•", radic: "âˆš", raemptyv: "â¦³", rang: "âŸ©", Rang: "âŸ«", rangd: "â¦’", range: "â¦¥", rangle: "âŸ©", raquo: "Â»", rarrap: "â¥µ", rarrb: "â‡¥", rarrbfs: "â¤ ", rarrc: "â¤³", rarr: "â†’", Rarr: "â† ", rArr: "â‡’", rarrfs: "â¤ž", rarrhk: "â†ª", rarrlp: "â†¬", rarrpl: "â¥…", rarrsim: "â¥´", Rarrtl: "â¤–", rarrtl: "â†£", rarrw: "â†", ratail: "â¤š", rAtail: "â¤œ", ratio: "âˆ¶", rationals: "â„š", rbarr: "â¤", rBarr: "â¤", RBarr: "â¤", rbbrk: "â³", rbrace: "}", rbrack: "]", rbrke: "â¦Œ", rbrksld: "â¦Ž", rbrkslu: "â¦", Rcaron: "Å˜", rcaron: "Å™", Rcedil: "Å–", rcedil: "Å—", rceil: "âŒ‰", rcub: "}", Rcy: "Ð ", rcy: "Ñ€", rdca: "â¤·", rdldhar: "â¥©", rdquo: "â€", rdquor: "â€", rdsh: "â†³", real: "â„œ", realine: "â„›", realpart: "â„œ", reals: "â„", Re: "â„œ", rect: "â–­", reg: "Â®", REG: "Â®", ReverseElement: "âˆ‹", ReverseEquilibrium: "â‡‹", ReverseUpEquilibrium: "â¥¯", rfisht: "â¥½", rfloor: "âŒ‹", rfr: "ð”¯", Rfr: "â„œ", rHar: "â¥¤", rhard: "â‡", rharu: "â‡€", rharul: "â¥¬", Rho: "Î¡", rho: "Ï", rhov: "Ï±", RightAngleBracket: "âŸ©", RightArrowBar: "â‡¥", rightarrow: "â†’", RightArrow: "â†’", Rightarrow: "â‡’", RightArrowLeftArrow: "â‡„", rightarrowtail: "â†£", RightCeiling: "âŒ‰", RightDoubleBracket: "âŸ§", RightDownTeeVector: "â¥", RightDownVectorBar: "â¥•", RightDownVector: "â‡‚", RightFloor: "âŒ‹", rightharpoondown: "â‡", rightharpoonup: "â‡€", rightleftarrows: "â‡„", rightleftharpoons: "â‡Œ", rightrightarrows: "â‡‰", rightsquigarrow: "â†", RightTeeArrow: "â†¦", RightTee: "âŠ¢", RightTeeVector: "â¥›", rightthreetimes: "â‹Œ", RightTriangleBar: "â§", RightTriangle: "âŠ³", RightTriangleEqual: "âŠµ", RightUpDownVector: "â¥", RightUpTeeVector: "â¥œ", RightUpVectorBar: "â¥”", RightUpVector: "â†¾", RightVectorBar: "â¥“", RightVector: "â‡€", ring: "Ëš", risingdotseq: "â‰“", rlarr: "â‡„", rlhar: "â‡Œ", rlm: "â€", rmoustache: "âŽ±", rmoust: "âŽ±", rnmid: "â«®", roang: "âŸ­", roarr: "â‡¾", robrk: "âŸ§", ropar: "â¦†", ropf: "ð•£", Ropf: "â„", roplus: "â¨®", rotimes: "â¨µ", RoundImplies: "â¥°", rpar: ")", rpargt: "â¦”", rppolint: "â¨’", rrarr: "â‡‰", Rrightarrow: "â‡›", rsaquo: "â€º", rscr: "ð“‡", Rscr: "â„›", rsh: "â†±", Rsh: "â†±", rsqb: "]", rsquo: "â€™", rsquor: "â€™", rthree: "â‹Œ", rtimes: "â‹Š", rtri: "â–¹", rtrie: "âŠµ", rtrif: "â–¸", rtriltri: "â§Ž", RuleDelayed: "â§´", ruluhar: "â¥¨", rx: "â„ž", Sacute: "Åš", sacute: "Å›", sbquo: "â€š", scap: "âª¸", Scaron: "Å ", scaron: "Å¡", Sc: "âª¼", sc: "â‰»", sccue: "â‰½", sce: "âª°", scE: "âª´", Scedil: "Åž", scedil: "ÅŸ", Scirc: "Åœ", scirc: "Å", scnap: "âªº", scnE: "âª¶", scnsim: "â‹©", scpolint: "â¨“", scsim: "â‰¿", Scy: "Ð¡", scy: "Ñ", sdotb: "âŠ¡", sdot: "â‹…", sdote: "â©¦", searhk: "â¤¥", searr: "â†˜", seArr: "â‡˜", searrow: "â†˜", sect: "Â§", semi: ";", seswar: "â¤©", setminus: "âˆ–", setmn: "âˆ–", sext: "âœ¶", Sfr: "ð”–", sfr: "ð”°", sfrown: "âŒ¢", sharp: "â™¯", SHCHcy: "Ð©", shchcy: "Ñ‰", SHcy: "Ð¨", shcy: "Ñˆ", ShortDownArrow: "â†“", ShortLeftArrow: "â†", shortmid: "âˆ£", shortparallel: "âˆ¥", ShortRightArrow: "â†’", ShortUpArrow: "â†‘", shy: "Â­", Sigma: "Î£", sigma: "Ïƒ", sigmaf: "Ï‚", sigmav: "Ï‚", sim: "âˆ¼", simdot: "â©ª", sime: "â‰ƒ", simeq: "â‰ƒ", simg: "âªž", simgE: "âª ", siml: "âª", simlE: "âªŸ", simne: "â‰†", simplus: "â¨¤", simrarr: "â¥²", slarr: "â†", SmallCircle: "âˆ˜", smallsetminus: "âˆ–", smashp: "â¨³", smeparsl: "â§¤", smid: "âˆ£", smile: "âŒ£", smt: "âªª", smte: "âª¬", smtes: "âª¬ï¸€", SOFTcy: "Ð¬", softcy: "ÑŒ", solbar: "âŒ¿", solb: "â§„", sol: "/", Sopf: "ð•Š", sopf: "ð•¤", spades: "â™ ", spadesuit: "â™ ", spar: "âˆ¥", sqcap: "âŠ“", sqcaps: "âŠ“ï¸€", sqcup: "âŠ”", sqcups: "âŠ”ï¸€", Sqrt: "âˆš", sqsub: "âŠ", sqsube: "âŠ‘", sqsubset: "âŠ", sqsubseteq: "âŠ‘", sqsup: "âŠ", sqsupe: "âŠ’", sqsupset: "âŠ", sqsupseteq: "âŠ’", square: "â–¡", Square: "â–¡", SquareIntersection: "âŠ“", SquareSubset: "âŠ", SquareSubsetEqual: "âŠ‘", SquareSuperset: "âŠ", SquareSupersetEqual: "âŠ’", SquareUnion: "âŠ”", squarf: "â–ª", squ: "â–¡", squf: "â–ª", srarr: "â†’", Sscr: "ð’®", sscr: "ð“ˆ", ssetmn: "âˆ–", ssmile: "âŒ£", sstarf: "â‹†", Star: "â‹†", star: "â˜†", starf: "â˜…", straightepsilon: "Ïµ", straightphi: "Ï•", strns: "Â¯", sub: "âŠ‚", Sub: "â‹", subdot: "âª½", subE: "â«…", sube: "âŠ†", subedot: "â«ƒ", submult: "â«", subnE: "â«‹", subne: "âŠŠ", subplus: "âª¿", subrarr: "â¥¹", subset: "âŠ‚", Subset: "â‹", subseteq: "âŠ†", subseteqq: "â«…", SubsetEqual: "âŠ†", subsetneq: "âŠŠ", subsetneqq: "â«‹", subsim: "â«‡", subsub: "â«•", subsup: "â«“", succapprox: "âª¸", succ: "â‰»", succcurlyeq: "â‰½", Succeeds: "â‰»", SucceedsEqual: "âª°", SucceedsSlantEqual: "â‰½", SucceedsTilde: "â‰¿", succeq: "âª°", succnapprox: "âªº", succneqq: "âª¶", succnsim: "â‹©", succsim: "â‰¿", SuchThat: "âˆ‹", sum: "âˆ‘", Sum: "âˆ‘", sung: "â™ª", sup1: "Â¹", sup2: "Â²", sup3: "Â³", sup: "âŠƒ", Sup: "â‹‘", supdot: "âª¾", supdsub: "â«˜", supE: "â«†", supe: "âŠ‡", supedot: "â«„", Superset: "âŠƒ", SupersetEqual: "âŠ‡", suphsol: "âŸ‰", suphsub: "â«—", suplarr: "â¥»", supmult: "â«‚", supnE: "â«Œ", supne: "âŠ‹", supplus: "â«€", supset: "âŠƒ", Supset: "â‹‘", supseteq: "âŠ‡", supseteqq: "â«†", supsetneq: "âŠ‹", supsetneqq: "â«Œ", supsim: "â«ˆ", supsub: "â«”", supsup: "â«–", swarhk: "â¤¦", swarr: "â†™", swArr: "â‡™", swarrow: "â†™", swnwar: "â¤ª", szlig: "ÃŸ", Tab: "	", target: "âŒ–", Tau: "Î¤", tau: "Ï„", tbrk: "âŽ´", Tcaron: "Å¤", tcaron: "Å¥", Tcedil: "Å¢", tcedil: "Å£", Tcy: "Ð¢", tcy: "Ñ‚", tdot: "âƒ›", telrec: "âŒ•", Tfr: "ð”—", tfr: "ð”±", there4: "âˆ´", therefore: "âˆ´", Therefore: "âˆ´", Theta: "Î˜", theta: "Î¸", thetasym: "Ï‘", thetav: "Ï‘", thickapprox: "â‰ˆ", thicksim: "âˆ¼", ThickSpace: "âŸâ€Š", ThinSpace: "â€‰", thinsp: "â€‰", thkap: "â‰ˆ", thksim: "âˆ¼", THORN: "Ãž", thorn: "Ã¾", tilde: "Ëœ", Tilde: "âˆ¼", TildeEqual: "â‰ƒ", TildeFullEqual: "â‰…", TildeTilde: "â‰ˆ", timesbar: "â¨±", timesb: "âŠ ", times: "Ã—", timesd: "â¨°", tint: "âˆ­", toea: "â¤¨", topbot: "âŒ¶", topcir: "â«±", top: "âŠ¤", Topf: "ð•‹", topf: "ð•¥", topfork: "â«š", tosa: "â¤©", tprime: "â€´", trade: "â„¢", TRADE: "â„¢", triangle: "â–µ", triangledown: "â–¿", triangleleft: "â—ƒ", trianglelefteq: "âŠ´", triangleq: "â‰œ", triangleright: "â–¹", trianglerighteq: "âŠµ", tridot: "â—¬", trie: "â‰œ", triminus: "â¨º", TripleDot: "âƒ›", triplus: "â¨¹", trisb: "â§", tritime: "â¨»", trpezium: "â¢", Tscr: "ð’¯", tscr: "ð“‰", TScy: "Ð¦", tscy: "Ñ†", TSHcy: "Ð‹", tshcy: "Ñ›", Tstrok: "Å¦", tstrok: "Å§", twixt: "â‰¬", twoheadleftarrow: "â†ž", twoheadrightarrow: "â† ", Uacute: "Ãš", uacute: "Ãº", uarr: "â†‘", Uarr: "â†Ÿ", uArr: "â‡‘", Uarrocir: "â¥‰", Ubrcy: "ÐŽ", ubrcy: "Ñž", Ubreve: "Å¬", ubreve: "Å­", Ucirc: "Ã›", ucirc: "Ã»", Ucy: "Ð£", ucy: "Ñƒ", udarr: "â‡…", Udblac: "Å°", udblac: "Å±", udhar: "â¥®", ufisht: "â¥¾", Ufr: "ð”˜", ufr: "ð”²", Ugrave: "Ã™", ugrave: "Ã¹", uHar: "â¥£", uharl: "â†¿", uharr: "â†¾", uhblk: "â–€", ulcorn: "âŒœ", ulcorner: "âŒœ", ulcrop: "âŒ", ultri: "â—¸", Umacr: "Åª", umacr: "Å«", uml: "Â¨", UnderBar: "_", UnderBrace: "âŸ", UnderBracket: "âŽµ", UnderParenthesis: "â", Union: "â‹ƒ", UnionPlus: "âŠŽ", Uogon: "Å²", uogon: "Å³", Uopf: "ð•Œ", uopf: "ð•¦", UpArrowBar: "â¤’", uparrow: "â†‘", UpArrow: "â†‘", Uparrow: "â‡‘", UpArrowDownArrow: "â‡…", updownarrow: "â†•", UpDownArrow: "â†•", Updownarrow: "â‡•", UpEquilibrium: "â¥®", upharpoonleft: "â†¿", upharpoonright: "â†¾", uplus: "âŠŽ", UpperLeftArrow: "â†–", UpperRightArrow: "â†—", upsi: "Ï…", Upsi: "Ï’", upsih: "Ï’", Upsilon: "Î¥", upsilon: "Ï…", UpTeeArrow: "â†¥", UpTee: "âŠ¥", upuparrows: "â‡ˆ", urcorn: "âŒ", urcorner: "âŒ", urcrop: "âŒŽ", Uring: "Å®", uring: "Å¯", urtri: "â—¹", Uscr: "ð’°", uscr: "ð“Š", utdot: "â‹°", Utilde: "Å¨", utilde: "Å©", utri: "â–µ", utrif: "â–´", uuarr: "â‡ˆ", Uuml: "Ãœ", uuml: "Ã¼", uwangle: "â¦§", vangrt: "â¦œ", varepsilon: "Ïµ", varkappa: "Ï°", varnothing: "âˆ…", varphi: "Ï•", varpi: "Ï–", varpropto: "âˆ", varr: "â†•", vArr: "â‡•", varrho: "Ï±", varsigma: "Ï‚", varsubsetneq: "âŠŠï¸€", varsubsetneqq: "â«‹ï¸€", varsupsetneq: "âŠ‹ï¸€", varsupsetneqq: "â«Œï¸€", vartheta: "Ï‘", vartriangleleft: "âŠ²", vartriangleright: "âŠ³", vBar: "â«¨", Vbar: "â««", vBarv: "â«©", Vcy: "Ð’", vcy: "Ð²", vdash: "âŠ¢", vDash: "âŠ¨", Vdash: "âŠ©", VDash: "âŠ«", Vdashl: "â«¦", veebar: "âŠ»", vee: "âˆ¨", Vee: "â‹", veeeq: "â‰š", vellip: "â‹®", verbar: "|", Verbar: "â€–", vert: "|", Vert: "â€–", VerticalBar: "âˆ£", VerticalLine: "|", VerticalSeparator: "â˜", VerticalTilde: "â‰€", VeryThinSpace: "â€Š", Vfr: "ð”™", vfr: "ð”³", vltri: "âŠ²", vnsub: "âŠ‚âƒ’", vnsup: "âŠƒâƒ’", Vopf: "ð•", vopf: "ð•§", vprop: "âˆ", vrtri: "âŠ³", Vscr: "ð’±", vscr: "ð“‹", vsubnE: "â«‹ï¸€", vsubne: "âŠŠï¸€", vsupnE: "â«Œï¸€", vsupne: "âŠ‹ï¸€", Vvdash: "âŠª", vzigzag: "â¦š", Wcirc: "Å´", wcirc: "Åµ", wedbar: "â©Ÿ", wedge: "âˆ§", Wedge: "â‹€", wedgeq: "â‰™", weierp: "â„˜", Wfr: "ð”š", wfr: "ð”´", Wopf: "ð•Ž", wopf: "ð•¨", wp: "â„˜", wr: "â‰€", wreath: "â‰€", Wscr: "ð’²", wscr: "ð“Œ", xcap: "â‹‚", xcirc: "â—¯", xcup: "â‹ƒ", xdtri: "â–½", Xfr: "ð”›", xfr: "ð”µ", xharr: "âŸ·", xhArr: "âŸº", Xi: "Îž", xi: "Î¾", xlarr: "âŸµ", xlArr: "âŸ¸", xmap: "âŸ¼", xnis: "â‹»", xodot: "â¨€", Xopf: "ð•", xopf: "ð•©", xoplus: "â¨", xotime: "â¨‚", xrarr: "âŸ¶", xrArr: "âŸ¹", Xscr: "ð’³", xscr: "ð“", xsqcup: "â¨†", xuplus: "â¨„", xutri: "â–³", xvee: "â‹", xwedge: "â‹€", Yacute: "Ã", yacute: "Ã½", YAcy: "Ð¯", yacy: "Ñ", Ycirc: "Å¶", ycirc: "Å·", Ycy: "Ð«", ycy: "Ñ‹", yen: "Â¥", Yfr: "ð”œ", yfr: "ð”¶", YIcy: "Ð‡", yicy: "Ñ—", Yopf: "ð•", yopf: "ð•ª", Yscr: "ð’´", yscr: "ð“Ž", YUcy: "Ð®", yucy: "ÑŽ", yuml: "Ã¿", Yuml: "Å¸", Zacute: "Å¹", zacute: "Åº", Zcaron: "Å½", zcaron: "Å¾", Zcy: "Ð—", zcy: "Ð·", Zdot: "Å»", zdot: "Å¼", zeetrf: "â„¨", ZeroWidthSpace: "â€‹", Zeta: "Î–", zeta: "Î¶", zfr: "ð”·", Zfr: "â„¨", ZHcy: "Ð–", zhcy: "Ð¶", zigrarr: "â‡", zopf: "ð•«", Zopf: "â„¤", Zscr: "ð’µ", zscr: "ð“", zwj: "â€", zwnj: "â€Œ" };
  }
}), M1 = F({
  "../node_modules/entities/lib/maps/legacy.json"(e, t) {
    t.exports = { Aacute: "Ã", aacute: "Ã¡", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", AElig: "Ã†", aelig: "Ã¦", Agrave: "Ã€", agrave: "Ã ", amp: "&", AMP: "&", Aring: "Ã…", aring: "Ã¥", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", brvbar: "Â¦", Ccedil: "Ã‡", ccedil: "Ã§", cedil: "Â¸", cent: "Â¢", copy: "Â©", COPY: "Â©", curren: "Â¤", deg: "Â°", divide: "Ã·", Eacute: "Ã‰", eacute: "Ã©", Ecirc: "ÃŠ", ecirc: "Ãª", Egrave: "Ãˆ", egrave: "Ã¨", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", frac12: "Â½", frac14: "Â¼", frac34: "Â¾", gt: ">", GT: ">", Iacute: "Ã", iacute: "Ã­", Icirc: "ÃŽ", icirc: "Ã®", iexcl: "Â¡", Igrave: "ÃŒ", igrave: "Ã¬", iquest: "Â¿", Iuml: "Ã", iuml: "Ã¯", laquo: "Â«", lt: "<", LT: "<", macr: "Â¯", micro: "Âµ", middot: "Â·", nbsp: "Â ", not: "Â¬", Ntilde: "Ã‘", ntilde: "Ã±", Oacute: "Ã“", oacute: "Ã³", Ocirc: "Ã”", ocirc: "Ã´", Ograve: "Ã’", ograve: "Ã²", ordf: "Âª", ordm: "Âº", Oslash: "Ã˜", oslash: "Ã¸", Otilde: "Ã•", otilde: "Ãµ", Ouml: "Ã–", ouml: "Ã¶", para: "Â¶", plusmn: "Â±", pound: "Â£", quot: '"', QUOT: '"', raquo: "Â»", reg: "Â®", REG: "Â®", sect: "Â§", shy: "Â­", sup1: "Â¹", sup2: "Â²", sup3: "Â³", szlig: "ÃŸ", THORN: "Ãž", thorn: "Ã¾", times: "Ã—", Uacute: "Ãš", uacute: "Ãº", Ucirc: "Ã›", ucirc: "Ã»", Ugrave: "Ã™", ugrave: "Ã¹", uml: "Â¨", Uuml: "Ãœ", uuml: "Ã¼", Yacute: "Ã", yacute: "Ã½", yen: "Â¥", yuml: "Ã¿" };
  }
}), Jv = F({
  "../node_modules/entities/lib/maps/xml.json"(e, t) {
    t.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
}), $1 = F({
  "../node_modules/entities/lib/maps/decode.json"(e, t) {
    t.exports = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
  }
}), L1 = F({
  "../node_modules/entities/lib/decode_codepoint.js"(e) {
    var t = e && e.__importDefault || function(i) {
      return i && i.__esModule ? i : { default: i };
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    var r = t($1()), n = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(i) {
        var s = "";
        return i > 65535 && (i -= 65536, s += String.fromCharCode(i >>> 10 & 1023 | 55296), i = 56320 | i & 1023), s += String.fromCharCode(i), s;
      }
    );
    function a(i) {
      return i >= 55296 && i <= 57343 || i > 1114111 ? "ï¿½" : (i in r.default && (i = r.default[i]), n(i));
    }
    o(a, "decodeCodePoint"), e.default = a;
  }
}), yy = F({
  "../node_modules/entities/lib/decode.js"(e) {
    var t = e && e.__importDefault || function(p) {
      return p && p.__esModule ? p : { default: p };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0;
    var r = t(Vv()), n = t(M1()), a = t(Jv()), i = t(L1()), s = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    e.decodeXML = l(a.default), e.decodeHTMLStrict = l(r.default);
    function l(p) {
      var f = u(p);
      return function(m) {
        return String(m).replace(s, f);
      };
    }
    o(l, "getStrictDecoder");
    var c = /* @__PURE__ */ o(function(p, f) {
      return p < f ? 1 : -1;
    }, "sorter");
    e.decodeHTML = (function() {
      for (var p = Object.keys(n.default).sort(c), f = Object.keys(r.default).sort(c), m = 0, y = 0; m < f.length; m++)
        p[y] === f[m] ? (f[m] += ";?", y++) : f[m] += ";";
      var g = new RegExp("&(?:" + f.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), v = u(r.default);
      function _(b) {
        return b.substr(-1) !== ";" && (b += ";"), v(b);
      }
      return o(_, "replacer"), function(b) {
        return String(b).replace(g, _);
      };
    })();
    function u(p) {
      return /* @__PURE__ */ o(function(f) {
        if (f.charAt(1) === "#") {
          var m = f.charAt(2);
          return m === "X" || m === "x" ? i.default(parseInt(f.substr(3), 16)) : i.default(parseInt(f.substr(2), 10));
        }
        return p[f.slice(1, -1)] || f;
      }, "replace");
    }
    o(u, "getReplacer");
  }
}), gy = F({
  "../node_modules/entities/lib/encode.js"(e) {
    var t = e && e.__importDefault || function(E) {
      return E && E.__esModule ? E : { default: E };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0;
    var r = t(Jv()), n = c(r.default), a = u(n);
    e.encodeXML = b(n);
    var i = t(Vv()), s = c(i.default), l = u(s);
    e.encodeHTML = y(s, l), e.encodeNonAsciiHTML = b(s);
    function c(E) {
      return Object.keys(E).sort().reduce(function(C, k) {
        return C[E[k]] = "&" + k + ";", C;
      }, {});
    }
    o(c, "getInverseObj");
    function u(E) {
      for (var C = [], k = [], N = 0, O = Object.keys(E); N < O.length; N++) {
        var S = O[N];
        S.length === 1 ? C.push("\\" + S) : k.push(S);
      }
      C.sort();
      for (var w = 0; w < C.length - 1; w++) {
        for (var T = w; T < C.length - 1 && C[T].charCodeAt(1) + 1 === C[T + 1].charCodeAt(1); )
          T += 1;
        var M = 1 + T - w;
        M < 3 || C.splice(w, M, C[w] + "-" + C[T]);
      }
      return k.unshift("[" + C.join("") + "]"), new RegExp(k.join("|"), "g");
    }
    o(u, "getInverseReplacer");
    var p = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, f = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (function(E) {
          return E.codePointAt(0);
        })
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (function(E) {
          return (E.charCodeAt(0) - 55296) * 1024 + E.charCodeAt(1) - 56320 + 65536;
        })
      )
    );
    function m(E) {
      return "&#x" + (E.length > 1 ? f(E) : E.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    o(m, "singleCharReplacer");
    function y(E, C) {
      return function(k) {
        return k.replace(C, function(N) {
          return E[N];
        }).replace(p, m);
      };
    }
    o(y, "getInverse");
    var g = new RegExp(a.source + "|" + p.source, "g");
    function v(E) {
      return E.replace(g, m);
    }
    o(v, "escape"), e.escape = v;
    function _(E) {
      return E.replace(a, m);
    }
    o(_, "escapeUTF8"), e.escapeUTF8 = _;
    function b(E) {
      return function(C) {
        return C.replace(g, function(k) {
          return E[k] || m(k);
        });
      };
    }
    o(b, "getASCIIEncoder");
  }
}), D1 = F({
  "../node_modules/entities/lib/index.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.decodeXMLStrict = e.decodeHTML5Strict = e.decodeHTML4Strict = e.decodeHTML5 = e.decodeHTML4 = e.decodeHTMLStrict = e.decodeHTML = e.decodeXML = e.encodeHTML5 = e.encodeHTML4 = e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = e.encode = e.decodeStrict = e.decode = void 0;
    var t = yy(), r = gy();
    function n(c, u) {
      return (!u || u <= 0 ? t.decodeXML : t.decodeHTML)(c);
    }
    o(n, "decode"), e.decode = n;
    function a(c, u) {
      return (!u || u <= 0 ? t.decodeXML : t.decodeHTMLStrict)(c);
    }
    o(a, "decodeStrict"), e.decodeStrict = a;
    function i(c, u) {
      return (!u || u <= 0 ? r.encodeXML : r.encodeHTML)(c);
    }
    o(i, "encode"), e.encode = i;
    var s = gy();
    Object.defineProperty(e, "encodeXML", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.encodeXML;
    }, "get") }), Object.defineProperty(e, "encodeHTML", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.encodeHTML;
    }, "get") }), Object.defineProperty(e, "encodeNonAsciiHTML", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.encodeNonAsciiHTML;
    }, "get") }), Object.defineProperty(e, "escape", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.escape;
    }, "get") }), Object.defineProperty(e, "escapeUTF8", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.escapeUTF8;
    }, "get") }), Object.defineProperty(e, "encodeHTML4", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.encodeHTML;
    }, "get") }), Object.defineProperty(e, "encodeHTML5", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return s.encodeHTML;
    }, "get") });
    var l = yy();
    Object.defineProperty(e, "decodeXML", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeXML;
    }, "get") }), Object.defineProperty(e, "decodeHTML", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTMLStrict", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeHTML4", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTML5", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeHTML;
    }, "get") }), Object.defineProperty(e, "decodeHTML4Strict", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeHTML5Strict", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeHTMLStrict;
    }, "get") }), Object.defineProperty(e, "decodeXMLStrict", { enumerable: !0, get: /* @__PURE__ */ o(function() {
      return l.decodeXML;
    }, "get") });
  }
}), F1 = F({
  "../node_modules/ansi-to-html/lib/ansi_to_html.js"(e, t) {
    function r(P, q) {
      if (!(P instanceof q))
        throw new TypeError("Cannot call a class as a function");
    }
    o(r, "_classCallCheck");
    function n(P, q) {
      for (var $ = 0; $ < q.length; $++) {
        var H = q[$];
        H.enumerable = H.enumerable || !1, H.configurable = !0, "value" in H && (H.writable = !0), Object.defineProperty(P, H.key, H);
      }
    }
    o(n, "_defineProperties");
    function a(P, q, $) {
      return q && n(P.prototype, q), $ && n(P, $), P;
    }
    o(a, "_createClass");
    function i(P, q) {
      var $ = typeof Symbol < "u" && P[Symbol.iterator] || P["@@iterator"];
      if (!$) {
        if (Array.isArray(P) || ($ = s(P)) || q && P && typeof P.length == "number") {
          $ && (P = $);
          var H = 0, z = /* @__PURE__ */ o(function() {
          }, "F");
          return { s: z, n: /* @__PURE__ */ o(function() {
            return H >= P.length ? { done: !0 } : { done: !1, value: P[H++] };
          }, "n"), e: /* @__PURE__ */ o(function(Y) {
            throw Y;
          }, "e"), f: z };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var Z = !0, oe = !1, ie;
      return { s: /* @__PURE__ */ o(function() {
        $ = $.call(P);
      }, "s"), n: /* @__PURE__ */ o(function() {
        var Y = $.next();
        return Z = Y.done, Y;
      }, "n"), e: /* @__PURE__ */ o(function(Y) {
        oe = !0, ie = Y;
      }, "e"), f: /* @__PURE__ */ o(function() {
        try {
          !Z && $.return != null && $.return();
        } finally {
          if (oe) throw ie;
        }
      }, "f") };
    }
    o(i, "_createForOfIteratorHelper");
    function s(P, q) {
      if (P) {
        if (typeof P == "string") return l(P, q);
        var $ = Object.prototype.toString.call(P).slice(8, -1);
        if ($ === "Object" && P.constructor && ($ = P.constructor.name), $ === "Map" || $ === "Set") return Array.from(P);
        if ($ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test($)) return l(P, q);
      }
    }
    o(s, "_unsupportedIterableToArray");
    function l(P, q) {
      (q == null || q > P.length) && (q = P.length);
      for (var $ = 0, H = new Array(q); $ < q; $++)
        H[$] = P[$];
      return H;
    }
    o(l, "_arrayLikeToArray");
    var c = D1(), u = {
      fg: "#FFF",
      bg: "#000",
      newline: !1,
      escapeXML: !1,
      stream: !1,
      colors: p()
    };
    function p() {
      var P = {
        0: "#000",
        1: "#A00",
        2: "#0A0",
        3: "#A50",
        4: "#00A",
        5: "#A0A",
        6: "#0AA",
        7: "#AAA",
        8: "#555",
        9: "#F55",
        10: "#5F5",
        11: "#FF5",
        12: "#55F",
        13: "#F5F",
        14: "#5FF",
        15: "#FFF"
      };
      return E(0, 5).forEach(function(q) {
        E(0, 5).forEach(function($) {
          E(0, 5).forEach(function(H) {
            return f(q, $, H, P);
          });
        });
      }), E(0, 23).forEach(function(q) {
        var $ = q + 232, H = m(q * 10 + 8);
        P[$] = "#" + H + H + H;
      }), P;
    }
    o(p, "getDefaultColors");
    function f(P, q, $, H) {
      var z = 16 + P * 36 + q * 6 + $, Z = P > 0 ? P * 40 + 55 : 0, oe = q > 0 ? q * 40 + 55 : 0, ie = $ > 0 ? $ * 40 + 55 : 0;
      H[z] = y([Z, oe, ie]);
    }
    o(f, "setStyleColor");
    function m(P) {
      for (var q = P.toString(16); q.length < 2; )
        q = "0" + q;
      return q;
    }
    o(m, "toHexString");
    function y(P) {
      var q = [], $ = i(P), H;
      try {
        for ($.s(); !(H = $.n()).done; ) {
          var z = H.value;
          q.push(m(z));
        }
      } catch (Z) {
        $.e(Z);
      } finally {
        $.f();
      }
      return "#" + q.join("");
    }
    o(y, "toColorHexString");
    function g(P, q, $, H) {
      var z;
      return q === "text" ? z = N($, H) : q === "display" ? z = _(P, $, H) : q === "xterm256Foreground" ? z = w(P, H.colors[$]) : q === "xterm256Background" ? z = T(P, H.colors[$]) : q === "rgb" && (z = v(P, $)), z;
    }
    o(g, "generateOutput");
    function v(P, q) {
      q = q.substring(2).slice(0, -1);
      var $ = +q.substr(0, 2), H = q.substring(5).split(";"), z = H.map(function(Z) {
        return ("0" + Number(Z).toString(16)).substr(-2);
      }).join("");
      return S(P, ($ === 38 ? "color:#" : "background-color:#") + z);
    }
    o(v, "handleRgb");
    function _(P, q, $) {
      q = parseInt(q, 10);
      var H = {
        "-1": /* @__PURE__ */ o(function() {
          return "<br/>";
        }, "_"),
        0: /* @__PURE__ */ o(function() {
          return P.length && b(P);
        }, "_"),
        1: /* @__PURE__ */ o(function() {
          return O(P, "b");
        }, "_"),
        3: /* @__PURE__ */ o(function() {
          return O(P, "i");
        }, "_"),
        4: /* @__PURE__ */ o(function() {
          return O(P, "u");
        }, "_"),
        8: /* @__PURE__ */ o(function() {
          return S(P, "display:none");
        }, "_"),
        9: /* @__PURE__ */ o(function() {
          return O(P, "strike");
        }, "_"),
        22: /* @__PURE__ */ o(function() {
          return S(P, "font-weight:normal;text-decoration:none;font-style:normal");
        }, "_"),
        23: /* @__PURE__ */ o(function() {
          return M(P, "i");
        }, "_"),
        24: /* @__PURE__ */ o(function() {
          return M(P, "u");
        }, "_"),
        39: /* @__PURE__ */ o(function() {
          return w(P, $.fg);
        }, "_"),
        49: /* @__PURE__ */ o(function() {
          return T(P, $.bg);
        }, "_"),
        53: /* @__PURE__ */ o(function() {
          return S(P, "text-decoration:overline");
        }, "_")
      }, z;
      return H[q] ? z = H[q]() : 4 < q && q < 7 ? z = O(P, "blink") : 29 < q && q < 38 ? z = w(P, $.colors[q - 30]) : 39 < q && q < 48 ? z = T(P, $.colors[q - 40]) : 89 < q && q < 98 ? z = w(P, $.colors[8 + (q - 90)]) : 99 < q && q < 108 && (z = T(P, $.colors[8 + (q - 100)])), z;
    }
    o(_, "handleDisplay");
    function b(P) {
      var q = P.slice(0);
      return P.length = 0, q.reverse().map(function($) {
        return "</" + $ + ">";
      }).join("");
    }
    o(b, "resetStyles");
    function E(P, q) {
      for (var $ = [], H = P; H <= q; H++)
        $.push(H);
      return $;
    }
    o(E, "range");
    function C(P) {
      return function(q) {
        return (P === null || q.category !== P) && P !== "all";
      };
    }
    o(C, "notCategory");
    function k(P) {
      P = parseInt(P, 10);
      var q = null;
      return P === 0 ? q = "all" : P === 1 ? q = "bold" : 2 < P && P < 5 ? q = "underline" : 4 < P && P < 7 ? q = "blink" : P === 8 ? q = "hide" : P === 9 ? q = "strike" : 29 < P && P < 38 || P === 39 || 89 < P && P < 98 ? q = "foreground-color" : (39 < P && P < 48 || P === 49 || 99 < P && P < 108) && (q = "background-color"), q;
    }
    o(k, "categoryForCode");
    function N(P, q) {
      return q.escapeXML ? c.encodeXML(P) : P;
    }
    o(N, "pushText");
    function O(P, q, $) {
      return $ || ($ = ""), P.push(q), "<".concat(q).concat($ ? ' style="'.concat($, '"') : "", ">");
    }
    o(O, "pushTag");
    function S(P, q) {
      return O(P, "span", q);
    }
    o(S, "pushStyle");
    function w(P, q) {
      return O(P, "span", "color:" + q);
    }
    o(w, "pushForegroundColor");
    function T(P, q) {
      return O(P, "span", "background-color:" + q);
    }
    o(T, "pushBackgroundColor");
    function M(P, q) {
      var $;
      if (P.slice(-1)[0] === q && ($ = P.pop()), $)
        return "</" + q + ">";
    }
    o(M, "closeTag");
    function R(P, q, $) {
      var H = !1, z = 3;
      function Z() {
        return "";
      }
      o(Z, "remove");
      function oe(re, he) {
        return $("xterm256Foreground", he), "";
      }
      o(oe, "removeXterm256Foreground");
      function ie(re, he) {
        return $("xterm256Background", he), "";
      }
      o(ie, "removeXterm256Background");
      function Y(re) {
        return q.newline ? $("display", -1) : $("text", re), "";
      }
      o(Y, "newline");
      function be(re, he) {
        H = !0, he.trim().length === 0 && (he = "0"), he = he.trimRight(";").split(";");
        var ce = i(he), Ce;
        try {
          for (ce.s(); !(Ce = ce.n()).done; ) {
            var Xe = Ce.value;
            $("display", Xe);
          }
        } catch (mt) {
          ce.e(mt);
        } finally {
          ce.f();
        }
        return "";
      }
      o(be, "ansiMess");
      function we(re) {
        return $("text", re), "";
      }
      o(we, "realText");
      function le(re) {
        return $("rgb", re), "";
      }
      o(le, "rgb");
      var X = [{
        pattern: /^\x08+/,
        sub: Z
      }, {
        pattern: /^\x1b\[[012]?K/,
        sub: Z
      }, {
        pattern: /^\x1b\[\(B/,
        sub: Z
      }, {
        pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/,
        sub: le
      }, {
        pattern: /^\x1b\[38;5;(\d+)m/,
        sub: oe
      }, {
        pattern: /^\x1b\[48;5;(\d+)m/,
        sub: ie
      }, {
        pattern: /^\n/,
        sub: Y
      }, {
        pattern: /^\r+\n/,
        sub: Y
      }, {
        pattern: /^\r/,
        sub: Y
      }, {
        pattern: /^\x1b\[((?:\d{1,3};?)+|)m/,
        sub: be
      }, {
        // CSI n J
        // ED - Erase in Display Clears part of the screen.
        // If n is 0 (or missing), clear from cursor to end of screen.
        // If n is 1, clear from cursor to beginning of the screen.
        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).
        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer
        //   (this feature was added for xterm and is supported by other terminal applications).
        pattern: /^\x1b\[\d?J/,
        sub: Z
      }, {
        // CSI n ; m f
        // HVP - Horizontal Vertical Position Same as CUP
        pattern: /^\x1b\[\d{0,3};\d{0,3}f/,
        sub: Z
      }, {
        // catch-all for CSI sequences?
        pattern: /^\x1b\[?[\d;]{0,3}/,
        sub: Z
      }, {
        /**
         * extracts real text - not containing:
         * - `\x1b' - ESC - escape (Ascii 27)
         * - '\x08' - BS - backspace (Ascii 8)
         * - `\n` - Newline - linefeed (LF) (ascii 10)
         * - `\r` - Windows Carriage Return (CR)
         */
        pattern: /^(([^\x1b\x08\r\n])+)/,
        sub: we
      }];
      function Re(re, he) {
        he > z && H || (H = !1, P = P.replace(re.pattern, re.sub));
      }
      o(Re, "process");
      var Pe = [], lt = P, rt = lt.length;
      e: for (; rt > 0; ) {
        for (var L = 0, K = 0, Q = X.length; K < Q; L = ++K) {
          var se = X[L];
          if (Re(se, L), P.length !== rt) {
            rt = P.length;
            continue e;
          }
        }
        if (P.length === rt)
          break;
        Pe.push(0), rt = P.length;
      }
      return Pe;
    }
    o(R, "tokenize");
    function D(P, q, $) {
      return q !== "text" && (P = P.filter(C(k($))), P.push({
        token: q,
        data: $,
        category: k($)
      })), P;
    }
    o(D, "updateStickyStack");
    var J = (function() {
      function P(q) {
        r(this, P), q = q || {}, q.colors && (q.colors = Object.assign({}, u.colors, q.colors)), this.options = Object.assign({}, u, q), this.stack = [], this.stickyStack = [];
      }
      return o(P, "Filter"), a(P, [{
        key: "toHtml",
        value: /* @__PURE__ */ o(function(q) {
          var $ = this;
          q = typeof q == "string" ? [q] : q;
          var H = this.stack, z = this.options, Z = [];
          return this.stickyStack.forEach(function(oe) {
            var ie = g(H, oe.token, oe.data, z);
            ie && Z.push(ie);
          }), R(q.join(""), z, function(oe, ie) {
            var Y = g(H, oe, ie, z);
            Y && Z.push(Y), z.stream && ($.stickyStack = D($.stickyStack, oe, ie));
          }), H.length && Z.push(b(H)), Z.join("");
        }, "toHtml")
      }]), P;
    })();
    t.exports = J;
  }
}), zv = F({
  "../node_modules/memoizerific/memoizerific.js"(e, t) {
    (function(r) {
      if (typeof e == "object" && typeof t < "u")
        t.exports = r();
      else if (typeof define == "function" && define.amd)
        define([], r);
      else {
        var n;
        typeof window < "u" ? n = window : typeof globalThis < "u" ? n = globalThis : typeof self < "u" ? n = self : n = this, n.memoizerific = r();
      }
    })(function() {
      return (/* @__PURE__ */ o(function r(n, a, i) {
        function s(u, p) {
          if (!a[u]) {
            if (!n[u]) {
              var f = typeof yi == "function" && yi;
              if (!p && f) return f(u, !0);
              if (l) return l(u, !0);
              var m = new Error("Cannot find module '" + u + "'");
              throw m.code = "MODULE_NOT_FOUND", m;
            }
            var y = a[u] = { exports: {} };
            n[u][0].call(y.exports, function(g) {
              var v = n[u][1][g];
              return s(v || g);
            }, y, y.exports, r, n, a, i);
          }
          return a[u].exports;
        }
        o(s, "s");
        for (var l = typeof yi == "function" && yi, c = 0; c < i.length; c++) s(i[c]);
        return s;
      }, "e"))({ 1: [function(r, n, a) {
        n.exports = function(i) {
          if (typeof Map != "function" || i) {
            var s = r("./similar");
            return new s();
          } else
            return /* @__PURE__ */ new Map();
        };
      }, { "./similar": 2 }], 2: [function(r, n, a) {
        function i() {
          return this.list = [], this.lastItem = void 0, this.size = 0, this;
        }
        o(i, "Similar"), i.prototype.get = function(s) {
          var l;
          if (this.lastItem && this.isEqual(this.lastItem.key, s))
            return this.lastItem.val;
          if (l = this.indexOf(s), l >= 0)
            return this.lastItem = this.list[l], this.list[l].val;
        }, i.prototype.set = function(s, l) {
          var c;
          return this.lastItem && this.isEqual(this.lastItem.key, s) ? (this.lastItem.val = l, this) : (c = this.indexOf(s), c >= 0 ? (this.lastItem = this.list[c], this.list[c].val = l, this) : (this.lastItem = { key: s, val: l }, this.list.push(this.lastItem), this.size++, this));
        }, i.prototype.delete = function(s) {
          var l;
          if (this.lastItem && this.isEqual(this.lastItem.key, s) && (this.lastItem = void 0), l = this.indexOf(s), l >= 0)
            return this.size--, this.list.splice(l, 1)[0];
        }, i.prototype.has = function(s) {
          var l;
          return this.lastItem && this.isEqual(this.lastItem.key, s) ? !0 : (l = this.indexOf(s), l >= 0 ? (this.lastItem = this.list[l], !0) : !1);
        }, i.prototype.forEach = function(s, l) {
          var c;
          for (c = 0; c < this.size; c++)
            s.call(l || this, this.list[c].val, this.list[c].key, this);
        }, i.prototype.indexOf = function(s) {
          var l;
          for (l = 0; l < this.size; l++)
            if (this.isEqual(this.list[l].key, s))
              return l;
          return -1;
        }, i.prototype.isEqual = function(s, l) {
          return s === l || s !== s && l !== l;
        }, n.exports = i;
      }, {}], 3: [function(r, n, a) {
        var i = r("map-or-similar");
        n.exports = function(u) {
          var p = new i(!1), f = [];
          return function(m) {
            var y = /* @__PURE__ */ o(function() {
              var g = p, v, _, b = arguments.length - 1, E = Array(b + 1), C = !0, k;
              if ((y.numArgs || y.numArgs === 0) && y.numArgs !== b + 1)
                throw new Error("Memoizerific functions should always be called with the same number of arguments");
              for (k = 0; k < b; k++) {
                if (E[k] = {
                  cacheItem: g,
                  arg: arguments[k]
                }, g.has(arguments[k])) {
                  g = g.get(arguments[k]);
                  continue;
                }
                C = !1, v = new i(!1), g.set(arguments[k], v), g = v;
              }
              return C && (g.has(arguments[b]) ? _ = g.get(arguments[b]) : C = !1), C || (_ = m.apply(null, arguments), g.set(arguments[b], _)), u > 0 && (E[b] = {
                cacheItem: g,
                arg: arguments[b]
              }, C ? s(f, E) : f.push(E), f.length > u && l(f.shift())), y.wasMemoized = C, y.numArgs = b + 1, _;
            }, "memoizerific");
            return y.limit = u, y.wasMemoized = !1, y.cache = p, y.lru = f, y;
          };
        };
        function s(u, p) {
          var f = u.length, m = p.length, y, g, v;
          for (g = 0; g < f; g++) {
            for (y = !0, v = 0; v < m; v++)
              if (!c(u[g][v].arg, p[v].arg)) {
                y = !1;
                break;
              }
            if (y)
              break;
          }
          u.push(u.splice(g, 1)[0]);
        }
        o(s, "moveToMostRecentLru");
        function l(u) {
          var p = u.length, f = u[p - 1], m, y;
          for (f.cacheItem.delete(f.arg), y = p - 2; y >= 0 && (f = u[y], m = f.cacheItem.get(f.arg), !m || !m.size); y--)
            f.cacheItem.delete(f.arg);
        }
        o(l, "removeCachedResult");
        function c(u, p) {
          return u === p || u !== u && p !== p;
        }
        o(c, "isEqual");
      }, { "map-or-similar": 1 }] }, {}, [3])(3);
    });
  }
}), ee = (() => {
  let e;
  return typeof window < "u" ? e = window : typeof globalThis < "u" || typeof globalThis < "u" ? e = globalThis : typeof self < "u" ? e = self : e = {}, e;
})(), by = /* @__PURE__ */ new Map(), B1 = "UNIVERSAL_STORE:", At = {
  PENDING: "PENDING",
  RESOLVED: "RESOLVED",
  REJECTED: "REJECTED"
}, en = class de {
  constructor(t, r) {
    if (this.debugging = !1, this.listeners = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set()]]), this.getState = /* @__PURE__ */ o(() => (this.debug("getState", { state: this.state }), this.state), "getState"), this.subscribe = /* @__PURE__ */ o((n, a) => {
      const i = typeof n == "function", s = i ? "*" : n, l = i ? n : a;
      if (this.debug("subscribe", { eventType: s, listener: l }), !l)
        throw new TypeError(
          `Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
        );
      return this.listeners.has(s) || this.listeners.set(s, /* @__PURE__ */ new Set()), this.listeners.get(s).add(l), () => {
        this.debug("unsubscribe", { eventType: s, listener: l }), this.listeners.has(s) && (this.listeners.get(s).delete(l), this.listeners.get(s)?.size === 0 && this.listeners.delete(s));
      };
    }, "subscribe"), this.send = /* @__PURE__ */ o((n) => {
      if (this.debug("send", { event: n }), this.status !== de.Status.READY)
        throw new TypeError(
          ye`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
            {
              event: n,
              id: this.id,
              actor: this.actor,
              environment: this.environment
            },
            null,
            2
          )}`
        );
      this.emitToListeners(n, { actor: this.actor }), this.emitToChannel(n, { actor: this.actor });
    }, "send"), this.debugging = t.debug ?? !1, !de.isInternalConstructing)
      throw new TypeError(
        "UniversalStore is not constructable - use UniversalStore.create() instead"
      );
    if (de.isInternalConstructing = !1, this.id = t.id, this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2), this.actorType = t.leader ? de.ActorType.LEADER : de.ActorType.FOLLOWER, this.state = t.initialState, this.channelEventName = `${B1}${this.id}`, this.debug("constructor", {
      options: t,
      environmentOverrides: r,
      channelEventName: this.channelEventName
    }), this.actor.type === de.ActorType.LEADER)
      this.syncing = {
        state: At.RESOLVED,
        promise: Promise.resolve()
      };
    else {
      let n, a;
      const i = new Promise((s, l) => {
        n = /* @__PURE__ */ o(() => {
          this.syncing.state === At.PENDING && (this.syncing.state = At.RESOLVED, s());
        }, "syncingResolve"), a = /* @__PURE__ */ o((c) => {
          this.syncing.state === At.PENDING && (this.syncing.state = At.REJECTED, l(c));
        }, "syncingReject");
      });
      this.syncing = {
        state: At.PENDING,
        promise: i,
        resolve: n,
        reject: a
      };
    }
    this.getState = this.getState.bind(this), this.setState = this.setState.bind(this), this.subscribe = this.subscribe.bind(this), this.onStateChange = this.onStateChange.bind(this), this.send = this.send.bind(this), this.emitToChannel = this.emitToChannel.bind(this), this.prepareThis = this.prepareThis.bind(this), this.emitToListeners = this.emitToListeners.bind(this), this.handleChannelEvents = this.handleChannelEvents.bind(this), this.debug = this.debug.bind(this), this.channel = r?.channel ?? de.preparation.channel, this.environment = r?.environment ?? de.preparation.environment, this.channel && this.environment ? (de.preparation.resolve({ channel: this.channel, environment: this.environment }), this.prepareThis({ channel: this.channel, environment: this.environment })) : de.preparation.promise.then(this.prepareThis);
  }
  static setupPreparationPromise() {
    let t, r;
    const n = new Promise(
      (a, i) => {
        t = /* @__PURE__ */ o((s) => {
          a(s);
        }, "resolveRef"), r = /* @__PURE__ */ o((...s) => {
          i(s);
        }, "rejectRef");
      }
    );
    de.preparation = {
      resolve: t,
      reject: r,
      promise: n
    };
  }
  /** The actor object representing the store instance with a unique ID and a type */
  get actor() {
    return Object.freeze({
      id: this.actorId,
      type: this.actorType,
      environment: this.environment ?? de.Environment.UNKNOWN
    });
  }
  /**
   * The current state of the store, that signals both if the store is prepared by Storybook and
   * also - in the case of a follower - if the state has been synced with the leader's state.
   */
  get status() {
    if (!this.channel || !this.environment)
      return de.Status.UNPREPARED;
    switch (this.syncing?.state) {
      case At.PENDING:
      case void 0:
        return de.Status.SYNCING;
      case At.REJECTED:
        return de.Status.ERROR;
      case At.RESOLVED:
      default:
        return de.Status.READY;
    }
  }
  /**
   * A promise that resolves when the store is fully ready. A leader will be ready when the store
   * has been prepared by Storybook, which is almost instantly.
   *
   * A follower will be ready when the state has been synced with the leader's state, within a few
   * hundred milliseconds.
   */
  untilReady() {
    return Promise.all([de.preparation.promise, this.syncing?.promise]);
  }
  /** Creates a new instance of UniversalStore */
  static create(t) {
    if (!t || typeof t?.id != "string")
      throw new TypeError("id is required and must be a string, when creating a UniversalStore");
    t.debug && console.debug(
      ye`[UniversalStore]
        create`,
      { options: t }
    );
    const r = by.get(t.id);
    if (r)
      return console.warn(ye`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`), r;
    de.isInternalConstructing = !0;
    const n = new de(t);
    return by.set(t.id, n), n;
  }
  /**
   * Used by Storybook to set the channel for all instances of UniversalStore in the given
   * environment.
   *
   * @internal
   */
  static __prepare(t, r) {
    de.preparation.channel = t, de.preparation.environment = r, de.preparation.resolve({ channel: t, environment: r });
  }
  /**
   * Updates the store's state
   *
   * Either a new state or a state updater function can be passed to the method.
   */
  setState(t) {
    const r = this.state, n = typeof t == "function" ? t(r) : t;
    if (this.debug("setState", { newState: n, previousState: r, updater: t }), this.status !== de.Status.READY)
      throw new TypeError(
        ye`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify(
          {
            newState: n,
            id: this.id,
            actor: this.actor,
            environment: this.environment
          },
          null,
          2
        )}`
      );
    this.state = n;
    const a = {
      type: de.InternalEventType.SET_STATE,
      payload: {
        state: n,
        previousState: r
      }
    };
    this.emitToChannel(a, { actor: this.actor }), this.emitToListeners(a, { actor: this.actor });
  }
  /**
   * Subscribes to state changes
   *
   * @returns Unsubscribe function
   */
  onStateChange(t) {
    return this.debug("onStateChange", { listener: t }), this.subscribe(
      de.InternalEventType.SET_STATE,
      ({ payload: r }, n) => {
        t(r.state, r.previousState, n);
      }
    );
  }
  emitToChannel(t, r) {
    this.debug("emitToChannel", { event: t, eventInfo: r, channel: !!this.channel }), this.channel?.emit(this.channelEventName, {
      event: t,
      eventInfo: r
    });
  }
  prepareThis({
    channel: t,
    environment: r
  }) {
    this.channel = t, this.environment = r, this.debug("prepared", { channel: !!t, environment: r }), this.channel.on(this.channelEventName, this.handleChannelEvents), this.actor.type === de.ActorType.LEADER ? this.emitToChannel(
      { type: de.InternalEventType.LEADER_CREATED },
      { actor: this.actor }
    ) : (this.emitToChannel(
      { type: de.InternalEventType.FOLLOWER_CREATED },
      { actor: this.actor }
    ), this.emitToChannel(
      { type: de.InternalEventType.EXISTING_STATE_REQUEST },
      { actor: this.actor }
    ), setTimeout(() => {
      this.syncing.reject(
        new TypeError(
          `No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
        )
      );
    }, 1e3));
  }
  emitToListeners(t, r) {
    const n = this.listeners.get(t.type), a = this.listeners.get("*");
    this.debug("emitToListeners", {
      event: t,
      eventInfo: r,
      eventTypeListeners: n,
      everythingListeners: a
    }), [...n ?? [], ...a ?? []].forEach(
      (i) => i(t, r)
    );
  }
  handleChannelEvents(t) {
    const { event: r, eventInfo: n } = t;
    if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
      this.debug("handleChannelEvents: Ignoring event from self", { channelEvent: t });
      return;
    } else if (this.syncing?.state === At.PENDING && r.type !== de.InternalEventType.EXISTING_STATE_RESPONSE) {
      this.debug("handleChannelEvents: Ignoring event while syncing", { channelEvent: t });
      return;
    }
    if (this.debug("handleChannelEvents", { channelEvent: t }), this.actor.type === de.ActorType.LEADER) {
      let a = !0;
      switch (r.type) {
        case de.InternalEventType.EXISTING_STATE_REQUEST:
          a = !1;
          const i = {
            type: de.InternalEventType.EXISTING_STATE_RESPONSE,
            payload: this.state
          };
          this.debug("handleChannelEvents: responding to existing state request", {
            responseEvent: i
          }), this.emitToChannel(i, { actor: this.actor }), this.emitToListeners(i, { actor: this.actor });
          break;
        case de.InternalEventType.LEADER_CREATED:
          a = !1, this.syncing.state = At.REJECTED, this.debug("handleChannelEvents: erroring due to second leader being created", {
            event: r
          }), console.error(
            ye`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`
          );
          break;
      }
      a && (this.debug("handleChannelEvents: forwarding event", { channelEvent: t }), this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
    }
    if (this.actor.type === de.ActorType.FOLLOWER)
      switch (r.type) {
        case de.InternalEventType.EXISTING_STATE_RESPONSE:
          if (this.debug("handleChannelEvents: Setting state from leader's existing state response", {
            event: r
          }), this.syncing?.state !== At.PENDING)
            break;
          this.syncing.resolve?.();
          const a = {
            type: de.InternalEventType.SET_STATE,
            payload: {
              state: r.payload,
              previousState: this.state
            }
          };
          this.state = r.payload, this.emitToListeners(a, n);
          break;
      }
    switch (r.type) {
      case de.InternalEventType.SET_STATE:
        this.debug("handleChannelEvents: Setting state", { event: r }), this.state = r.payload.state;
        break;
    }
    this.emitToListeners(r, { actor: n.actor });
  }
  debug(t, r) {
    this.debugging && console.debug(
      ye`[UniversalStore::${this.id}::${this.environment ?? de.Environment.UNKNOWN}]
        ${t}`,
      JSON.stringify(
        {
          data: r,
          actor: this.actor,
          state: this.state,
          status: this.status
        },
        null,
        2
      )
    );
  }
  /**
   * Used to reset the static fields of the UniversalStore class when cleaning up tests
   *
   * @internal
   */
  static __reset() {
    de.preparation.reject(new Error("reset")), de.setupPreparationPromise(), de.isInternalConstructing = !1;
  }
};
o(en, "UniversalStore");
en.ActorType = {
  LEADER: "LEADER",
  FOLLOWER: "FOLLOWER"
};
en.Environment = {
  SERVER: "SERVER",
  MANAGER: "MANAGER",
  PREVIEW: "PREVIEW",
  UNKNOWN: "UNKNOWN",
  MOCK: "MOCK"
};
en.InternalEventType = {
  EXISTING_STATE_REQUEST: "__EXISTING_STATE_REQUEST",
  EXISTING_STATE_RESPONSE: "__EXISTING_STATE_RESPONSE",
  SET_STATE: "__SET_STATE",
  LEADER_CREATED: "__LEADER_CREATED",
  FOLLOWER_CREATED: "__FOLLOWER_CREATED"
};
en.Status = {
  UNPREPARED: "UNPREPARED",
  SYNCING: "SYNCING",
  READY: "READY",
  ERROR: "ERROR"
};
en.isInternalConstructing = !1;
en.setupPreparationPromise();
var Ou = en, U1 = Object.create, Wv = Object.defineProperty, H1 = Object.getOwnPropertyDescriptor, Gv = Object.getOwnPropertyNames, V1 = Object.getPrototypeOf, J1 = Object.prototype.hasOwnProperty, me = /* @__PURE__ */ o((e, t) => /* @__PURE__ */ o(function() {
  return t || (0, e[Gv(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, "__require"), "__commonJS"), z1 = /* @__PURE__ */ o((e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let a of Gv(t))
      !J1.call(e, a) && a !== r && Wv(e, a, { get: /* @__PURE__ */ o(() => t[a], "get"), enumerable: !(n = H1(t, a)) || n.enumerable });
  return e;
}, "__copyProps"), dp = /* @__PURE__ */ o((e, t, r) => (r = e != null ? U1(V1(e)) : {}, z1(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? Wv(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), "__toESM"), W1 = [
  "bubbles",
  "cancelBubble",
  "cancelable",
  "composed",
  "currentTarget",
  "defaultPrevented",
  "eventPhase",
  "isTrusted",
  "returnValue",
  "srcElement",
  "target",
  "timeStamp",
  "type"
], G1 = ["detail"];
function Kv(e) {
  const t = W1.filter((r) => e[r] !== void 0).reduce((r, n) => (r[n] = e[n], r), {});
  if (e instanceof CustomEvent)
    for (const r of G1.filter(
      (n) => e[n] !== void 0
    ))
      t[r] = e[r];
  return t;
}
o(Kv, "extractEventHiddenProperties");
var Yv = me({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(e, t) {
    t.exports = Object;
  }
}), K1 = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(e, t) {
    t.exports = Error;
  }
}), Y1 = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(e, t) {
    t.exports = EvalError;
  }
}), X1 = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(e, t) {
    t.exports = RangeError;
  }
}), Q1 = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(e, t) {
    t.exports = ReferenceError;
  }
}), Z1 = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(e, t) {
    t.exports = SyntaxError;
  }
}), pp = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(e, t) {
    t.exports = TypeError;
  }
}), eI = me({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(e, t) {
    t.exports = URIError;
  }
}), tI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(e, t) {
    t.exports = Math.abs;
  }
}), rI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(e, t) {
    t.exports = Math.floor;
  }
}), nI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(e, t) {
    t.exports = Math.max;
  }
}), oI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(e, t) {
    t.exports = Math.min;
  }
}), aI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(e, t) {
    t.exports = Math.pow;
  }
}), iI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(e, t) {
    t.exports = Math.round;
  }
}), sI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(e, t) {
    t.exports = Number.isNaN || /* @__PURE__ */ o(function(r) {
      return r !== r;
    }, "isNaN2");
  }
}), lI = me({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(e, t) {
    var r = sI();
    t.exports = /* @__PURE__ */ o(function(n) {
      return r(n) || n === 0 ? n : n < 0 ? -1 : 1;
    }, "sign");
  }
}), uI = me({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(e, t) {
    t.exports = Object.getOwnPropertyDescriptor;
  }
}), fp = me({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(e, t) {
    var r = uI();
    if (r)
      try {
        r([], "length");
      } catch {
        r = null;
      }
    t.exports = r;
  }
}), cI = me({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(e, t) {
    var r = Object.defineProperty || !1;
    if (r)
      try {
        r({}, "a", { value: 1 });
      } catch {
        r = !1;
      }
    t.exports = r;
  }
}), Xv = me({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(e, t) {
    t.exports = /* @__PURE__ */ o(function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
      if (typeof Symbol.iterator == "symbol")
        return !0;
      var r = {}, n = Symbol("test"), a = Object(n);
      if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
        return !1;
      var i = 42;
      r[n] = i;
      for (var s in r)
        return !1;
      if (typeof Object.keys == "function" && Object.keys(r).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r).length !== 0)
        return !1;
      var l = Object.getOwnPropertySymbols(r);
      if (l.length !== 1 || l[0] !== n || !Object.prototype.propertyIsEnumerable.call(r, n))
        return !1;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var c = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(r, n)
        );
        if (c.value !== i || c.enumerable !== !0)
          return !1;
      }
      return !0;
    }, "hasSymbols");
  }
}), Qv = me({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(e, t) {
    var r = typeof Symbol < "u" && Symbol, n = Xv();
    t.exports = /* @__PURE__ */ o(function() {
      return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : n();
    }, "hasNativeSymbols");
  }
}), Zv = me({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
  }
}), ew = me({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(e, t) {
    var r = Yv();
    t.exports = r.getPrototypeOf || null;
  }
}), dI = me({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(e, t) {
    var r = "Function.prototype.bind called on incompatible ", n = Object.prototype.toString, a = Math.max, i = "[object Function]", s = /* @__PURE__ */ o(function(u, p) {
      for (var f = [], m = 0; m < u.length; m += 1)
        f[m] = u[m];
      for (var y = 0; y < p.length; y += 1)
        f[y + u.length] = p[y];
      return f;
    }, "concatty2"), l = /* @__PURE__ */ o(function(u, p) {
      for (var f = [], m = p || 0, y = 0; m < u.length; m += 1, y += 1)
        f[y] = u[m];
      return f;
    }, "slicy2"), c = /* @__PURE__ */ o(function(u, p) {
      for (var f = "", m = 0; m < u.length; m += 1)
        f += u[m], m + 1 < u.length && (f += p);
      return f;
    }, "joiny");
    t.exports = /* @__PURE__ */ o(function(u) {
      var p = this;
      if (typeof p != "function" || n.apply(p) !== i)
        throw new TypeError(r + p);
      for (var f = l(arguments, 1), m, y = /* @__PURE__ */ o(function() {
        if (this instanceof m) {
          var E = p.apply(
            this,
            s(f, arguments)
          );
          return Object(E) === E ? E : this;
        }
        return p.apply(
          u,
          s(f, arguments)
        );
      }, "binder"), g = a(0, p.length - f.length), v = [], _ = 0; _ < g; _++)
        v[_] = "$" + _;
      if (m = Function("binder", "return function (" + c(v, ",") + "){ return binder.apply(this,arguments); }")(y), p.prototype) {
        var b = /* @__PURE__ */ o(function() {
        }, "Empty2");
        b.prototype = p.prototype, m.prototype = new b(), b.prototype = null;
      }
      return m;
    }, "bind");
  }
}), Ds = me({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(e, t) {
    var r = dI();
    t.exports = Function.prototype.bind || r;
  }
}), mp = me({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(e, t) {
    t.exports = Function.prototype.call;
  }
}), tw = me({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(e, t) {
    t.exports = Function.prototype.apply;
  }
}), pI = me({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(e, t) {
    t.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
  }
}), fI = me({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(e, t) {
    var r = Ds(), n = tw(), a = mp(), i = pI();
    t.exports = i || r.call(a, n);
  }
}), rw = me({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(e, t) {
    var r = Ds(), n = pp(), a = mp(), i = fI();
    t.exports = /* @__PURE__ */ o(function(s) {
      if (s.length < 1 || typeof s[0] != "function")
        throw new n("a function is required");
      return i(r, a, s);
    }, "callBindBasic");
  }
}), mI = me({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(e, t) {
    var r = rw(), n = fp(), a;
    try {
      a = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (c) {
      if (!c || typeof c != "object" || !("code" in c) || c.code !== "ERR_PROTO_ACCESS")
        throw c;
    }
    var i = !!a && n && n(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), s = Object, l = s.getPrototypeOf;
    t.exports = i && typeof i.get == "function" ? r([i.get]) : typeof l == "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ o(function(c) {
        return l(c == null ? c : s(c));
      }, "getDunder")
    ) : !1;
  }
}), hI = me({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(e, t) {
    var r = Zv(), n = ew(), a = mI();
    t.exports = r ? /* @__PURE__ */ o(function(i) {
      return r(i);
    }, "getProto") : n ? /* @__PURE__ */ o(function(i) {
      if (!i || typeof i != "object" && typeof i != "function")
        throw new TypeError("getProto: not an object");
      return n(i);
    }, "getProto") : a ? /* @__PURE__ */ o(function(i) {
      return a(i);
    }, "getProto") : null;
  }
}), nw = me({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(e, t) {
    var r = Function.prototype.call, n = Object.prototype.hasOwnProperty, a = Ds();
    t.exports = a.call(r, n);
  }
}), yI = me({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(e, t) {
    var r, n = Yv(), a = K1(), i = Y1(), s = X1(), l = Q1(), c = Z1(), u = pp(), p = eI(), f = tI(), m = rI(), y = nI(), g = oI(), v = aI(), _ = iI(), b = lI(), E = Function, C = /* @__PURE__ */ o(function(L) {
      try {
        return E('"use strict"; return (' + L + ").constructor;")();
      } catch {
      }
    }, "getEvalledConstructor"), k = fp(), N = cI(), O = /* @__PURE__ */ o(function() {
      throw new u();
    }, "throwTypeError"), S = k ? (function() {
      try {
        return arguments.callee, O;
      } catch {
        try {
          return k(arguments, "callee").get;
        } catch {
          return O;
        }
      }
    })() : O, w = Qv()(), T = hI(), M = ew(), R = Zv(), D = tw(), J = mp(), P = {}, q = typeof Uint8Array > "u" || !T ? r : T(Uint8Array), $ = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
      "%ArrayIteratorPrototype%": w && T ? T([][Symbol.iterator]()) : r,
      "%AsyncFromSyncIteratorPrototype%": r,
      "%AsyncFunction%": P,
      "%AsyncGenerator%": P,
      "%AsyncGeneratorFunction%": P,
      "%AsyncIteratorPrototype%": P,
      "%Atomics%": typeof Atomics > "u" ? r : Atomics,
      "%BigInt%": typeof BigInt > "u" ? r : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? r : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": a,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": i,
      "%Float16Array%": typeof Float16Array > "u" ? r : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
      "%Function%": E,
      "%GeneratorFunction%": P,
      "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": w && T ? T(T([][Symbol.iterator]())) : r,
      "%JSON%": typeof JSON == "object" ? JSON : r,
      "%Map%": typeof Map > "u" ? r : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !w || !T ? r : T((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": n,
      "%Object.getOwnPropertyDescriptor%": k,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? r : Promise,
      "%Proxy%": typeof Proxy > "u" ? r : Proxy,
      "%RangeError%": s,
      "%ReferenceError%": l,
      "%Reflect%": typeof Reflect > "u" ? r : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? r : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !w || !T ? r : T((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": w && T ? T(""[Symbol.iterator]()) : r,
      "%Symbol%": w ? Symbol : r,
      "%SyntaxError%": c,
      "%ThrowTypeError%": S,
      "%TypedArray%": q,
      "%TypeError%": u,
      "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
      "%URIError%": p,
      "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet,
      "%Function.prototype.call%": J,
      "%Function.prototype.apply%": D,
      "%Object.defineProperty%": N,
      "%Object.getPrototypeOf%": M,
      "%Math.abs%": f,
      "%Math.floor%": m,
      "%Math.max%": y,
      "%Math.min%": g,
      "%Math.pow%": v,
      "%Math.round%": _,
      "%Math.sign%": b,
      "%Reflect.getPrototypeOf%": R
    };
    if (T)
      try {
        null.error;
      } catch (L) {
        H = T(T(L)), $["%Error.prototype%"] = H;
      }
    var H, z = /* @__PURE__ */ o(function L(K) {
      var Q;
      if (K === "%AsyncFunction%")
        Q = C("async function () {}");
      else if (K === "%GeneratorFunction%")
        Q = C("function* () {}");
      else if (K === "%AsyncGeneratorFunction%")
        Q = C("async function* () {}");
      else if (K === "%AsyncGenerator%") {
        var se = L("%AsyncGeneratorFunction%");
        se && (Q = se.prototype);
      } else if (K === "%AsyncIteratorPrototype%") {
        var re = L("%AsyncGenerator%");
        re && T && (Q = T(re.prototype));
      }
      return $[K] = Q, Q;
    }, "doEval2"), Z = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, oe = Ds(), ie = nw(), Y = oe.call(J, Array.prototype.concat), be = oe.call(D, Array.prototype.splice), we = oe.call(J, String.prototype.replace), le = oe.call(J, String.prototype.slice), X = oe.call(J, RegExp.prototype.exec), Re = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Pe = /\\(\\)?/g, lt = /* @__PURE__ */ o(function(L) {
      var K = le(L, 0, 1), Q = le(L, -1);
      if (K === "%" && Q !== "%")
        throw new c("invalid intrinsic syntax, expected closing `%`");
      if (Q === "%" && K !== "%")
        throw new c("invalid intrinsic syntax, expected opening `%`");
      var se = [];
      return we(L, Re, function(re, he, ce, Ce) {
        se[se.length] = ce ? we(Ce, Pe, "$1") : he || re;
      }), se;
    }, "stringToPath3"), rt = /* @__PURE__ */ o(function(L, K) {
      var Q = L, se;
      if (ie(Z, Q) && (se = Z[Q], Q = "%" + se[0] + "%"), ie($, Q)) {
        var re = $[Q];
        if (re === P && (re = z(Q)), typeof re > "u" && !K)
          throw new u("intrinsic " + L + " exists, but is not available. Please file an issue!");
        return {
          alias: se,
          name: Q,
          value: re
        };
      }
      throw new c("intrinsic " + L + " does not exist!");
    }, "getBaseIntrinsic2");
    t.exports = /* @__PURE__ */ o(function(L, K) {
      if (typeof L != "string" || L.length === 0)
        throw new u("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof K != "boolean")
        throw new u('"allowMissing" argument must be a boolean');
      if (X(/^%?[^%]*%?$/, L) === null)
        throw new c("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var Q = lt(L), se = Q.length > 0 ? Q[0] : "", re = rt("%" + se + "%", K), he = re.name, ce = re.value, Ce = !1, Xe = re.alias;
      Xe && (se = Xe[0], be(Q, Y([0, 1], Xe)));
      for (var mt = 1, Ct = !0; mt < Q.length; mt += 1) {
        var ct = Q[mt], cr = le(ct, 0, 1), Dt = le(ct, -1);
        if ((cr === '"' || cr === "'" || cr === "`" || Dt === '"' || Dt === "'" || Dt === "`") && cr !== Dt)
          throw new c("property names with quotes must have matching quotes");
        if ((ct === "constructor" || !Ct) && (Ce = !0), se += "." + ct, he = "%" + se + "%", ie($, he))
          ce = $[he];
        else if (ce != null) {
          if (!(ct in ce)) {
            if (!K)
              throw new u("base intrinsic for " + L + " exists, but the property is not available.");
            return;
          }
          if (k && mt + 1 >= Q.length) {
            var Ft = k(ce, ct);
            Ct = !!Ft, Ct && "get" in Ft && !("originalValue" in Ft.get) ? ce = Ft.get : ce = ce[ct];
          } else
            Ct = ie(ce, ct), ce = ce[ct];
          Ct && !Ce && ($[he] = ce);
        }
      }
      return ce;
    }, "GetIntrinsic");
  }
}), hp = me({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(e, t) {
    var r = yI(), n = rw(), a = n([r("%String.prototype.indexOf%")]);
    t.exports = /* @__PURE__ */ o(function(i, s) {
      var l = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        r(i, !!s)
      );
      return typeof l == "function" && a(i, ".prototype.") > -1 ? n(
        /** @type {const} */
        [l]
      ) : l;
    }, "callBoundIntrinsic");
  }
}), gI = me({
  "node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(e, t) {
    var r = Xv();
    t.exports = /* @__PURE__ */ o(function() {
      return r() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
}), ow = me({
  "node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js"(e, t) {
    var r = hp(), n = gI()(), a = nw(), i = fp(), s;
    n ? (l = r("RegExp.prototype.exec"), c = {}, u = /* @__PURE__ */ o(function() {
      throw c;
    }, "throwRegexMarker"), p = {
      toString: u,
      valueOf: u
    }, typeof Symbol.toPrimitive == "symbol" && (p[Symbol.toPrimitive] = u), s = /* @__PURE__ */ o(function(y) {
      if (!y || typeof y != "object")
        return !1;
      var g = (
        /** @type {NonNullable<typeof gOPD>} */
        i(
          /** @type {{ lastIndex?: unknown }} */
          y,
          "lastIndex"
        )
      ), v = g && a(g, "value");
      if (!v)
        return !1;
      try {
        l(
          y,
          /** @type {string} */
          /** @type {unknown} */
          p
        );
      } catch (_) {
        return _ === c;
      }
    }, "isRegex")) : (f = r("Object.prototype.toString"), m = "[object RegExp]", s = /* @__PURE__ */ o(function(y) {
      return !y || typeof y != "object" && typeof y != "function" ? !1 : f(y) === m;
    }, "isRegex"));
    var l, c, u, p, f, m;
    t.exports = s;
  }
}), bI = me({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(e, t) {
    t.exports = n;
    var r = Object.prototype.toString;
    function n(a) {
      if (!a)
        return !1;
      var i = r.call(a);
      return i === "[object Function]" || typeof a == "function" && i !== "[object RegExp]" || typeof window < "u" && // IE8 and below
      (a === window.setTimeout || a === window.alert || a === window.confirm || a === window.prompt);
    }
    o(n, "isFunction3");
  }
}), vI = me({
  "node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js"(e, t) {
    var r = hp(), n = ow(), a = r("RegExp.prototype.exec"), i = pp();
    t.exports = /* @__PURE__ */ o(function(s) {
      if (!n(s))
        throw new i("`regex` must be a RegExp");
      return /* @__PURE__ */ o(function(l) {
        return a(s, l) !== null;
      }, "test");
    }, "regexTester");
  }
}), wI = me({
  "node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js"(e, t) {
    var r = hp(), n = r("Object.prototype.toString"), a = Qv()(), i = vI();
    a ? (s = r("Symbol.prototype.toString"), l = i(/^Symbol\(.*\)$/), c = /* @__PURE__ */ o(function(u) {
      return typeof u.valueOf() != "symbol" ? !1 : l(s(u));
    }, "isRealSymbolObject"), t.exports = /* @__PURE__ */ o(function(u) {
      if (typeof u == "symbol")
        return !0;
      if (!u || typeof u != "object" || n(u) !== "[object Symbol]")
        return !1;
      try {
        return c(u);
      } catch {
        return !1;
      }
    }, "isSymbol3")) : t.exports = /* @__PURE__ */ o(function(u) {
      return !1;
    }, "isSymbol3");
    var s, l, c;
  }
}), _I = dp(ow()), EI = dp(bI()), xI = dp(wI());
function aw(e) {
  return e != null && typeof e == "object" && Array.isArray(e) === !1;
}
o(aw, "isObject");
var TI = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, SI = TI, PI = typeof self == "object" && self && self.Object === Object && self, OI = SI || PI || Function("return this")(), yp = OI, CI = yp.Symbol, ao = CI, iw = Object.prototype, AI = iw.hasOwnProperty, RI = iw.toString, Uo = ao ? ao.toStringTag : void 0;
function sw(e) {
  var t = AI.call(e, Uo), r = e[Uo];
  try {
    e[Uo] = void 0;
    var n = !0;
  } catch {
  }
  var a = RI.call(e);
  return n && (t ? e[Uo] = r : delete e[Uo]), a;
}
o(sw, "getRawTag");
var kI = sw, II = Object.prototype, jI = II.toString;
function lw(e) {
  return jI.call(e);
}
o(lw, "objectToString");
var NI = lw, qI = "[object Null]", MI = "[object Undefined]", vy = ao ? ao.toStringTag : void 0;
function uw(e) {
  return e == null ? e === void 0 ? MI : qI : vy && vy in Object(e) ? kI(e) : NI(e);
}
o(uw, "baseGetTag");
var cw = uw;
function dw(e) {
  return e != null && typeof e == "object";
}
o(dw, "isObjectLike");
var $I = dw, LI = "[object Symbol]";
function pw(e) {
  return typeof e == "symbol" || $I(e) && cw(e) == LI;
}
o(pw, "isSymbol");
var gp = pw;
function fw(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, a = Array(n); ++r < n; )
    a[r] = t(e[r], r, e);
  return a;
}
o(fw, "arrayMap");
var DI = fw, FI = Array.isArray, bp = FI, wy = ao ? ao.prototype : void 0, _y = wy ? wy.toString : void 0;
function vp(e) {
  if (typeof e == "string")
    return e;
  if (bp(e))
    return DI(e, vp) + "";
  if (gp(e))
    return _y ? _y.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
o(vp, "baseToString");
var BI = vp;
function mw(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
o(mw, "isObject2");
var hw = mw, UI = "[object AsyncFunction]", HI = "[object Function]", VI = "[object GeneratorFunction]", JI = "[object Proxy]";
function yw(e) {
  if (!hw(e))
    return !1;
  var t = cw(e);
  return t == HI || t == VI || t == UI || t == JI;
}
o(yw, "isFunction");
var zI = yw, WI = yp["__core-js_shared__"], Cu = WI, Ey = (function() {
  var e = /[^.]+$/.exec(Cu && Cu.keys && Cu.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function gw(e) {
  return !!Ey && Ey in e;
}
o(gw, "isMasked");
var GI = gw, KI = Function.prototype, YI = KI.toString;
function bw(e) {
  if (e != null) {
    try {
      return YI.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
o(bw, "toSource");
var XI = bw, QI = /[\\^$.*+?()[\]{}|]/g, ZI = /^\[object .+?Constructor\]$/, ej = Function.prototype, tj = Object.prototype, rj = ej.toString, nj = tj.hasOwnProperty, oj = RegExp(
  "^" + rj.call(nj).replace(QI, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function vw(e) {
  if (!hw(e) || GI(e))
    return !1;
  var t = zI(e) ? oj : ZI;
  return t.test(XI(e));
}
o(vw, "baseIsNative");
var aj = vw;
function ww(e, t) {
  return e?.[t];
}
o(ww, "getValue");
var ij = ww;
function _w(e, t) {
  var r = ij(e, t);
  return aj(r) ? r : void 0;
}
o(_w, "getNative");
var Ew = _w;
function xw(e, t) {
  return e === t || e !== e && t !== t;
}
o(xw, "eq");
var sj = xw, lj = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, uj = /^\w*$/;
function Tw(e, t) {
  if (bp(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || gp(e) ? !0 : uj.test(e) || !lj.test(e) || t != null && e in Object(t);
}
o(Tw, "isKey");
var cj = Tw, dj = Ew(Object, "create"), ya = dj;
function Sw() {
  this.__data__ = ya ? ya(null) : {}, this.size = 0;
}
o(Sw, "hashClear");
var pj = Sw;
function Pw(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
o(Pw, "hashDelete");
var fj = Pw, mj = "__lodash_hash_undefined__", hj = Object.prototype, yj = hj.hasOwnProperty;
function Ow(e) {
  var t = this.__data__;
  if (ya) {
    var r = t[e];
    return r === mj ? void 0 : r;
  }
  return yj.call(t, e) ? t[e] : void 0;
}
o(Ow, "hashGet");
var gj = Ow, bj = Object.prototype, vj = bj.hasOwnProperty;
function Cw(e) {
  var t = this.__data__;
  return ya ? t[e] !== void 0 : vj.call(t, e);
}
o(Cw, "hashHas");
var wj = Cw, _j = "__lodash_hash_undefined__";
function Aw(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = ya && t === void 0 ? _j : t, this;
}
o(Aw, "hashSet");
var Ej = Aw;
function Rn(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(Rn, "Hash");
Rn.prototype.clear = pj;
Rn.prototype.delete = fj;
Rn.prototype.get = gj;
Rn.prototype.has = wj;
Rn.prototype.set = Ej;
var xy = Rn;
function Rw() {
  this.__data__ = [], this.size = 0;
}
o(Rw, "listCacheClear");
var xj = Rw;
function kw(e, t) {
  for (var r = e.length; r--; )
    if (sj(e[r][0], t))
      return r;
  return -1;
}
o(kw, "assocIndexOf");
var Fs = kw, Tj = Array.prototype, Sj = Tj.splice;
function Iw(e) {
  var t = this.__data__, r = Fs(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : Sj.call(t, r, 1), --this.size, !0;
}
o(Iw, "listCacheDelete");
var Pj = Iw;
function jw(e) {
  var t = this.__data__, r = Fs(t, e);
  return r < 0 ? void 0 : t[r][1];
}
o(jw, "listCacheGet");
var Oj = jw;
function Nw(e) {
  return Fs(this.__data__, e) > -1;
}
o(Nw, "listCacheHas");
var Cj = Nw;
function qw(e, t) {
  var r = this.__data__, n = Fs(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
o(qw, "listCacheSet");
var Aj = qw;
function kn(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(kn, "ListCache");
kn.prototype.clear = xj;
kn.prototype.delete = Pj;
kn.prototype.get = Oj;
kn.prototype.has = Cj;
kn.prototype.set = Aj;
var Rj = kn, kj = Ew(yp, "Map"), Ij = kj;
function Mw() {
  this.size = 0, this.__data__ = {
    hash: new xy(),
    map: new (Ij || Rj)(),
    string: new xy()
  };
}
o(Mw, "mapCacheClear");
var jj = Mw;
function $w(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
o($w, "isKeyable");
var Nj = $w;
function Lw(e, t) {
  var r = e.__data__;
  return Nj(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
o(Lw, "getMapData");
var Bs = Lw;
function Dw(e) {
  var t = Bs(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
o(Dw, "mapCacheDelete");
var qj = Dw;
function Fw(e) {
  return Bs(this, e).get(e);
}
o(Fw, "mapCacheGet");
var Mj = Fw;
function Bw(e) {
  return Bs(this, e).has(e);
}
o(Bw, "mapCacheHas");
var $j = Bw;
function Uw(e, t) {
  var r = Bs(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
o(Uw, "mapCacheSet");
var Lj = Uw;
function In(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
o(In, "MapCache");
In.prototype.clear = jj;
In.prototype.delete = qj;
In.prototype.get = Mj;
In.prototype.has = $j;
In.prototype.set = Lj;
var Hw = In, Dj = "Expected a function";
function Us(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Dj);
  var r = /* @__PURE__ */ o(function() {
    var n = arguments, a = t ? t.apply(this, n) : n[0], i = r.cache;
    if (i.has(a))
      return i.get(a);
    var s = e.apply(this, n);
    return r.cache = i.set(a, s) || i, s;
  }, "memoized");
  return r.cache = new (Us.Cache || Hw)(), r;
}
o(Us, "memoize");
Us.Cache = Hw;
var Fj = Us, Bj = 500;
function Vw(e) {
  var t = Fj(e, function(n) {
    return r.size === Bj && r.clear(), n;
  }), r = t.cache;
  return t;
}
o(Vw, "memoizeCapped");
var Uj = Vw, Hj = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Vj = /\\(\\)?/g, Jj = Uj(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Hj, function(r, n, a, i) {
    t.push(a ? i.replace(Vj, "$1") : n || r);
  }), t;
}), zj = Jj;
function Jw(e) {
  return e == null ? "" : BI(e);
}
o(Jw, "toString");
var Wj = Jw;
function zw(e, t) {
  return bp(e) ? e : cj(e, t) ? [e] : zj(Wj(e));
}
o(zw, "castPath");
var Gj = zw;
function Ww(e) {
  if (typeof e == "string" || gp(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
o(Ww, "toKey");
var Kj = Ww;
function Gw(e, t) {
  t = Gj(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[Kj(t[r++])];
  return r && r == n ? e : void 0;
}
o(Gw, "baseGet");
var Yj = Gw;
function Kw(e, t, r) {
  var n = e == null ? void 0 : Yj(e, t);
  return n === void 0 ? r : n;
}
o(Kw, "get");
var Xj = Kw, wp = aw, Qj = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/, _p = /* @__PURE__ */ o((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), "isJSON");
function Ep(e) {
  if (!wp(e))
    return e;
  let t = e, r = !1;
  return typeof Event < "u" && e instanceof Event && (t = Kv(t), r = !0), t = Object.keys(t).reduce((n, a) => {
    try {
      t[a] && t[a].toJSON, n[a] = t[a];
    } catch {
      r = !0;
    }
    return n;
  }, {}), r ? t : e;
}
o(Ep, "convertUnconventionalData");
var Zj = /* @__PURE__ */ o(function(e) {
  let t, r, n, a;
  return /* @__PURE__ */ o(function(i, s) {
    try {
      if (i === "")
        return a = [], t = /* @__PURE__ */ new Map([[s, "[]"]]), r = /* @__PURE__ */ new Map(), n = [], s;
      const l = r.get(this) || this;
      for (; n.length && l !== n[0]; )
        n.shift(), a.pop();
      if (typeof s == "boolean")
        return s;
      if (s === void 0)
        return e.allowUndefined ? "_undefined_" : void 0;
      if (s === null)
        return null;
      if (typeof s == "number")
        return s === Number.NEGATIVE_INFINITY ? "_-Infinity_" : s === Number.POSITIVE_INFINITY ? "_Infinity_" : Number.isNaN(s) ? "_NaN_" : s;
      if (typeof s == "bigint")
        return `_bigint_${s.toString()}`;
      if (typeof s == "string")
        return Qj.test(s) ? e.allowDate ? `_date_${s}` : void 0 : s;
      if ((0, _I.default)(s))
        return e.allowRegExp ? `_regexp_${s.flags}|${s.source}` : void 0;
      if ((0, EI.default)(s))
        return;
      if ((0, xI.default)(s)) {
        if (!e.allowSymbol)
          return;
        const u = Symbol.keyFor(s);
        return u !== void 0 ? `_gsymbol_${u}` : `_symbol_${s.toString().slice(7, -1)}`;
      }
      if (n.length >= e.maxDepth)
        return Array.isArray(s) ? `[Array(${s.length})]` : "[Object]";
      if (s === this)
        return `_duplicate_${JSON.stringify(a)}`;
      if (s instanceof Error && e.allowError)
        return {
          __isConvertedError__: !0,
          errorProperties: {
            // @ts-expect-error cause is not defined in the current tsconfig target(es2020)
            ...s.cause ? { cause: s.cause } : {},
            ...s,
            name: s.name,
            message: s.message,
            stack: s.stack,
            "_constructor-name_": s.constructor.name
          }
        };
      if (s?.constructor?.name && s.constructor.name !== "Object" && !Array.isArray(s)) {
        const u = t.get(s);
        if (!u) {
          const p = {
            __isClassInstance__: !0,
            __className__: s.constructor.name,
            ...Object.getOwnPropertyNames(s).reduce(
              (f, m) => {
                try {
                  f[m] = s[m];
                } catch {
                }
                return f;
              },
              {}
            )
          };
          return a.push(i), n.unshift(p), t.set(s, JSON.stringify(a)), s !== p && r.set(s, p), p;
        }
        return `_duplicate_${u}`;
      }
      const c = t.get(s);
      if (!c) {
        const u = Array.isArray(s) ? s : Ep(s);
        return a.push(i), n.unshift(u), t.set(s, JSON.stringify(a)), s !== u && r.set(s, u), u;
      }
      return `_duplicate_${c}`;
    } catch {
      return;
    }
  }, "replace");
}, "replacer2"), eN = /* @__PURE__ */ o(function(e) {
  const t = [];
  let r;
  return /* @__PURE__ */ o(function(n, a) {
    if (n === "" && (r = a, t.forEach(({ target: i, container: s, replacement: l }) => {
      const c = _p(l) ? JSON.parse(l) : l.split(".");
      c.length === 0 ? s[i] = r : s[i] = Xj(r, c);
    })), n === "_constructor-name_")
      return a;
    if (wp(a) && a.__isConvertedError__) {
      const { message: i, ...s } = a.errorProperties, l = new Error(i);
      return Object.assign(l, s), l;
    }
    if (typeof a == "string" && a.startsWith("_regexp_") && e.allowRegExp) {
      const [, i, s] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
      return new RegExp(s, i);
    }
    return typeof a == "string" && a.startsWith("_date_") && e.allowDate ? new Date(a.replace("_date_", "")) : typeof a == "string" && a.startsWith("_duplicate_") ? (t.push({ target: n, container: this, replacement: a.replace(/^_duplicate_/, "") }), null) : typeof a == "string" && a.startsWith("_symbol_") && e.allowSymbol ? Symbol(a.replace("_symbol_", "")) : typeof a == "string" && a.startsWith("_gsymbol_") && e.allowSymbol ? Symbol.for(a.replace("_gsymbol_", "")) : typeof a == "string" && a === "_-Infinity_" ? Number.NEGATIVE_INFINITY : typeof a == "string" && a === "_Infinity_" ? Number.POSITIVE_INFINITY : typeof a == "string" && a === "_NaN_" ? Number.NaN : typeof a == "string" && a.startsWith("_bigint_") && typeof BigInt == "function" ? BigInt(a.replace("_bigint_", "")) : a;
  }, "revive");
}, "reviver2"), Yw = {
  maxDepth: 10,
  space: void 0,
  allowRegExp: !0,
  allowDate: !0,
  allowError: !0,
  allowUndefined: !0,
  allowSymbol: !0
}, Xw = /* @__PURE__ */ o((e, t = {}) => {
  const r = { ...Yw, ...t };
  return JSON.stringify(Ep(e), Zj(r), t.space);
}, "stringify"), tN = /* @__PURE__ */ o(() => {
  const e = /* @__PURE__ */ new Map();
  return /* @__PURE__ */ o(function t(r) {
    wp(r) && Object.entries(r).forEach(([n, a]) => {
      a === "_undefined_" ? r[n] = void 0 : e.get(a) || (e.set(a, !0), t(a));
    }), Array.isArray(r) && r.forEach((n, a) => {
      n === "_undefined_" ? (e.set(n, !0), r[a] = void 0) : e.get(n) || (e.set(n, !0), t(n));
    });
  }, "mutateUndefined");
}, "mutator"), Qw = /* @__PURE__ */ o((e, t = {}) => {
  const r = { ...Yw, ...t }, n = JSON.parse(e, eN(r));
  return tN()(n), n;
}, "parse"), { LOGLEVEL: rN } = ee, $r = {
  trace: 1,
  debug: 2,
  info: 3,
  warn: 4,
  error: 5,
  silent: 10
}, nN = rN, Ln = $r[nN] || $r.info, qe = {
  trace: /* @__PURE__ */ o((e, ...t) => {
    Ln <= $r.trace && console.trace(e, ...t);
  }, "trace"),
  debug: /* @__PURE__ */ o((e, ...t) => {
    Ln <= $r.debug && console.debug(e, ...t);
  }, "debug"),
  info: /* @__PURE__ */ o((e, ...t) => {
    Ln <= $r.info && console.info(e, ...t);
  }, "info"),
  warn: /* @__PURE__ */ o((e, ...t) => {
    Ln <= $r.warn && console.warn(e, ...t);
  }, "warn"),
  error: /* @__PURE__ */ o((e, ...t) => {
    Ln <= $r.error && console.error(e, ...t);
  }, "error"),
  log: /* @__PURE__ */ o((e, ...t) => {
    Ln < $r.silent && console.log(e, ...t);
  }, "log")
}, tc = /* @__PURE__ */ new Set(), Ue = /* @__PURE__ */ o((e) => (t, ...r) => {
  if (!tc.has(t))
    return tc.add(t), qe[e](t, ...r);
}, "once");
Ue.clear = () => tc.clear();
Ue.trace = Ue("trace");
Ue.debug = Ue("debug");
Ue.info = Ue("info");
Ue.warn = Ue("warn");
Ue.error = Ue("error");
Ue.log = Ue("log");
var Zw = Ue("warn"), qt = /* @__PURE__ */ o((e) => (...t) => {
  const r = [];
  if (t.length) {
    const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi, a = /<\/span>/gi;
    let i;
    for (r.push(t[0].replace(n, "%c").replace(a, "%c")); i = n.exec(t[0]); )
      r.push(i[2]), r.push("");
    for (let s = 1; s < t.length; s++)
      r.push(t[s]);
  }
  qe[e].apply(qe, r);
}, "pretty");
qt.trace = qt("trace");
qt.debug = qt("debug");
qt.info = qt("info");
qt.warn = qt("warn");
qt.error = qt("error");
var xp = /* @__PURE__ */ ((e) => (e.CHANNEL_WS_DISCONNECT = "channelWSDisconnect", e.CHANNEL_CREATED = "channelCreated", e.CONFIG_ERROR = "configError", e.STORY_INDEX_INVALIDATED = "storyIndexInvalidated", e.STORY_SPECIFIED = "storySpecified", e.SET_CONFIG = "setConfig", e.SET_STORIES = "setStories", e.SET_INDEX = "setIndex", e.SET_CURRENT_STORY = "setCurrentStory", e.CURRENT_STORY_WAS_SET = "currentStoryWasSet", e.FORCE_RE_RENDER = "forceReRender", e.FORCE_REMOUNT = "forceRemount", e.PRELOAD_ENTRIES = "preloadStories", e.STORY_PREPARED = "storyPrepared", e.DOCS_PREPARED = "docsPrepared", e.STORY_CHANGED = "storyChanged", e.STORY_UNCHANGED = "storyUnchanged", e.STORY_RENDERED = "storyRendered", e.STORY_FINISHED = "storyFinished", e.STORY_MISSING = "storyMissing", e.STORY_ERRORED = "storyErrored", e.STORY_THREW_EXCEPTION = "storyThrewException", e.STORY_RENDER_PHASE_CHANGED = "storyRenderPhaseChanged", e.STORY_HOT_UPDATED = "storyHotUpdated", e.PLAY_FUNCTION_THREW_EXCEPTION = "playFunctionThrewException", e.UNHANDLED_ERRORS_WHILE_PLAYING = "unhandledErrorsWhilePlaying", e.UPDATE_STORY_ARGS = "updateStoryArgs", e.STORY_ARGS_UPDATED = "storyArgsUpdated", e.RESET_STORY_ARGS = "resetStoryArgs", e.SET_FILTER = "setFilter", e.SET_GLOBALS = "setGlobals", e.UPDATE_GLOBALS = "updateGlobals", e.GLOBALS_UPDATED = "globalsUpdated", e.REGISTER_SUBSCRIPTION = "registerSubscription", e.PREVIEW_INITIALIZED = "previewInitialized", e.PREVIEW_KEYDOWN = "previewKeydown", e.PREVIEW_BUILDER_PROGRESS = "preview_builder_progress", e.SELECT_STORY = "selectStory", e.STORIES_COLLAPSE_ALL = "storiesCollapseAll", e.STORIES_EXPAND_ALL = "storiesExpandAll", e.DOCS_RENDERED = "docsRendered", e.SHARED_STATE_CHANGED = "sharedStateChanged", e.SHARED_STATE_SET = "sharedStateSet", e.NAVIGATE_URL = "navigateUrl", e.UPDATE_QUERY_PARAMS = "updateQueryParams", e.REQUEST_WHATS_NEW_DATA = "requestWhatsNewData", e.RESULT_WHATS_NEW_DATA = "resultWhatsNewData", e.SET_WHATS_NEW_CACHE = "setWhatsNewCache", e.TOGGLE_WHATS_NEW_NOTIFICATIONS = "toggleWhatsNewNotifications", e.TELEMETRY_ERROR = "telemetryError", e.FILE_COMPONENT_SEARCH_REQUEST = "fileComponentSearchRequest", e.FILE_COMPONENT_SEARCH_RESPONSE = "fileComponentSearchResponse", e.SAVE_STORY_REQUEST = "saveStoryRequest", e.SAVE_STORY_RESPONSE = "saveStoryResponse", e.ARGTYPES_INFO_REQUEST = "argtypesInfoRequest", e.ARGTYPES_INFO_RESPONSE = "argtypesInfoResponse", e.CREATE_NEW_STORYFILE_REQUEST = "createNewStoryfileRequest", e.CREATE_NEW_STORYFILE_RESPONSE = "createNewStoryfileResponse", e.OPEN_IN_EDITOR_REQUEST = "openInEditorRequest", e.OPEN_IN_EDITOR_RESPONSE = "openInEditorResponse", e))(xp || {}), oN = xp, {
  CHANNEL_WS_DISCONNECT: e_,
  CHANNEL_CREATED: aN,
  CONFIG_ERROR: t_,
  CREATE_NEW_STORYFILE_REQUEST: iN,
  CREATE_NEW_STORYFILE_RESPONSE: sN,
  CURRENT_STORY_WAS_SET: rc,
  DOCS_PREPARED: r_,
  DOCS_RENDERED: Tp,
  FILE_COMPONENT_SEARCH_REQUEST: lN,
  FILE_COMPONENT_SEARCH_RESPONSE: uN,
  FORCE_RE_RENDER: Sp,
  FORCE_REMOUNT: Hi,
  GLOBALS_UPDATED: ga,
  NAVIGATE_URL: cN,
  PLAY_FUNCTION_THREW_EXCEPTION: n_,
  UNHANDLED_ERRORS_WHILE_PLAYING: o_,
  PRELOAD_ENTRIES: a_,
  PREVIEW_INITIALIZED: i_,
  PREVIEW_BUILDER_PROGRESS: dN,
  PREVIEW_KEYDOWN: s_,
  REGISTER_SUBSCRIPTION: pN,
  RESET_STORY_ARGS: Pp,
  SELECT_STORY: fN,
  SET_CONFIG: mN,
  SET_CURRENT_STORY: Op,
  SET_FILTER: hN,
  SET_GLOBALS: l_,
  SET_INDEX: yN,
  SET_STORIES: gN,
  SHARED_STATE_CHANGED: bN,
  SHARED_STATE_SET: vN,
  STORIES_COLLAPSE_ALL: wN,
  STORIES_EXPAND_ALL: _N,
  STORY_ARGS_UPDATED: u_,
  STORY_CHANGED: c_,
  STORY_ERRORED: d_,
  STORY_INDEX_INVALIDATED: p_,
  STORY_MISSING: nc,
  STORY_PREPARED: f_,
  STORY_RENDER_PHASE_CHANGED: vn,
  STORY_RENDERED: Vi,
  STORY_FINISHED: oc,
  STORY_SPECIFIED: m_,
  STORY_THREW_EXCEPTION: h_,
  STORY_UNCHANGED: y_,
  STORY_HOT_UPDATED: g_,
  UPDATE_GLOBALS: Cp,
  UPDATE_QUERY_PARAMS: b_,
  UPDATE_STORY_ARGS: Ap,
  REQUEST_WHATS_NEW_DATA: EN,
  RESULT_WHATS_NEW_DATA: xN,
  SET_WHATS_NEW_CACHE: TN,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: SN,
  TELEMETRY_ERROR: PN,
  SAVE_STORY_REQUEST: ON,
  SAVE_STORY_RESPONSE: CN,
  ARGTYPES_INFO_REQUEST: v_,
  ARGTYPES_INFO_RESPONSE: ac,
  OPEN_IN_EDITOR_REQUEST: AN,
  OPEN_IN_EDITOR_RESPONSE: RN
} = xp;
const kN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ARGTYPES_INFO_REQUEST: v_,
  ARGTYPES_INFO_RESPONSE: ac,
  CHANNEL_CREATED: aN,
  CHANNEL_WS_DISCONNECT: e_,
  CONFIG_ERROR: t_,
  CREATE_NEW_STORYFILE_REQUEST: iN,
  CREATE_NEW_STORYFILE_RESPONSE: sN,
  CURRENT_STORY_WAS_SET: rc,
  DOCS_PREPARED: r_,
  DOCS_RENDERED: Tp,
  FILE_COMPONENT_SEARCH_REQUEST: lN,
  FILE_COMPONENT_SEARCH_RESPONSE: uN,
  FORCE_REMOUNT: Hi,
  FORCE_RE_RENDER: Sp,
  GLOBALS_UPDATED: ga,
  NAVIGATE_URL: cN,
  OPEN_IN_EDITOR_REQUEST: AN,
  OPEN_IN_EDITOR_RESPONSE: RN,
  PLAY_FUNCTION_THREW_EXCEPTION: n_,
  PRELOAD_ENTRIES: a_,
  PREVIEW_BUILDER_PROGRESS: dN,
  PREVIEW_INITIALIZED: i_,
  PREVIEW_KEYDOWN: s_,
  REGISTER_SUBSCRIPTION: pN,
  REQUEST_WHATS_NEW_DATA: EN,
  RESET_STORY_ARGS: Pp,
  RESULT_WHATS_NEW_DATA: xN,
  SAVE_STORY_REQUEST: ON,
  SAVE_STORY_RESPONSE: CN,
  SELECT_STORY: fN,
  SET_CONFIG: mN,
  SET_CURRENT_STORY: Op,
  SET_FILTER: hN,
  SET_GLOBALS: l_,
  SET_INDEX: yN,
  SET_STORIES: gN,
  SET_WHATS_NEW_CACHE: TN,
  SHARED_STATE_CHANGED: bN,
  SHARED_STATE_SET: vN,
  STORIES_COLLAPSE_ALL: wN,
  STORIES_EXPAND_ALL: _N,
  STORY_ARGS_UPDATED: u_,
  STORY_CHANGED: c_,
  STORY_ERRORED: d_,
  STORY_FINISHED: oc,
  STORY_HOT_UPDATED: g_,
  STORY_INDEX_INVALIDATED: p_,
  STORY_MISSING: nc,
  STORY_PREPARED: f_,
  STORY_RENDERED: Vi,
  STORY_RENDER_PHASE_CHANGED: vn,
  STORY_SPECIFIED: m_,
  STORY_THREW_EXCEPTION: h_,
  STORY_UNCHANGED: y_,
  TELEMETRY_ERROR: PN,
  TOGGLE_WHATS_NEW_NOTIFICATIONS: SN,
  UNHANDLED_ERRORS_WHILE_PLAYING: o_,
  UPDATE_GLOBALS: Cp,
  UPDATE_QUERY_PARAMS: b_,
  UPDATE_STORY_ARGS: Ap,
  default: oN
}, Symbol.toStringTag, { value: "Module" }));
var IN = /* @__PURE__ */ o((e) => e.transports !== void 0, "isMulti"), jN = /* @__PURE__ */ o(() => Math.random().toString(16).slice(2), "generateRandomId"), w_ = class {
  constructor(e = {}) {
    this.sender = jN(), this.events = {}, this.data = {}, this.transports = [], this.isAsync = e.async || !1, IN(e) ? (this.transports = e.transports || [], this.transports.forEach((t) => {
      t.setHandler((r) => this.handleEvent(r));
    })) : this.transports = e.transport ? [e.transport] : [], this.transports.forEach((t) => {
      t.setHandler((r) => this.handleEvent(r));
    });
  }
  get hasTransport() {
    return this.transports.length > 0;
  }
  addListener(e, t) {
    this.events[e] = this.events[e] || [], this.events[e].push(t);
  }
  emit(e, ...t) {
    const r = { type: e, args: t, from: this.sender };
    let n = {};
    t.length >= 1 && t[0] && t[0].options && (n = t[0].options);
    const a = /* @__PURE__ */ o(() => {
      this.transports.forEach((i) => {
        i.send(r, n);
      }), this.handleEvent(r);
    }, "handler");
    this.isAsync ? setImmediate(a) : a();
  }
  last(e) {
    return this.data[e];
  }
  eventNames() {
    return Object.keys(this.events);
  }
  listenerCount(e) {
    const t = this.listeners(e);
    return t ? t.length : 0;
  }
  listeners(e) {
    return this.events[e] || void 0;
  }
  once(e, t) {
    const r = this.onceListener(e, t);
    this.addListener(e, r);
  }
  removeAllListeners(e) {
    e ? this.events[e] && delete this.events[e] : this.events = {};
  }
  removeListener(e, t) {
    const r = this.listeners(e);
    r && (this.events[e] = r.filter((n) => n !== t));
  }
  on(e, t) {
    this.addListener(e, t);
  }
  off(e, t) {
    this.removeListener(e, t);
  }
  handleEvent(e) {
    const t = this.listeners(e.type);
    t && t.length && t.forEach((r) => {
      r.apply(e, e.args);
    }), this.data[e.type] = e.args;
  }
  onceListener(e, t) {
    const r = /* @__PURE__ */ o((...n) => (this.removeListener(e, r), t(...n)), "onceListener");
    return r;
  }
};
o(w_, "Channel");
var __ = w_, NN = /* @__PURE__ */ o((e) => {
  const t = Array.from(
    document.querySelectorAll("iframe[data-is-storybook]")
  ), [r, ...n] = t.filter((i) => {
    try {
      return i.contentWindow?.location.origin === e.source.location.origin && i.contentWindow?.location.pathname === e.source.location.pathname;
    } catch {
    }
    try {
      return i.contentWindow === e.source;
    } catch {
    }
    const s = i.getAttribute("src");
    let l;
    try {
      if (!s)
        return !1;
      ({ origin: l } = new URL(s, document.location.toString()));
    } catch {
      return !1;
    }
    return l === e.origin;
  }), a = r?.getAttribute("src");
  if (a && n.length === 0) {
    const { protocol: i, host: s, pathname: l } = new URL(a, document.location.toString());
    return `${i}//${s}${l}`;
  }
  return n.length > 0 && qe.error("found multiple candidates for event source"), null;
}, "getEventSourceUrl"), { document: Au, location: Ru } = ee, Ty = "storybook-channel", qN = { maxDepth: 25 }, E_ = class {
  constructor(e) {
    if (this.config = e, this.connected = !1, this.buffer = [], typeof ee?.addEventListener == "function" && ee.addEventListener("message", this.handleEvent.bind(this), !1), e.page !== "manager" && e.page !== "preview")
      throw new Error(`postmsg-channel: "config.page" cannot be "${e.page}"`);
  }
  setHandler(e) {
    this.handler = (...t) => {
      e.apply(this, t), !this.connected && this.getLocalFrame().length && (this.flush(), this.connected = !0);
    };
  }
  /**
   * Sends `event` to the associated window. If the window does not yet exist the event will be
   * stored in a buffer and sent when the window exists.
   *
   * @param event
   */
  send(e, t) {
    const {
      target: r,
      // telejson options
      allowRegExp: n,
      allowSymbol: a,
      allowDate: i,
      allowError: s,
      allowUndefined: l,
      maxDepth: c,
      space: u
    } = t || {}, p = Object.fromEntries(
      Object.entries({
        allowRegExp: n,
        allowSymbol: a,
        allowDate: i,
        allowError: s,
        allowUndefined: l,
        maxDepth: c,
        space: u
      }).filter(([v, _]) => typeof _ < "u")
    ), f = {
      ...qN,
      ...ee.CHANNEL_OPTIONS || {},
      ...p
    }, m = this.getFrames(r), y = new URLSearchParams(Ru?.search || ""), g = Xw(
      {
        key: Ty,
        event: e,
        refId: y.get("refId")
      },
      f
    );
    return m.length ? (this.buffer.length && this.flush(), m.forEach((v) => {
      try {
        v.postMessage(g, "*");
      } catch {
        qe.error("sending over postmessage fail");
      }
    }), Promise.resolve(null)) : new Promise((v, _) => {
      this.buffer.push({ event: e, resolve: v, reject: _ });
    });
  }
  flush() {
    const { buffer: e } = this;
    this.buffer = [], e.forEach((t) => {
      this.send(t.event).then(t.resolve).catch(t.reject);
    });
  }
  getFrames(e) {
    if (this.config.page === "manager") {
      const t = Array.from(
        Au.querySelectorAll("iframe[data-is-storybook][data-is-loaded]")
      ).flatMap((r) => {
        try {
          return r.contentWindow && r.dataset.isStorybook !== void 0 && r.id === e ? [r.contentWindow] : [];
        } catch {
          return [];
        }
      });
      return t?.length ? t : this.getCurrentFrames();
    }
    return ee && ee.parent && ee.parent !== ee.self ? [ee.parent] : [];
  }
  getCurrentFrames() {
    return this.config.page === "manager" ? Array.from(
      Au.querySelectorAll('[data-is-storybook="true"]')
    ).flatMap((e) => e.contentWindow ? [e.contentWindow] : []) : ee && ee.parent ? [ee.parent] : [];
  }
  getLocalFrame() {
    return this.config.page === "manager" ? Array.from(
      Au.querySelectorAll("#storybook-preview-iframe")
    ).flatMap((e) => e.contentWindow ? [e.contentWindow] : []) : ee && ee.parent ? [ee.parent] : [];
  }
  handleEvent(e) {
    try {
      const { data: t } = e, { key: r, event: n, refId: a } = typeof t == "string" && _p(t) ? Qw(t, ee.CHANNEL_OPTIONS || {}) : t;
      if (r === Ty) {
        const i = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>', s = Object.values(kN).includes(n.type) ? `<span style="color: #FF4785">${n.type}</span>` : `<span style="color: #FFAE00">${n.type}</span>`;
        if (a && (n.refId = a), n.source = this.config.page === "preview" ? e.origin : NN(e), !n.source) {
          qt.error(
            `${i} received ${s} but was unable to determine the source of the event`
          );
          return;
        }
        const l = `${i} received ${s} (${t.length})`;
        qt.debug(
          Ru.origin !== n.source ? l : `${l} <span style="color: gray">(on ${Ru.origin} from ${n.source})</span>`,
          ...n.args
        ), nr(this.handler, "ChannelHandler should be set"), this.handler(n);
      }
    } catch (t) {
      qe.error(t);
    }
  }
};
o(E_, "PostMessageTransport");
var MN = E_, { WebSocket: $N } = ee, LN = 15e3, DN = 5e3, x_ = class {
  constructor({ url: e, onError: t, page: r }) {
    this.buffer = [], this.isReady = !1, this.isClosed = !1, this.pingTimeout = 0, this.socket = new $N(e), this.socket.onopen = () => {
      this.isReady = !0, this.heartbeat(), this.flush();
    }, this.socket.onmessage = ({ data: n }) => {
      const a = typeof n == "string" && _p(n) ? Qw(n) : n;
      nr(this.handler), this.handler(a), a.type === "ping" && (this.heartbeat(), this.send({ type: "pong" }));
    }, this.socket.onerror = (n) => {
      t && t(n);
    }, this.socket.onclose = (n) => {
      nr(this.handler), this.handler({
        type: e_,
        args: [{ reason: n.reason, code: n.code }],
        from: r || "preview"
      }), this.isClosed = !0, clearTimeout(this.pingTimeout);
    };
  }
  heartbeat() {
    clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      this.socket.close(3008, "timeout");
    }, LN + DN);
  }
  setHandler(e) {
    this.handler = e;
  }
  send(e) {
    this.isClosed || (this.isReady ? this.sendNow(e) : this.sendLater(e));
  }
  sendLater(e) {
    this.buffer.push(e);
  }
  sendNow(e) {
    const t = Xw(e, {
      maxDepth: 15,
      ...ee.CHANNEL_OPTIONS
    });
    this.socket.send(t);
  }
  flush() {
    const { buffer: e } = this;
    this.buffer = [], e.forEach((t) => this.send(t));
  }
};
o(x_, "WebsocketTransport");
var FN = x_, { CONFIG_TYPE: BN } = ee;
function UN({ page: e, extraTransports: t = [] }) {
  const r = [new MN({ page: e }), ...t];
  if (BN === "DEVELOPMENT") {
    const a = window.location.protocol === "http:" ? "ws" : "wss", { hostname: i, port: s } = window.location, l = `${a}://${i}:${s}/storybook-server-channel`;
    r.push(new FN({ url: l, onError: /* @__PURE__ */ o(() => {
    }, "onError"), page: e }));
  }
  const n = new __({ transports: r });
  return Ou.__prepare(
    n,
    e === "manager" ? Ou.Environment.MANAGER : Ou.Environment.PREVIEW
  ), n;
}
o(UN, "createBrowserChannel");
var Ji = "backgrounds", HN = "measureEnabled", T_ = "outline", VN = {
  light: { name: "light", value: "#F8F8F8" },
  dark: { name: "dark", value: "#333" }
}, Hs = "storybook/highlight", JN = `${Hs}/add`, zN = `${Hs}/remove`, WN = `${Hs}/reset`, GN = `${Hs}/scroll-into-view`, Sy = 2147483647, Lr = 28, KN = "storybook/actions", YN = `${KN}/action-event`, XN = {
  depth: 10,
  clearOnStoryChange: !0,
  limit: 50
}, S_ = /* @__PURE__ */ o((e, t) => {
  const r = Object.getPrototypeOf(e);
  return !r || t(r) ? r : S_(r, t);
}, "findProto"), QN = /* @__PURE__ */ o((e) => !!(typeof e == "object" && e && S_(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) && typeof e.persist == "function"), "isReactSyntheticEvent"), ZN = /* @__PURE__ */ o((e) => {
  if (QN(e)) {
    const t = Object.create(
      e.constructor.prototype,
      Object.getOwnPropertyDescriptors(e)
    );
    t.persist();
    const r = Object.getOwnPropertyDescriptor(t, "view"), n = r?.value;
    return typeof n == "object" && n?.constructor.name === "Window" && Object.defineProperty(t, "view", {
      ...r,
      value: Object.create(n.constructor.prototype)
    }), t;
  }
  return e;
}, "serializeArg");
function Vs(e, t = {}) {
  const r = {
    ...XN,
    ...t
  }, n = /* @__PURE__ */ o(function(...a) {
    if (t.implicit) {
      const f = ("__STORYBOOK_PREVIEW__" in ee ? ee.__STORYBOOK_PREVIEW__ : void 0)?.storyRenders.find(
        (m) => m.phase === "playing" || m.phase === "rendering"
      );
      if (f) {
        const m = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8, y = new zk({
          phase: f.phase,
          name: e,
          deprecated: m
        });
        if (m)
          console.warn(y);
        else
          throw y;
      }
    }
    const i = zt.getChannel(), s = Date.now().toString(36) + Math.random().toString(36).substring(2), l = 5, c = a.map(ZN), u = a.length > 1 ? c : c[0], p = {
      id: s,
      count: 0,
      data: { name: e, args: u },
      options: {
        ...r,
        maxDepth: l + (r.depth || 3)
      }
    };
    i.emit(YN, p);
  }, "actionHandler");
  return n.isAction = !0, n.implicit = t.implicit, n;
}
o(Vs, "action");
var eq = "viewport", P_ = F({
  "../node_modules/picocolors/picocolors.browser.js"(e, t) {
    var r = String, n = /* @__PURE__ */ o(function() {
      return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
    }, "create");
    t.exports = n(), t.exports.createColors = n;
  }
}), tq = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, O_ = Object.entries(tq);
function Ha(e) {
  return String(e);
}
o(Ha, "a");
Ha.open = "";
Ha.close = "";
O_.reduce(
  (e, [t]) => (e[t] = Ha, e),
  { isColorSupported: !1 }
);
function C_(e = !1) {
  let t = typeof process < "u" ? process : void 0, r = t?.env || {}, n = t?.argv || [];
  return !("NO_COLOR" in r || n.includes("--no-color")) && ("FORCE_COLOR" in r || n.includes("--color") || t?.platform === "win32" || e && r.TERM !== "dumb" || "CI" in r) || typeof window < "u" && !!window.chrome;
}
o(C_, "C");
function A_(e = !1) {
  let t = C_(e), r = /* @__PURE__ */ o((s, l, c, u) => {
    let p = "", f = 0;
    do
      p += s.substring(f, u) + c, f = u + l.length, u = s.indexOf(l, f);
    while (~u);
    return p + s.substring(f);
  }, "i"), n = /* @__PURE__ */ o((s, l, c = s) => {
    let u = /* @__PURE__ */ o((p) => {
      let f = String(p), m = f.indexOf(l, s.length);
      return ~m ? s + r(f, l, c, m) + l : s + f + l;
    }, "o");
    return u.open = s, u.close = l, u;
  }, "g"), a = {
    isColorSupported: t
  }, i = /* @__PURE__ */ o((s) => `\x1B[${s}m`, "d");
  for (let [s, l] of O_)
    a[s] = t ? n(
      i(l[0]),
      i(l[1]),
      l[2]
    ) : Ha;
  return a;
}
o(A_, "p");
var Be = A_();
function Rp(e, t) {
  return t.forEach(function(r) {
    r && typeof r != "string" && !Array.isArray(r) && Object.keys(r).forEach(function(n) {
      if (n !== "default" && !(n in e)) {
        var a = Object.getOwnPropertyDescriptor(r, n);
        Object.defineProperty(e, n, a.get ? a : {
          enumerable: !0,
          get: /* @__PURE__ */ o(function() {
            return r[n];
          }, "get")
        });
      }
    });
  }), Object.freeze(e);
}
o(Rp, "_mergeNamespaces");
function R_(e, t) {
  const r = Object.keys(e), n = t === null ? r : r.sort(t);
  if (Object.getOwnPropertySymbols)
    for (const a of Object.getOwnPropertySymbols(e))
      Object.getOwnPropertyDescriptor(e, a).enumerable && n.push(a);
  return n;
}
o(R_, "getKeysOfEnumerableProperties");
function Po(e, t, r, n, a, i, s = ": ") {
  let l = "", c = 0, u = e.next();
  if (!u.done) {
    l += t.spacingOuter;
    const p = r + t.indent;
    for (; !u.done; ) {
      if (l += p, c++ === t.maxWidth) {
        l += "â€¦";
        break;
      }
      const f = i(u.value[0], t, p, n, a), m = i(u.value[1], t, p, n, a);
      l += f + s + m, u = e.next(), u.done ? t.min || (l += ",") : l += `,${t.spacingInner}`;
    }
    l += t.spacingOuter + r;
  }
  return l;
}
o(Po, "printIteratorEntries");
function Js(e, t, r, n, a, i) {
  let s = "", l = 0, c = e.next();
  if (!c.done) {
    s += t.spacingOuter;
    const u = r + t.indent;
    for (; !c.done; ) {
      if (s += u, l++ === t.maxWidth) {
        s += "â€¦";
        break;
      }
      s += i(c.value, t, u, n, a), c = e.next(), c.done ? t.min || (s += ",") : s += `,${t.spacingInner}`;
    }
    s += t.spacingOuter + r;
  }
  return s;
}
o(Js, "printIteratorValues");
function ba(e, t, r, n, a, i) {
  let s = "";
  e = e instanceof ArrayBuffer ? new DataView(e) : e;
  const l = /* @__PURE__ */ o((u) => u instanceof DataView, "isDataView"), c = l(e) ? e.byteLength : e.length;
  if (c > 0) {
    s += t.spacingOuter;
    const u = r + t.indent;
    for (let p = 0; p < c; p++) {
      if (s += u, p === t.maxWidth) {
        s += "â€¦";
        break;
      }
      (l(e) || p in e) && (s += i(l(e) ? e.getInt8(p) : e[p], t, u, n, a)), p < c - 1 ? s += `,${t.spacingInner}` : t.min || (s += ",");
    }
    s += t.spacingOuter + r;
  }
  return s;
}
o(ba, "printListItems");
function zs(e, t, r, n, a, i) {
  let s = "";
  const l = R_(e, t.compareKeys);
  if (l.length > 0) {
    s += t.spacingOuter;
    const c = r + t.indent;
    for (let u = 0; u < l.length; u++) {
      const p = l[u], f = i(p, t, c, n, a), m = i(e[p], t, c, n, a);
      s += `${c + f}: ${m}`, u < l.length - 1 ? s += `,${t.spacingInner}` : t.min || (s += ",");
    }
    s += t.spacingOuter + r;
  }
  return s;
}
o(zs, "printObjectProperties");
var rq = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, ku = " ", nq = /* @__PURE__ */ o((e, t, r, n, a, i) => {
  const s = e.toString();
  if (s === "ArrayContaining" || s === "ArrayNotContaining")
    return ++n > t.maxDepth ? `[${s}]` : `${s + ku}[${ba(e.sample, t, r, n, a, i)}]`;
  if (s === "ObjectContaining" || s === "ObjectNotContaining")
    return ++n > t.maxDepth ? `[${s}]` : `${s + ku}{${zs(e.sample, t, r, n, a, i)}}`;
  if (s === "StringMatching" || s === "StringNotMatching" || s === "StringContaining" || s === "StringNotContaining")
    return s + ku + i(e.sample, t, r, n, a);
  if (typeof e.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`);
  return e.toAsymmetricMatcher();
}, "serialize$5"), oq = /* @__PURE__ */ o((e) => e && e.$$typeof === rq, "test$5"), aq = {
  serialize: nq,
  test: oq
}, iq = " ", k_ = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), sq = /^(?:HTML\w*Collection|NodeList)$/;
function I_(e) {
  return k_.has(e) || sq.test(e);
}
o(I_, "testName");
var lq = /* @__PURE__ */ o((e) => e && e.constructor && !!e.constructor.name && I_(e.constructor.name), "test$4");
function j_(e) {
  return e.constructor.name === "NamedNodeMap";
}
o(j_, "isNamedNodeMap");
var uq = /* @__PURE__ */ o((e, t, r, n, a, i) => {
  const s = e.constructor.name;
  return ++n > t.maxDepth ? `[${s}]` : (t.min ? "" : s + iq) + (k_.has(s) ? `{${zs(j_(e) ? [...e].reduce((l, c) => (l[c.name] = c.value, l), {}) : { ...e }, t, r, n, a, i)}}` : `[${ba([...e], t, r, n, a, i)}]`);
}, "serialize$4"), cq = {
  serialize: uq,
  test: lq
};
function kp(e) {
  return e.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
o(kp, "escapeHTML");
function Ws(e, t, r, n, a, i, s) {
  const l = n + r.indent, c = r.colors;
  return e.map((u) => {
    const p = t[u];
    let f = s(p, r, l, a, i);
    return typeof p != "string" && (f.includes(`
`) && (f = r.spacingOuter + l + f + r.spacingOuter + n), f = `{${f}}`), `${r.spacingInner + n + c.prop.open + u + c.prop.close}=${c.value.open}${f}${c.value.close}`;
  }).join("");
}
o(Ws, "printProps");
function Gs(e, t, r, n, a, i) {
  return e.map((s) => t.spacingOuter + r + (typeof s == "string" ? Ip(s, t) : i(s, t, r, n, a))).join("");
}
o(Gs, "printChildren");
function Ip(e, t) {
  const r = t.colors.content;
  return r.open + kp(e) + r.close;
}
o(Ip, "printText");
function N_(e, t) {
  const r = t.colors.comment;
  return `${r.open}<!--${kp(e)}-->${r.close}`;
}
o(N_, "printComment");
function Ks(e, t, r, n, a) {
  const i = n.colors.tag;
  return `${i.open}<${e}${t && i.close + t + n.spacingOuter + a + i.open}${r ? `>${i.close}${r}${n.spacingOuter}${a}${i.open}</${e}` : `${t && !n.min ? "" : " "}/`}>${i.close}`;
}
o(Ks, "printElement");
function Ys(e, t) {
  const r = t.colors.tag;
  return `${r.open}<${e}${r.close} â€¦${r.open} />${r.close}`;
}
o(Ys, "printElementAsLeaf");
var dq = 1, q_ = 3, M_ = 8, $_ = 11, pq = /^(?:(?:HTML|SVG)\w*)?Element$/;
function L_(e) {
  try {
    return typeof e.hasAttribute == "function" && e.hasAttribute("is");
  } catch {
    return !1;
  }
}
o(L_, "testHasAttribute");
function D_(e) {
  const t = e.constructor.name, { nodeType: r, tagName: n } = e, a = typeof n == "string" && n.includes("-") || L_(e);
  return r === dq && (pq.test(t) || a) || r === q_ && t === "Text" || r === M_ && t === "Comment" || r === $_ && t === "DocumentFragment";
}
o(D_, "testNode");
var fq = /* @__PURE__ */ o((e) => {
  var t;
  return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && D_(e);
}, "test$3");
function F_(e) {
  return e.nodeType === q_;
}
o(F_, "nodeIsText");
function B_(e) {
  return e.nodeType === M_;
}
o(B_, "nodeIsComment");
function Ti(e) {
  return e.nodeType === $_;
}
o(Ti, "nodeIsFragment");
var mq = /* @__PURE__ */ o((e, t, r, n, a, i) => {
  if (F_(e))
    return Ip(e.data, t);
  if (B_(e))
    return N_(e.data, t);
  const s = Ti(e) ? "DocumentFragment" : e.tagName.toLowerCase();
  return ++n > t.maxDepth ? Ys(s, t) : Ks(s, Ws(Ti(e) ? [] : Array.from(e.attributes, (l) => l.name).sort(), Ti(e) ? {} : [...e.attributes].reduce((l, c) => (l[c.name] = c.value, l), {}), t, r + t.indent, n, a, i), Gs(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, a, i), t, r);
}, "serialize$3"), hq = {
  serialize: mq,
  test: fq
}, yq = "@@__IMMUTABLE_ITERABLE__@@", gq = "@@__IMMUTABLE_LIST__@@", bq = "@@__IMMUTABLE_KEYED__@@", vq = "@@__IMMUTABLE_MAP__@@", Py = "@@__IMMUTABLE_ORDERED__@@", wq = "@@__IMMUTABLE_RECORD__@@", _q = "@@__IMMUTABLE_SEQ__@@", Eq = "@@__IMMUTABLE_SET__@@", xq = "@@__IMMUTABLE_STACK__@@", io = /* @__PURE__ */ o((e) => `Immutable.${e}`, "getImmutableName"), Xs = /* @__PURE__ */ o((e) => `[${e}]`, "printAsLeaf"), va = " ", Oy = "â€¦";
function U_(e, t, r, n, a, i, s) {
  return ++n > t.maxDepth ? Xs(io(s)) : `${io(s) + va}{${Po(e.entries(), t, r, n, a, i)}}`;
}
o(U_, "printImmutableEntries");
function H_(e) {
  let t = 0;
  return { next() {
    if (t < e._keys.length) {
      const r = e._keys[t++];
      return {
        done: !1,
        value: [r, e.get(r)]
      };
    }
    return {
      done: !0,
      value: void 0
    };
  } };
}
o(H_, "getRecordEntries");
function V_(e, t, r, n, a, i) {
  const s = io(e._name || "Record");
  return ++n > t.maxDepth ? Xs(s) : `${s + va}{${Po(H_(e), t, r, n, a, i)}}`;
}
o(V_, "printImmutableRecord");
function J_(e, t, r, n, a, i) {
  const s = io("Seq");
  return ++n > t.maxDepth ? Xs(s) : e[bq] ? `${s + va}{${e._iter || e._object ? Po(e.entries(), t, r, n, a, i) : Oy}}` : `${s + va}[${e._iter || e._array || e._collection || e._iterable ? Js(e.values(), t, r, n, a, i) : Oy}]`;
}
o(J_, "printImmutableSeq");
function Si(e, t, r, n, a, i, s) {
  return ++n > t.maxDepth ? Xs(io(s)) : `${io(s) + va}[${Js(e.values(), t, r, n, a, i)}]`;
}
o(Si, "printImmutableValues");
var Tq = /* @__PURE__ */ o((e, t, r, n, a, i) => e[vq] ? U_(e, t, r, n, a, i, e[Py] ? "OrderedMap" : "Map") : e[gq] ? Si(e, t, r, n, a, i, "List") : e[Eq] ? Si(e, t, r, n, a, i, e[Py] ? "OrderedSet" : "Set") : e[xq] ? Si(e, t, r, n, a, i, "Stack") : e[_q] ? J_(e, t, r, n, a, i) : V_(e, t, r, n, a, i), "serialize$2"), Sq = /* @__PURE__ */ o((e) => e && (e[yq] === !0 || e[wq] === !0), "test$2"), Pq = {
  serialize: Tq,
  test: Sq
};
function jp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
o(jp, "getDefaultExportFromCjs");
var Cy = { exports: {} }, Ae = {}, Ay;
function z_() {
  if (Ay) return Ae;
  Ay = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), m = Symbol.for("react.view_transition"), y = Symbol.for("react.client.reference");
  function g(v) {
    if (typeof v == "object" && v !== null) {
      var _ = v.$$typeof;
      switch (_) {
        case e:
          switch (v = v.type, v) {
            case r:
            case a:
            case n:
            case c:
            case u:
            case m:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case l:
                case f:
                case p:
                  return v;
                case i:
                  return v;
                default:
                  return _;
              }
          }
        case t:
          return _;
      }
    }
  }
  return o(g, "typeOf"), Ae.ContextConsumer = i, Ae.ContextProvider = s, Ae.Element = e, Ae.ForwardRef = l, Ae.Fragment = r, Ae.Lazy = f, Ae.Memo = p, Ae.Portal = t, Ae.Profiler = a, Ae.StrictMode = n, Ae.Suspense = c, Ae.SuspenseList = u, Ae.isContextConsumer = function(v) {
    return g(v) === i;
  }, Ae.isContextProvider = function(v) {
    return g(v) === s;
  }, Ae.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, Ae.isForwardRef = function(v) {
    return g(v) === l;
  }, Ae.isFragment = function(v) {
    return g(v) === r;
  }, Ae.isLazy = function(v) {
    return g(v) === f;
  }, Ae.isMemo = function(v) {
    return g(v) === p;
  }, Ae.isPortal = function(v) {
    return g(v) === t;
  }, Ae.isProfiler = function(v) {
    return g(v) === a;
  }, Ae.isStrictMode = function(v) {
    return g(v) === n;
  }, Ae.isSuspense = function(v) {
    return g(v) === c;
  }, Ae.isSuspenseList = function(v) {
    return g(v) === u;
  }, Ae.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === a || v === n || v === c || v === u || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === p || v.$$typeof === s || v.$$typeof === i || v.$$typeof === l || v.$$typeof === y || v.getModuleId !== void 0);
  }, Ae.typeOf = g, Ae;
}
o(z_, "requireReactIs_production");
var Oq = {};
function Cq() {
  return Oq;
}
o(Cq, "requireReactIs_development$1");
var Ry;
function W_() {
  return Ry || (Ry = 1, Cy.exports = z_()), Cy.exports;
}
o(W_, "requireReactIs$1");
var G_ = W_(), Aq = jp(G_), Rq = Rp({
  __proto__: null,
  default: Aq
}, [G_]), ky = { exports: {} }, Se = {}, Iy;
function K_() {
  if (Iy) return Se;
  Iy = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), g;
  g = Symbol.for("react.module.reference");
  function v(_) {
    if (typeof _ == "object" && _ !== null) {
      var b = _.$$typeof;
      switch (b) {
        case e:
          switch (_ = _.type, _) {
            case r:
            case a:
            case n:
            case u:
            case p:
              return _;
            default:
              switch (_ = _ && _.$$typeof, _) {
                case l:
                case s:
                case c:
                case m:
                case f:
                case i:
                  return _;
                default:
                  return b;
              }
          }
        case t:
          return b;
      }
    }
  }
  return o(v, "v"), Se.ContextConsumer = s, Se.ContextProvider = i, Se.Element = e, Se.ForwardRef = c, Se.Fragment = r, Se.Lazy = m, Se.Memo = f, Se.Portal = t, Se.Profiler = a, Se.StrictMode = n, Se.Suspense = u, Se.SuspenseList = p, Se.isAsyncMode = function() {
    return !1;
  }, Se.isConcurrentMode = function() {
    return !1;
  }, Se.isContextConsumer = function(_) {
    return v(_) === s;
  }, Se.isContextProvider = function(_) {
    return v(_) === i;
  }, Se.isElement = function(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === e;
  }, Se.isForwardRef = function(_) {
    return v(_) === c;
  }, Se.isFragment = function(_) {
    return v(_) === r;
  }, Se.isLazy = function(_) {
    return v(_) === m;
  }, Se.isMemo = function(_) {
    return v(_) === f;
  }, Se.isPortal = function(_) {
    return v(_) === t;
  }, Se.isProfiler = function(_) {
    return v(_) === a;
  }, Se.isStrictMode = function(_) {
    return v(_) === n;
  }, Se.isSuspense = function(_) {
    return v(_) === u;
  }, Se.isSuspenseList = function(_) {
    return v(_) === p;
  }, Se.isValidElementType = function(_) {
    return typeof _ == "string" || typeof _ == "function" || _ === r || _ === a || _ === n || _ === u || _ === p || _ === y || typeof _ == "object" && _ !== null && (_.$$typeof === m || _.$$typeof === f || _.$$typeof === i || _.$$typeof === s || _.$$typeof === c || _.$$typeof === g || _.getModuleId !== void 0);
  }, Se.typeOf = v, Se;
}
o(K_, "requireReactIs_production_min");
var kq = {};
function Iq() {
  return kq;
}
o(Iq, "requireReactIs_development");
var jy;
function Y_() {
  return jy || (jy = 1, ky.exports = K_()), ky.exports;
}
o(Y_, "requireReactIs");
var X_ = Y_(), jq = jp(X_), Nq = Rp({
  __proto__: null,
  default: jq
}, [X_]), qq = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], sn = Object.fromEntries(qq.map((e) => [e, (t) => Nq[e](t) || Rq[e](t)]));
function Np(e, t = []) {
  if (Array.isArray(e))
    for (const r of e)
      Np(r, t);
  else e != null && e !== !1 && e !== "" && t.push(e);
  return t;
}
o(Np, "getChildren");
function ic(e) {
  const t = e.type;
  if (typeof t == "string")
    return t;
  if (typeof t == "function")
    return t.displayName || t.name || "Unknown";
  if (sn.isFragment(e))
    return "React.Fragment";
  if (sn.isSuspense(e))
    return "React.Suspense";
  if (typeof t == "object" && t !== null) {
    if (sn.isContextProvider(e))
      return "Context.Provider";
    if (sn.isContextConsumer(e))
      return "Context.Consumer";
    if (sn.isForwardRef(e)) {
      if (t.displayName)
        return t.displayName;
      const r = t.render.displayName || t.render.name || "";
      return r === "" ? "ForwardRef" : `ForwardRef(${r})`;
    }
    if (sn.isMemo(e)) {
      const r = t.displayName || t.type.displayName || t.type.name || "";
      return r === "" ? "Memo" : `Memo(${r})`;
    }
  }
  return "UNDEFINED";
}
o(ic, "getType");
function Q_(e) {
  const { props: t } = e;
  return Object.keys(t).filter((r) => r !== "children" && t[r] !== void 0).sort();
}
o(Q_, "getPropKeys$1");
var Mq = /* @__PURE__ */ o((e, t, r, n, a, i) => ++n > t.maxDepth ? Ys(ic(e), t) : Ks(ic(e), Ws(Q_(e), e.props, t, r + t.indent, n, a, i), Gs(Np(e.props.children), t, r + t.indent, n, a, i), t, r), "serialize$1"), $q = /* @__PURE__ */ o((e) => e != null && sn.isElement(e), "test$1"), Lq = {
  serialize: Mq,
  test: $q
}, Dq = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function Z_(e) {
  const { props: t } = e;
  return t ? Object.keys(t).filter((r) => t[r] !== void 0).sort() : [];
}
o(Z_, "getPropKeys");
var Fq = /* @__PURE__ */ o((e, t, r, n, a, i) => ++n > t.maxDepth ? Ys(e.type, t) : Ks(e.type, e.props ? Ws(Z_(e), e.props, t, r + t.indent, n, a, i) : "", e.children ? Gs(e.children, t, r + t.indent, n, a, i) : "", t, r), "serialize"), Bq = /* @__PURE__ */ o((e) => e && e.$$typeof === Dq, "test"), Uq = {
  serialize: Fq,
  test: Bq
}, eE = Object.prototype.toString, Hq = Date.prototype.toISOString, Vq = Error.prototype.toString, Ny = RegExp.prototype.toString;
function ra(e) {
  return typeof e.constructor == "function" && e.constructor.name || "Object";
}
o(ra, "getConstructorName");
function tE(e) {
  return typeof window < "u" && e === window;
}
o(tE, "isWindow");
var Jq = /^Symbol\((.*)\)(.*)$/, zq = /\n/g, rE = class extends Error {
  constructor(e, t) {
    super(e), this.stack = t, this.name = this.constructor.name;
  }
};
o(rE, "PrettyFormatPluginError");
var nE = rE;
function oE(e) {
  return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
}
o(oE, "isToStringedArrayType");
function aE(e) {
  return Object.is(e, -0) ? "-0" : String(e);
}
o(aE, "printNumber");
function iE(e) {
  return `${e}n`;
}
o(iE, "printBigInt");
function sc(e, t) {
  return t ? `[Function ${e.name || "anonymous"}]` : "[Function]";
}
o(sc, "printFunction");
function lc(e) {
  return String(e).replace(Jq, "Symbol($1)");
}
o(lc, "printSymbol");
function uc(e) {
  return `[${Vq.call(e)}]`;
}
o(uc, "printError");
function qp(e, t, r, n) {
  if (e === !0 || e === !1)
    return `${e}`;
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const a = typeof e;
  if (a === "number")
    return aE(e);
  if (a === "bigint")
    return iE(e);
  if (a === "string")
    return n ? `"${e.replaceAll(/"|\\/g, "\\$&")}"` : `"${e}"`;
  if (a === "function")
    return sc(e, t);
  if (a === "symbol")
    return lc(e);
  const i = eE.call(e);
  return i === "[object WeakMap]" ? "WeakMap {}" : i === "[object WeakSet]" ? "WeakSet {}" : i === "[object Function]" || i === "[object GeneratorFunction]" ? sc(e, t) : i === "[object Symbol]" ? lc(e) : i === "[object Date]" ? Number.isNaN(+e) ? "Date { NaN }" : Hq.call(e) : i === "[object Error]" ? uc(e) : i === "[object RegExp]" ? r ? Ny.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : Ny.call(e) : e instanceof Error ? uc(e) : null;
}
o(qp, "printBasicValue");
function Mp(e, t, r, n, a, i) {
  if (a.includes(e))
    return "[Circular]";
  a = [...a], a.push(e);
  const s = ++n > t.maxDepth, l = t.min;
  if (t.callToJSON && !s && e.toJSON && typeof e.toJSON == "function" && !i)
    return _r(e.toJSON(), t, r, n, a, !0);
  const c = eE.call(e);
  return c === "[object Arguments]" ? s ? "[Arguments]" : `${l ? "" : "Arguments "}[${ba(e, t, r, n, a, _r)}]` : oE(c) ? s ? `[${e.constructor.name}]` : `${l || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : `${e.constructor.name} `}[${ba(e, t, r, n, a, _r)}]` : c === "[object Map]" ? s ? "[Map]" : `Map {${Po(e.entries(), t, r, n, a, _r, " => ")}}` : c === "[object Set]" ? s ? "[Set]" : `Set {${Js(e.values(), t, r, n, a, _r)}}` : s || tE(e) ? `[${ra(e)}]` : `${l || !t.printBasicPrototype && ra(e) === "Object" ? "" : `${ra(e)} `}{${zs(e, t, r, n, a, _r)}}`;
}
o(Mp, "printComplexValue");
var Wq = {
  test: /* @__PURE__ */ o((e) => e && e instanceof Error, "test"),
  serialize(e, t, r, n, a, i) {
    if (a.includes(e))
      return "[Circular]";
    a = [...a, e];
    const s = ++n > t.maxDepth, { message: l, cause: c, ...u } = e, p = {
      message: l,
      ...typeof c < "u" ? { cause: c } : {},
      ...e instanceof AggregateError ? { errors: e.errors } : {},
      ...u
    }, f = e.name !== "Error" ? e.name : ra(e);
    return s ? `[${f}]` : `${f} {${Po(Object.entries(p).values(), t, r, n, a, i)}}`;
  }
};
function sE(e) {
  return e.serialize != null;
}
o(sE, "isNewPlugin");
function $p(e, t, r, n, a, i) {
  let s;
  try {
    s = sE(e) ? e.serialize(t, r, n, a, i, _r) : e.print(t, (l) => _r(l, r, n, a, i), (l) => {
      const c = n + r.indent;
      return c + l.replaceAll(zq, `
${c}`);
    }, {
      edgeSpacing: r.spacingOuter,
      min: r.min,
      spacing: r.spacingInner
    }, r.colors);
  } catch (l) {
    throw new nE(l.message, l.stack);
  }
  if (typeof s != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof s}".`);
  return s;
}
o($p, "printPlugin");
function Lp(e, t) {
  for (const r of e)
    try {
      if (r.test(t))
        return r;
    } catch (n) {
      throw new nE(n.message, n.stack);
    }
  return null;
}
o(Lp, "findPlugin");
function _r(e, t, r, n, a, i) {
  const s = Lp(t.plugins, e);
  if (s !== null)
    return $p(s, e, t, r, n, a);
  const l = qp(e, t.printFunctionName, t.escapeRegex, t.escapeString);
  return l !== null ? l : Mp(e, t, r, n, a, i);
}
o(_r, "printer");
var Dp = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, lE = Object.keys(Dp), Ht = {
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: Dp
};
function uE(e) {
  for (const t of Object.keys(e))
    if (!Object.prototype.hasOwnProperty.call(Ht, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  if (e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
o(uE, "validateOptions");
function cE() {
  return lE.reduce((e, t) => {
    const r = Dp[t], n = r && Be[r];
    if (n && typeof n.close == "string" && typeof n.open == "string")
      e[t] = n;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`);
    return e;
  }, /* @__PURE__ */ Object.create(null));
}
o(cE, "getColorsHighlight");
function dE() {
  return lE.reduce((e, t) => (e[t] = {
    close: "",
    open: ""
  }, e), /* @__PURE__ */ Object.create(null));
}
o(dE, "getColorsEmpty");
function Fp(e) {
  return e?.printFunctionName ?? Ht.printFunctionName;
}
o(Fp, "getPrintFunctionName");
function Bp(e) {
  return e?.escapeRegex ?? Ht.escapeRegex;
}
o(Bp, "getEscapeRegex");
function Up(e) {
  return e?.escapeString ?? Ht.escapeString;
}
o(Up, "getEscapeString");
function cc(e) {
  return {
    callToJSON: e?.callToJSON ?? Ht.callToJSON,
    colors: e?.highlight ? cE() : dE(),
    compareKeys: typeof e?.compareKeys == "function" || e?.compareKeys === null ? e.compareKeys : Ht.compareKeys,
    escapeRegex: Bp(e),
    escapeString: Up(e),
    indent: e?.min ? "" : pE(e?.indent ?? Ht.indent),
    maxDepth: e?.maxDepth ?? Ht.maxDepth,
    maxWidth: e?.maxWidth ?? Ht.maxWidth,
    min: e?.min ?? Ht.min,
    plugins: e?.plugins ?? Ht.plugins,
    printBasicPrototype: e?.printBasicPrototype ?? !0,
    printFunctionName: Fp(e),
    spacingInner: e?.min ? " " : `
`,
    spacingOuter: e?.min ? "" : `
`
  };
}
o(cc, "getConfig");
function pE(e) {
  return Array.from({ length: e + 1 }).join(" ");
}
o(pE, "createIndent");
function Jt(e, t) {
  if (t && (uE(t), t.plugins)) {
    const n = Lp(t.plugins, e);
    if (n !== null)
      return $p(n, e, cc(t), "", 0, []);
  }
  const r = qp(e, Fp(t), Bp(t), Up(t));
  return r !== null ? r : Mp(e, cc(t), "", 0, []);
}
o(Jt, "format");
var Hp = {
  AsymmetricMatcher: aq,
  DOMCollection: cq,
  DOMElement: hq,
  Immutable: Pq,
  ReactElement: Lq,
  ReactTestComponent: Uq,
  Error: Wq
}, qy = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, Gq = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, so = "â€¦";
function fE(e, t) {
  const r = qy[Gq[t]] || qy[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
o(fE, "colorise");
function mE({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: n = !0,
  showProxy: a = !1,
  maxArrayLength: i = 1 / 0,
  breakLength: s = 1 / 0,
  seen: l = [],
  // eslint-disable-next-line no-shadow
  truncate: c = 1 / 0,
  stylize: u = String
} = {}, p) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!a,
    maxArrayLength: Number(i),
    breakLength: Number(s),
    truncate: Number(c),
    seen: l,
    inspect: p,
    stylize: u
  };
  return f.colors && (f.stylize = fE), f;
}
o(mE, "normaliseOptions");
function hE(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
o(hE, "isHighSurrogate");
function Ar(e, t, r = so) {
  e = String(e);
  const n = r.length, a = e.length;
  if (n > t && a > n)
    return r;
  if (a > t && a > n) {
    let i = t - n;
    return i > 0 && hE(e[i - 1]) && (i = i - 1), `${e.slice(0, i)}${r}`;
  }
  return e;
}
o(Ar, "truncate");
function Mt(e, t, r, n = ", ") {
  r = r || t.inspect;
  const a = e.length;
  if (a === 0)
    return "";
  const i = t.truncate;
  let s = "", l = "", c = "";
  for (let u = 0; u < a; u += 1) {
    const p = u + 1 === e.length, f = u + 2 === e.length;
    c = `${so}(${e.length - u})`;
    const m = e[u];
    t.truncate = i - s.length - (p ? 0 : n.length);
    const y = l || r(m, t) + (p ? "" : n), g = s.length + y.length, v = g + c.length;
    if (p && g > i && s.length + c.length <= i || !p && !f && v > i || (l = p ? "" : r(e[u + 1], t) + (f ? "" : n), !p && f && v > i && g + l.length > i))
      break;
    if (s += y, !p && !f && g + l.length >= i) {
      c = `${so}(${e.length - u - 1})`;
      break;
    }
    c = "";
  }
  return `${s}${c}`;
}
o(Mt, "inspectList");
function yE(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
o(yE, "quoteComplexKey");
function lo([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = yE(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
o(lo, "inspectProperty");
function gE(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const n = Mt(e, t);
  t.truncate -= n.length;
  let a = "";
  return r.length && (a = Mt(r.map((i) => [i, e[i]]), t, lo)), `[ ${n}${a ? `, ${a}` : ""} ]`;
}
o(gE, "inspectArray");
var Kq = /* @__PURE__ */ o((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function Xt(e, t) {
  const r = Kq(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let a = "";
  for (let s = 0; s < e.length; s++) {
    const l = `${t.stylize(Ar(e[s], t.truncate), "number")}${s === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= l.length, e[s] !== e.length && t.truncate <= 3) {
      a += `${so}(${e.length - e[s] + 1})`;
      break;
    }
    a += l;
  }
  let i = "";
  return n.length && (i = Mt(n.map((s) => [s, e[s]]), t, lo)), `${r}[ ${a}${i ? `, ${i}` : ""} ]`;
}
o(Xt, "inspectTypedArray");
function bE(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const n = r.split("T"), a = n[0];
  return t.stylize(`${a}T${Ar(n[1], t.truncate - a.length - 1)}`, "date");
}
o(bE, "inspectDate");
function dc(e, t) {
  const r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${Ar(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
o(dc, "inspectFunction");
function vE([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
o(vE, "inspectMapEntry");
function wE(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
o(wE, "mapToEntries");
function _E(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Mt(wE(e), t, vE)} }`);
}
o(_E, "inspectMap");
var Yq = Number.isNaN || ((e) => e !== e);
function pc(e, t) {
  return Yq(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(Ar(String(e), t.truncate), "number");
}
o(pc, "inspectNumber");
function fc(e, t) {
  let r = Ar(e.toString(), t.truncate - 1);
  return r !== so && (r += "n"), t.stylize(r, "bigint");
}
o(fc, "inspectBigInt");
function EE(e, t) {
  const r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), a = e.source;
  return t.stylize(`/${Ar(a, n)}/${r}`, "regexp");
}
o(EE, "inspectRegExp");
function xE(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
o(xE, "arrayFromSet");
function TE(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Mt(xE(e), t)} }`);
}
o(TE, "inspectSet");
var My = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), Xq = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, Qq = 16;
function SE(e) {
  return Xq[e] || `\\u${`0000${e.charCodeAt(0).toString(Qq)}`.slice(-4)}`;
}
o(SE, "escape");
function mc(e, t) {
  return My.test(e) && (e = e.replace(My, SE)), t.stylize(`'${Ar(e, t.truncate - 2)}'`, "string");
}
o(mc, "inspectString");
function hc(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
o(hc, "inspectSymbol");
var Zq = /* @__PURE__ */ o(() => "Promise{â€¦}", "getPromiseValue"), eM = Zq;
function na(e, t) {
  const r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = Mt(r.map((l) => [l, e[l]]), t, lo), i = Mt(n.map((l) => [l, e[l]]), t, lo);
  t.seen.pop();
  let s = "";
  return a && i && (s = ", "), `{ ${a}${s}${i} }`;
}
o(na, "inspectObject");
var Iu = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function PE(e, t) {
  let r = "";
  return Iu && Iu in e && (r = e[Iu]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${na(e, t)}`;
}
o(PE, "inspectClass");
function OE(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Mt(e, t)} ]`);
}
o(OE, "inspectArguments");
var tM = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function CE(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((s) => tM.indexOf(s) === -1), n = e.name;
  t.truncate -= n.length;
  let a = "";
  if (typeof e.message == "string" ? a = Ar(e.message, t.truncate) : r.unshift("message"), a = a ? `: ${a}` : "", t.truncate -= a.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const i = Mt(r.map((s) => [s, e[s]]), t, lo);
  return `${n}${a}${i ? ` { ${i} }` : ""}`;
}
o(CE, "inspectObject");
function AE([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
o(AE, "inspectAttribute");
function zi(e, t) {
  return Mt(e, t, RE, `
`);
}
o(zi, "inspectNodeCollection");
function RE(e, t) {
  switch (e.nodeType) {
    case 1:
      return Vp(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
o(RE, "inspectNode");
function Vp(e, t) {
  const r = e.getAttributeNames(), n = e.tagName.toLowerCase(), a = t.stylize(`<${n}`, "special"), i = t.stylize(">", "special"), s = t.stylize(`</${n}>`, "special");
  t.truncate -= n.length * 2 + 5;
  let l = "";
  r.length > 0 && (l += " ", l += Mt(r.map((p) => [p, e.getAttribute(p)]), t, AE, " ")), t.truncate -= l.length;
  const c = t.truncate;
  let u = zi(e.children, t);
  return u && u.length > c && (u = `${so}(${e.children.length})`), `${a}${l}${i}${u}${s}`;
}
o(Vp, "inspectHTML");
var rM = typeof Symbol == "function" && typeof Symbol.for == "function", ju = rM ? Symbol.for("chai/inspect") : "@@chai/inspect", Nu = Symbol.for("nodejs.util.inspect.custom"), $y = /* @__PURE__ */ new WeakMap(), Ly = {}, Dy = {
  undefined: /* @__PURE__ */ o((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ o((e, t) => t.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ o((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ o((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: pc,
  Number: pc,
  bigint: fc,
  BigInt: fc,
  string: mc,
  String: mc,
  function: dc,
  Function: dc,
  symbol: hc,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: hc,
  Array: gE,
  Date: bE,
  Map: _E,
  Set: TE,
  RegExp: EE,
  Promise: eM,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ o((e, t) => t.stylize("WeakSet{â€¦}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ o((e, t) => t.stylize("WeakMap{â€¦}", "special"), "WeakMap"),
  Arguments: OE,
  Int8Array: Xt,
  Uint8Array: Xt,
  Uint8ClampedArray: Xt,
  Int16Array: Xt,
  Uint16Array: Xt,
  Int32Array: Xt,
  Uint32Array: Xt,
  Float32Array: Xt,
  Float64Array: Xt,
  Generator: /* @__PURE__ */ o(() => "", "Generator"),
  DataView: /* @__PURE__ */ o(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ o(() => "", "ArrayBuffer"),
  Error: CE,
  HTMLCollection: zi,
  NodeList: zi
}, nM = /* @__PURE__ */ o((e, t, r, n) => ju in e && typeof e[ju] == "function" ? e[ju](t) : Nu in e && typeof e[Nu] == "function" ? e[Nu](t.depth, t, n) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && $y.has(e.constructor) ? $y.get(e.constructor)(e, t) : Ly[r] ? Ly[r](e, t) : "", "inspectCustom"), oM = Object.prototype.toString;
function oa(e, t = {}) {
  const r = mE(t, oa), { customInspect: n } = r;
  let a = e === null ? "null" : typeof e;
  if (a === "object" && (a = oM.call(e).slice(8, -1)), a in Dy)
    return Dy[a](e, r);
  if (n && e) {
    const s = nM(e, r, a, oa);
    if (s)
      return typeof s == "string" ? s : oa(s, r);
  }
  const i = e ? Object.getPrototypeOf(e) : !1;
  return i === Object.prototype || i === null ? na(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? Vp(e, r) : "constructor" in e ? e.constructor !== Object ? PE(e, r) : na(e, r) : e === Object(e) ? na(e, r) : r.stylize(String(e), a);
}
o(oa, "inspect");
var { AsymmetricMatcher: aM, DOMCollection: iM, DOMElement: sM, Immutable: lM, ReactElement: uM, ReactTestComponent: cM } = Hp, Fy = [
  cM,
  uM,
  sM,
  iM,
  lM,
  aM
];
function dt(e, t = 10, { maxLength: r, ...n } = {}) {
  const a = r ?? 1e4;
  let i;
  try {
    i = Jt(e, {
      maxDepth: t,
      escapeString: !1,
      plugins: Fy,
      ...n
    });
  } catch {
    i = Jt(e, {
      callToJSON: !1,
      maxDepth: t,
      escapeString: !1,
      plugins: Fy,
      ...n
    });
  }
  return i.length >= a && t > 1 ? dt(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength: r,
    ...n
  }) : i;
}
o(dt, "stringify");
var dM = /%[sdjifoOc%]/g;
function kE(...e) {
  if (typeof e[0] != "string") {
    const i = [];
    for (let s = 0; s < e.length; s++)
      i.push(Bn(e[s], {
        depth: 0,
        colors: !1
      }));
    return i.join(" ");
  }
  const t = e.length;
  let r = 1;
  const n = e[0];
  let a = String(n).replace(dM, (i) => {
    if (i === "%%")
      return "%";
    if (r >= t)
      return i;
    switch (i) {
      case "%s": {
        const s = e[r++];
        return typeof s == "bigint" ? `${s.toString()}n` : typeof s == "number" && s === 0 && 1 / s < 0 ? "-0" : typeof s == "object" && s !== null ? typeof s.toString == "function" && s.toString !== Object.prototype.toString ? s.toString() : Bn(s, {
          depth: 0,
          colors: !1
        }) : String(s);
      }
      case "%d": {
        const s = e[r++];
        return typeof s == "bigint" ? `${s.toString()}n` : Number(s).toString();
      }
      case "%i": {
        const s = e[r++];
        return typeof s == "bigint" ? `${s.toString()}n` : Number.parseInt(String(s)).toString();
      }
      case "%f":
        return Number.parseFloat(String(e[r++])).toString();
      case "%o":
        return Bn(e[r++], {
          showHidden: !0,
          showProxy: !0
        });
      case "%O":
        return Bn(e[r++]);
      case "%c":
        return r++, "";
      case "%j":
        try {
          return JSON.stringify(e[r++]);
        } catch (s) {
          const l = s.message;
          if (l.includes("circular structure") || l.includes("cyclic structures") || l.includes("cyclic object"))
            return "[Circular]";
          throw s;
        }
      default:
        return i;
    }
  });
  for (let i = e[r]; r < t; i = e[++r])
    i === null || typeof i != "object" ? a += ` ${i}` : a += ` ${Bn(i)}`;
  return a;
}
o(kE, "format");
function Bn(e, t = {}) {
  return t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), oa(e, t);
}
o(Bn, "inspect");
function Jp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
o(Jp, "getDefaultExportFromCjs");
function Qt(e, t, r) {
  const n = typeof e;
  if (!r.includes(n))
    throw new TypeError(`${t} value must be ${r.join(" or ")}, received "${n}"`);
}
o(Qt, "assertTypes");
function aa(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
o(aa, "isObject");
function IE(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
o(IE, "isFinalObj");
function wa(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
o(wa, "getType");
function jE(e, t) {
  const r = typeof t == "function" ? t : (n) => t.add(n);
  Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r);
}
o(jE, "collectOwnProperties");
function zp(e) {
  const t = /* @__PURE__ */ new Set();
  return IE(e) ? [] : (jE(e, t), Array.from(t));
}
o(zp, "getOwnProperties");
var NE = { forceWritable: !1 };
function yc(e, t = NE) {
  return Wi(e, /* @__PURE__ */ new WeakMap(), t);
}
o(yc, "deepClone");
function Wi(e, t, r = NE) {
  let n, a;
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    for (a = Array.from({ length: n = e.length }), t.set(e, a); n--; )
      a[n] = Wi(e[n], t, r);
    return a;
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
    a = Object.create(Object.getPrototypeOf(e)), t.set(e, a);
    const i = zp(e);
    for (const s of i) {
      const l = Object.getOwnPropertyDescriptor(e, s);
      if (!l)
        continue;
      const c = Wi(e[s], t, r);
      r.forceWritable ? Object.defineProperty(a, s, {
        enumerable: l.enumerable,
        configurable: !0,
        writable: !0,
        value: c
      }) : "get" in l ? Object.defineProperty(a, s, {
        ...l,
        get() {
          return c;
        }
      }) : Object.defineProperty(a, s, {
        ...l,
        value: c
      });
    }
    return a;
  }
  return e;
}
o(Wi, "clone");
function qE() {
}
o(qE, "noop");
var at = -1, Qe = 1, Fe = 0, ME = class {
  0;
  1;
  constructor(e, t) {
    this[0] = e, this[1] = t;
  }
};
o(ME, "Diff");
var Le = ME;
function $E(e, t) {
  if (!e || !t || e.charAt(0) !== t.charAt(0))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), a = n, i = 0;
  for (; r < a; )
    e.substring(i, a) === t.substring(i, a) ? (r = a, i = r) : n = a, a = Math.floor((n - r) / 2 + r);
  return a;
}
o($E, "diff_commonPrefix");
function Wp(e, t) {
  if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1))
    return 0;
  let r = 0, n = Math.min(e.length, t.length), a = n, i = 0;
  for (; r < a; )
    e.substring(e.length - a, e.length - i) === t.substring(t.length - a, t.length - i) ? (r = a, i = r) : n = a, a = Math.floor((n - r) / 2 + r);
  return a;
}
o(Wp, "diff_commonSuffix");
function gc(e, t) {
  const r = e.length, n = t.length;
  if (r === 0 || n === 0)
    return 0;
  r > n ? e = e.substring(r - n) : r < n && (t = t.substring(0, r));
  const a = Math.min(r, n);
  if (e === t)
    return a;
  let i = 0, s = 1;
  for (; ; ) {
    const l = e.substring(a - s), c = t.indexOf(l);
    if (c === -1)
      return i;
    s += c, (c === 0 || e.substring(a - s) === t.substring(0, s)) && (i = s, s++);
  }
}
o(gc, "diff_commonOverlap_");
function LE(e) {
  let t = !1;
  const r = [];
  let n = 0, a = null, i = 0, s = 0, l = 0, c = 0, u = 0;
  for (; i < e.length; )
    e[i][0] === Fe ? (r[n++] = i, s = c, l = u, c = 0, u = 0, a = e[i][1]) : (e[i][0] === Qe ? c += e[i][1].length : u += e[i][1].length, a && a.length <= Math.max(s, l) && a.length <= Math.max(c, u) && (e.splice(r[n - 1], 0, new Le(at, a)), e[r[n - 1] + 1][0] = Qe, n--, n--, i = n > 0 ? r[n - 1] : -1, s = 0, l = 0, c = 0, u = 0, a = null, t = !0)), i++;
  for (t && Gp(e), DE(e), i = 1; i < e.length; ) {
    if (e[i - 1][0] === at && e[i][0] === Qe) {
      const p = e[i - 1][1], f = e[i][1], m = gc(p, f), y = gc(f, p);
      m >= y ? (m >= p.length / 2 || m >= f.length / 2) && (e.splice(i, 0, new Le(Fe, f.substring(0, m))), e[i - 1][1] = p.substring(0, p.length - m), e[i + 1][1] = f.substring(m), i++) : (y >= p.length / 2 || y >= f.length / 2) && (e.splice(i, 0, new Le(Fe, p.substring(0, y))), e[i - 1][0] = Qe, e[i - 1][1] = f.substring(0, f.length - y), e[i + 1][0] = at, e[i + 1][1] = p.substring(y), i++), i++;
    }
    i++;
  }
}
o(LE, "diff_cleanupSemantic");
var By = /[^a-z0-9]/i, Uy = /\s/, Hy = /[\r\n]/, pM = /\n\r?\n$/, fM = /^\r?\n\r?\n/;
function DE(e) {
  let t = 1;
  for (; t < e.length - 1; ) {
    if (e[t - 1][0] === Fe && e[t + 1][0] === Fe) {
      let r = e[t - 1][1], n = e[t][1], a = e[t + 1][1];
      const i = Wp(r, n);
      if (i) {
        const p = n.substring(n.length - i);
        r = r.substring(0, r.length - i), n = p + n.substring(0, n.length - i), a = p + a;
      }
      let s = r, l = n, c = a, u = Wo(r, n) + Wo(n, a);
      for (; n.charAt(0) === a.charAt(0); ) {
        r += n.charAt(0), n = n.substring(1) + a.charAt(0), a = a.substring(1);
        const p = Wo(r, n) + Wo(n, a);
        p >= u && (u = p, s = r, l = n, c = a);
      }
      e[t - 1][1] !== s && (s ? e[t - 1][1] = s : (e.splice(t - 1, 1), t--), e[t][1] = l, c ? e[t + 1][1] = c : (e.splice(t + 1, 1), t--));
    }
    t++;
  }
}
o(DE, "diff_cleanupSemanticLossless");
function Gp(e) {
  e.push(new Le(Fe, ""));
  let t = 0, r = 0, n = 0, a = "", i = "", s;
  for (; t < e.length; )
    switch (e[t][0]) {
      case Qe:
        n++, i += e[t][1], t++;
        break;
      case at:
        r++, a += e[t][1], t++;
        break;
      case Fe:
        r + n > 1 ? (r !== 0 && n !== 0 && (s = $E(i, a), s !== 0 && (t - r - n > 0 && e[t - r - n - 1][0] === Fe ? e[t - r - n - 1][1] += i.substring(0, s) : (e.splice(0, 0, new Le(Fe, i.substring(0, s))), t++), i = i.substring(s), a = a.substring(s)), s = Wp(i, a), s !== 0 && (e[t][1] = i.substring(i.length - s) + e[t][1], i = i.substring(0, i.length - s), a = a.substring(0, a.length - s))), t -= r + n, e.splice(t, r + n), a.length && (e.splice(t, 0, new Le(at, a)), t++), i.length && (e.splice(t, 0, new Le(Qe, i)), t++), t++) : t !== 0 && e[t - 1][0] === Fe ? (e[t - 1][1] += e[t][1], e.splice(t, 1)) : t++, n = 0, r = 0, a = "", i = "";
        break;
    }
  e[e.length - 1][1] === "" && e.pop();
  let l = !1;
  for (t = 1; t < e.length - 1; )
    e[t - 1][0] === Fe && e[t + 1][0] === Fe && (e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1] ? (e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length), e[t + 1][1] = e[t - 1][1] + e[t + 1][1], e.splice(t - 1, 1), l = !0) : e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] && (e[t - 1][1] += e[t + 1][1], e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1], e.splice(t + 1, 1), l = !0)), t++;
  l && Gp(e);
}
o(Gp, "diff_cleanupMerge");
function Wo(e, t) {
  if (!e || !t)
    return 6;
  const r = e.charAt(e.length - 1), n = t.charAt(0), a = r.match(By), i = n.match(By), s = a && r.match(Uy), l = i && n.match(Uy), c = s && r.match(Hy), u = l && n.match(Hy), p = c && e.match(pM), f = u && t.match(fM);
  return p || f ? 5 : c || u ? 4 : a && !s && l ? 3 : s || l ? 2 : a || i ? 1 : 0;
}
o(Wo, "diff_cleanupSemanticScore_");
var FE = "Compared values have no visual difference.", mM = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", gi = {}, Vy;
function BE() {
  if (Vy) return gi;
  Vy = 1, Object.defineProperty(gi, "__esModule", {
    value: !0
  }), gi.default = m;
  const e = "diff-sequences", t = 0, r = /* @__PURE__ */ o((y, g, v, _, b) => {
    let E = 0;
    for (; y < g && v < _ && b(y, v); )
      y += 1, v += 1, E += 1;
    return E;
  }, "countCommonItemsF"), n = /* @__PURE__ */ o((y, g, v, _, b) => {
    let E = 0;
    for (; y <= g && v <= _ && b(g, _); )
      g -= 1, _ -= 1, E += 1;
    return E;
  }, "countCommonItemsR"), a = /* @__PURE__ */ o((y, g, v, _, b, E, C) => {
    let k = 0, N = -y, O = E[k], S = O;
    E[k] += r(
      O + 1,
      g,
      _ + O - N + 1,
      v,
      b
    );
    const w = y < C ? y : C;
    for (k += 1, N += 2; k <= w; k += 1, N += 2) {
      if (k !== y && S < E[k])
        O = E[k];
      else if (O = S + 1, g <= O)
        return k - 1;
      S = E[k], E[k] = O + r(O + 1, g, _ + O - N + 1, v, b);
    }
    return C;
  }, "extendPathsF"), i = /* @__PURE__ */ o((y, g, v, _, b, E, C) => {
    let k = 0, N = y, O = E[k], S = O;
    E[k] -= n(
      g,
      O - 1,
      v,
      _ + O - N - 1,
      b
    );
    const w = y < C ? y : C;
    for (k += 1, N -= 2; k <= w; k += 1, N -= 2) {
      if (k !== y && E[k] < S)
        O = E[k];
      else if (O = S - 1, O < g)
        return k - 1;
      S = E[k], E[k] = O - n(
        g,
        O - 1,
        v,
        _ + O - N - 1,
        b
      );
    }
    return C;
  }, "extendPathsR"), s = /* @__PURE__ */ o((y, g, v, _, b, E, C, k, N, O, S) => {
    const w = _ - g, T = v - g, M = b - _ - T, R = -M - (y - 1), D = -M + (y - 1);
    let J = t;
    const P = y < k ? y : k;
    for (let q = 0, $ = -y; q <= P; q += 1, $ += 2) {
      const H = q === 0 || q !== y && J < C[q], z = H ? C[q] : J, Z = H ? z : z + 1, oe = w + Z - $, ie = r(
        Z + 1,
        v,
        oe + 1,
        b,
        E
      ), Y = Z + ie;
      if (J = C[q], C[q] = Y, R <= $ && $ <= D) {
        const be = (y - 1 - ($ + M)) / 2;
        if (be <= O && N[be] - 1 <= Y) {
          const we = w + z - (H ? $ + 1 : $ - 1), le = n(
            g,
            z,
            _,
            we,
            E
          ), X = z - le, Re = we - le, Pe = X + 1, lt = Re + 1;
          S.nChangePreceding = y - 1, y - 1 === Pe + lt - g - _ ? (S.aEndPreceding = g, S.bEndPreceding = _) : (S.aEndPreceding = Pe, S.bEndPreceding = lt), S.nCommonPreceding = le, le !== 0 && (S.aCommonPreceding = Pe, S.bCommonPreceding = lt), S.nCommonFollowing = ie, ie !== 0 && (S.aCommonFollowing = Z + 1, S.bCommonFollowing = oe + 1);
          const rt = Y + 1, L = oe + ie + 1;
          return S.nChangeFollowing = y - 1, y - 1 === v + b - rt - L ? (S.aStartFollowing = v, S.bStartFollowing = b) : (S.aStartFollowing = rt, S.bStartFollowing = L), !0;
        }
      }
    }
    return !1;
  }, "extendOverlappablePathsF"), l = /* @__PURE__ */ o((y, g, v, _, b, E, C, k, N, O, S) => {
    const w = b - v, T = v - g, M = b - _ - T, R = M - y, D = M + y;
    let J = t;
    const P = y < O ? y : O;
    for (let q = 0, $ = y; q <= P; q += 1, $ -= 2) {
      const H = q === 0 || q !== y && N[q] < J, z = H ? N[q] : J, Z = H ? z : z - 1, oe = w + Z - $, ie = n(
        g,
        Z - 1,
        _,
        oe - 1,
        E
      ), Y = Z - ie;
      if (J = N[q], N[q] = Y, R <= $ && $ <= D) {
        const be = (y + ($ - M)) / 2;
        if (be <= k && Y - 1 <= C[be]) {
          const we = oe - ie;
          if (S.nChangePreceding = y, y === Y + we - g - _ ? (S.aEndPreceding = g, S.bEndPreceding = _) : (S.aEndPreceding = Y, S.bEndPreceding = we), S.nCommonPreceding = ie, ie !== 0 && (S.aCommonPreceding = Y, S.bCommonPreceding = we), S.nChangeFollowing = y - 1, y === 1)
            S.nCommonFollowing = 0, S.aStartFollowing = v, S.bStartFollowing = b;
          else {
            const le = w + z - (H ? $ - 1 : $ + 1), X = r(
              z,
              v,
              le,
              b,
              E
            );
            S.nCommonFollowing = X, X !== 0 && (S.aCommonFollowing = z, S.bCommonFollowing = le);
            const Re = z + X, Pe = le + X;
            y - 1 === v + b - Re - Pe ? (S.aStartFollowing = v, S.bStartFollowing = b) : (S.aStartFollowing = Re, S.bStartFollowing = Pe);
          }
          return !0;
        }
      }
    }
    return !1;
  }, "extendOverlappablePathsR"), c = /* @__PURE__ */ o((y, g, v, _, b, E, C, k, N) => {
    const O = _ - g, S = b - v, w = v - g, T = b - _, M = T - w;
    let R = w, D = w;
    if (C[0] = g - 1, k[0] = v, M % 2 === 0) {
      const J = (y || M) / 2, P = (w + T) / 2;
      for (let q = 1; q <= P; q += 1)
        if (R = a(q, v, b, O, E, C, R), q < J)
          D = i(q, g, _, S, E, k, D);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          l(
            q,
            g,
            v,
            _,
            b,
            E,
            C,
            R,
            k,
            D,
            N
          )
        )
          return;
    } else {
      const J = ((y || M) + 1) / 2, P = (w + T + 1) / 2;
      let q = 1;
      for (R = a(q, v, b, O, E, C, R), q += 1; q <= P; q += 1)
        if (D = i(
          q - 1,
          g,
          _,
          S,
          E,
          k,
          D
        ), q < J)
          R = a(q, v, b, O, E, C, R);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          s(
            q,
            g,
            v,
            _,
            b,
            E,
            C,
            R,
            k,
            D,
            N
          )
        )
          return;
    }
    throw new Error(
      `${e}: no overlap aStart=${g} aEnd=${v} bStart=${_} bEnd=${b}`
    );
  }, "divide"), u = /* @__PURE__ */ o((y, g, v, _, b, E, C, k, N, O) => {
    if (b - _ < v - g) {
      if (E = !E, E && C.length === 1) {
        const { foundSubsequence: be, isCommon: we } = C[0];
        C[1] = {
          foundSubsequence: /* @__PURE__ */ o((le, X, Re) => {
            be(le, Re, X);
          }, "foundSubsequence"),
          isCommon: /* @__PURE__ */ o((le, X) => we(X, le), "isCommon")
        };
      }
      const ie = g, Y = v;
      g = _, v = b, _ = ie, b = Y;
    }
    const { foundSubsequence: S, isCommon: w } = C[E ? 1 : 0];
    c(
      y,
      g,
      v,
      _,
      b,
      w,
      k,
      N,
      O
    );
    const {
      nChangePreceding: T,
      aEndPreceding: M,
      bEndPreceding: R,
      nCommonPreceding: D,
      aCommonPreceding: J,
      bCommonPreceding: P,
      nCommonFollowing: q,
      aCommonFollowing: $,
      bCommonFollowing: H,
      nChangeFollowing: z,
      aStartFollowing: Z,
      bStartFollowing: oe
    } = O;
    g < M && _ < R && u(
      T,
      g,
      M,
      _,
      R,
      E,
      C,
      k,
      N,
      O
    ), D !== 0 && S(D, J, P), q !== 0 && S(q, $, H), Z < v && oe < b && u(
      z,
      Z,
      v,
      oe,
      b,
      E,
      C,
      k,
      N,
      O
    );
  }, "findSubsequences"), p = /* @__PURE__ */ o((y, g) => {
    if (typeof g != "number")
      throw new TypeError(`${e}: ${y} typeof ${typeof g} is not a number`);
    if (!Number.isSafeInteger(g))
      throw new RangeError(`${e}: ${y} value ${g} is not a safe integer`);
    if (g < 0)
      throw new RangeError(`${e}: ${y} value ${g} is a negative integer`);
  }, "validateLength"), f = /* @__PURE__ */ o((y, g) => {
    const v = typeof g;
    if (v !== "function")
      throw new TypeError(`${e}: ${y} typeof ${v} is not a function`);
  }, "validateCallback");
  function m(y, g, v, _) {
    p("aLength", y), p("bLength", g), f("isCommon", v), f("foundSubsequence", _);
    const b = r(0, y, 0, g, v);
    if (b !== 0 && _(b, 0, 0), y !== b || g !== b) {
      const E = b, C = b, k = n(
        E,
        y - 1,
        C,
        g - 1,
        v
      ), N = y - k, O = g - k, S = b + k;
      y !== S && g !== S && u(
        0,
        E,
        N,
        C,
        O,
        !1,
        [
          {
            foundSubsequence: _,
            isCommon: v
          }
        ],
        [t],
        [t],
        {
          aCommonFollowing: t,
          aCommonPreceding: t,
          aEndPreceding: t,
          aStartFollowing: t,
          bCommonFollowing: t,
          bCommonPreceding: t,
          bEndPreceding: t,
          bStartFollowing: t,
          nChangeFollowing: t,
          nChangePreceding: t,
          nCommonFollowing: t,
          nCommonPreceding: t
        }
      ), k !== 0 && _(k, N, O);
    }
  }
  return o(m, "diffSequence"), gi;
}
o(BE, "requireBuild");
var hM = BE(), UE = Jp(hM);
function HE(e, t) {
  return e.replace(/\s+$/, (r) => t(r));
}
o(HE, "formatTrailingSpaces");
function Qs(e, t, r, n, a, i) {
  return e.length !== 0 ? r(`${n} ${HE(e, a)}`) : n !== " " ? r(n) : t && i.length !== 0 ? r(`${n} ${i}`) : "";
}
o(Qs, "printDiffLine");
function Kp(e, t, { aColor: r, aIndicator: n, changeLineTrailingSpaceColor: a, emptyFirstOrLastLinePlaceholder: i }) {
  return Qs(e, t, r, n, a, i);
}
o(Kp, "printDeleteLine");
function Yp(e, t, { bColor: r, bIndicator: n, changeLineTrailingSpaceColor: a, emptyFirstOrLastLinePlaceholder: i }) {
  return Qs(e, t, r, n, a, i);
}
o(Yp, "printInsertLine");
function Xp(e, t, { commonColor: r, commonIndicator: n, commonLineTrailingSpaceColor: a, emptyFirstOrLastLinePlaceholder: i }) {
  return Qs(e, t, r, n, a, i);
}
o(Xp, "printCommonLine");
function bc(e, t, r, n, { patchColor: a }) {
  return a(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
o(bc, "createPatchMark");
function VE(e, t) {
  const r = e.length, n = t.contextLines, a = n + n;
  let i = r, s = !1, l = 0, c = 0;
  for (; c !== r; ) {
    const k = c;
    for (; c !== r && e[c][0] === Fe; )
      c += 1;
    if (k !== c)
      if (k === 0)
        c > n && (i -= c - n, s = !0);
      else if (c === r) {
        const N = c - k;
        N > n && (i -= N - n, s = !0);
      } else {
        const N = c - k;
        N > a && (i -= N - a, l += 1);
      }
    for (; c !== r && e[c][0] !== Fe; )
      c += 1;
  }
  const u = l !== 0 || s;
  l !== 0 ? i += l + 1 : s && (i += 1);
  const p = i - 1, f = [];
  let m = 0;
  u && f.push("");
  let y = 0, g = 0, v = 0, _ = 0;
  const b = /* @__PURE__ */ o((k) => {
    const N = f.length;
    f.push(Xp(k, N === 0 || N === p, t)), v += 1, _ += 1;
  }, "pushCommonLine"), E = /* @__PURE__ */ o((k) => {
    const N = f.length;
    f.push(Kp(k, N === 0 || N === p, t)), v += 1;
  }, "pushDeleteLine"), C = /* @__PURE__ */ o((k) => {
    const N = f.length;
    f.push(Yp(k, N === 0 || N === p, t)), _ += 1;
  }, "pushInsertLine");
  for (c = 0; c !== r; ) {
    let k = c;
    for (; c !== r && e[c][0] === Fe; )
      c += 1;
    if (k !== c)
      if (k === 0) {
        c > n && (k = c - n, y = k, g = k, v = y, _ = g);
        for (let N = k; N !== c; N += 1)
          b(e[N][1]);
      } else if (c === r) {
        const N = c - k > n ? k + n : c;
        for (let O = k; O !== N; O += 1)
          b(e[O][1]);
      } else {
        const N = c - k;
        if (N > a) {
          const O = k + n;
          for (let w = k; w !== O; w += 1)
            b(e[w][1]);
          f[m] = bc(y, v, g, _, t), m = f.length, f.push("");
          const S = N - a;
          y = v + S, g = _ + S, v = y, _ = g;
          for (let w = c - n; w !== c; w += 1)
            b(e[w][1]);
        } else
          for (let O = k; O !== c; O += 1)
            b(e[O][1]);
      }
    for (; c !== r && e[c][0] === at; )
      E(e[c][1]), c += 1;
    for (; c !== r && e[c][0] === Qe; )
      C(e[c][1]), c += 1;
  }
  return u && (f[m] = bc(y, v, g, _, t)), f.join(`
`);
}
o(VE, "joinAlignedDiffsNoExpand");
function JE(e, t) {
  return e.map((r, n, a) => {
    const i = r[1], s = n === 0 || n === a.length - 1;
    switch (r[0]) {
      case at:
        return Kp(i, s, t);
      case Qe:
        return Yp(i, s, t);
      default:
        return Xp(i, s, t);
    }
  }).join(`
`);
}
o(JE, "joinAlignedDiffsExpand");
var qu = /* @__PURE__ */ o((e) => e, "noColor"), zE = 5, yM = 0;
function WE() {
  return {
    aAnnotation: "Expected",
    aColor: Be.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: Be.red,
    bIndicator: "+",
    changeColor: Be.inverse,
    changeLineTrailingSpaceColor: qu,
    commonColor: Be.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: qu,
    compareKeys: void 0,
    contextLines: zE,
    emptyFirstOrLastLinePlaceholder: "",
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: Be.yellow,
    printBasicPrototype: !1,
    truncateThreshold: yM,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: qu
  };
}
o(WE, "getDefaultOptions");
function GE(e) {
  return e && typeof e == "function" ? e : void 0;
}
o(GE, "getCompareKeys");
function KE(e) {
  return typeof e == "number" && Number.isSafeInteger(e) && e >= 0 ? e : zE;
}
o(KE, "getContextLines");
function tn(e = {}) {
  return {
    ...WE(),
    ...e,
    compareKeys: GE(e.compareKeys),
    contextLines: KE(e.contextLines)
  };
}
o(tn, "normalizeDiffOptions");
function cn(e) {
  return e.length === 1 && e[0].length === 0;
}
o(cn, "isEmptyString");
function YE(e) {
  let t = 0, r = 0;
  return e.forEach((n) => {
    switch (n[0]) {
      case at:
        t += 1;
        break;
      case Qe:
        r += 1;
        break;
    }
  }), {
    a: t,
    b: r
  };
}
o(YE, "countChanges");
function XE({ aAnnotation: e, aColor: t, aIndicator: r, bAnnotation: n, bColor: a, bIndicator: i, includeChangeCounts: s, omitAnnotationLines: l }, c) {
  if (l)
    return "";
  let u = "", p = "";
  if (s) {
    const y = String(c.a), g = String(c.b), v = n.length - e.length, _ = " ".repeat(Math.max(0, v)), b = " ".repeat(Math.max(0, -v)), E = g.length - y.length, C = " ".repeat(Math.max(0, E)), k = " ".repeat(Math.max(0, -E));
    u = `${_}  ${r} ${C}${y}`, p = `${b}  ${i} ${k}${g}`;
  }
  const f = `${r} ${e}${u}`, m = `${i} ${n}${p}`;
  return `${t(f)}
${a(m)}

`;
}
o(XE, "printAnnotation");
function Zs(e, t, r) {
  return XE(r, YE(e)) + (r.expand ? JE(e, r) : VE(e, r)) + (t ? r.truncateAnnotationColor(`
${r.truncateAnnotation}`) : "");
}
o(Zs, "printDiffLines");
function Va(e, t, r) {
  const n = tn(r), [a, i] = Qp(cn(e) ? [] : e, cn(t) ? [] : t, n);
  return Zs(a, i, n);
}
o(Va, "diffLinesUnified");
function QE(e, t, r, n, a) {
  if (cn(e) && cn(r) && (e = [], r = []), cn(t) && cn(n) && (t = [], n = []), e.length !== r.length || t.length !== n.length)
    return Va(e, t, a);
  const [i, s] = Qp(r, n, a);
  let l = 0, c = 0;
  return i.forEach((u) => {
    switch (u[0]) {
      case at:
        u[1] = e[l], l += 1;
        break;
      case Qe:
        u[1] = t[c], c += 1;
        break;
      default:
        u[1] = t[c], l += 1, c += 1;
    }
  }), Zs(i, s, tn(a));
}
o(QE, "diffLinesUnified2");
function Qp(e, t, r) {
  const n = r?.truncateThreshold ?? !1, a = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0), i = n ? Math.min(e.length, a) : e.length, s = n ? Math.min(t.length, a) : t.length, l = i !== e.length || s !== t.length, c = /* @__PURE__ */ o((m, y) => e[m] === t[y], "isCommon"), u = [];
  let p = 0, f = 0;
  for (UE(i, s, c, /* @__PURE__ */ o((m, y, g) => {
    for (; p !== y; p += 1)
      u.push(new Le(at, e[p]));
    for (; f !== g; f += 1)
      u.push(new Le(Qe, t[f]));
    for (; m !== 0; m -= 1, p += 1, f += 1)
      u.push(new Le(Fe, t[f]));
  }, "foundSubsequence")); p !== i; p += 1)
    u.push(new Le(at, e[p]));
  for (; f !== s; f += 1)
    u.push(new Le(Qe, t[f]));
  return [u, l];
}
o(Qp, "diffLinesRaw");
function vc(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  if (Array.isArray(e))
    return "array";
  if (typeof e == "boolean")
    return "boolean";
  if (typeof e == "function")
    return "function";
  if (typeof e == "number")
    return "number";
  if (typeof e == "string")
    return "string";
  if (typeof e == "bigint")
    return "bigint";
  if (typeof e == "object") {
    if (e != null) {
      if (e.constructor === RegExp)
        return "regexp";
      if (e.constructor === Map)
        return "map";
      if (e.constructor === Set)
        return "set";
      if (e.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof e == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${e}`);
}
o(vc, "getType");
function wc(e) {
  return e.includes(`\r
`) ? `\r
` : `
`;
}
o(wc, "getNewLineSymbol");
function ZE(e, t, r) {
  const n = r?.truncateThreshold ?? !1, a = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
  let i = e.length, s = t.length;
  if (n) {
    const m = e.includes(`
`), y = t.includes(`
`), g = wc(e), v = wc(t), _ = m ? `${e.split(g, a).join(g)}
` : e, b = y ? `${t.split(v, a).join(v)}
` : t;
    i = _.length, s = b.length;
  }
  const l = i !== e.length || s !== t.length, c = /* @__PURE__ */ o((m, y) => e[m] === t[y], "isCommon");
  let u = 0, p = 0;
  const f = [];
  return UE(i, s, c, /* @__PURE__ */ o((m, y, g) => {
    u !== y && f.push(new Le(at, e.slice(u, y))), p !== g && f.push(new Le(Qe, t.slice(p, g))), u = y + m, p = g + m, f.push(new Le(Fe, t.slice(g, p)));
  }, "foundSubsequence")), u !== i && f.push(new Le(at, e.slice(u))), p !== s && f.push(new Le(Qe, t.slice(p))), [f, l];
}
o(ZE, "diffStrings");
function ex(e, t, r) {
  return t.reduce((n, a) => n + (a[0] === Fe ? a[1] : a[0] === e && a[1].length !== 0 ? r(a[1]) : ""), "");
}
o(ex, "concatenateRelevantDiffs");
var tx = class {
  op;
  line;
  lines;
  changeColor;
  constructor(e, t) {
    this.op = e, this.line = [], this.lines = [], this.changeColor = t;
  }
  pushSubstring(e) {
    this.pushDiff(new Le(this.op, e));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Le(this.op, ex(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Le(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(e) {
    this.line.push(e);
  }
  // Main input to buffer.
  align(e) {
    const t = e[1];
    if (t.includes(`
`)) {
      const r = t.split(`
`), n = r.length - 1;
      r.forEach((a, i) => {
        i < n ? (this.pushSubstring(a), this.pushLine()) : a.length !== 0 && this.pushSubstring(a);
      });
    } else
      this.pushDiff(e);
  }
  // Output from buffer.
  moveLinesTo(e) {
    this.isLineEmpty() || this.pushLine(), e.push(...this.lines), this.lines.length = 0;
  }
};
o(tx, "ChangeBuffer");
var Jy = tx, rx = class {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(e, t) {
    this.deleteBuffer = e, this.insertBuffer = t, this.lines = [];
  }
  pushDiffCommonLine(e) {
    this.lines.push(e);
  }
  pushDiffChangeLines(e) {
    const t = e[1].length === 0;
    (!t || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(e), (!t || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(e);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(e) {
    const t = e[0], r = e[1];
    if (r.includes(`
`)) {
      const n = r.split(`
`), a = n.length - 1;
      n.forEach((i, s) => {
        if (s === 0) {
          const l = new Le(t, i);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(l)) : (this.pushDiffChangeLines(l), this.flushChangeLines());
        } else s < a ? this.pushDiffCommonLine(new Le(t, i)) : i.length !== 0 && this.pushDiffChangeLines(new Le(t, i));
      });
    } else
      this.pushDiffChangeLines(e);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
o(rx, "CommonBuffer");
var gM = rx;
function nx(e, t) {
  const r = new Jy(at, t), n = new Jy(Qe, t), a = new gM(r, n);
  return e.forEach((i) => {
    switch (i[0]) {
      case at:
        r.align(i);
        break;
      case Qe:
        n.align(i);
        break;
      default:
        a.align(i);
    }
  }), a.getLines();
}
o(nx, "getAlignedDiffs");
function ox(e, t) {
  if (t) {
    const r = e.length - 1;
    return e.some((n, a) => n[0] === Fe && (a !== r || n[1] !== `
`));
  }
  return e.some((r) => r[0] === Fe);
}
o(ox, "hasCommonDiff");
function ax(e, t, r) {
  if (e !== t && e.length !== 0 && t.length !== 0) {
    const n = e.includes(`
`) || t.includes(`
`), [a, i] = Zp(n ? `${e}
` : e, n ? `${t}
` : t, !0, r);
    if (ox(a, n)) {
      const s = tn(r), l = nx(a, s.changeColor);
      return Zs(l, i, s);
    }
  }
  return Va(e.split(`
`), t.split(`
`), r);
}
o(ax, "diffStringsUnified");
function Zp(e, t, r, n) {
  const [a, i] = ZE(e, t, n);
  return r && LE(a), [a, i];
}
o(Zp, "diffStringsRaw");
function Gi(e, t) {
  const { commonColor: r } = tn(t);
  return r(e);
}
o(Gi, "getCommonMessage");
var { AsymmetricMatcher: bM, DOMCollection: vM, DOMElement: wM, Immutable: _M, ReactElement: EM, ReactTestComponent: xM } = Hp, ix = [
  xM,
  EM,
  wM,
  vM,
  _M,
  bM,
  Hp.Error
], _c = {
  maxDepth: 20,
  plugins: ix
}, sx = {
  callToJSON: !1,
  maxDepth: 8,
  plugins: ix
};
function jn(e, t, r) {
  if (Object.is(e, t))
    return "";
  const n = vc(e);
  let a = n, i = !1;
  if (n === "object" && typeof e.asymmetricMatch == "function") {
    if (e.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof e.getExpectedType != "function")
      return;
    a = e.getExpectedType(), i = a === "string";
  }
  if (a !== vc(t)) {
    let s = function(C) {
      return C.length <= _ ? C : `${C.slice(0, _)}...`;
    };
    o(s, "truncate");
    const { aAnnotation: l, aColor: c, aIndicator: u, bAnnotation: p, bColor: f, bIndicator: m } = tn(r), y = Ki(sx, r);
    let g = Jt(e, y), v = Jt(t, y);
    const _ = 1e5;
    g = s(g), v = s(v);
    const b = `${c(`${u} ${l}:`)} 
${g}`, E = `${f(`${m} ${p}:`)} 
${v}`;
    return `${b}

${E}`;
  }
  if (!i)
    switch (n) {
      case "string":
        return Va(e.split(`
`), t.split(`
`), r);
      case "boolean":
      case "number":
        return lx(e, t, r);
      case "map":
        return Pi(Ec(e), Ec(t), r);
      case "set":
        return Pi(xc(e), xc(t), r);
      default:
        return Pi(e, t, r);
    }
}
o(jn, "diff");
function lx(e, t, r) {
  const n = Jt(e, _c), a = Jt(t, _c);
  return n === a ? "" : Va(n.split(`
`), a.split(`
`), r);
}
o(lx, "comparePrimitive");
function Ec(e) {
  return new Map(Array.from(e.entries()).sort());
}
o(Ec, "sortMap");
function xc(e) {
  return new Set(Array.from(e.values()).sort());
}
o(xc, "sortSet");
function Pi(e, t, r) {
  let n, a = !1;
  try {
    const s = Ki(_c, r);
    n = Tc(e, t, s, r);
  } catch {
    a = !0;
  }
  const i = Gi(FE, r);
  if (n === void 0 || n === i) {
    const s = Ki(sx, r);
    n = Tc(e, t, s, r), n !== i && !a && (n = `${Gi(mM, r)}

${n}`);
  }
  return n;
}
o(Pi, "compareObjects");
function Ki(e, t) {
  const { compareKeys: r, printBasicPrototype: n, maxDepth: a } = tn(t);
  return {
    ...e,
    compareKeys: r,
    printBasicPrototype: n,
    maxDepth: a ?? e.maxDepth
  };
}
o(Ki, "getFormatOptions");
function Tc(e, t, r, n) {
  const a = {
    ...r,
    indent: 0
  }, i = Jt(e, a), s = Jt(t, a);
  if (i === s)
    return Gi(FE, n);
  {
    const l = Jt(e, r), c = Jt(t, r);
    return QE(l.split(`
`), c.split(`
`), i.split(`
`), s.split(`
`), n);
  }
}
o(Tc, "getObjectsDifference");
var zy = 2e4;
function Sc(e) {
  return wa(e) === "Object" && typeof e.asymmetricMatch == "function";
}
o(Sc, "isAsymmetricMatcher");
function Pc(e, t) {
  const r = wa(e), n = wa(t);
  return r === n && (r === "Object" || r === "Array");
}
o(Pc, "isReplaceable");
function ef(e, t, r) {
  const { aAnnotation: n, bAnnotation: a } = tn(r);
  if (typeof t == "string" && typeof e == "string" && t.length > 0 && e.length > 0 && t.length <= zy && e.length <= zy && t !== e) {
    if (t.includes(`
`) || e.includes(`
`))
      return ax(t, e, r);
    const [u] = Zp(t, e, !0), p = u.some((g) => g[0] === Fe), f = ux(n, a), m = f(n) + dx(Oc(u, at, p)), y = f(a) + cx(Oc(u, Qe, p));
    return `${m}
${y}`;
  }
  const i = yc(t, { forceWritable: !0 }), s = yc(e, { forceWritable: !0 }), { replacedExpected: l, replacedActual: c } = tf(s, i);
  return jn(l, c, r);
}
o(ef, "printDiffOrStringify");
function tf(e, t, r = /* @__PURE__ */ new WeakSet(), n = /* @__PURE__ */ new WeakSet()) {
  return e instanceof Error && t instanceof Error && typeof e.cause < "u" && typeof t.cause > "u" ? (delete e.cause, {
    replacedActual: e,
    replacedExpected: t
  }) : Pc(e, t) ? r.has(e) || n.has(t) ? {
    replacedActual: e,
    replacedExpected: t
  } : (r.add(e), n.add(t), zp(t).forEach((a) => {
    const i = t[a], s = e[a];
    if (Sc(i))
      i.asymmetricMatch(s) && (e[a] = i);
    else if (Sc(s))
      s.asymmetricMatch(i) && (t[a] = s);
    else if (Pc(s, i)) {
      const l = tf(s, i, r, n);
      e[a] = l.replacedActual, t[a] = l.replacedExpected;
    }
  }), {
    replacedActual: e,
    replacedExpected: t
  }) : {
    replacedActual: e,
    replacedExpected: t
  };
}
o(tf, "replaceAsymmetricMatcher");
function ux(...e) {
  const t = e.reduce((r, n) => n.length > r ? n.length : r, 0);
  return (r) => `${r}: ${" ".repeat(t - r.length)}`;
}
o(ux, "getLabelPrinter");
var TM = "Â·";
function rf(e) {
  return e.replace(/\s+$/gm, (t) => TM.repeat(t.length));
}
o(rf, "replaceTrailingSpaces");
function cx(e) {
  return Be.red(rf(dt(e)));
}
o(cx, "printReceived");
function dx(e) {
  return Be.green(rf(dt(e)));
}
o(dx, "printExpected");
function Oc(e, t, r) {
  return e.reduce((n, a) => n + (a[0] === Fe ? a[1] : a[0] === t ? r ? Be.inverse(a[1]) : a[1] : ""), "");
}
o(Oc, "getCommonAndChangedSubstrings");
var SM = "@@__IMMUTABLE_RECORD__@@", PM = "@@__IMMUTABLE_ITERABLE__@@";
function px(e) {
  return e && (e[PM] || e[SM]);
}
o(px, "isImmutable");
var OM = Object.getPrototypeOf({});
function Cc(e) {
  return e instanceof Error ? `<unserializable>: ${e.message}` : typeof e == "string" ? `<unserializable>: ${e}` : "<unserializable>";
}
o(Cc, "getUnserializableMessage");
function Er(e, t = /* @__PURE__ */ new WeakMap()) {
  if (!e || typeof e == "string")
    return e;
  if (e instanceof Error && "toJSON" in e && typeof e.toJSON == "function") {
    const r = e.toJSON();
    return r && r !== e && typeof r == "object" && (typeof e.message == "string" && Go(() => r.message ?? (r.message = e.message)), typeof e.stack == "string" && Go(() => r.stack ?? (r.stack = e.stack)), typeof e.name == "string" && Go(() => r.name ?? (r.name = e.name)), e.cause != null && Go(() => r.cause ?? (r.cause = Er(e.cause, t)))), Er(r, t);
  }
  if (typeof e == "function")
    return `Function<${e.name || "anonymous"}>`;
  if (typeof e == "symbol")
    return e.toString();
  if (typeof e != "object")
    return e;
  if (typeof Buffer < "u" && e instanceof Buffer)
    return `<Buffer(${e.length}) ...>`;
  if (typeof Uint8Array < "u" && e instanceof Uint8Array)
    return `<Uint8Array(${e.length}) ...>`;
  if (px(e))
    return Er(e.toJSON(), t);
  if (e instanceof Promise || e.constructor && e.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && e instanceof Element)
    return e.tagName;
  if (typeof e.asymmetricMatch == "function")
    return `${e.toString()} ${kE(e.sample)}`;
  if (typeof e.toJSON == "function")
    return Er(e.toJSON(), t);
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    const r = new Array(e.length);
    return t.set(e, r), e.forEach((n, a) => {
      try {
        r[a] = Er(n, t);
      } catch (i) {
        r[a] = Cc(i);
      }
    }), r;
  } else {
    const r = /* @__PURE__ */ Object.create(null);
    t.set(e, r);
    let n = e;
    for (; n && n !== OM; )
      Object.getOwnPropertyNames(n).forEach((a) => {
        if (!(a in r))
          try {
            r[a] = Er(e[a], t);
          } catch (i) {
            delete r[a], r[a] = Cc(i);
          }
      }), n = Object.getPrototypeOf(n);
    return r;
  }
}
o(Er, "serializeValue");
function Go(e) {
  try {
    return e();
  } catch {
  }
}
o(Go, "safe");
function fx(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
o(fx, "normalizeErrorMessage");
function el(e, t, r = /* @__PURE__ */ new WeakSet()) {
  if (!e || typeof e != "object")
    return { message: String(e) };
  const n = e;
  (n.showDiff || n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0) && (n.diff = ef(n.actual, n.expected, {
    ...t,
    ...n.diffOptions
  })), "expected" in n && typeof n.expected != "string" && (n.expected = dt(n.expected, 10)), "actual" in n && typeof n.actual != "string" && (n.actual = dt(n.actual, 10));
  try {
    typeof n.message == "string" && (n.message = fx(n.message));
  } catch {
  }
  try {
    !r.has(n) && typeof n.cause == "object" && (r.add(n), n.cause = el(n.cause, t, r));
  } catch {
  }
  try {
    return Er(n);
  } catch (a) {
    return Er(new Error(`Failed to fully serialize error: ${a?.message}
Inner error message: ${n?.message}`));
  }
}
o(el, "processError");
var mr = {
  CALL: "storybook/instrumenter/call",
  SYNC: "storybook/instrumenter/sync",
  START: "storybook/instrumenter/start",
  BACK: "storybook/instrumenter/back",
  GOTO: "storybook/instrumenter/goto",
  NEXT: "storybook/instrumenter/next",
  END: "storybook/instrumenter/end"
}, Mu = globalThis.__STORYBOOK_ADDONS_PREVIEW, CM = new Error(
  "This function ran after the play function completed. Did you forget to `await` it?"
), Wy = /* @__PURE__ */ o((e) => Object.prototype.toString.call(e) === "[object Object]", "isObject"), AM = /* @__PURE__ */ o((e) => Object.prototype.toString.call(e) === "[object Module]", "isModule"), RM = /* @__PURE__ */ o((e) => {
  if (!Wy(e) && !AM(e))
    return !1;
  if (e.constructor === void 0)
    return !0;
  const t = e.constructor.prototype;
  return !!Wy(t);
}, "isInstrumentable"), kM = /* @__PURE__ */ o((e) => {
  try {
    return new e.constructor();
  } catch {
    return {};
  }
}, "construct"), $u = /* @__PURE__ */ o(() => ({
  renderPhase: "preparing",
  isDebugging: !1,
  isPlaying: !1,
  isLocked: !1,
  cursor: 0,
  calls: [],
  shadowCalls: [],
  callRefsByResult: /* @__PURE__ */ new Map(),
  chainedCallIds: /* @__PURE__ */ new Set(),
  ancestors: [],
  playUntil: void 0,
  resolvers: {},
  syncTimeout: void 0
}), "getInitialState"), Gy = /* @__PURE__ */ o((e, t = !1) => {
  const r = (t ? e.shadowCalls : e.calls).filter((a) => a.retain);
  if (!r.length)
    return;
  const n = new Map(
    Array.from(e.callRefsByResult.entries()).filter(([, a]) => a.retain)
  );
  return { cursor: r.length, calls: r, callRefsByResult: n };
}, "getRetainedState"), mx = class {
  constructor() {
    this.detached = !1, this.initialized = !1, this.state = {}, this.loadParentWindowState = /* @__PURE__ */ o(() => {
      try {
        this.state = ee.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
      } catch {
        this.detached = !0;
      }
    }, "loadParentWindowState"), this.updateParentWindowState = /* @__PURE__ */ o(() => {
      try {
        ee.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
      } catch {
        this.detached = !0;
      }
    }, "updateParentWindowState"), this.loadParentWindowState();
    const e = /* @__PURE__ */ o(({
      storyId: l,
      renderPhase: c,
      isPlaying: u = !0,
      isDebugging: p = !1
    }) => {
      const f = this.getState(l);
      this.setState(l, {
        ...$u(),
        ...Gy(f, p),
        renderPhase: c || f.renderPhase,
        shadowCalls: p ? f.shadowCalls : [],
        chainedCallIds: p ? f.chainedCallIds : /* @__PURE__ */ new Set(),
        playUntil: p ? f.playUntil : void 0,
        isPlaying: u,
        isDebugging: p
      }), this.sync(l);
    }, "resetState"), t = /* @__PURE__ */ o((l) => ({ storyId: c, playUntil: u }) => {
      this.getState(c).isDebugging || this.setState(c, ({ calls: f }) => ({
        calls: [],
        shadowCalls: f.map((m) => ({
          ...m,
          status: "waiting"
          /* WAITING */
        })),
        isDebugging: !0
      }));
      const p = this.getLog(c);
      this.setState(c, ({ shadowCalls: f }) => {
        if (u || !p.length)
          return { playUntil: u };
        const m = f.findIndex((y) => y.id === p[0].callId);
        return {
          playUntil: f.slice(0, m).filter((y) => y.interceptable && !y.ancestors?.length).slice(-1)[0]?.id
        };
      }), l.emit(Hi, { storyId: c, isDebugging: !0 });
    }, "start"), r = /* @__PURE__ */ o((l) => ({ storyId: c }) => {
      const u = this.getLog(c).filter((f) => !f.ancestors?.length), p = u.reduceRight((f, m, y) => f >= 0 || m.status === "waiting" ? f : y, -1);
      t(l)({ storyId: c, playUntil: u[p - 1]?.callId });
    }, "back"), n = /* @__PURE__ */ o((l) => ({ storyId: c, callId: u }) => {
      const { calls: p, shadowCalls: f, resolvers: m } = this.getState(c), y = p.find(({ id: v }) => v === u), g = f.find(({ id: v }) => v === u);
      if (!y && g && Object.values(m).length > 0) {
        const v = this.getLog(c).find(
          (_) => _.status === "waiting"
          /* WAITING */
        )?.callId;
        g.id !== v && this.setState(c, { playUntil: g.id }), Object.values(m).forEach((_) => _());
      } else
        t(l)({ storyId: c, playUntil: u });
    }, "goto"), a = /* @__PURE__ */ o((l) => ({ storyId: c }) => {
      const { resolvers: u } = this.getState(c);
      if (Object.values(u).length > 0)
        Object.values(u).forEach((p) => p());
      else {
        const p = this.getLog(c).find(
          (f) => f.status === "waiting"
          /* WAITING */
        )?.callId;
        p ? t(l)({ storyId: c, playUntil: p }) : i({ storyId: c });
      }
    }, "next"), i = /* @__PURE__ */ o(({ storyId: l }) => {
      this.setState(l, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(l).resolvers).forEach((c) => c());
    }, "end"), s = /* @__PURE__ */ o(({
      storyId: l,
      newPhase: c
    }) => {
      const { isDebugging: u } = this.getState(l);
      if (c === "preparing" && u)
        return e({ storyId: l, renderPhase: c, isDebugging: u });
      if (c === "playing")
        return e({ storyId: l, renderPhase: c, isDebugging: u });
      c === "played" ? this.setState(l, {
        renderPhase: c,
        isLocked: !1,
        isPlaying: !1,
        isDebugging: !1
      }) : c === "errored" ? this.setState(l, {
        renderPhase: c,
        isLocked: !1,
        isPlaying: !1
      }) : c === "aborted" ? this.setState(l, {
        renderPhase: c,
        isLocked: !0,
        isPlaying: !1
      }) : this.setState(l, {
        renderPhase: c
      }), this.sync(l);
    }, "renderPhaseChanged");
    Mu && Mu.ready().then(() => {
      this.channel = Mu.getChannel(), this.channel.on(Hi, e), this.channel.on(vn, s), this.channel.on(Op, () => {
        this.initialized ? this.cleanup() : this.initialized = !0;
      }), this.channel.on(mr.START, t(this.channel)), this.channel.on(mr.BACK, r(this.channel)), this.channel.on(mr.GOTO, n(this.channel)), this.channel.on(mr.NEXT, a(this.channel)), this.channel.on(mr.END, i);
    });
  }
  getState(e) {
    return this.state[e] || $u();
  }
  setState(e, t) {
    if (e) {
      const r = this.getState(e), n = typeof t == "function" ? t(r) : t;
      this.state = { ...this.state, [e]: { ...r, ...n } }, this.updateParentWindowState();
    }
  }
  cleanup() {
    this.state = Object.entries(this.state).reduce(
      (t, [r, n]) => {
        const a = Gy(n);
        return a && (t[r] = Object.assign($u(), a)), t;
      },
      {}
    );
    const e = { controlStates: {
      detached: this.detached,
      start: !1,
      back: !1,
      goto: !1,
      next: !1,
      end: !1
    }, logItems: [] };
    this.channel?.emit(mr.SYNC, e), this.updateParentWindowState();
  }
  getLog(e) {
    const { calls: t, shadowCalls: r } = this.getState(e), n = [...r];
    t.forEach((i, s) => {
      n[s] = i;
    });
    const a = /* @__PURE__ */ new Set();
    return n.reduceRight((i, s) => (s.args.forEach((l) => {
      l?.__callId__ && a.add(l.__callId__);
    }), s.path.forEach((l) => {
      l.__callId__ && a.add(l.__callId__);
    }), (s.interceptable || s.exception) && !a.has(s.id) && (i.unshift({ callId: s.id, status: s.status, ancestors: s.ancestors }), a.add(s.id)), i), []);
  }
  // Traverses the object structure to recursively patch all function properties.
  // Returns the original object, or a new object with the same constructor,
  // depending on whether it should mutate.
  instrument(e, t, r = 0) {
    if (!RM(e))
      return e;
    const { mutate: n = !1, path: a = [] } = t, i = t.getKeys ? t.getKeys(e, r) : Object.keys(e);
    return r += 1, i.reduce(
      (s, l) => {
        const c = hx(e, l);
        if (typeof c?.get == "function") {
          if (c.configurable) {
            const p = /* @__PURE__ */ o(() => c?.get?.bind(e)?.(), "getter");
            Object.defineProperty(s, l, {
              get: /* @__PURE__ */ o(() => this.instrument(p(), { ...t, path: a.concat(l) }, r), "get")
            });
          }
          return s;
        }
        const u = e[l];
        return typeof u != "function" ? (s[l] = this.instrument(u, { ...t, path: a.concat(l) }, r), s) : "__originalFn__" in u && typeof u.__originalFn__ == "function" ? (s[l] = u, s) : (s[l] = (...p) => this.track(l, u, e, p, t), s[l].__originalFn__ = u, Object.defineProperty(s[l], "name", { value: l, writable: !1 }), Object.keys(u).length > 0 && Object.assign(
          s[l],
          this.instrument({ ...u }, { ...t, path: a.concat(l) }, r)
        ), s);
      },
      n ? e : kM(e)
    );
  }
  // Monkey patch an object method to record calls.
  // Returns a function that invokes the original function, records the invocation ("call") and
  // returns the original result.
  track(e, t, r, n, a) {
    const i = n?.[0]?.__storyId__ || ee.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor: s, ancestors: l } = this.getState(i);
    this.setState(i, { cursor: s + 1 });
    const c = `${l.slice(-1)[0] || i} [${s}] ${e}`, { path: u = [], intercept: p = !1, retain: f = !1 } = a, m = typeof p == "function" ? p(e, u) : p, y = { id: c, cursor: s, storyId: i, ancestors: l, path: u, method: e, args: n, interceptable: m, retain: f }, g = (m && !l.length ? this.intercept : this.invoke).call(this, t, r, y, a);
    return this.instrument(g, { ...a, mutate: !0, path: [{ __callId__: y.id }] });
  }
  intercept(e, t, r, n) {
    const { chainedCallIds: a, isDebugging: i, playUntil: s } = this.getState(r.storyId), l = a.has(r.id);
    return !i || l || s ? (s === r.id && this.setState(r.storyId, { playUntil: void 0 }), this.invoke(e, t, r, n)) : new Promise((c) => {
      this.setState(r.storyId, ({ resolvers: u }) => ({
        isLocked: !1,
        resolvers: { ...u, [r.id]: c }
      }));
    }).then(() => (this.setState(r.storyId, (c) => {
      const { [r.id]: u, ...p } = c.resolvers;
      return { isLocked: !0, resolvers: p };
    }), this.invoke(e, t, r, n)));
  }
  invoke(e, t, r, n) {
    const { callRefsByResult: a, renderPhase: i } = this.getState(r.storyId), s = 25, l = /* @__PURE__ */ o((p, f, m) => {
      if (m.includes(p))
        return "[Circular]";
      if (m = [...m, p], f > s)
        return "...";
      if (a.has(p))
        return a.get(p);
      if (p instanceof Array)
        return p.map((y) => l(y, ++f, m));
      if (p instanceof Date)
        return { __date__: { value: p.toISOString() } };
      if (p instanceof Error) {
        const { name: y, message: g, stack: v } = p;
        return { __error__: { name: y, message: g, stack: v } };
      }
      if (p instanceof RegExp) {
        const { flags: y, source: g } = p;
        return { __regexp__: { flags: y, source: g } };
      }
      if (p instanceof ee.window?.HTMLElement) {
        const { prefix: y, localName: g, id: v, classList: _, innerText: b } = p, E = Array.from(_);
        return { __element__: { prefix: y, localName: g, id: v, classNames: E, innerText: b } };
      }
      return typeof p == "function" ? {
        __function__: { name: "getMockName" in p ? p.getMockName() : p.name }
      } : typeof p == "symbol" ? { __symbol__: { description: p.description } } : typeof p == "object" && p?.constructor?.name && p?.constructor?.name !== "Object" ? { __class__: { name: p.constructor.name } } : Object.prototype.toString.call(p) === "[object Object]" ? Object.fromEntries(
        Object.entries(p).map(([y, g]) => [y, l(g, ++f, m)])
      ) : p;
    }, "serializeValues"), c = {
      ...r,
      args: r.args.map((p) => l(p, 0, []))
    };
    r.path.forEach((p) => {
      p?.__callId__ && this.setState(r.storyId, ({ chainedCallIds: f }) => ({
        chainedCallIds: new Set(Array.from(f).concat(p.__callId__))
      }));
    });
    const u = /* @__PURE__ */ o((p) => {
      if (p instanceof Error) {
        const { name: f, message: m, stack: y, callId: g = r.id } = p, {
          showDiff: v = void 0,
          diff: _ = void 0,
          actual: b = void 0,
          expected: E = void 0
        } = p.name === "AssertionError" ? el(p) : p, C = { name: f, message: m, stack: y, callId: g, showDiff: v, diff: _, actual: b, expected: E };
        if (this.update({ ...c, status: "error", exception: C }), this.setState(r.storyId, (k) => ({
          callRefsByResult: new Map([
            ...Array.from(k.callRefsByResult.entries()),
            [p, { __callId__: r.id, retain: r.retain }]
          ])
        })), r.ancestors?.length)
          throw Object.prototype.hasOwnProperty.call(p, "callId") || Object.defineProperty(p, "callId", { value: r.id }), p;
      }
      throw p;
    }, "handleException");
    try {
      if (i === "played" && !r.retain)
        throw CM;
      const p = (n.getArgs ? n.getArgs(r, this.getState(r.storyId)) : r.args).map((m) => typeof m != "function" || yx(m) || Object.keys(m).length ? m : (...y) => {
        const { cursor: g, ancestors: v } = this.getState(r.storyId);
        this.setState(r.storyId, { cursor: 0, ancestors: [...v, r.id] });
        const _ = /* @__PURE__ */ o(() => this.setState(r.storyId, { cursor: g, ancestors: v }), "restore");
        let b = !1;
        try {
          const E = m(...y);
          return E instanceof Promise ? (b = !0, E.finally(_)) : E;
        } finally {
          b || _();
        }
      }), f = e.apply(t, p);
      return f && ["object", "function", "symbol"].includes(typeof f) && this.setState(r.storyId, (m) => ({
        callRefsByResult: new Map([
          ...Array.from(m.callRefsByResult.entries()),
          [f, { __callId__: r.id, retain: r.retain }]
        ])
      })), this.update({
        ...c,
        status: f instanceof Promise ? "active" : "done"
        /* DONE */
      }), f instanceof Promise ? f.then((m) => (this.update({
        ...c,
        status: "done"
        /* DONE */
      }), m), u) : f;
    } catch (p) {
      return u(p);
    }
  }
  // Sends the call info to the manager and synchronizes the log.
  update(e) {
    this.channel?.emit(mr.CALL, e), this.setState(e.storyId, ({ calls: t }) => {
      const r = t.concat(e).reduce((n, a) => Object.assign(n, { [a.id]: a }), {});
      return {
        // Calls are sorted to ensure parent calls always come before calls in their callback.
        calls: Object.values(r).sort(
          (n, a) => n.id.localeCompare(a.id, void 0, { numeric: !0 })
        )
      };
    }), this.sync(e.storyId);
  }
  // Builds a log of interceptable calls and control states and sends it to the manager.
  // Uses a 0ms debounce because this might get called many times in one tick.
  sync(e) {
    const t = /* @__PURE__ */ o(() => {
      const { isLocked: r, isPlaying: n } = this.getState(e), a = this.getLog(e), i = a.filter(({ ancestors: u }) => !u.length).find(
        (u) => u.status === "waiting"
        /* WAITING */
      )?.callId, s = a.some(
        (u) => u.status === "active"
        /* ACTIVE */
      );
      if (this.detached || r || s || a.length === 0) {
        const u = { controlStates: {
          detached: this.detached,
          start: !1,
          back: !1,
          goto: !1,
          next: !1,
          end: !1
        }, logItems: a };
        this.channel?.emit(mr.SYNC, u);
        return;
      }
      const l = a.some(
        (u) => u.status === "done" || u.status === "error"
        /* ERROR */
      ), c = { controlStates: {
        detached: this.detached,
        start: l,
        back: l,
        goto: !0,
        next: n,
        end: n
      }, logItems: a, pausedAt: i };
      this.channel?.emit(mr.SYNC, c);
    }, "synchronize");
    this.setState(e, ({ syncTimeout: r }) => (clearTimeout(r), { syncTimeout: setTimeout(t, 0) }));
  }
};
o(mx, "Instrumenter");
var IM = mx;
function Oo(e, t = {}) {
  try {
    let r = !1, n = !1;
    return ee.window?.location?.search?.includes("instrument=true") ? r = !0 : ee.window?.location?.search?.includes("instrument=false") && (n = !0), ee.window?.parent === ee.window && !r || n ? e : (ee.window && !ee.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ && (ee.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new IM()), (ee.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t));
  } catch (r) {
    return Ue.warn(r), e;
  }
}
o(Oo, "instrument");
function hx(e, t) {
  let r = e;
  for (; r != null; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n)
      return n;
    r = Object.getPrototypeOf(r);
  }
}
o(hx, "getPropertyDescriptor");
function yx(e) {
  if (typeof e != "function")
    return !1;
  const t = Object.getOwnPropertyDescriptor(e, "prototype");
  return t ? !t.writable : !1;
}
o(yx, "isClass");
var jM = F({
  "../node_modules/min-indent/index.js"(e, t) {
    t.exports = (r) => {
      const n = r.match(/^[ \t]*(?=\S)/gm);
      return n ? n.reduce((a, i) => Math.min(a, i.length), 1 / 0) : 0;
    };
  }
}), NM = F({
  "../node_modules/strip-indent/index.js"(e, t) {
    var r = jM();
    t.exports = (n) => {
      const a = r(n);
      if (a === 0)
        return n;
      const i = new RegExp(`^[ \\t]{${a}}`, "gm");
      return n.replace(i, "");
    };
  }
}), qM = F({
  "../node_modules/indent-string/index.js"(e, t) {
    t.exports = (r, n = 1, a) => {
      if (a = {
        indent: " ",
        includeEmptyLines: !1,
        ...a
      }, typeof r != "string")
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof r}\``
        );
      if (typeof n != "number")
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof n}\``
        );
      if (typeof a.indent != "string")
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof a.indent}\``
        );
      if (n === 0)
        return r;
      const i = a.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return r.replace(i, a.indent.repeat(n));
    };
  }
}), gx = F({
  "../node_modules/redent/index.js"(e, t) {
    var r = NM(), n = qM();
    t.exports = (a, i = 0, s) => n(r(a), i, s);
  }
}), MM = F({
  "../node_modules/aria-query/lib/util/iteratorProxy.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    function t() {
      var r = this, n = 0, a = {
        "@@iterator": /* @__PURE__ */ o(function() {
          return a;
        }, "iterator"),
        next: /* @__PURE__ */ o(function() {
          if (n < r.length) {
            var i = r[n];
            return n = n + 1, {
              done: !1,
              value: i
            };
          } else
            return {
              done: !0
            };
        }, "next")
      };
      return a;
    }
    o(t, "iteratorProxy"), e.default = t;
  }
}), Ja = F({
  "../node_modules/aria-query/lib/util/iterationDecorator.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = a;
    var t = r(MM());
    function r(i) {
      return i && i.__esModule ? i : { default: i };
    }
    o(r, "_interopRequireDefault");
    function n(i) {
      "@babel/helpers - typeof";
      return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
        return typeof s;
      } : function(s) {
        return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
      }, n(i);
    }
    o(n, "_typeof");
    function a(i, s) {
      return typeof Symbol == "function" && n(Symbol.iterator) === "symbol" && Object.defineProperty(i, Symbol.iterator, {
        value: t.default.bind(s)
      }), i;
    }
    o(a, "iterationDecorator");
  }
}), $M = F({
  "../node_modules/aria-query/lib/ariaPropsMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = r(Ja());
    function r(f) {
      return f && f.__esModule ? f : { default: f };
    }
    o(r, "_interopRequireDefault");
    function n(f, m) {
      return c(f) || l(f, m) || i(f, m) || a();
    }
    o(n, "_slicedToArray");
    function a() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    o(a, "_nonIterableRest");
    function i(f, m) {
      if (f) {
        if (typeof f == "string") return s(f, m);
        var y = {}.toString.call(f).slice(8, -1);
        return y === "Object" && f.constructor && (y = f.constructor.name), y === "Map" || y === "Set" ? Array.from(f) : y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y) ? s(f, m) : void 0;
      }
    }
    o(i, "_unsupportedIterableToArray");
    function s(f, m) {
      (m == null || m > f.length) && (m = f.length);
      for (var y = 0, g = Array(m); y < m; y++) g[y] = f[y];
      return g;
    }
    o(s, "_arrayLikeToArray");
    function l(f, m) {
      var y = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (y != null) {
        var g, v, _, b, E = [], C = !0, k = !1;
        try {
          if (_ = (y = y.call(f)).next, m === 0) {
            if (Object(y) !== y) return;
            C = !1;
          } else for (; !(C = (g = _.call(y)).done) && (E.push(g.value), E.length !== m); C = !0) ;
        } catch (N) {
          k = !0, v = N;
        } finally {
          try {
            if (!C && y.return != null && (b = y.return(), Object(b) !== b)) return;
          } finally {
            if (k) throw v;
          }
        }
        return E;
      }
    }
    o(l, "_iterableToArrayLimit");
    function c(f) {
      if (Array.isArray(f)) return f;
    }
    o(c, "_arrayWithHoles");
    var u = [["aria-activedescendant", {
      type: "id"
    }], ["aria-atomic", {
      type: "boolean"
    }], ["aria-autocomplete", {
      type: "token",
      values: ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      type: "string"
    }], ["aria-brailleroledescription", {
      type: "string"
    }], ["aria-busy", {
      type: "boolean"
    }], ["aria-checked", {
      type: "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      type: "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", !0, !1]
    }], ["aria-describedby", {
      type: "idlist"
    }], ["aria-description", {
      type: "string"
    }], ["aria-details", {
      type: "id"
    }], ["aria-disabled", {
      type: "boolean"
    }], ["aria-dropeffect", {
      type: "tokenlist",
      values: ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      type: "id"
    }], ["aria-expanded", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-flowto", {
      type: "idlist"
    }], ["aria-grabbed", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-haspopup", {
      type: "token",
      values: [!1, !0, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-invalid", {
      type: "token",
      values: ["grammar", !1, "spelling", !0]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      type: "string"
    }], ["aria-labelledby", {
      type: "idlist"
    }], ["aria-level", {
      type: "integer"
    }], ["aria-live", {
      type: "token",
      values: ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      type: "boolean"
    }], ["aria-multiselectable", {
      type: "boolean"
    }], ["aria-orientation", {
      type: "token",
      values: ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      type: "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      type: "integer"
    }], ["aria-pressed", {
      type: "tristate"
    }], ["aria-readonly", {
      type: "boolean"
    }], ["aria-relevant", {
      type: "tokenlist",
      values: ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      type: "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      type: "boolean",
      allowundefined: !0
    }], ["aria-setsize", {
      type: "integer"
    }], ["aria-sort", {
      type: "token",
      values: ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      type: "number"
    }], ["aria-valuemin", {
      type: "number"
    }], ["aria-valuenow", {
      type: "number"
    }], ["aria-valuetext", {
      type: "string"
    }]], p = {
      entries: /* @__PURE__ */ o(function() {
        return u;
      }, "entries"),
      forEach: /* @__PURE__ */ o(function(f) {
        for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, y = 0, g = u; y < g.length; y++) {
          var v = n(g[y], 2), _ = v[0], b = v[1];
          f.call(m, b, _, u);
        }
      }, "forEach"),
      get: /* @__PURE__ */ o(function(f) {
        var m = u.filter(function(y) {
          return y[0] === f;
        })[0];
        return m && m[1];
      }, "get"),
      has: /* @__PURE__ */ o(function(f) {
        return !!p.get(f);
      }, "has"),
      keys: /* @__PURE__ */ o(function() {
        return u.map(function(f) {
          var m = n(f, 1), y = m[0];
          return y;
        });
      }, "keys"),
      values: /* @__PURE__ */ o(function() {
        return u.map(function(f) {
          var m = n(f, 2), y = m[1];
          return y;
        });
      }, "values")
    };
    e.default = (0, t.default)(p, p.entries());
  }
}), LM = F({
  "../node_modules/aria-query/lib/domMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = r(Ja());
    function r(f) {
      return f && f.__esModule ? f : { default: f };
    }
    o(r, "_interopRequireDefault");
    function n(f, m) {
      return c(f) || l(f, m) || i(f, m) || a();
    }
    o(n, "_slicedToArray");
    function a() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    o(a, "_nonIterableRest");
    function i(f, m) {
      if (f) {
        if (typeof f == "string") return s(f, m);
        var y = {}.toString.call(f).slice(8, -1);
        return y === "Object" && f.constructor && (y = f.constructor.name), y === "Map" || y === "Set" ? Array.from(f) : y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y) ? s(f, m) : void 0;
      }
    }
    o(i, "_unsupportedIterableToArray");
    function s(f, m) {
      (m == null || m > f.length) && (m = f.length);
      for (var y = 0, g = Array(m); y < m; y++) g[y] = f[y];
      return g;
    }
    o(s, "_arrayLikeToArray");
    function l(f, m) {
      var y = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
      if (y != null) {
        var g, v, _, b, E = [], C = !0, k = !1;
        try {
          if (_ = (y = y.call(f)).next, m === 0) {
            if (Object(y) !== y) return;
            C = !1;
          } else for (; !(C = (g = _.call(y)).done) && (E.push(g.value), E.length !== m); C = !0) ;
        } catch (N) {
          k = !0, v = N;
        } finally {
          try {
            if (!C && y.return != null && (b = y.return(), Object(b) !== b)) return;
          } finally {
            if (k) throw v;
          }
        }
        return E;
      }
    }
    o(l, "_iterableToArrayLimit");
    function c(f) {
      if (Array.isArray(f)) return f;
    }
    o(c, "_arrayWithHoles");
    var u = [["a", {
      reserved: !1
    }], ["abbr", {
      reserved: !1
    }], ["acronym", {
      reserved: !1
    }], ["address", {
      reserved: !1
    }], ["applet", {
      reserved: !1
    }], ["area", {
      reserved: !1
    }], ["article", {
      reserved: !1
    }], ["aside", {
      reserved: !1
    }], ["audio", {
      reserved: !1
    }], ["b", {
      reserved: !1
    }], ["base", {
      reserved: !0
    }], ["bdi", {
      reserved: !1
    }], ["bdo", {
      reserved: !1
    }], ["big", {
      reserved: !1
    }], ["blink", {
      reserved: !1
    }], ["blockquote", {
      reserved: !1
    }], ["body", {
      reserved: !1
    }], ["br", {
      reserved: !1
    }], ["button", {
      reserved: !1
    }], ["canvas", {
      reserved: !1
    }], ["caption", {
      reserved: !1
    }], ["center", {
      reserved: !1
    }], ["cite", {
      reserved: !1
    }], ["code", {
      reserved: !1
    }], ["col", {
      reserved: !0
    }], ["colgroup", {
      reserved: !0
    }], ["content", {
      reserved: !1
    }], ["data", {
      reserved: !1
    }], ["datalist", {
      reserved: !1
    }], ["dd", {
      reserved: !1
    }], ["del", {
      reserved: !1
    }], ["details", {
      reserved: !1
    }], ["dfn", {
      reserved: !1
    }], ["dialog", {
      reserved: !1
    }], ["dir", {
      reserved: !1
    }], ["div", {
      reserved: !1
    }], ["dl", {
      reserved: !1
    }], ["dt", {
      reserved: !1
    }], ["em", {
      reserved: !1
    }], ["embed", {
      reserved: !1
    }], ["fieldset", {
      reserved: !1
    }], ["figcaption", {
      reserved: !1
    }], ["figure", {
      reserved: !1
    }], ["font", {
      reserved: !1
    }], ["footer", {
      reserved: !1
    }], ["form", {
      reserved: !1
    }], ["frame", {
      reserved: !1
    }], ["frameset", {
      reserved: !1
    }], ["h1", {
      reserved: !1
    }], ["h2", {
      reserved: !1
    }], ["h3", {
      reserved: !1
    }], ["h4", {
      reserved: !1
    }], ["h5", {
      reserved: !1
    }], ["h6", {
      reserved: !1
    }], ["head", {
      reserved: !0
    }], ["header", {
      reserved: !1
    }], ["hgroup", {
      reserved: !1
    }], ["hr", {
      reserved: !1
    }], ["html", {
      reserved: !0
    }], ["i", {
      reserved: !1
    }], ["iframe", {
      reserved: !1
    }], ["img", {
      reserved: !1
    }], ["input", {
      reserved: !1
    }], ["ins", {
      reserved: !1
    }], ["kbd", {
      reserved: !1
    }], ["keygen", {
      reserved: !1
    }], ["label", {
      reserved: !1
    }], ["legend", {
      reserved: !1
    }], ["li", {
      reserved: !1
    }], ["link", {
      reserved: !0
    }], ["main", {
      reserved: !1
    }], ["map", {
      reserved: !1
    }], ["mark", {
      reserved: !1
    }], ["marquee", {
      reserved: !1
    }], ["menu", {
      reserved: !1
    }], ["menuitem", {
      reserved: !1
    }], ["meta", {
      reserved: !0
    }], ["meter", {
      reserved: !1
    }], ["nav", {
      reserved: !1
    }], ["noembed", {
      reserved: !0
    }], ["noscript", {
      reserved: !0
    }], ["object", {
      reserved: !1
    }], ["ol", {
      reserved: !1
    }], ["optgroup", {
      reserved: !1
    }], ["option", {
      reserved: !1
    }], ["output", {
      reserved: !1
    }], ["p", {
      reserved: !1
    }], ["param", {
      reserved: !0
    }], ["picture", {
      reserved: !0
    }], ["pre", {
      reserved: !1
    }], ["progress", {
      reserved: !1
    }], ["q", {
      reserved: !1
    }], ["rp", {
      reserved: !1
    }], ["rt", {
      reserved: !1
    }], ["rtc", {
      reserved: !1
    }], ["ruby", {
      reserved: !1
    }], ["s", {
      reserved: !1
    }], ["samp", {
      reserved: !1
    }], ["script", {
      reserved: !0
    }], ["section", {
      reserved: !1
    }], ["select", {
      reserved: !1
    }], ["small", {
      reserved: !1
    }], ["source", {
      reserved: !0
    }], ["spacer", {
      reserved: !1
    }], ["span", {
      reserved: !1
    }], ["strike", {
      reserved: !1
    }], ["strong", {
      reserved: !1
    }], ["style", {
      reserved: !0
    }], ["sub", {
      reserved: !1
    }], ["summary", {
      reserved: !1
    }], ["sup", {
      reserved: !1
    }], ["table", {
      reserved: !1
    }], ["tbody", {
      reserved: !1
    }], ["td", {
      reserved: !1
    }], ["textarea", {
      reserved: !1
    }], ["tfoot", {
      reserved: !1
    }], ["th", {
      reserved: !1
    }], ["thead", {
      reserved: !1
    }], ["time", {
      reserved: !1
    }], ["title", {
      reserved: !0
    }], ["tr", {
      reserved: !1
    }], ["track", {
      reserved: !0
    }], ["tt", {
      reserved: !1
    }], ["u", {
      reserved: !1
    }], ["ul", {
      reserved: !1
    }], ["var", {
      reserved: !1
    }], ["video", {
      reserved: !1
    }], ["wbr", {
      reserved: !1
    }], ["xmp", {
      reserved: !1
    }]], p = {
      entries: /* @__PURE__ */ o(function() {
        return u;
      }, "entries"),
      forEach: /* @__PURE__ */ o(function(f) {
        for (var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, y = 0, g = u; y < g.length; y++) {
          var v = n(g[y], 2), _ = v[0], b = v[1];
          f.call(m, b, _, u);
        }
      }, "forEach"),
      get: /* @__PURE__ */ o(function(f) {
        var m = u.filter(function(y) {
          return y[0] === f;
        })[0];
        return m && m[1];
      }, "get"),
      has: /* @__PURE__ */ o(function(f) {
        return !!p.get(f);
      }, "has"),
      keys: /* @__PURE__ */ o(function() {
        return u.map(function(f) {
          var m = n(f, 1), y = m[0];
          return y;
        });
      }, "keys"),
      values: /* @__PURE__ */ o(function() {
        return u.map(function(f) {
          var m = n(f, 2), y = m[1];
          return y;
        });
      }, "values")
    };
    e.default = (0, t.default)(p, p.entries());
  }
}), DM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), FM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), BM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    e.default = t;
  }
}), UM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), HM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), VM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    e.default = t;
  }
}), JM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), zM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), WM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), GM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), KM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), YM = F({
  "../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !0,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    e.default = t;
  }
}), XM = F({
  "../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = y(DM()), r = y(FM()), n = y(BM()), a = y(UM()), i = y(HM()), s = y(VM()), l = y(JM()), c = y(zM()), u = y(WM()), p = y(GM()), f = y(KM()), m = y(YM());
    function y(v) {
      return v && v.__esModule ? v : { default: v };
    }
    o(y, "_interopRequireDefault");
    var g = [["command", t.default], ["composite", r.default], ["input", n.default], ["landmark", a.default], ["range", i.default], ["roletype", s.default], ["section", l.default], ["sectionhead", c.default], ["select", u.default], ["structure", p.default], ["widget", f.default], ["window", m.default]];
    e.default = g;
  }
}), QM = F({
  "../node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), ZM = F({
  "../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    e.default = t;
  }
}), e$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), t$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    e.default = t;
  }
}), r$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), n$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), o$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), a$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), i$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), s$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), l$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), u$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), c$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), d$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), p$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), f$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), m$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), h$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    e.default = t;
  }
}), y$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    e.default = t;
  }
}), g$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), b$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), v$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    e.default = t;
  }
}), w$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), _$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/formRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), E$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), x$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    e.default = t;
  }
}), T$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), S$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), P$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), O$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), C$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), A$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), R$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/listRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), k$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), I$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), j$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/logRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), N$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), q$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/markRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), M$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), $$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), L$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), D$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    e.default = t;
  }
}), F$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    e.default = t;
  }
}), B$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    e.default = t;
  }
}), U$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    e.default = t;
  }
}), H$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), V$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), J$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    e.default = t;
  }
}), z$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), W$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), G$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), K$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), Y$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), X$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), Q$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), Z$ = F({
  "../node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), eL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), tL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), rL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), nL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), oL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), aL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    e.default = t;
  }
}), iL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    e.default = t;
  }
}), sL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), lL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    e.default = t;
  }
}), uL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), cL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), dL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), pL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), fL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    e.default = t;
  }
}), mL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    e.default = t;
  }
}), hL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), yL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    e.default = t;
  }
}), gL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), bL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/termRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), vL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    e.default = t;
  }
}), wL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), _L = F({
  "../node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    e.default = t;
  }
}), EL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), xL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), TL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    e.default = t;
  }
}), SL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    e.default = t;
  }
}), PL = F({
  "../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    e.default = t;
  }
}), OL = F({
  "../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = W(QM()), r = W(ZM()), n = W(e$()), a = W(t$()), i = W(r$()), s = W(n$()), l = W(o$()), c = W(a$()), u = W(i$()), p = W(s$()), f = W(l$()), m = W(u$()), y = W(c$()), g = W(d$()), v = W(p$()), _ = W(f$()), b = W(m$()), E = W(h$()), C = W(y$()), k = W(g$()), N = W(b$()), O = W(v$()), S = W(w$()), w = W(_$()), T = W(E$()), M = W(x$()), R = W(T$()), D = W(S$()), J = W(P$()), P = W(O$()), q = W(C$()), $ = W(A$()), H = W(R$()), z = W(k$()), Z = W(I$()), oe = W(j$()), ie = W(N$()), Y = W(q$()), be = W(M$()), we = W($$()), le = W(L$()), X = W(D$()), Re = W(F$()), Pe = W(B$()), lt = W(U$()), rt = W(H$()), L = W(V$()), K = W(J$()), Q = W(z$()), se = W(W$()), re = W(G$()), he = W(K$()), ce = W(Y$()), Ce = W(X$()), Xe = W(Q$()), mt = W(Z$()), Ct = W(eL()), ct = W(tL()), cr = W(rL()), Dt = W(nL()), Ft = W(oL()), $n = W(aL()), ci = W(iL()), cu = W(sL()), di = W(lL()), du = W(uL()), pu = W(cL()), fu = W(dL()), pi = W(pL()), mu = W(fL()), hu = W(mL()), yu = W(hL()), gu = W(yL()), bu = W(gL()), vu = W(bL()), wu = W(vL()), _u = W(wL()), Eu = W(_L()), xu = W(EL()), Tu = W(xL()), Su = W(TL()), Lo = W(SL()), fi = W(PL());
    function W(Ir) {
      return Ir && Ir.__esModule ? Ir : { default: Ir };
    }
    o(W, "_interopRequireDefault");
    var ke = [["alert", t.default], ["alertdialog", r.default], ["application", n.default], ["article", a.default], ["banner", i.default], ["blockquote", s.default], ["button", l.default], ["caption", c.default], ["cell", u.default], ["checkbox", p.default], ["code", f.default], ["columnheader", m.default], ["combobox", y.default], ["complementary", g.default], ["contentinfo", v.default], ["definition", _.default], ["deletion", b.default], ["dialog", E.default], ["directory", C.default], ["document", k.default], ["emphasis", N.default], ["feed", O.default], ["figure", S.default], ["form", w.default], ["generic", T.default], ["grid", M.default], ["gridcell", R.default], ["group", D.default], ["heading", J.default], ["img", P.default], ["insertion", q.default], ["link", $.default], ["list", H.default], ["listbox", z.default], ["listitem", Z.default], ["log", oe.default], ["main", ie.default], ["mark", Y.default], ["marquee", be.default], ["math", we.default], ["menu", le.default], ["menubar", X.default], ["menuitem", Re.default], ["menuitemcheckbox", Pe.default], ["menuitemradio", lt.default], ["meter", rt.default], ["navigation", L.default], ["none", K.default], ["note", Q.default], ["option", se.default], ["paragraph", re.default], ["presentation", he.default], ["progressbar", ce.default], ["radio", Ce.default], ["radiogroup", Xe.default], ["region", mt.default], ["row", Ct.default], ["rowgroup", ct.default], ["rowheader", cr.default], ["scrollbar", Dt.default], ["search", Ft.default], ["searchbox", $n.default], ["separator", ci.default], ["slider", cu.default], ["spinbutton", di.default], ["status", du.default], ["strong", pu.default], ["subscript", fu.default], ["superscript", pi.default], ["switch", mu.default], ["tab", hu.default], ["table", yu.default], ["tablist", gu.default], ["tabpanel", bu.default], ["term", vu.default], ["textbox", wu.default], ["time", _u.default], ["timer", Eu.default], ["toolbar", xu.default], ["tooltip", Tu.default], ["tree", Su.default], ["treegrid", Lo.default], ["treeitem", fi.default]];
    e.default = ke;
  }
}), CL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), AL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), RL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), kL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), IL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), jL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    e.default = t;
  }
}), NL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), qL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), ML = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), $L = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), LL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), DL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    e.default = t;
  }
}), FL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), BL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), UL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), HL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    e.default = t;
  }
}), VL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), JL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), zL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), WL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), GL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), KL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), YL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), XL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), QL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), ZL = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), eD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), tD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    e.default = t;
  }
}), rD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    e.default = t;
  }
}), nD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    e.default = t;
  }
}), oD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), aD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), iD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), sD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), lD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), uD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    e.default = t;
  }
}), cD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    e.default = t;
  }
}), dD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    e.default = t;
  }
}), pD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    e.default = t;
  }
}), fD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    e.default = t;
  }
}), mD = F({
  "../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    e.default = t;
  }
}), hD = F({
  "../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = X(CL()), r = X(AL()), n = X(RL()), a = X(kL()), i = X(IL()), s = X(jL()), l = X(NL()), c = X(qL()), u = X(ML()), p = X($L()), f = X(LL()), m = X(DL()), y = X(FL()), g = X(BL()), v = X(UL()), _ = X(HL()), b = X(VL()), E = X(JL()), C = X(zL()), k = X(WL()), N = X(GL()), O = X(KL()), S = X(YL()), w = X(XL()), T = X(QL()), M = X(ZL()), R = X(eD()), D = X(tD()), J = X(rD()), P = X(nD()), q = X(oD()), $ = X(aD()), H = X(iD()), z = X(sD()), Z = X(lD()), oe = X(uD()), ie = X(cD()), Y = X(dD()), be = X(pD()), we = X(fD()), le = X(mD());
    function X(Pe) {
      return Pe && Pe.__esModule ? Pe : { default: Pe };
    }
    o(X, "_interopRequireDefault");
    var Re = [["doc-abstract", t.default], ["doc-acknowledgments", r.default], ["doc-afterword", n.default], ["doc-appendix", a.default], ["doc-backlink", i.default], ["doc-biblioentry", s.default], ["doc-bibliography", l.default], ["doc-biblioref", c.default], ["doc-chapter", u.default], ["doc-colophon", p.default], ["doc-conclusion", f.default], ["doc-cover", m.default], ["doc-credit", y.default], ["doc-credits", g.default], ["doc-dedication", v.default], ["doc-endnote", _.default], ["doc-endnotes", b.default], ["doc-epigraph", E.default], ["doc-epilogue", C.default], ["doc-errata", k.default], ["doc-example", N.default], ["doc-footnote", O.default], ["doc-foreword", S.default], ["doc-glossary", w.default], ["doc-glossref", T.default], ["doc-index", M.default], ["doc-introduction", R.default], ["doc-noteref", D.default], ["doc-notice", J.default], ["doc-pagebreak", P.default], ["doc-pagefooter", q.default], ["doc-pageheader", $.default], ["doc-pagelist", H.default], ["doc-part", z.default], ["doc-preface", Z.default], ["doc-prologue", oe.default], ["doc-pullquote", ie.default], ["doc-qna", Y.default], ["doc-subtitle", be.default], ["doc-tip", we.default], ["doc-toc", le.default]];
    e.default = Re;
  }
}), yD = F({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    e.default = t;
  }
}), gD = F({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !1,
      baseConcepts: [],
      childrenPresentational: !1,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    e.default = t;
  }
}), bD = F({
  "../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = {
      abstract: !1,
      accessibleNameRequired: !0,
      baseConcepts: [],
      childrenPresentational: !0,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    e.default = t;
  }
}), vD = F({
  "../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = a(yD()), r = a(gD()), n = a(bD());
    function a(s) {
      return s && s.__esModule ? s : { default: s };
    }
    o(a, "_interopRequireDefault");
    var i = [["graphics-document", t.default], ["graphics-object", r.default], ["graphics-symbol", n.default]];
    e.default = i;
  }
}), nf = F({
  "../node_modules/aria-query/lib/rolesMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = s(XM()), r = s(OL()), n = s(hD()), a = s(vD()), i = s(Ja());
    function s(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    o(s, "_interopRequireDefault");
    function l(_, b) {
      var E = typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
      if (!E) {
        if (Array.isArray(_) || (E = p(_)) || b && _ && typeof _.length == "number") {
          E && (_ = E);
          var C = 0, k = /* @__PURE__ */ o(function() {
          }, "F");
          return { s: k, n: /* @__PURE__ */ o(function() {
            return C >= _.length ? { done: !0 } : { done: !1, value: _[C++] };
          }, "n"), e: /* @__PURE__ */ o(function(w) {
            throw w;
          }, "e"), f: k };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      var N, O = !0, S = !1;
      return { s: /* @__PURE__ */ o(function() {
        E = E.call(_);
      }, "s"), n: /* @__PURE__ */ o(function() {
        var w = E.next();
        return O = w.done, w;
      }, "n"), e: /* @__PURE__ */ o(function(w) {
        S = !0, N = w;
      }, "e"), f: /* @__PURE__ */ o(function() {
        try {
          O || E.return == null || E.return();
        } finally {
          if (S) throw N;
        }
      }, "f") };
    }
    o(l, "_createForOfIteratorHelper");
    function c(_, b) {
      return y(_) || m(_, b) || p(_, b) || u();
    }
    o(c, "_slicedToArray");
    function u() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    o(u, "_nonIterableRest");
    function p(_, b) {
      if (_) {
        if (typeof _ == "string") return f(_, b);
        var E = {}.toString.call(_).slice(8, -1);
        return E === "Object" && _.constructor && (E = _.constructor.name), E === "Map" || E === "Set" ? Array.from(_) : E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E) ? f(_, b) : void 0;
      }
    }
    o(p, "_unsupportedIterableToArray");
    function f(_, b) {
      (b == null || b > _.length) && (b = _.length);
      for (var E = 0, C = Array(b); E < b; E++) C[E] = _[E];
      return C;
    }
    o(f, "_arrayLikeToArray");
    function m(_, b) {
      var E = _ == null ? null : typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
      if (E != null) {
        var C, k, N, O, S = [], w = !0, T = !1;
        try {
          if (N = (E = E.call(_)).next, b === 0) {
            if (Object(E) !== E) return;
            w = !1;
          } else for (; !(w = (C = N.call(E)).done) && (S.push(C.value), S.length !== b); w = !0) ;
        } catch (M) {
          T = !0, k = M;
        } finally {
          try {
            if (!w && E.return != null && (O = E.return(), Object(O) !== O)) return;
          } finally {
            if (T) throw k;
          }
        }
        return S;
      }
    }
    o(m, "_iterableToArrayLimit");
    function y(_) {
      if (Array.isArray(_)) return _;
    }
    o(y, "_arrayWithHoles");
    var g = [].concat(t.default, r.default, n.default, a.default);
    g.forEach(function(_) {
      var b = c(_, 2), E = b[1], C = l(E.superClass), k;
      try {
        for (C.s(); !(k = C.n()).done; ) {
          var N = k.value, O = l(N), S;
          try {
            var w = /* @__PURE__ */ o(function() {
              var T = S.value, M = g.filter(function(q) {
                var $ = c(q, 1), H = $[0];
                return H === T;
              })[0];
              if (M)
                for (var R = M[1], D = 0, J = Object.keys(R.props); D < J.length; D++) {
                  var P = J[D];
                  Object.prototype.hasOwnProperty.call(E.props, P) || (E.props[P] = R.props[P]);
                }
            }, "_loop");
            for (O.s(); !(S = O.n()).done; )
              w();
          } catch (T) {
            O.e(T);
          } finally {
            O.f();
          }
        }
      } catch (T) {
        C.e(T);
      } finally {
        C.f();
      }
    });
    var v = {
      entries: /* @__PURE__ */ o(function() {
        return g;
      }, "entries"),
      forEach: /* @__PURE__ */ o(function(_) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, E = l(g), C;
        try {
          for (E.s(); !(C = E.n()).done; ) {
            var k = c(C.value, 2), N = k[0], O = k[1];
            _.call(b, O, N, g);
          }
        } catch (S) {
          E.e(S);
        } finally {
          E.f();
        }
      }, "forEach"),
      get: /* @__PURE__ */ o(function(_) {
        var b = g.filter(function(E) {
          return E[0] === _;
        })[0];
        return b && b[1];
      }, "get"),
      has: /* @__PURE__ */ o(function(_) {
        return !!v.get(_);
      }, "has"),
      keys: /* @__PURE__ */ o(function() {
        return g.map(function(_) {
          var b = c(_, 1), E = b[0];
          return E;
        });
      }, "keys"),
      values: /* @__PURE__ */ o(function() {
        return g.map(function(_) {
          var b = c(_, 2), E = b[1];
          return E;
        });
      }, "values")
    };
    e.default = (0, i.default)(v, v.entries());
  }
}), wD = F({
  "../node_modules/aria-query/lib/elementRoleMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = n(Ja()), r = n(nf());
    function n(O) {
      return O && O.__esModule ? O : { default: O };
    }
    o(n, "_interopRequireDefault");
    function a(O, S) {
      return u(O) || c(O, S) || s(O, S) || i();
    }
    o(a, "_slicedToArray");
    function i() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    o(i, "_nonIterableRest");
    function s(O, S) {
      if (O) {
        if (typeof O == "string") return l(O, S);
        var w = {}.toString.call(O).slice(8, -1);
        return w === "Object" && O.constructor && (w = O.constructor.name), w === "Map" || w === "Set" ? Array.from(O) : w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w) ? l(O, S) : void 0;
      }
    }
    o(s, "_unsupportedIterableToArray");
    function l(O, S) {
      (S == null || S > O.length) && (S = O.length);
      for (var w = 0, T = Array(S); w < S; w++) T[w] = O[w];
      return T;
    }
    o(l, "_arrayLikeToArray");
    function c(O, S) {
      var w = O == null ? null : typeof Symbol < "u" && O[Symbol.iterator] || O["@@iterator"];
      if (w != null) {
        var T, M, R, D, J = [], P = !0, q = !1;
        try {
          if (R = (w = w.call(O)).next, S === 0) {
            if (Object(w) !== w) return;
            P = !1;
          } else for (; !(P = (T = R.call(w)).done) && (J.push(T.value), J.length !== S); P = !0) ;
        } catch ($) {
          q = !0, M = $;
        } finally {
          try {
            if (!P && w.return != null && (D = w.return(), Object(D) !== D)) return;
          } finally {
            if (q) throw M;
          }
        }
        return J;
      }
    }
    o(c, "_iterableToArrayLimit");
    function u(O) {
      if (Array.isArray(O)) return O;
    }
    o(u, "_arrayWithHoles");
    var p = [], f = r.default.keys();
    for (b = 0; b < f.length; b++)
      if (m = f[b], y = r.default.get(m), y)
        for (g = [].concat(y.baseConcepts, y.relatedConcepts), v = /* @__PURE__ */ o(function() {
          var O = g[_];
          if (O.module === "HTML") {
            var S = O.concept;
            if (S) {
              var w = p.filter(function(D) {
                return C(D[0], S);
              })[0], T;
              w ? T = w[1] : T = [];
              for (var M = !0, R = 0; R < T.length; R++)
                if (T[R] === m) {
                  M = !1;
                  break;
                }
              M && T.push(m), w || p.push([S, T]);
            }
          }
        }, "_loop"), _ = 0; _ < g.length; _++)
          v();
    var m, y, g, v, _, b, E = {
      entries: /* @__PURE__ */ o(function() {
        return p;
      }, "entries"),
      forEach: /* @__PURE__ */ o(function(O) {
        for (var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, w = 0, T = p; w < T.length; w++) {
          var M = a(T[w], 2), R = M[0], D = M[1];
          O.call(S, D, R, p);
        }
      }, "forEach"),
      get: /* @__PURE__ */ o(function(O) {
        var S = p.filter(function(w) {
          return O.name === w[0].name && N(O.attributes, w[0].attributes);
        })[0];
        return S && S[1];
      }, "get"),
      has: /* @__PURE__ */ o(function(O) {
        return !!E.get(O);
      }, "has"),
      keys: /* @__PURE__ */ o(function() {
        return p.map(function(O) {
          var S = a(O, 1), w = S[0];
          return w;
        });
      }, "keys"),
      values: /* @__PURE__ */ o(function() {
        return p.map(function(O) {
          var S = a(O, 2), w = S[1];
          return w;
        });
      }, "values")
    };
    function C(O, S) {
      return O.name === S.name && k(O.constraints, S.constraints) && N(O.attributes, S.attributes);
    }
    o(C, "ariaRoleRelationConceptEquals");
    function k(O, S) {
      if (O === void 0 && S !== void 0 || O !== void 0 && S === void 0)
        return !1;
      if (O !== void 0 && S !== void 0) {
        if (O.length !== S.length)
          return !1;
        for (var w = 0; w < O.length; w++)
          if (O[w] !== S[w])
            return !1;
      }
      return !0;
    }
    o(k, "ariaRoleRelationConstraintsEquals");
    function N(O, S) {
      if (O === void 0 && S !== void 0 || O !== void 0 && S === void 0)
        return !1;
      if (O !== void 0 && S !== void 0) {
        if (O.length !== S.length)
          return !1;
        for (var w = 0; w < O.length; w++) {
          if (O[w].name !== S[w].name || O[w].value !== S[w].value || O[w].constraints === void 0 && S[w].constraints !== void 0 || O[w].constraints !== void 0 && S[w].constraints === void 0)
            return !1;
          if (O[w].constraints !== void 0 && S[w].constraints !== void 0) {
            if (O[w].constraints.length !== S[w].constraints.length)
              return !1;
            for (var T = 0; T < O[w].constraints.length; T++)
              if (O[w].constraints[T] !== S[w].constraints[T])
                return !1;
          }
        }
      }
      return !0;
    }
    o(N, "ariaRoleRelationConceptAttributeEquals"), e.default = (0, t.default)(E, E.entries());
  }
}), _D = F({
  "../node_modules/aria-query/lib/roleElementMap.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var t = n(Ja()), r = n(nf());
    function n(N) {
      return N && N.__esModule ? N : { default: N };
    }
    o(n, "_interopRequireDefault");
    function a(N, O) {
      return u(N) || c(N, O) || s(N, O) || i();
    }
    o(a, "_slicedToArray");
    function i() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    o(i, "_nonIterableRest");
    function s(N, O) {
      if (N) {
        if (typeof N == "string") return l(N, O);
        var S = {}.toString.call(N).slice(8, -1);
        return S === "Object" && N.constructor && (S = N.constructor.name), S === "Map" || S === "Set" ? Array.from(N) : S === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S) ? l(N, O) : void 0;
      }
    }
    o(s, "_unsupportedIterableToArray");
    function l(N, O) {
      (O == null || O > N.length) && (O = N.length);
      for (var S = 0, w = Array(O); S < O; S++) w[S] = N[S];
      return w;
    }
    o(l, "_arrayLikeToArray");
    function c(N, O) {
      var S = N == null ? null : typeof Symbol < "u" && N[Symbol.iterator] || N["@@iterator"];
      if (S != null) {
        var w, T, M, R, D = [], J = !0, P = !1;
        try {
          if (M = (S = S.call(N)).next, O === 0) {
            if (Object(S) !== S) return;
            J = !1;
          } else for (; !(J = (w = M.call(S)).done) && (D.push(w.value), D.length !== O); J = !0) ;
        } catch (q) {
          P = !0, T = q;
        } finally {
          try {
            if (!J && S.return != null && (R = S.return(), Object(R) !== R)) return;
          } finally {
            if (P) throw T;
          }
        }
        return D;
      }
    }
    o(c, "_iterableToArrayLimit");
    function u(N) {
      if (Array.isArray(N)) return N;
    }
    o(u, "_arrayWithHoles");
    var p = [], f = r.default.keys();
    for (C = 0; C < f.length; C++)
      if (m = f[C], y = r.default.get(m), g = [], y) {
        for (v = [].concat(y.baseConcepts, y.relatedConcepts), E = 0; E < v.length; E++)
          _ = v[E], _.module === "HTML" && (b = _.concept, b != null && g.push(b));
        g.length > 0 && p.push([m, g]);
      }
    var m, y, g, v, _, b, E, C, k = {
      entries: /* @__PURE__ */ o(function() {
        return p;
      }, "entries"),
      forEach: /* @__PURE__ */ o(function(N) {
        for (var O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, S = 0, w = p; S < w.length; S++) {
          var T = a(w[S], 2), M = T[0], R = T[1];
          N.call(O, R, M, p);
        }
      }, "forEach"),
      get: /* @__PURE__ */ o(function(N) {
        var O = p.filter(function(S) {
          return S[0] === N;
        })[0];
        return O && O[1];
      }, "get"),
      has: /* @__PURE__ */ o(function(N) {
        return !!k.get(N);
      }, "has"),
      keys: /* @__PURE__ */ o(function() {
        return p.map(function(N) {
          var O = a(N, 1), S = O[0];
          return S;
        });
      }, "keys"),
      values: /* @__PURE__ */ o(function() {
        return p.map(function(N) {
          var O = a(N, 2), S = O[1];
          return S;
        });
      }, "values")
    };
    e.default = (0, t.default)(k, k.entries());
  }
}), of = F({
  "../node_modules/aria-query/lib/index.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0;
    var t = s($M()), r = s(LM()), n = s(nf()), a = s(wD()), i = s(_D());
    function s(l) {
      return l && l.__esModule ? l : { default: l };
    }
    o(s, "_interopRequireDefault"), e.aria = t.default, e.dom = r.default, e.roles = n.default, e.elementRoles = a.default, e.roleElements = i.default;
  }
}), bx = F({
  "../node_modules/css.escape/css.escape.js"(e, t) {
    (function(r, n) {
      typeof e == "object" ? t.exports = n(r) : typeof define == "function" && define.amd ? define([], n.bind(r, r)) : n(r);
    })(typeof globalThis < "u" ? globalThis : e, function(r) {
      if (r.CSS && r.CSS.escape)
        return r.CSS.escape;
      var n = /* @__PURE__ */ o(function(a) {
        if (arguments.length == 0)
          throw new TypeError("`CSS.escape` requires an argument.");
        for (var i = String(a), s = i.length, l = -1, c, u = "", p = i.charCodeAt(0); ++l < s; ) {
          if (c = i.charCodeAt(l), c == 0) {
            u += "ï¿½";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, [â€¦]
            c >= 1 && c <= 31 || c == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), [â€¦]
            l == 0 && c >= 48 && c <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), [â€¦]
            l == 1 && c >= 48 && c <= 57 && p == 45
          ) {
            u += "\\" + c.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, [â€¦]
            l == 0 && s == 1 && c == 45
          ) {
            u += "\\" + i.charAt(l);
            continue;
          }
          if (c >= 128 || c == 45 || c == 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
            u += i.charAt(l);
            continue;
          }
          u += "\\" + i.charAt(l);
        }
        return u;
      }, "cssEscape");
      return r.CSS || (r.CSS = {}), r.CSS.escape = n, n;
    });
  }
}), vx = F({
  "../node_modules/pretty-format/node_modules/ansi-styles/index.js"(e, t) {
    var r = 10, n = /* @__PURE__ */ o((s = 0) => (l) => `\x1B[${38 + s};5;${l}m`, "wrapAnsi256"), a = /* @__PURE__ */ o((s = 0) => (l, c, u) => `\x1B[${38 + s};2;${l};${c};${u}m`, "wrapAnsi16m");
    function i() {
      const s = /* @__PURE__ */ new Map(), l = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      l.color.gray = l.color.blackBright, l.bgColor.bgGray = l.bgColor.bgBlackBright, l.color.grey = l.color.blackBright, l.bgColor.bgGrey = l.bgColor.bgBlackBright;
      for (const [c, u] of Object.entries(l)) {
        for (const [p, f] of Object.entries(u))
          l[p] = {
            open: `\x1B[${f[0]}m`,
            close: `\x1B[${f[1]}m`
          }, u[p] = l[p], s.set(f[0], f[1]);
        Object.defineProperty(l, c, {
          value: u,
          enumerable: !1
        });
      }
      return Object.defineProperty(l, "codes", {
        value: s,
        enumerable: !1
      }), l.color.close = "\x1B[39m", l.bgColor.close = "\x1B[49m", l.color.ansi256 = n(), l.color.ansi16m = a(), l.bgColor.ansi256 = n(r), l.bgColor.ansi16m = a(r), Object.defineProperties(l, {
        rgbToAnsi256: {
          value: /* @__PURE__ */ o((c, u, p) => c === u && u === p ? c < 8 ? 16 : c > 248 ? 231 : Math.round((c - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(c / 255 * 5) + 6 * Math.round(u / 255 * 5) + Math.round(p / 255 * 5), "value"),
          enumerable: !1
        },
        hexToRgb: {
          value: /* @__PURE__ */ o((c) => {
            const u = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(c.toString(16));
            if (!u)
              return [0, 0, 0];
            let { colorString: p } = u.groups;
            p.length === 3 && (p = p.split("").map((m) => m + m).join(""));
            const f = Number.parseInt(p, 16);
            return [
              f >> 16 & 255,
              f >> 8 & 255,
              f & 255
            ];
          }, "value"),
          enumerable: !1
        },
        hexToAnsi256: {
          value: /* @__PURE__ */ o((c) => l.rgbToAnsi256(...l.hexToRgb(c)), "value"),
          enumerable: !1
        }
      }), l;
    }
    o(i, "assembleStyles"), Object.defineProperty(t, "exports", {
      enumerable: !0,
      get: i
    });
  }
}), tl = F({
  "../node_modules/pretty-format/build/collections.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.printIteratorEntries = r, e.printIteratorValues = n, e.printListItems = a, e.printObjectProperties = i;
    var t = /* @__PURE__ */ o((s, l) => {
      const c = Object.keys(s).sort(l);
      return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(s).forEach((u) => {
        Object.getOwnPropertyDescriptor(s, u).enumerable && c.push(u);
      }), c;
    }, "getKeysOfEnumerableProperties");
    function r(s, l, c, u, p, f, m = ": ") {
      let y = "", g = s.next();
      if (!g.done) {
        y += l.spacingOuter;
        const v = c + l.indent;
        for (; !g.done; ) {
          const _ = f(
            g.value[0],
            l,
            v,
            u,
            p
          ), b = f(
            g.value[1],
            l,
            v,
            u,
            p
          );
          y += v + _ + m + b, g = s.next(), g.done ? l.min || (y += ",") : y += "," + l.spacingInner;
        }
        y += l.spacingOuter + c;
      }
      return y;
    }
    o(r, "printIteratorEntries");
    function n(s, l, c, u, p, f) {
      let m = "", y = s.next();
      if (!y.done) {
        m += l.spacingOuter;
        const g = c + l.indent;
        for (; !y.done; )
          m += g + f(y.value, l, g, u, p), y = s.next(), y.done ? l.min || (m += ",") : m += "," + l.spacingInner;
        m += l.spacingOuter + c;
      }
      return m;
    }
    o(n, "printIteratorValues");
    function a(s, l, c, u, p, f) {
      let m = "";
      if (s.length) {
        m += l.spacingOuter;
        const y = c + l.indent;
        for (let g = 0; g < s.length; g++)
          m += y, g in s && (m += f(s[g], l, y, u, p)), g < s.length - 1 ? m += "," + l.spacingInner : l.min || (m += ",");
        m += l.spacingOuter + c;
      }
      return m;
    }
    o(a, "printListItems");
    function i(s, l, c, u, p, f) {
      let m = "";
      const y = t(s, l.compareKeys);
      if (y.length) {
        m += l.spacingOuter;
        const g = c + l.indent;
        for (let v = 0; v < y.length; v++) {
          const _ = y[v], b = f(_, l, g, u, p), E = f(s[_], l, g, u, p);
          m += g + b + ": " + E, v < y.length - 1 ? m += "," + l.spacingInner : l.min || (m += ",");
        }
        m += l.spacingOuter + c;
      }
      return m;
    }
    o(i, "printObjectProperties");
  }
}), ED = F({
  "../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = tl(), r = (function() {
      return typeof globalThis < "u" ? globalThis : typeof r < "u" ? r : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), n = r["jest-symbol-do-not-touch"] || r.Symbol, a = typeof n == "function" && n.for ? n.for("jest.asymmetricMatcher") : 1267621, i = " ", s = /* @__PURE__ */ o((p, f, m, y, g, v) => {
      const _ = p.toString();
      return _ === "ArrayContaining" || _ === "ArrayNotContaining" ? ++y > f.maxDepth ? "[" + _ + "]" : _ + i + "[" + (0, t.printListItems)(
        p.sample,
        f,
        m,
        y,
        g,
        v
      ) + "]" : _ === "ObjectContaining" || _ === "ObjectNotContaining" ? ++y > f.maxDepth ? "[" + _ + "]" : _ + i + "{" + (0, t.printObjectProperties)(
        p.sample,
        f,
        m,
        y,
        g,
        v
      ) + "}" : _ === "StringMatching" || _ === "StringNotMatching" || _ === "StringContaining" || _ === "StringNotContaining" ? _ + i + v(p.sample, f, m, y, g) : p.toAsymmetricMatcher();
    }, "serialize");
    e.serialize = s;
    var l = /* @__PURE__ */ o((p) => p && p.$$typeof === a, "test");
    e.test = l;
    var c = {
      serialize: s,
      test: l
    }, u = c;
    e.default = u;
  }
}), xD = F({
  "../node_modules/pretty-format/node_modules/ansi-regex/index.js"(e, t) {
    t.exports = ({ onlyFirst: r = !1 } = {}) => {
      const n = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(n, r ? void 0 : "g");
    };
  }
}), TD = F({
  "../node_modules/pretty-format/build/plugins/ConvertAnsi.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = n(xD()), r = n(vx());
    function n(u) {
      return u && u.__esModule ? u : { default: u };
    }
    o(n, "_interopRequireDefault");
    var a = /* @__PURE__ */ o((u) => u.replace((0, t.default)(), (p) => {
      switch (p) {
        case r.default.red.close:
        case r.default.green.close:
        case r.default.cyan.close:
        case r.default.gray.close:
        case r.default.white.close:
        case r.default.yellow.close:
        case r.default.bgRed.close:
        case r.default.bgGreen.close:
        case r.default.bgYellow.close:
        case r.default.inverse.close:
        case r.default.dim.close:
        case r.default.bold.close:
        case r.default.reset.open:
        case r.default.reset.close:
          return "</>";
        case r.default.red.open:
          return "<red>";
        case r.default.green.open:
          return "<green>";
        case r.default.cyan.open:
          return "<cyan>";
        case r.default.gray.open:
          return "<gray>";
        case r.default.white.open:
          return "<white>";
        case r.default.yellow.open:
          return "<yellow>";
        case r.default.bgRed.open:
          return "<bgRed>";
        case r.default.bgGreen.open:
          return "<bgGreen>";
        case r.default.bgYellow.open:
          return "<bgYellow>";
        case r.default.inverse.open:
          return "<inverse>";
        case r.default.dim.open:
          return "<dim>";
        case r.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    }), "toHumanReadableAnsi"), i = /* @__PURE__ */ o((u) => typeof u == "string" && !!u.match((0, t.default)()), "test");
    e.test = i;
    var s = /* @__PURE__ */ o((u, p, f, m, y, g) => g(a(u), p, f, m, y), "serialize");
    e.serialize = s;
    var l = {
      serialize: s,
      test: i
    }, c = l;
    e.default = c;
  }
}), SD = F({
  "../node_modules/pretty-format/build/plugins/DOMCollection.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = tl(), r = " ", n = ["DOMStringMap", "NamedNodeMap"], a = /^(HTML\w*Collection|NodeList)$/, i = /* @__PURE__ */ o((f) => n.indexOf(f) !== -1 || a.test(f), "testName"), s = /* @__PURE__ */ o((f) => f && f.constructor && !!f.constructor.name && i(f.constructor.name), "test");
    e.test = s;
    var l = /* @__PURE__ */ o((f) => f.constructor.name === "NamedNodeMap", "isNamedNodeMap"), c = /* @__PURE__ */ o((f, m, y, g, v, _) => {
      const b = f.constructor.name;
      return ++g > m.maxDepth ? "[" + b + "]" : (m.min ? "" : b + r) + (n.indexOf(b) !== -1 ? "{" + (0, t.printObjectProperties)(
        l(f) ? Array.from(f).reduce((E, C) => (E[C.name] = C.value, E), {}) : { ...f },
        m,
        y,
        g,
        v,
        _
      ) + "}" : "[" + (0, t.printListItems)(
        Array.from(f),
        m,
        y,
        g,
        v,
        _
      ) + "]");
    }, "serialize");
    e.serialize = c;
    var u = {
      serialize: c,
      test: s
    }, p = u;
    e.default = p;
  }
}), PD = F({
  "../node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = t;
    function t(r) {
      return r.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    o(t, "escapeHTML");
  }
}), af = F({
  "../node_modules/pretty-format/build/plugins/lib/markup.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.printText = e.printProps = e.printElementAsLeaf = e.printElement = e.printComment = e.printChildren = void 0;
    var t = r(PD());
    function r(u) {
      return u && u.__esModule ? u : { default: u };
    }
    o(r, "_interopRequireDefault");
    var n = /* @__PURE__ */ o((u, p, f, m, y, g, v) => {
      const _ = m + f.indent, b = f.colors;
      return u.map((E) => {
        const C = p[E];
        let k = v(C, f, _, y, g);
        return typeof C != "string" && (k.indexOf(`
`) !== -1 && (k = f.spacingOuter + _ + k + f.spacingOuter + m), k = "{" + k + "}"), f.spacingInner + m + b.prop.open + E + b.prop.close + "=" + b.value.open + k + b.value.close;
      }).join("");
    }, "printProps");
    e.printProps = n;
    var a = /* @__PURE__ */ o((u, p, f, m, y, g) => u.map(
      (v) => p.spacingOuter + f + (typeof v == "string" ? i(v, p) : g(v, p, f, m, y))
    ).join(""), "printChildren");
    e.printChildren = a;
    var i = /* @__PURE__ */ o((u, p) => {
      const f = p.colors.content;
      return f.open + (0, t.default)(u) + f.close;
    }, "printText");
    e.printText = i;
    var s = /* @__PURE__ */ o((u, p) => {
      const f = p.colors.comment;
      return f.open + "<!--" + (0, t.default)(u) + "-->" + f.close;
    }, "printComment");
    e.printComment = s;
    var l = /* @__PURE__ */ o((u, p, f, m, y) => {
      const g = m.colors.tag;
      return g.open + "<" + u + (p && g.close + p + m.spacingOuter + y + g.open) + (f ? ">" + g.close + f + m.spacingOuter + y + g.open + "</" + u : (p && !m.min ? "" : " ") + "/") + ">" + g.close;
    }, "printElement");
    e.printElement = l;
    var c = /* @__PURE__ */ o((u, p) => {
      const f = p.colors.tag;
      return f.open + "<" + u + f.close + " â€¦" + f.open + " />" + f.close;
    }, "printElementAsLeaf");
    e.printElementAsLeaf = c;
  }
}), OD = F({
  "../node_modules/pretty-format/build/plugins/DOMElement.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = af(), r = 1, n = 3, a = 8, i = 11, s = /^((HTML|SVG)\w*)?Element$/, l = /* @__PURE__ */ o((_) => {
      try {
        return typeof _.hasAttribute == "function" && _.hasAttribute("is");
      } catch {
        return !1;
      }
    }, "testHasAttribute"), c = /* @__PURE__ */ o((_) => {
      const b = _.constructor.name, { nodeType: E, tagName: C } = _, k = typeof C == "string" && C.includes("-") || l(_);
      return E === r && (s.test(b) || k) || E === n && b === "Text" || E === a && b === "Comment" || E === i && b === "DocumentFragment";
    }, "testNode"), u = /* @__PURE__ */ o((_) => {
      var b;
      return (_ == null || (b = _.constructor) === null || b === void 0 ? void 0 : b.name) && c(_);
    }, "test");
    e.test = u;
    function p(_) {
      return _.nodeType === n;
    }
    o(p, "nodeIsText");
    function f(_) {
      return _.nodeType === a;
    }
    o(f, "nodeIsComment");
    function m(_) {
      return _.nodeType === i;
    }
    o(m, "nodeIsFragment");
    var y = /* @__PURE__ */ o((_, b, E, C, k, N) => {
      if (p(_))
        return (0, t.printText)(_.data, b);
      if (f(_))
        return (0, t.printComment)(_.data, b);
      const O = m(_) ? "DocumentFragment" : _.tagName.toLowerCase();
      return ++C > b.maxDepth ? (0, t.printElementAsLeaf)(O, b) : (0, t.printElement)(
        O,
        (0, t.printProps)(
          m(_) ? [] : Array.from(_.attributes).map((S) => S.name).sort(),
          m(_) ? {} : Array.from(_.attributes).reduce((S, w) => (S[w.name] = w.value, S), {}),
          b,
          E + b.indent,
          C,
          k,
          N
        ),
        (0, t.printChildren)(
          Array.prototype.slice.call(_.childNodes || _.children),
          b,
          E + b.indent,
          C,
          k,
          N
        ),
        b,
        E
      );
    }, "serialize");
    e.serialize = y;
    var g = {
      serialize: y,
      test: u
    }, v = g;
    e.default = v;
  }
}), CD = F({
  "../node_modules/pretty-format/build/plugins/Immutable.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = tl(), r = "@@__IMMUTABLE_ITERABLE__@@", n = "@@__IMMUTABLE_LIST__@@", a = "@@__IMMUTABLE_KEYED__@@", i = "@@__IMMUTABLE_MAP__@@", s = "@@__IMMUTABLE_ORDERED__@@", l = "@@__IMMUTABLE_RECORD__@@", c = "@@__IMMUTABLE_SEQ__@@", u = "@@__IMMUTABLE_SET__@@", p = "@@__IMMUTABLE_STACK__@@", f = /* @__PURE__ */ o((w) => "Immutable." + w, "getImmutableName"), m = /* @__PURE__ */ o((w) => "[" + w + "]", "printAsLeaf"), y = " ", g = "â€¦", v = /* @__PURE__ */ o((w, T, M, R, D, J, P) => ++R > T.maxDepth ? m(f(P)) : f(P) + y + "{" + (0, t.printIteratorEntries)(
      w.entries(),
      T,
      M,
      R,
      D,
      J
    ) + "}", "printImmutableEntries");
    function _(w) {
      let T = 0;
      return {
        next() {
          if (T < w._keys.length) {
            const M = w._keys[T++];
            return {
              done: !1,
              value: [M, w.get(M)]
            };
          }
          return {
            done: !0,
            value: void 0
          };
        }
      };
    }
    o(_, "getRecordEntries");
    var b = /* @__PURE__ */ o((w, T, M, R, D, J) => {
      const P = f(w._name || "Record");
      return ++R > T.maxDepth ? m(P) : P + y + "{" + (0, t.printIteratorEntries)(
        _(w),
        T,
        M,
        R,
        D,
        J
      ) + "}";
    }, "printImmutableRecord"), E = /* @__PURE__ */ o((w, T, M, R, D, J) => {
      const P = f("Seq");
      return ++R > T.maxDepth ? m(P) : w[a] ? P + y + "{" + // from Immutable collection of entries or from ECMAScript object
      (w._iter || w._object ? (0, t.printIteratorEntries)(
        w.entries(),
        T,
        M,
        R,
        D,
        J
      ) : g) + "}" : P + y + "[" + (w._iter || // from Immutable collection of values
      w._array || // from ECMAScript array
      w._collection || // from ECMAScript collection in immutable v4
      w._iterable ? (0, t.printIteratorValues)(
        w.values(),
        T,
        M,
        R,
        D,
        J
      ) : g) + "]";
    }, "printImmutableSeq"), C = /* @__PURE__ */ o((w, T, M, R, D, J, P) => ++R > T.maxDepth ? m(f(P)) : f(P) + y + "[" + (0, t.printIteratorValues)(
      w.values(),
      T,
      M,
      R,
      D,
      J
    ) + "]", "printImmutableValues"), k = /* @__PURE__ */ o((w, T, M, R, D, J) => w[i] ? v(
      w,
      T,
      M,
      R,
      D,
      J,
      w[s] ? "OrderedMap" : "Map"
    ) : w[n] ? C(
      w,
      T,
      M,
      R,
      D,
      J,
      "List"
    ) : w[u] ? C(
      w,
      T,
      M,
      R,
      D,
      J,
      w[s] ? "OrderedSet" : "Set"
    ) : w[p] ? C(
      w,
      T,
      M,
      R,
      D,
      J,
      "Stack"
    ) : w[c] ? E(w, T, M, R, D, J) : b(w, T, M, R, D, J), "serialize");
    e.serialize = k;
    var N = /* @__PURE__ */ o((w) => w && (w[r] === !0 || w[l] === !0), "test");
    e.test = N;
    var O = {
      serialize: k,
      test: N
    }, S = O;
    e.default = S;
  }
}), AD = F({
  "../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js"(e) {
    var t = 60103, r = 60106, n = 60107, a = 60108, i = 60114, s = 60109, l = 60110, c = 60112, u = 60113, p = 60120, f = 60115, m = 60116, y = 60121, g = 60122, v = 60117, _ = 60129, b = 60131;
    typeof Symbol == "function" && Symbol.for && (E = Symbol.for, t = E("react.element"), r = E("react.portal"), n = E("react.fragment"), a = E("react.strict_mode"), i = E("react.profiler"), s = E("react.provider"), l = E("react.context"), c = E("react.forward_ref"), u = E("react.suspense"), p = E("react.suspense_list"), f = E("react.memo"), m = E("react.lazy"), y = E("react.block"), g = E("react.server.block"), v = E("react.fundamental"), _ = E("react.debug_trace_mode"), b = E("react.legacy_hidden"));
    var E;
    function C(P) {
      if (typeof P == "object" && P !== null) {
        var q = P.$$typeof;
        switch (q) {
          case t:
            switch (P = P.type, P) {
              case n:
              case i:
              case a:
              case u:
              case p:
                return P;
              default:
                switch (P = P && P.$$typeof, P) {
                  case l:
                  case c:
                  case m:
                  case f:
                  case s:
                    return P;
                  default:
                    return q;
                }
            }
          case r:
            return q;
        }
      }
    }
    o(C, "y");
    var k = s, N = t, O = c, S = n, w = m, T = f, M = r, R = i, D = a, J = u;
    e.ContextConsumer = l, e.ContextProvider = k, e.Element = N, e.ForwardRef = O, e.Fragment = S, e.Lazy = w, e.Memo = T, e.Portal = M, e.Profiler = R, e.StrictMode = D, e.Suspense = J, e.isAsyncMode = function() {
      return !1;
    }, e.isConcurrentMode = function() {
      return !1;
    }, e.isContextConsumer = function(P) {
      return C(P) === l;
    }, e.isContextProvider = function(P) {
      return C(P) === s;
    }, e.isElement = function(P) {
      return typeof P == "object" && P !== null && P.$$typeof === t;
    }, e.isForwardRef = function(P) {
      return C(P) === c;
    }, e.isFragment = function(P) {
      return C(P) === n;
    }, e.isLazy = function(P) {
      return C(P) === m;
    }, e.isMemo = function(P) {
      return C(P) === f;
    }, e.isPortal = function(P) {
      return C(P) === r;
    }, e.isProfiler = function(P) {
      return C(P) === i;
    }, e.isStrictMode = function(P) {
      return C(P) === a;
    }, e.isSuspense = function(P) {
      return C(P) === u;
    }, e.isValidElementType = function(P) {
      return typeof P == "string" || typeof P == "function" || P === n || P === i || P === _ || P === a || P === u || P === p || P === b || typeof P == "object" && P !== null && (P.$$typeof === m || P.$$typeof === f || P.$$typeof === s || P.$$typeof === l || P.$$typeof === c || P.$$typeof === v || P.$$typeof === y || P[0] === g);
    }, e.typeOf = C;
  }
}), RD = F({
  "../node_modules/pretty-format/node_modules/react-is/index.js"(e, t) {
    t.exports = AD();
  }
}), kD = F({
  "../node_modules/pretty-format/build/plugins/ReactElement.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = a(RD()), r = af();
    function n(m) {
      if (typeof WeakMap != "function") return null;
      var y = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
      return (n = /* @__PURE__ */ o(function(v) {
        return v ? g : y;
      }, "_getRequireWildcardCache"))(m);
    }
    o(n, "_getRequireWildcardCache");
    function a(m, y) {
      if (!y && m && m.__esModule)
        return m;
      if (m === null || typeof m != "object" && typeof m != "function")
        return { default: m };
      var g = n(y);
      if (g && g.has(m))
        return g.get(m);
      var v = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b in m)
        if (b !== "default" && Object.prototype.hasOwnProperty.call(m, b)) {
          var E = _ ? Object.getOwnPropertyDescriptor(m, b) : null;
          E && (E.get || E.set) ? Object.defineProperty(v, b, E) : v[b] = m[b];
        }
      return v.default = m, g && g.set(m, v), v;
    }
    o(a, "_interopRequireWildcard");
    var i = /* @__PURE__ */ o((m, y = []) => (Array.isArray(m) ? m.forEach((g) => {
      i(g, y);
    }) : m != null && m !== !1 && y.push(m), y), "getChildren"), s = /* @__PURE__ */ o((m) => {
      const y = m.type;
      if (typeof y == "string")
        return y;
      if (typeof y == "function")
        return y.displayName || y.name || "Unknown";
      if (t.isFragment(m))
        return "React.Fragment";
      if (t.isSuspense(m))
        return "React.Suspense";
      if (typeof y == "object" && y !== null) {
        if (t.isContextProvider(m))
          return "Context.Provider";
        if (t.isContextConsumer(m))
          return "Context.Consumer";
        if (t.isForwardRef(m)) {
          if (y.displayName)
            return y.displayName;
          const g = y.render.displayName || y.render.name || "";
          return g !== "" ? "ForwardRef(" + g + ")" : "ForwardRef";
        }
        if (t.isMemo(m)) {
          const g = y.displayName || y.type.displayName || y.type.name || "";
          return g !== "" ? "Memo(" + g + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    }, "getType"), l = /* @__PURE__ */ o((m) => {
      const { props: y } = m;
      return Object.keys(y).filter((g) => g !== "children" && y[g] !== void 0).sort();
    }, "getPropKeys"), c = /* @__PURE__ */ o((m, y, g, v, _, b) => ++v > y.maxDepth ? (0, r.printElementAsLeaf)(s(m), y) : (0, r.printElement)(
      s(m),
      (0, r.printProps)(
        l(m),
        m.props,
        y,
        g + y.indent,
        v,
        _,
        b
      ),
      (0, r.printChildren)(
        i(m.props.children),
        y,
        g + y.indent,
        v,
        _,
        b
      ),
      y,
      g
    ), "serialize");
    e.serialize = c;
    var u = /* @__PURE__ */ o((m) => m != null && t.isElement(m), "test");
    e.test = u;
    var p = {
      serialize: c,
      test: u
    }, f = p;
    e.default = f;
  }
}), ID = F({
  "../node_modules/pretty-format/build/plugins/ReactTestComponent.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.test = e.serialize = e.default = void 0;
    var t = af(), r = (function() {
      return typeof globalThis < "u" ? globalThis : typeof r < "u" ? r : typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
    })(), n = r["jest-symbol-do-not-touch"] || r.Symbol, a = typeof n == "function" && n.for ? n.for("react.test.json") : 245830487, i = /* @__PURE__ */ o((p) => {
      const { props: f } = p;
      return f ? Object.keys(f).filter((m) => f[m] !== void 0).sort() : [];
    }, "getPropKeys"), s = /* @__PURE__ */ o((p, f, m, y, g, v) => ++y > f.maxDepth ? (0, t.printElementAsLeaf)(p.type, f) : (0, t.printElement)(
      p.type,
      p.props ? (0, t.printProps)(
        i(p),
        p.props,
        f,
        m + f.indent,
        y,
        g,
        v
      ) : "",
      p.children ? (0, t.printChildren)(
        p.children,
        f,
        m + f.indent,
        y,
        g,
        v
      ) : "",
      f,
      m
    ), "serialize");
    e.serialize = s;
    var l = /* @__PURE__ */ o((p) => p && p.$$typeof === a, "test");
    e.test = l;
    var c = {
      serialize: s,
      test: l
    }, u = c;
    e.default = u;
  }
}), jD = F({
  "../node_modules/pretty-format/build/index.js"(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = e.DEFAULT_OPTIONS = void 0, e.format = Pe, e.plugins = void 0;
    var t = p(vx()), r = tl(), n = p(
      ED()
    ), a = p(TD()), i = p(SD()), s = p(OD()), l = p(CD()), c = p(kD()), u = p(
      ID()
    );
    function p(L) {
      return L && L.__esModule ? L : { default: L };
    }
    o(p, "_interopRequireDefault");
    var f = Object.prototype.toString, m = Date.prototype.toISOString, y = Error.prototype.toString, g = RegExp.prototype.toString, v = /* @__PURE__ */ o((L) => typeof L.constructor == "function" && L.constructor.name || "Object", "getConstructorName"), _ = /* @__PURE__ */ o((L) => typeof window < "u" && L === window, "isWindow"), b = /^Symbol\((.*)\)(.*)$/, E = /\n/gi, C = class extends Error {
      constructor(L, K) {
        super(L), this.stack = K, this.name = this.constructor.name;
      }
    };
    o(C, "PrettyFormatPluginError");
    var k = C;
    function N(L) {
      return L === "[object Array]" || L === "[object ArrayBuffer]" || L === "[object DataView]" || L === "[object Float32Array]" || L === "[object Float64Array]" || L === "[object Int8Array]" || L === "[object Int16Array]" || L === "[object Int32Array]" || L === "[object Uint8Array]" || L === "[object Uint8ClampedArray]" || L === "[object Uint16Array]" || L === "[object Uint32Array]";
    }
    o(N, "isToStringedArrayType");
    function O(L) {
      return Object.is(L, -0) ? "-0" : String(L);
    }
    o(O, "printNumber");
    function S(L) {
      return `${L}n`;
    }
    o(S, "printBigInt");
    function w(L, K) {
      return K ? "[Function " + (L.name || "anonymous") + "]" : "[Function]";
    }
    o(w, "printFunction");
    function T(L) {
      return String(L).replace(b, "Symbol($1)");
    }
    o(T, "printSymbol");
    function M(L) {
      return "[" + y.call(L) + "]";
    }
    o(M, "printError");
    function R(L, K, Q, se) {
      if (L === !0 || L === !1)
        return "" + L;
      if (L === void 0)
        return "undefined";
      if (L === null)
        return "null";
      const re = typeof L;
      if (re === "number")
        return O(L);
      if (re === "bigint")
        return S(L);
      if (re === "string")
        return se ? '"' + L.replace(/"|\\/g, "\\$&") + '"' : '"' + L + '"';
      if (re === "function")
        return w(L, K);
      if (re === "symbol")
        return T(L);
      const he = f.call(L);
      return he === "[object WeakMap]" ? "WeakMap {}" : he === "[object WeakSet]" ? "WeakSet {}" : he === "[object Function]" || he === "[object GeneratorFunction]" ? w(L, K) : he === "[object Symbol]" ? T(L) : he === "[object Date]" ? isNaN(+L) ? "Date { NaN }" : m.call(L) : he === "[object Error]" ? M(L) : he === "[object RegExp]" ? Q ? g.call(L).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : g.call(L) : L instanceof Error ? M(L) : null;
    }
    o(R, "printBasicValue");
    function D(L, K, Q, se, re, he) {
      if (re.indexOf(L) !== -1)
        return "[Circular]";
      re = re.slice(), re.push(L);
      const ce = ++se > K.maxDepth, Ce = K.min;
      if (K.callToJSON && !ce && L.toJSON && typeof L.toJSON == "function" && !he)
        return $(L.toJSON(), K, Q, se, re, !0);
      const Xe = f.call(L);
      return Xe === "[object Arguments]" ? ce ? "[Arguments]" : (Ce ? "" : "Arguments ") + "[" + (0, r.printListItems)(
        L,
        K,
        Q,
        se,
        re,
        $
      ) + "]" : N(Xe) ? ce ? "[" + L.constructor.name + "]" : (Ce || !K.printBasicPrototype && L.constructor.name === "Array" ? "" : L.constructor.name + " ") + "[" + (0, r.printListItems)(
        L,
        K,
        Q,
        se,
        re,
        $
      ) + "]" : Xe === "[object Map]" ? ce ? "[Map]" : "Map {" + (0, r.printIteratorEntries)(
        L.entries(),
        K,
        Q,
        se,
        re,
        $,
        " => "
      ) + "}" : Xe === "[object Set]" ? ce ? "[Set]" : "Set {" + (0, r.printIteratorValues)(
        L.values(),
        K,
        Q,
        se,
        re,
        $
      ) + "}" : ce || _(L) ? "[" + v(L) + "]" : (Ce || !K.printBasicPrototype && v(L) === "Object" ? "" : v(L) + " ") + "{" + (0, r.printObjectProperties)(
        L,
        K,
        Q,
        se,
        re,
        $
      ) + "}";
    }
    o(D, "printComplexValue");
    function J(L) {
      return L.serialize != null;
    }
    o(J, "isNewPlugin");
    function P(L, K, Q, se, re, he) {
      let ce;
      try {
        ce = J(L) ? L.serialize(K, Q, se, re, he, $) : L.print(
          K,
          (Ce) => $(Ce, Q, se, re, he),
          (Ce) => {
            const Xe = se + Q.indent;
            return Xe + Ce.replace(E, `
` + Xe);
          },
          {
            edgeSpacing: Q.spacingOuter,
            min: Q.min,
            spacing: Q.spacingInner
          },
          Q.colors
        );
      } catch (Ce) {
        throw new k(Ce.message, Ce.stack);
      }
      if (typeof ce != "string")
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof ce}".`
        );
      return ce;
    }
    o(P, "printPlugin");
    function q(L, K) {
      for (let Q = 0; Q < L.length; Q++)
        try {
          if (L[Q].test(K))
            return L[Q];
        } catch (se) {
          throw new k(se.message, se.stack);
        }
      return null;
    }
    o(q, "findPlugin");
    function $(L, K, Q, se, re, he) {
      const ce = q(K.plugins, L);
      if (ce !== null)
        return P(ce, L, K, Q, se, re);
      const Ce = R(
        L,
        K.printFunctionName,
        K.escapeRegex,
        K.escapeString
      );
      return Ce !== null ? Ce : D(
        L,
        K,
        Q,
        se,
        re,
        he
      );
    }
    o($, "printer");
    var H = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    }, z = Object.keys(H), Z = {
      callToJSON: !0,
      compareKeys: void 0,
      escapeRegex: !1,
      escapeString: !0,
      highlight: !1,
      indent: 2,
      maxDepth: 1 / 0,
      min: !1,
      plugins: [],
      printBasicPrototype: !0,
      printFunctionName: !0,
      theme: H
    };
    e.DEFAULT_OPTIONS = Z;
    function oe(L) {
      if (Object.keys(L).forEach((K) => {
        if (!Z.hasOwnProperty(K))
          throw new Error(`pretty-format: Unknown option "${K}".`);
      }), L.min && L.indent !== void 0 && L.indent !== 0)
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      if (L.theme !== void 0) {
        if (L.theme === null)
          throw new Error('pretty-format: Option "theme" must not be null.');
        if (typeof L.theme != "object")
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof L.theme}".`
          );
      }
    }
    o(oe, "validateOptions");
    var ie = /* @__PURE__ */ o((L) => z.reduce((K, Q) => {
      const se = L.theme && L.theme[Q] !== void 0 ? L.theme[Q] : H[Q], re = se && t.default[se];
      if (re && typeof re.close == "string" && typeof re.open == "string")
        K[Q] = re;
      else
        throw new Error(
          `pretty-format: Option "theme" has a key "${Q}" whose value "${se}" is undefined in ansi-styles.`
        );
      return K;
    }, /* @__PURE__ */ Object.create(null)), "getColorsHighlight"), Y = /* @__PURE__ */ o(() => z.reduce((L, K) => (L[K] = {
      close: "",
      open: ""
    }, L), /* @__PURE__ */ Object.create(null)), "getColorsEmpty"), be = /* @__PURE__ */ o((L) => L && L.printFunctionName !== void 0 ? L.printFunctionName : Z.printFunctionName, "getPrintFunctionName"), we = /* @__PURE__ */ o((L) => L && L.escapeRegex !== void 0 ? L.escapeRegex : Z.escapeRegex, "getEscapeRegex"), le = /* @__PURE__ */ o((L) => L && L.escapeString !== void 0 ? L.escapeString : Z.escapeString, "getEscapeString"), X = /* @__PURE__ */ o((L) => {
      var K;
      return {
        callToJSON: L && L.callToJSON !== void 0 ? L.callToJSON : Z.callToJSON,
        colors: L && L.highlight ? ie(L) : Y(),
        compareKeys: L && typeof L.compareKeys == "function" ? L.compareKeys : Z.compareKeys,
        escapeRegex: we(L),
        escapeString: le(L),
        indent: L && L.min ? "" : Re(
          L && L.indent !== void 0 ? L.indent : Z.indent
        ),
        maxDepth: L && L.maxDepth !== void 0 ? L.maxDepth : Z.maxDepth,
        min: L && L.min !== void 0 ? L.min : Z.min,
        plugins: L && L.plugins !== void 0 ? L.plugins : Z.plugins,
        printBasicPrototype: (K = L?.printBasicPrototype) !== null && K !== void 0 ? K : !0,
        printFunctionName: be(L),
        spacingInner: L && L.min ? " " : `
`,
        spacingOuter: L && L.min ? "" : `
`
      };
    }, "getConfig");
    function Re(L) {
      return new Array(L + 1).join(" ");
    }
    o(Re, "createIndent");
    function Pe(L, K) {
      if (K && (oe(K), K.plugins)) {
        const se = q(K.plugins, L);
        if (se !== null)
          return P(se, L, X(K), "", 0, []);
      }
      const Q = R(
        L,
        be(K),
        we(K),
        le(K)
      );
      return Q !== null ? Q : D(L, X(K), "", 0, []);
    }
    o(Pe, "format");
    var lt = {
      AsymmetricMatcher: n.default,
      ConvertAnsi: a.default,
      DOMCollection: i.default,
      DOMElement: s.default,
      Immutable: l.default,
      ReactElement: c.default,
      ReactTestComponent: u.default
    };
    e.plugins = lt;
    var rt = Pe;
    e.default = rt;
  }
}), ND = F({
  "../node_modules/lz-string/libs/lz-string.js"(e, t) {
    var r = (function() {
      var n = String.fromCharCode, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", s = {};
      function l(u, p) {
        if (!s[u]) {
          s[u] = {};
          for (var f = 0; f < u.length; f++)
            s[u][u.charAt(f)] = f;
        }
        return s[u][p];
      }
      o(l, "getBaseValue");
      var c = {
        compressToBase64: /* @__PURE__ */ o(function(u) {
          if (u == null) return "";
          var p = c._compress(u, 6, function(f) {
            return a.charAt(f);
          });
          switch (p.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return p;
            case 1:
              return p + "===";
            case 2:
              return p + "==";
            case 3:
              return p + "=";
          }
        }, "compressToBase64"),
        decompressFromBase64: /* @__PURE__ */ o(function(u) {
          return u == null ? "" : u == "" ? null : c._decompress(u.length, 32, function(p) {
            return l(a, u.charAt(p));
          });
        }, "decompressFromBase64"),
        compressToUTF16: /* @__PURE__ */ o(function(u) {
          return u == null ? "" : c._compress(u, 15, function(p) {
            return n(p + 32);
          }) + " ";
        }, "compressToUTF16"),
        decompressFromUTF16: /* @__PURE__ */ o(function(u) {
          return u == null ? "" : u == "" ? null : c._decompress(u.length, 16384, function(p) {
            return u.charCodeAt(p) - 32;
          });
        }, "decompressFromUTF16"),
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: /* @__PURE__ */ o(function(u) {
          for (var p = c.compress(u), f = new Uint8Array(p.length * 2), m = 0, y = p.length; m < y; m++) {
            var g = p.charCodeAt(m);
            f[m * 2] = g >>> 8, f[m * 2 + 1] = g % 256;
          }
          return f;
        }, "compressToUint8Array"),
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: /* @__PURE__ */ o(function(u) {
          if (u == null)
            return c.decompress(u);
          for (var p = new Array(u.length / 2), f = 0, m = p.length; f < m; f++)
            p[f] = u[f * 2] * 256 + u[f * 2 + 1];
          var y = [];
          return p.forEach(function(g) {
            y.push(n(g));
          }), c.decompress(y.join(""));
        }, "decompressFromUint8Array"),
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: /* @__PURE__ */ o(function(u) {
          return u == null ? "" : c._compress(u, 6, function(p) {
            return i.charAt(p);
          });
        }, "compressToEncodedURIComponent"),
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: /* @__PURE__ */ o(function(u) {
          return u == null ? "" : u == "" ? null : (u = u.replace(/ /g, "+"), c._decompress(u.length, 32, function(p) {
            return l(i, u.charAt(p));
          }));
        }, "decompressFromEncodedURIComponent"),
        compress: /* @__PURE__ */ o(function(u) {
          return c._compress(u, 16, function(p) {
            return n(p);
          });
        }, "compress"),
        _compress: /* @__PURE__ */ o(function(u, p, f) {
          if (u == null) return "";
          var m, y, g = {}, v = {}, _ = "", b = "", E = "", C = 2, k = 3, N = 2, O = [], S = 0, w = 0, T;
          for (T = 0; T < u.length; T += 1)
            if (_ = u.charAt(T), Object.prototype.hasOwnProperty.call(g, _) || (g[_] = k++, v[_] = !0), b = E + _, Object.prototype.hasOwnProperty.call(g, b))
              E = b;
            else {
              if (Object.prototype.hasOwnProperty.call(v, E)) {
                if (E.charCodeAt(0) < 256) {
                  for (m = 0; m < N; m++)
                    S = S << 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++;
                  for (y = E.charCodeAt(0), m = 0; m < 8; m++)
                    S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
                } else {
                  for (y = 1, m = 0; m < N; m++)
                    S = S << 1 | y, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = 0;
                  for (y = E.charCodeAt(0), m = 0; m < 16; m++)
                    S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
                }
                C--, C == 0 && (C = Math.pow(2, N), N++), delete v[E];
              } else
                for (y = g[E], m = 0; m < N; m++)
                  S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
              C--, C == 0 && (C = Math.pow(2, N), N++), g[b] = k++, E = String(_);
            }
          if (E !== "") {
            if (Object.prototype.hasOwnProperty.call(v, E)) {
              if (E.charCodeAt(0) < 256) {
                for (m = 0; m < N; m++)
                  S = S << 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++;
                for (y = E.charCodeAt(0), m = 0; m < 8; m++)
                  S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
              } else {
                for (y = 1, m = 0; m < N; m++)
                  S = S << 1 | y, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = 0;
                for (y = E.charCodeAt(0), m = 0; m < 16; m++)
                  S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
              }
              C--, C == 0 && (C = Math.pow(2, N), N++), delete v[E];
            } else
              for (y = g[E], m = 0; m < N; m++)
                S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
            C--, C == 0 && (C = Math.pow(2, N), N++);
          }
          for (y = 2, m = 0; m < N; m++)
            S = S << 1 | y & 1, w == p - 1 ? (w = 0, O.push(f(S)), S = 0) : w++, y = y >> 1;
          for (; ; )
            if (S = S << 1, w == p - 1) {
              O.push(f(S));
              break;
            } else w++;
          return O.join("");
        }, "_compress"),
        decompress: /* @__PURE__ */ o(function(u) {
          return u == null ? "" : u == "" ? null : c._decompress(u.length, 32768, function(p) {
            return u.charCodeAt(p);
          });
        }, "decompress"),
        _decompress: /* @__PURE__ */ o(function(u, p, f) {
          var m = [], y = 4, g = 4, v = 3, _ = "", b = [], E, C, k, N, O, S, w, T = { val: f(0), position: p, index: 1 };
          for (E = 0; E < 3; E += 1)
            m[E] = E;
          for (k = 0, O = Math.pow(2, 2), S = 1; S != O; )
            N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), k |= (N > 0 ? 1 : 0) * S, S <<= 1;
          switch (k) {
            case 0:
              for (k = 0, O = Math.pow(2, 8), S = 1; S != O; )
                N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), k |= (N > 0 ? 1 : 0) * S, S <<= 1;
              w = n(k);
              break;
            case 1:
              for (k = 0, O = Math.pow(2, 16), S = 1; S != O; )
                N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), k |= (N > 0 ? 1 : 0) * S, S <<= 1;
              w = n(k);
              break;
            case 2:
              return "";
          }
          for (m[3] = w, C = w, b.push(w); ; ) {
            if (T.index > u)
              return "";
            for (k = 0, O = Math.pow(2, v), S = 1; S != O; )
              N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), k |= (N > 0 ? 1 : 0) * S, S <<= 1;
            switch (w = k) {
              case 0:
                for (k = 0, O = Math.pow(2, 8), S = 1; S != O; )
                  N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), k |= (N > 0 ? 1 : 0) * S, S <<= 1;
                m[g++] = n(k), w = g - 1, y--;
                break;
              case 1:
                for (k = 0, O = Math.pow(2, 16), S = 1; S != O; )
                  N = T.val & T.position, T.position >>= 1, T.position == 0 && (T.position = p, T.val = f(T.index++)), k |= (N > 0 ? 1 : 0) * S, S <<= 1;
                m[g++] = n(k), w = g - 1, y--;
                break;
              case 2:
                return b.join("");
            }
            if (y == 0 && (y = Math.pow(2, v), v++), m[w])
              _ = m[w];
            else if (w === g)
              _ = C + C.charAt(0);
            else
              return null;
            b.push(_), m[g++] = C + _.charAt(0), y--, C = _, y == 0 && (y = Math.pow(2, v), v++);
          }
        }, "_decompress")
      };
      return c;
    })();
    typeof define == "function" && define.amd ? define(function() {
      return r;
    }) : typeof t < "u" && t != null ? t.exports = r : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
      return r;
    });
  }
}), wx = Object.defineProperty, U = /* @__PURE__ */ o((e, t) => wx(e, "name", { value: t, configurable: !0 }), "__name"), sf = /* @__PURE__ */ o((e, t) => {
  for (var r in t)
    wx(e, r, { get: t[r], enumerable: !0 });
}, "__export"), er = {};
sf(er, {
  addChainableMethod: /* @__PURE__ */ o(() => fl, "addChainableMethod"),
  addLengthGuard: /* @__PURE__ */ o(() => Ro, "addLengthGuard"),
  addMethod: /* @__PURE__ */ o(() => cl, "addMethod"),
  addProperty: /* @__PURE__ */ o(() => ul, "addProperty"),
  checkError: /* @__PURE__ */ o(() => bt, "checkError"),
  compareByInspect: /* @__PURE__ */ o(() => Ta, "compareByInspect"),
  eql: /* @__PURE__ */ o(() => Ex, "eql"),
  expectTypes: /* @__PURE__ */ o(() => mf, "expectTypes"),
  flag: /* @__PURE__ */ o(() => pe, "flag"),
  getActual: /* @__PURE__ */ o(() => Wa, "getActual"),
  getMessage: /* @__PURE__ */ o(() => ol, "getMessage"),
  getName: /* @__PURE__ */ o(() => Ka, "getName"),
  getOperator: /* @__PURE__ */ o(() => gl, "getOperator"),
  getOwnEnumerableProperties: /* @__PURE__ */ o(() => yl, "getOwnEnumerableProperties"),
  getOwnEnumerablePropertySymbols: /* @__PURE__ */ o(() => hl, "getOwnEnumerablePropertySymbols"),
  getPathInfo: /* @__PURE__ */ o(() => ll, "getPathInfo"),
  hasProperty: /* @__PURE__ */ o(() => Ga, "hasProperty"),
  inspect: /* @__PURE__ */ o(() => ve, "inspect"),
  isNaN: /* @__PURE__ */ o(() => cs, "isNaN"),
  isNumeric: /* @__PURE__ */ o(() => Ge, "isNumeric"),
  isProxyEnabled: /* @__PURE__ */ o(() => Ao, "isProxyEnabled"),
  isRegExp: /* @__PURE__ */ o(() => Sa, "isRegExp"),
  objDisplay: /* @__PURE__ */ o(() => Ur, "objDisplay"),
  overwriteChainableMethod: /* @__PURE__ */ o(() => ml, "overwriteChainableMethod"),
  overwriteMethod: /* @__PURE__ */ o(() => pl, "overwriteMethod"),
  overwriteProperty: /* @__PURE__ */ o(() => dl, "overwriteProperty"),
  proxify: /* @__PURE__ */ o(() => Nn, "proxify"),
  test: /* @__PURE__ */ o(() => rl, "test"),
  transferFlags: /* @__PURE__ */ o(() => $t, "transferFlags"),
  type: /* @__PURE__ */ o(() => Oe, "type")
});
var bt = {};
sf(bt, {
  compatibleConstructor: /* @__PURE__ */ o(() => cf, "compatibleConstructor"),
  compatibleInstance: /* @__PURE__ */ o(() => uf, "compatibleInstance"),
  compatibleMessage: /* @__PURE__ */ o(() => df, "compatibleMessage"),
  getConstructorName: /* @__PURE__ */ o(() => pf, "getConstructorName"),
  getMessage: /* @__PURE__ */ o(() => ff, "getMessage")
});
function za(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
o(za, "isErrorInstance");
U(za, "isErrorInstance");
function lf(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
o(lf, "isRegExp");
U(lf, "isRegExp");
function uf(e, t) {
  return za(t) && e === t;
}
o(uf, "compatibleInstance");
U(uf, "compatibleInstance");
function cf(e, t) {
  return za(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : !1;
}
o(cf, "compatibleConstructor");
U(cf, "compatibleConstructor");
function df(e, t) {
  const r = typeof e == "string" ? e : e.message;
  return lf(t) ? t.test(r) : typeof t == "string" ? r.indexOf(t) !== -1 : !1;
}
o(df, "compatibleMessage");
U(df, "compatibleMessage");
function pf(e) {
  let t = e;
  return za(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
o(pf, "getConstructorName");
U(pf, "getConstructorName");
function ff(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
o(ff, "getMessage");
U(ff, "getMessage");
function pe(e, t, r) {
  let n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    n[t] = r;
  else
    return n[t];
}
o(pe, "flag");
U(pe, "flag");
function rl(e, t) {
  let r = pe(e, "negate"), n = t[0];
  return r ? !n : n;
}
o(rl, "test");
U(rl, "test");
function Oe(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
o(Oe, "type");
U(Oe, "type");
var qD = "captureStackTrace" in Error, Ho, Te = (Ho = class extends Error {
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(e = "Unspecified AssertionError", t, r) {
    super(e), this.message = e, qD && Error.captureStackTrace(this, r || Ho);
    for (const n in t)
      n in this || (this[n] = t[n]);
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, o(Ho, "_AssertionError"), U(Ho, "AssertionError"), Ho);
function mf(e, t) {
  let r = pe(e, "message"), n = pe(e, "ssfi");
  r = r ? r + ": " : "", e = pe(e, "object"), t = t.map(function(s) {
    return s.toLowerCase();
  }), t.sort();
  let a = t.map(function(s, l) {
    let c = ~["a", "e", "i", "o", "u"].indexOf(s.charAt(0)) ? "an" : "a";
    return (t.length > 1 && l === t.length - 1 ? "or " : "") + c + " " + s;
  }).join(", "), i = Oe(e).toLowerCase();
  if (!t.some(function(s) {
    return i === s;
  }))
    throw new Te(
      r + "object tested must be " + a + ", but " + i + " given",
      void 0,
      n
    );
}
o(mf, "expectTypes");
U(mf, "expectTypes");
function Wa(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
o(Wa, "getActual");
U(Wa, "getActual");
var Ky = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, MD = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, uo = "â€¦";
function hf(e, t) {
  const r = Ky[MD[t]] || Ky[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
o(hf, "colorise");
U(hf, "colorise");
function yf({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: n = !0,
  showProxy: a = !1,
  maxArrayLength: i = 1 / 0,
  breakLength: s = 1 / 0,
  seen: l = [],
  // eslint-disable-next-line no-shadow
  truncate: c = 1 / 0,
  stylize: u = String
} = {}, p) {
  const f = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!n,
    showProxy: !!a,
    maxArrayLength: Number(i),
    breakLength: Number(s),
    truncate: Number(c),
    seen: l,
    inspect: p,
    stylize: u
  };
  return f.colors && (f.stylize = hf), f;
}
o(yf, "normaliseOptions");
U(yf, "normaliseOptions");
function gf(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
o(gf, "isHighSurrogate");
U(gf, "isHighSurrogate");
function sr(e, t, r = uo) {
  e = String(e);
  const n = r.length, a = e.length;
  if (n > t && a > n)
    return r;
  if (a > t && a > n) {
    let i = t - n;
    return i > 0 && gf(e[i - 1]) && (i = i - 1), `${e.slice(0, i)}${r}`;
  }
  return e;
}
o(sr, "truncate");
U(sr, "truncate");
function Et(e, t, r, n = ", ") {
  r = r || t.inspect;
  const a = e.length;
  if (a === 0)
    return "";
  const i = t.truncate;
  let s = "", l = "", c = "";
  for (let u = 0; u < a; u += 1) {
    const p = u + 1 === e.length, f = u + 2 === e.length;
    c = `${uo}(${e.length - u})`;
    const m = e[u];
    t.truncate = i - s.length - (p ? 0 : n.length);
    const y = l || r(m, t) + (p ? "" : n), g = s.length + y.length, v = g + c.length;
    if (p && g > i && s.length + c.length <= i || !p && !f && v > i || (l = p ? "" : r(e[u + 1], t) + (f ? "" : n), !p && f && v > i && g + l.length > i))
      break;
    if (s += y, !p && !f && g + l.length >= i) {
      c = `${uo}(${e.length - u - 1})`;
      break;
    }
    c = "";
  }
  return `${s}${c}`;
}
o(Et, "inspectList");
U(Et, "inspectList");
function bf(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
o(bf, "quoteComplexKey");
U(bf, "quoteComplexKey");
function wn([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = bf(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
o(wn, "inspectProperty");
U(wn, "inspectProperty");
function vf(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const n = Et(e, t);
  t.truncate -= n.length;
  let a = "";
  return r.length && (a = Et(r.map((i) => [i, e[i]]), t, wn)), `[ ${n}${a ? `, ${a}` : ""} ]`;
}
o(vf, "inspectArray");
U(vf, "inspectArray");
var $D = U((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function Ut(e, t) {
  const r = $D(e);
  t.truncate -= r.length + 4;
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return `${r}[]`;
  let a = "";
  for (let s = 0; s < e.length; s++) {
    const l = `${t.stylize(sr(e[s], t.truncate), "number")}${s === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= l.length, e[s] !== e.length && t.truncate <= 3) {
      a += `${uo}(${e.length - e[s] + 1})`;
      break;
    }
    a += l;
  }
  let i = "";
  return n.length && (i = Et(n.map((s) => [s, e[s]]), t, wn)), `${r}[ ${a}${i ? `, ${i}` : ""} ]`;
}
o(Ut, "inspectTypedArray");
U(Ut, "inspectTypedArray");
function wf(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const n = r.split("T"), a = n[0];
  return t.stylize(`${a}T${sr(n[1], t.truncate - a.length - 1)}`, "date");
}
o(wf, "inspectDate");
U(wf, "inspectDate");
function Yi(e, t) {
  const r = e[Symbol.toStringTag] || "Function", n = e.name;
  return n ? t.stylize(`[${r} ${sr(n, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
o(Yi, "inspectFunction");
U(Yi, "inspectFunction");
function _f([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
o(_f, "inspectMapEntry");
U(_f, "inspectMapEntry");
function Ef(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push([n, r]);
  }), t;
}
o(Ef, "mapToEntries");
U(Ef, "mapToEntries");
function xf(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Et(Ef(e), t, _f)} }`);
}
o(xf, "inspectMap");
U(xf, "inspectMap");
var LD = Number.isNaN || ((e) => e !== e);
function Xi(e, t) {
  return LD(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(sr(String(e), t.truncate), "number");
}
o(Xi, "inspectNumber");
U(Xi, "inspectNumber");
function Qi(e, t) {
  let r = sr(e.toString(), t.truncate - 1);
  return r !== uo && (r += "n"), t.stylize(r, "bigint");
}
o(Qi, "inspectBigInt");
U(Qi, "inspectBigInt");
function Tf(e, t) {
  const r = e.toString().split("/")[2], n = t.truncate - (2 + r.length), a = e.source;
  return t.stylize(`/${sr(a, n)}/${r}`, "regexp");
}
o(Tf, "inspectRegExp");
U(Tf, "inspectRegExp");
function Sf(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
o(Sf, "arrayFromSet");
U(Sf, "arrayFromSet");
function Pf(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Et(Sf(e), t)} }`);
}
o(Pf, "inspectSet");
U(Pf, "inspectSet");
var Yy = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), DD = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, FD = 16;
function Of(e) {
  return DD[e] || `\\u${`0000${e.charCodeAt(0).toString(FD)}`.slice(-4)}`;
}
o(Of, "escape");
U(Of, "escape");
function Zi(e, t) {
  return Yy.test(e) && (e = e.replace(Yy, Of)), t.stylize(`'${sr(e, t.truncate - 2)}'`, "string");
}
o(Zi, "inspectString");
U(Zi, "inspectString");
function es(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
o(es, "inspectSymbol");
U(es, "inspectSymbol");
var BD = U(() => "Promise{â€¦}", "getPromiseValue"), UD = BD;
function Qn(e, t) {
  const r = Object.getOwnPropertyNames(e), n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && n.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = Et(r.map((l) => [l, e[l]]), t, wn), i = Et(n.map((l) => [l, e[l]]), t, wn);
  t.seen.pop();
  let s = "";
  return a && i && (s = ", "), `{ ${a}${s}${i} }`;
}
o(Qn, "inspectObject");
U(Qn, "inspectObject");
var Lu = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function Cf(e, t) {
  let r = "";
  return Lu && Lu in e && (r = e[Lu]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${Qn(e, t)}`;
}
o(Cf, "inspectClass");
U(Cf, "inspectClass");
function Af(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Et(e, t)} ]`);
}
o(Af, "inspectArguments");
U(Af, "inspectArguments");
var HD = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function Rf(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((s) => HD.indexOf(s) === -1), n = e.name;
  t.truncate -= n.length;
  let a = "";
  if (typeof e.message == "string" ? a = sr(e.message, t.truncate) : r.unshift("message"), a = a ? `: ${a}` : "", t.truncate -= a.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const i = Et(r.map((s) => [s, e[s]]), t, wn);
  return `${n}${a}${i ? ` { ${i} }` : ""}`;
}
o(Rf, "inspectObject2");
U(Rf, "inspectObject");
function kf([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
o(kf, "inspectAttribute");
U(kf, "inspectAttribute");
function _a(e, t) {
  return Et(e, t, If, `
`);
}
o(_a, "inspectNodeCollection");
U(_a, "inspectNodeCollection");
function If(e, t) {
  switch (e.nodeType) {
    case 1:
      return nl(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
o(If, "inspectNode");
U(If, "inspectNode");
function nl(e, t) {
  const r = e.getAttributeNames(), n = e.tagName.toLowerCase(), a = t.stylize(`<${n}`, "special"), i = t.stylize(">", "special"), s = t.stylize(`</${n}>`, "special");
  t.truncate -= n.length * 2 + 5;
  let l = "";
  r.length > 0 && (l += " ", l += Et(r.map((p) => [p, e.getAttribute(p)]), t, kf, " ")), t.truncate -= l.length;
  const c = t.truncate;
  let u = _a(e.children, t);
  return u && u.length > c && (u = `${uo}(${e.children.length})`), `${a}${l}${i}${u}${s}`;
}
o(nl, "inspectHTML");
U(nl, "inspectHTML");
var VD = typeof Symbol == "function" && typeof Symbol.for == "function", Du = VD ? Symbol.for("chai/inspect") : "@@chai/inspect", Fu = Symbol.for("nodejs.util.inspect.custom"), Xy = /* @__PURE__ */ new WeakMap(), Qy = {}, Zy = {
  undefined: U((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: U((e, t) => t.stylize("null", "null"), "null"),
  boolean: U((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: U((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: Xi,
  Number: Xi,
  bigint: Qi,
  BigInt: Qi,
  string: Zi,
  String: Zi,
  function: Yi,
  Function: Yi,
  symbol: es,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: es,
  Array: vf,
  Date: wf,
  Map: xf,
  Set: Pf,
  RegExp: Tf,
  Promise: UD,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: U((e, t) => t.stylize("WeakSet{â€¦}", "special"), "WeakSet"),
  WeakMap: U((e, t) => t.stylize("WeakMap{â€¦}", "special"), "WeakMap"),
  Arguments: Af,
  Int8Array: Ut,
  Uint8Array: Ut,
  Uint8ClampedArray: Ut,
  Int16Array: Ut,
  Uint16Array: Ut,
  Int32Array: Ut,
  Uint32Array: Ut,
  Float32Array: Ut,
  Float64Array: Ut,
  Generator: U(() => "", "Generator"),
  DataView: U(() => "", "DataView"),
  ArrayBuffer: U(() => "", "ArrayBuffer"),
  Error: Rf,
  HTMLCollection: _a,
  NodeList: _a
}, JD = U((e, t, r) => Du in e && typeof e[Du] == "function" ? e[Du](t) : Fu in e && typeof e[Fu] == "function" ? e[Fu](t.depth, t) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && Xy.has(e.constructor) ? Xy.get(e.constructor)(e, t) : Qy[r] ? Qy[r](e, t) : "", "inspectCustom"), zD = Object.prototype.toString;
function Ea(e, t = {}) {
  const r = yf(t, Ea), { customInspect: n } = r;
  let a = e === null ? "null" : typeof e;
  if (a === "object" && (a = zD.call(e).slice(8, -1)), a in Zy)
    return Zy[a](e, r);
  if (n && e) {
    const s = JD(e, r, a);
    if (s)
      return typeof s == "string" ? s : Ea(s, r);
  }
  const i = e ? Object.getPrototypeOf(e) : !1;
  return i === Object.prototype || i === null ? Qn(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? nl(e, r) : "constructor" in e ? e.constructor !== Object ? Cf(e, r) : Qn(e, r) : e === Object(e) ? Qn(e, r) : r.stylize(String(e), a);
}
o(Ea, "inspect");
U(Ea, "inspect");
var ut = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function ve(e, t, r, n) {
  let a = {
    colors: n,
    depth: typeof r > "u" ? 2 : r,
    showHidden: t,
    truncate: ut.truncateThreshold ? ut.truncateThreshold : 1 / 0
  };
  return Ea(e, a);
}
o(ve, "inspect2");
U(ve, "inspect");
function Ur(e) {
  let t = ve(e), r = Object.prototype.toString.call(e);
  if (ut.truncateThreshold && t.length >= ut.truncateThreshold) {
    if (r === "[object Function]")
      return !e.name || e.name === "" ? "[Function]" : "[Function: " + e.name + "]";
    if (r === "[object Array]")
      return "[ Array(" + e.length + ") ]";
    if (r === "[object Object]") {
      let n = Object.keys(e);
      return "{ Object (" + (n.length > 2 ? n.splice(0, 2).join(", ") + ", ..." : n.join(", ")) + ") }";
    } else
      return t;
  } else
    return t;
}
o(Ur, "objDisplay");
U(Ur, "objDisplay");
function ol(e, t) {
  let r = pe(e, "negate"), n = pe(e, "object"), a = t[3], i = Wa(e, t), s = r ? t[2] : t[1], l = pe(e, "message");
  return typeof s == "function" && (s = s()), s = s || "", s = s.replace(/#\{this\}/g, function() {
    return Ur(n);
  }).replace(/#\{act\}/g, function() {
    return Ur(i);
  }).replace(/#\{exp\}/g, function() {
    return Ur(a);
  }), l ? l + ": " + s : s;
}
o(ol, "getMessage2");
U(ol, "getMessage");
function $t(e, t, r) {
  let n = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), r = arguments.length === 3 ? r : !0;
  for (let a in n)
    (r || a !== "object" && a !== "ssfi" && a !== "lockSsfi" && a != "message") && (t.__flags[a] = n[a]);
}
o($t, "transferFlags");
U($t, "transferFlags");
function ts(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
o(ts, "type2");
U(ts, "type");
function al() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
o(al, "FakeMap");
U(al, "FakeMap");
al.prototype = {
  get: U(/* @__PURE__ */ o(function(e) {
    return e[this._key];
  }, "get"), "get"),
  set: U(/* @__PURE__ */ o(function(e, t) {
    Object.isExtensible(e) && Object.defineProperty(e, this._key, {
      value: t,
      configurable: !0
    });
  }, "set"), "set")
};
var _x = typeof WeakMap == "function" ? WeakMap : al;
function rs(e, t, r) {
  if (!r || Gr(e) || Gr(t))
    return null;
  var n = r.get(e);
  if (n) {
    var a = n.get(t);
    if (typeof a == "boolean")
      return a;
  }
  return null;
}
o(rs, "memoizeCompare");
U(rs, "memoizeCompare");
function Wn(e, t, r, n) {
  if (!(!r || Gr(e) || Gr(t))) {
    var a = r.get(e);
    a ? a.set(t, n) : (a = new _x(), a.set(t, n), r.set(e, a));
  }
}
o(Wn, "memoizeSet");
U(Wn, "memoizeSet");
var Ex = Co;
function Co(e, t, r) {
  if (r && r.comparator)
    return ns(e, t, r);
  var n = il(e, t);
  return n !== null ? n : ns(e, t, r);
}
o(Co, "deepEqual");
U(Co, "deepEqual");
function il(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? !0 : Gr(e) || Gr(t) ? !1 : null;
}
o(il, "simpleEqual");
U(il, "simpleEqual");
function ns(e, t, r) {
  r = r || {}, r.memoize = r.memoize === !1 ? !1 : r.memoize || new _x();
  var n = r && r.comparator, a = rs(e, t, r.memoize);
  if (a !== null)
    return a;
  var i = rs(t, e, r.memoize);
  if (i !== null)
    return i;
  if (n) {
    var s = n(e, t);
    if (s === !1 || s === !0)
      return Wn(e, t, r.memoize, s), s;
    var l = il(e, t);
    if (l !== null)
      return l;
  }
  var c = ts(e);
  if (c !== ts(t))
    return Wn(e, t, r.memoize, !1), !1;
  Wn(e, t, r.memoize, !0);
  var u = jf(e, t, c, r);
  return Wn(e, t, r.memoize, u), u;
}
o(ns, "extensiveDeepEqual");
U(ns, "extensiveDeepEqual");
function jf(e, t, r, n) {
  switch (r) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Co(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return sl(e, t, ["name", "message", "code"], n);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Pr(e, t, n);
    case "RegExp":
      return Nf(e, t);
    case "Generator":
      return qf(e, t, n);
    case "DataView":
      return Pr(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
    case "ArrayBuffer":
      return Pr(new Uint8Array(e), new Uint8Array(t), n);
    case "Set":
      return os(e, t, n);
    case "Map":
      return os(e, t, n);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return $f(e, t, n);
  }
}
o(jf, "extensiveDeepEqualByType");
U(jf, "extensiveDeepEqualByType");
function Nf(e, t) {
  return e.toString() === t.toString();
}
o(Nf, "regexpEqual");
U(Nf, "regexpEqual");
function os(e, t, r) {
  try {
    if (e.size !== t.size)
      return !1;
    if (e.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var n = [], a = [];
  return e.forEach(U(/* @__PURE__ */ o(function(i, s) {
    n.push([i, s]);
  }, "gatherEntries"), "gatherEntries")), t.forEach(U(/* @__PURE__ */ o(function(i, s) {
    a.push([i, s]);
  }, "gatherEntries"), "gatherEntries")), Pr(n.sort(), a.sort(), r);
}
o(os, "entriesEqual");
U(os, "entriesEqual");
function Pr(e, t, r) {
  var n = e.length;
  if (n !== t.length)
    return !1;
  if (n === 0)
    return !0;
  for (var a = -1; ++a < n; )
    if (Co(e[a], t[a], r) === !1)
      return !1;
  return !0;
}
o(Pr, "iterableEqual");
U(Pr, "iterableEqual");
function qf(e, t, r) {
  return Pr(xa(e), xa(t), r);
}
o(qf, "generatorEqual");
U(qf, "generatorEqual");
function Mf(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
o(Mf, "hasIteratorFunction");
U(Mf, "hasIteratorFunction");
function as(e) {
  if (Mf(e))
    try {
      return xa(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
o(as, "getIteratorEntries");
U(as, "getIteratorEntries");
function xa(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; )
    t = e.next(), r.push(t.value);
  return r;
}
o(xa, "getGeneratorEntries");
U(xa, "getGeneratorEntries");
function is(e) {
  var t = [];
  for (var r in e)
    t.push(r);
  return t;
}
o(is, "getEnumerableKeys");
U(is, "getEnumerableKeys");
function ss(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
    var a = r[n];
    Object.getOwnPropertyDescriptor(e, a).enumerable && t.push(a);
  }
  return t;
}
o(ss, "getEnumerableSymbols");
U(ss, "getEnumerableSymbols");
function sl(e, t, r, n) {
  var a = r.length;
  if (a === 0)
    return !0;
  for (var i = 0; i < a; i += 1)
    if (Co(e[r[i]], t[r[i]], n) === !1)
      return !1;
  return !0;
}
o(sl, "keysEqual");
U(sl, "keysEqual");
function $f(e, t, r) {
  var n = is(e), a = is(t), i = ss(e), s = ss(t);
  if (n = n.concat(i), a = a.concat(s), n.length && n.length === a.length)
    return Pr(ls(n).sort(), ls(a).sort()) === !1 ? !1 : sl(e, t, n, r);
  var l = as(e), c = as(t);
  return l.length && l.length === c.length ? (l.sort(), c.sort(), Pr(l, c, r)) : n.length === 0 && l.length === 0 && a.length === 0 && c.length === 0;
}
o($f, "objectEqual");
U($f, "objectEqual");
function Gr(e) {
  return e === null || typeof e != "object";
}
o(Gr, "isPrimitive");
U(Gr, "isPrimitive");
function ls(e) {
  return e.map(U(/* @__PURE__ */ o(function(t) {
    return typeof t == "symbol" ? t.toString() : t;
  }, "mapSymbol"), "mapSymbol"));
}
o(ls, "mapSymbols");
U(ls, "mapSymbols");
function Ga(e, t) {
  return typeof e > "u" || e === null ? !1 : t in Object(e);
}
o(Ga, "hasProperty");
U(Ga, "hasProperty");
function Lf(e) {
  return e.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((t) => {
    if (t === "constructor" || t === "__proto__" || t === "prototype")
      return {};
    const r = /^\[(\d+)\]$/.exec(t);
    let n = null;
    return r ? n = { i: parseFloat(r[1]) } : n = { p: t.replace(/\\([.[\]])/g, "$1") }, n;
  });
}
o(Lf, "parsePath");
U(Lf, "parsePath");
function us(e, t, r) {
  let n = e, a = null;
  r = typeof r > "u" ? t.length : r;
  for (let i = 0; i < r; i++) {
    const s = t[i];
    n && (typeof s.p > "u" ? n = n[s.i] : n = n[s.p], i === r - 1 && (a = n));
  }
  return a;
}
o(us, "internalGetPathValue");
U(us, "internalGetPathValue");
function ll(e, t) {
  const r = Lf(t), n = r[r.length - 1], a = {
    parent: r.length > 1 ? us(e, r, r.length - 1) : e,
    name: n.p || n.i,
    value: us(e, r)
  };
  return a.exists = Ga(a.parent, a.name), a;
}
o(ll, "getPathInfo");
U(ll, "getPathInfo");
var Vo, I = (Vo = class {
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(e, t, r, n) {
    return pe(this, "ssfi", r || Vo), pe(this, "lockSsfi", n), pe(this, "object", e), pe(this, "message", t), pe(this, "eql", ut.deepEqual || Ex), Nn(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), ut.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(e) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), ut.includeStack = e;
  }
  /** @returns {boolean} */
  static get showDiff() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), ut.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(e) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), ut.showDiff = e;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(e, t) {
    ul(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(e, t) {
    cl(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(e, t, r) {
    fl(this.prototype, e, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(e, t) {
    dl(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(e, t) {
    pl(this.prototype, e, t);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(e, t, r) {
    ml(this.prototype, e, t, r);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(e, t, r, n, a, i) {
    const s = rl(this, arguments);
    if (i !== !1 && (i = !0), n === void 0 && a === void 0 && (i = !1), ut.showDiff !== !0 && (i = !1), !s) {
      t = ol(this, arguments);
      const l = {
        actual: Wa(this, arguments),
        expected: n,
        showDiff: i
      }, c = gl(this, arguments);
      throw c && (l.operator = c), new Te(
        t,
        l,
        // @ts-expect-error Not sure what to do about these types yet
        ut.includeStack ? this.assert : pe(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return pe(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(e) {
    pe(this, "object", e);
  }
}, o(Vo, "_Assertion"), U(Vo, "Assertion"), Vo);
function Ao() {
  return ut.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
o(Ao, "isProxyEnabled");
U(Ao, "isProxyEnabled");
function ul(e, t, r) {
  r = r === void 0 ? function() {
  } : r, Object.defineProperty(e, t, {
    get: U(/* @__PURE__ */ o(function n() {
      !Ao() && !pe(this, "lockSsfi") && pe(this, "ssfi", n);
      let a = r.call(this);
      if (a !== void 0) return a;
      let i = new I();
      return $t(this, i), i;
    }, "propertyGetter"), "propertyGetter"),
    configurable: !0
  });
}
o(ul, "addProperty");
U(ul, "addProperty");
var WD = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Ro(e, t, r) {
  return WD.configurable && Object.defineProperty(e, "length", {
    get: U(function() {
      throw Error(
        r ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".'
      );
    }, "get")
  }), e;
}
o(Ro, "addLengthGuard");
U(Ro, "addLengthGuard");
function Df(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(a) {
    t.indexOf(a) === -1 && t.push(a);
  }
  o(r, "addProperty2"), U(r, "addProperty");
  let n = Object.getPrototypeOf(e);
  for (; n !== null; )
    Object.getOwnPropertyNames(n).forEach(r), n = Object.getPrototypeOf(n);
  return t;
}
o(Df, "getProperties");
U(Df, "getProperties");
var eg = ["__flags", "__methods", "_obj", "assert"];
function Nn(e, t) {
  return Ao() ? new Proxy(e, {
    get: U(/* @__PURE__ */ o(function r(n, a) {
      if (typeof a == "string" && ut.proxyExcludedKeys.indexOf(a) === -1 && !Reflect.has(n, a)) {
        if (t)
          throw Error(
            "Invalid Chai property: " + t + "." + a + '. See docs for proper usage of "' + t + '".'
          );
        let i = null, s = 4;
        throw Df(n).forEach(function(l) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(l) && eg.indexOf(l) === -1
          ) {
            let c = Ff(a, l, s);
            c < s && (i = l, s = c);
          }
        }), Error(
          i !== null ? "Invalid Chai property: " + a + '. Did you mean "' + i + '"?' : "Invalid Chai property: " + a
        );
      }
      return eg.indexOf(a) === -1 && !pe(n, "lockSsfi") && pe(n, "ssfi", r), Reflect.get(n, a);
    }, "proxyGetter"), "proxyGetter")
  }) : e;
}
o(Nn, "proxify");
U(Nn, "proxify");
function Ff(e, t, r) {
  if (Math.abs(e.length - t.length) >= r)
    return r;
  let n = [];
  for (let a = 0; a <= e.length; a++)
    n[a] = Array(t.length + 1).fill(0), n[a][0] = a;
  for (let a = 0; a < t.length; a++)
    n[0][a] = a;
  for (let a = 1; a <= e.length; a++) {
    let i = e.charCodeAt(a - 1);
    for (let s = 1; s <= t.length; s++) {
      if (Math.abs(a - s) >= r) {
        n[a][s] = r;
        continue;
      }
      n[a][s] = Math.min(
        n[a - 1][s] + 1,
        n[a][s - 1] + 1,
        n[a - 1][s - 1] + (i === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  }
  return n[e.length][t.length];
}
o(Ff, "stringDistanceCapped");
U(Ff, "stringDistanceCapped");
function cl(e, t, r) {
  let n = U(function() {
    pe(this, "lockSsfi") || pe(this, "ssfi", n);
    let a = r.apply(this, arguments);
    if (a !== void 0) return a;
    let i = new I();
    return $t(this, i), i;
  }, "methodWrapper");
  Ro(n, t, !1), e[t] = Nn(n, t);
}
o(cl, "addMethod");
U(cl, "addMethod");
function dl(e, t, r) {
  let n = Object.getOwnPropertyDescriptor(e, t), a = U(function() {
  }, "_super");
  n && typeof n.get == "function" && (a = n.get), Object.defineProperty(e, t, {
    get: U(/* @__PURE__ */ o(function i() {
      !Ao() && !pe(this, "lockSsfi") && pe(this, "ssfi", i);
      let s = pe(this, "lockSsfi");
      pe(this, "lockSsfi", !0);
      let l = r(a).call(this);
      if (pe(this, "lockSsfi", s), l !== void 0)
        return l;
      let c = new I();
      return $t(this, c), c;
    }, "overwritingPropertyGetter"), "overwritingPropertyGetter"),
    configurable: !0
  });
}
o(dl, "overwriteProperty");
U(dl, "overwriteProperty");
function pl(e, t, r) {
  let n = e[t], a = U(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  n && typeof n == "function" && (a = n);
  let i = U(function() {
    pe(this, "lockSsfi") || pe(this, "ssfi", i);
    let s = pe(this, "lockSsfi");
    pe(this, "lockSsfi", !0);
    let l = r(a).apply(this, arguments);
    if (pe(this, "lockSsfi", s), l !== void 0)
      return l;
    let c = new I();
    return $t(this, c), c;
  }, "overwritingMethodWrapper");
  Ro(i, t, !1), e[t] = Nn(i, t);
}
o(pl, "overwriteMethod");
U(pl, "overwriteMethod");
var GD = typeof Object.setPrototypeOf == "function", tg = U(function() {
}, "testFn"), KD = Object.getOwnPropertyNames(tg).filter(function(e) {
  let t = Object.getOwnPropertyDescriptor(tg, e);
  return typeof t != "object" ? !0 : !t.configurable;
}), YD = Function.prototype.call, XD = Function.prototype.apply;
function fl(e, t, r, n) {
  typeof n != "function" && (n = U(function() {
  }, "chainingBehavior"));
  let a = {
    method: r,
    chainingBehavior: n
  };
  e.__methods || (e.__methods = {}), e.__methods[t] = a, Object.defineProperty(e, t, {
    get: U(/* @__PURE__ */ o(function() {
      a.chainingBehavior.call(this);
      let i = U(function() {
        pe(this, "lockSsfi") || pe(this, "ssfi", i);
        let s = a.method.apply(this, arguments);
        if (s !== void 0)
          return s;
        let l = new I();
        return $t(this, l), l;
      }, "chainableMethodWrapper");
      if (Ro(i, t, !0), GD) {
        let s = Object.create(this);
        s.call = YD, s.apply = XD, Object.setPrototypeOf(i, s);
      } else
        Object.getOwnPropertyNames(e).forEach(function(s) {
          if (KD.indexOf(s) !== -1)
            return;
          let l = Object.getOwnPropertyDescriptor(e, s);
          Object.defineProperty(i, s, l);
        });
      return $t(this, i), Nn(i);
    }, "chainableMethodGetter"), "chainableMethodGetter"),
    configurable: !0
  });
}
o(fl, "addChainableMethod");
U(fl, "addChainableMethod");
function ml(e, t, r, n) {
  let a = e.__methods[t], i = a.chainingBehavior;
  a.chainingBehavior = U(/* @__PURE__ */ o(function() {
    let l = n(i).call(this);
    if (l !== void 0)
      return l;
    let c = new I();
    return $t(this, c), c;
  }, "overwritingChainableMethodGetter"), "overwritingChainableMethodGetter");
  let s = a.method;
  a.method = U(/* @__PURE__ */ o(function() {
    let l = r(s).apply(this, arguments);
    if (l !== void 0)
      return l;
    let c = new I();
    return $t(this, c), c;
  }, "overwritingChainableMethodWrapper"), "overwritingChainableMethodWrapper");
}
o(ml, "overwriteChainableMethod");
U(ml, "overwriteChainableMethod");
function Ta(e, t) {
  return ve(e) < ve(t) ? -1 : 1;
}
o(Ta, "compareByInspect");
U(Ta, "compareByInspect");
function hl(e) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.getOwnPropertyDescriptor(e, t).enumerable;
  });
}
o(hl, "getOwnEnumerablePropertySymbols");
U(hl, "getOwnEnumerablePropertySymbols");
function yl(e) {
  return Object.keys(e).concat(hl(e));
}
o(yl, "getOwnEnumerableProperties");
U(yl, "getOwnEnumerableProperties");
var cs = Number.isNaN;
function Bf(e) {
  let t = Oe(e);
  return ["Array", "Object", "Function"].indexOf(t) !== -1;
}
o(Bf, "isObjectType");
U(Bf, "isObjectType");
function gl(e, t) {
  let r = pe(e, "operator"), n = pe(e, "negate"), a = t[3], i = n ? t[2] : t[1];
  if (r)
    return r;
  if (typeof i == "function" && (i = i()), i = i || "", !i || /\shave\s/.test(i))
    return;
  let s = Bf(a);
  return /\snot\s/.test(i) ? s ? "notDeepStrictEqual" : "notStrictEqual" : s ? "deepStrictEqual" : "strictEqual";
}
o(gl, "getOperator");
U(gl, "getOperator");
function Ka(e) {
  return e.name;
}
o(Ka, "getName");
U(Ka, "getName");
function Sa(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
o(Sa, "isRegExp2");
U(Sa, "isRegExp");
function Ge(e) {
  return ["Number", "BigInt"].includes(Oe(e));
}
o(Ge, "isNumeric");
U(Ge, "isNumeric");
var { flag: B } = er;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(e) {
  I.addProperty(e);
});
I.addProperty("not", function() {
  B(this, "negate", !0);
});
I.addProperty("deep", function() {
  B(this, "deep", !0);
});
I.addProperty("nested", function() {
  B(this, "nested", !0);
});
I.addProperty("own", function() {
  B(this, "own", !0);
});
I.addProperty("ordered", function() {
  B(this, "ordered", !0);
});
I.addProperty("any", function() {
  B(this, "any", !0), B(this, "all", !1);
});
I.addProperty("all", function() {
  B(this, "all", !0), B(this, "any", !1);
});
var rg = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function bl(e, t) {
  t && B(this, "message", t), e = e.toLowerCase();
  let r = B(this, "object"), n = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a ";
  const a = Oe(r).toLowerCase();
  rg.function.includes(e) ? this.assert(
    rg[e].includes(a),
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  ) : this.assert(
    e === a,
    "expected #{this} to be " + n + e,
    "expected #{this} not to be " + n + e
  );
}
o(bl, "an");
U(bl, "an");
I.addChainableMethod("an", bl);
I.addChainableMethod("a", bl);
function Uf(e, t) {
  return cs(e) && cs(t) || e === t;
}
o(Uf, "SameValueZero");
U(Uf, "SameValueZero");
function ko() {
  B(this, "contains", !0);
}
o(ko, "includeChainingBehavior");
U(ko, "includeChainingBehavior");
function Io(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = Oe(r).toLowerCase(), a = B(this, "message"), i = B(this, "negate"), s = B(this, "ssfi"), l = B(this, "deep"), c = l ? "deep " : "", u = l ? B(this, "eql") : Uf;
  a = a ? a + ": " : "";
  let p = !1;
  switch (n) {
    case "string":
      p = r.indexOf(e) !== -1;
      break;
    case "weakset":
      if (l)
        throw new Te(
          a + "unable to use .deep.include with WeakSet",
          void 0,
          s
        );
      p = r.has(e);
      break;
    case "map":
      r.forEach(function(f) {
        p = p || u(f, e);
      });
      break;
    case "set":
      l ? r.forEach(function(f) {
        p = p || u(f, e);
      }) : p = r.has(e);
      break;
    case "array":
      l ? p = r.some(function(f) {
        return u(f, e);
      }) : p = r.indexOf(e) !== -1;
      break;
    default: {
      if (e !== Object(e))
        throw new Te(
          a + "the given combination of arguments (" + n + " and " + Oe(e).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + Oe(e).toLowerCase(),
          void 0,
          s
        );
      let f = Object.keys(e), m = null, y = 0;
      if (f.forEach(function(g) {
        let v = new I(r);
        if ($t(this, v, !0), B(v, "lockSsfi", !0), !i || f.length === 1) {
          v.property(g, e[g]);
          return;
        }
        try {
          v.property(g, e[g]);
        } catch (_) {
          if (!bt.compatibleConstructor(_, Te))
            throw _;
          m === null && (m = _), y++;
        }
      }, this), i && f.length > 1 && y === f.length)
        throw m;
      return;
    }
  }
  this.assert(
    p,
    "expected #{this} to " + c + "include " + ve(e),
    "expected #{this} to not " + c + "include " + ve(e)
  );
}
o(Io, "include");
U(Io, "include");
I.addChainableMethod("include", Io, ko);
I.addChainableMethod("contain", Io, ko);
I.addChainableMethod("contains", Io, ko);
I.addChainableMethod("includes", Io, ko);
I.addProperty("ok", function() {
  this.assert(
    B(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
I.addProperty("true", function() {
  this.assert(
    B(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !B(this, "negate")
  );
});
I.addProperty("numeric", function() {
  const e = B(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(Oe(e)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !B(this, "negate")
  );
});
I.addProperty("callable", function() {
  const e = B(this, "object"), t = B(this, "ssfi"), r = B(this, "message"), n = r ? `${r}: ` : "", a = B(this, "negate"), i = a ? `${n}expected ${ve(e)} not to be a callable function` : `${n}expected ${ve(e)} to be a callable function`, s = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(Oe(e));
  if (s && a || !s && !a)
    throw new Te(i, void 0, t);
});
I.addProperty("false", function() {
  this.assert(
    B(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!B(this, "negate")
  );
});
I.addProperty("null", function() {
  this.assert(
    B(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
I.addProperty("undefined", function() {
  this.assert(
    B(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
I.addProperty("NaN", function() {
  this.assert(
    cs(B(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function vl() {
  let e = B(this, "object");
  this.assert(
    e != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
o(vl, "assertExist");
U(vl, "assertExist");
I.addProperty("exist", vl);
I.addProperty("exists", vl);
I.addProperty("empty", function() {
  let e = B(this, "object"), t = B(this, "ssfi"), r = B(this, "message"), n;
  switch (r = r ? r + ": " : "", Oe(e).toLowerCase()) {
    case "array":
    case "string":
      n = e.length;
      break;
    case "map":
    case "set":
      n = e.size;
      break;
    case "weakmap":
    case "weakset":
      throw new Te(
        r + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function": {
      const a = r + ".empty was passed a function " + Ka(e);
      throw new Te(a.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new Te(
          r + ".empty was passed non-string primitive " + ve(e),
          void 0,
          t
        );
      n = Object.keys(e).length;
  }
  this.assert(
    n === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function wl() {
  let e = B(this, "object"), t = Oe(e);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
o(wl, "checkArguments");
U(wl, "checkArguments");
I.addProperty("arguments", wl);
I.addProperty("Arguments", wl);
function Ya(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object");
  if (B(this, "deep")) {
    let n = B(this, "lockSsfi");
    B(this, "lockSsfi", !0), this.eql(e), B(this, "lockSsfi", n);
  } else
    this.assert(
      e === r,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      e,
      this._obj,
      !0
    );
}
o(Ya, "assertEqual");
U(Ya, "assertEqual");
I.addMethod("equal", Ya);
I.addMethod("equals", Ya);
I.addMethod("eq", Ya);
function _l(e, t) {
  t && B(this, "message", t);
  let r = B(this, "eql");
  this.assert(
    r(e, B(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    e,
    this._obj,
    !0
  );
}
o(_l, "assertEql");
U(_l, "assertEql");
I.addMethod("eql", _l);
I.addMethod("eqls", _l);
function Xa(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "doLength"), a = B(this, "message"), i = a ? a + ": " : "", s = B(this, "ssfi"), l = Oe(r).toLowerCase(), c = Oe(e).toLowerCase();
  if (n && l !== "map" && l !== "set" && new I(r, a, s, !0).to.have.property("length"), !n && l === "date" && c !== "date")
    throw new Te(
      i + "the argument to above must be a date",
      void 0,
      s
    );
  if (!Ge(e) && (n || Ge(r)))
    throw new Te(
      i + "the argument to above must be a number",
      void 0,
      s
    );
  if (!n && l !== "date" && !Ge(r)) {
    let u = l === "string" ? "'" + r + "'" : r;
    throw new Te(
      i + "expected " + u + " to be a number or a date",
      void 0,
      s
    );
  }
  if (n) {
    let u = "length", p;
    l === "map" || l === "set" ? (u = "size", p = r.size) : p = r.length, this.assert(
      p > e,
      "expected #{this} to have a " + u + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + u + " above #{exp}",
      e,
      p
    );
  } else
    this.assert(
      r > e,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      e
    );
}
o(Xa, "assertAbove");
U(Xa, "assertAbove");
I.addMethod("above", Xa);
I.addMethod("gt", Xa);
I.addMethod("greaterThan", Xa);
function Qa(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "doLength"), a = B(this, "message"), i = a ? a + ": " : "", s = B(this, "ssfi"), l = Oe(r).toLowerCase(), c = Oe(e).toLowerCase(), u, p = !0;
  if (n && l !== "map" && l !== "set" && new I(r, a, s, !0).to.have.property("length"), !n && l === "date" && c !== "date")
    u = i + "the argument to least must be a date";
  else if (!Ge(e) && (n || Ge(r)))
    u = i + "the argument to least must be a number";
  else if (!n && l !== "date" && !Ge(r)) {
    let f = l === "string" ? "'" + r + "'" : r;
    u = i + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Te(u, void 0, s);
  if (n) {
    let f = "length", m;
    l === "map" || l === "set" ? (f = "size", m = r.size) : m = r.length, this.assert(
      m >= e,
      "expected #{this} to have a " + f + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + f + " below #{exp}",
      e,
      m
    );
  } else
    this.assert(
      r >= e,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      e
    );
}
o(Qa, "assertLeast");
U(Qa, "assertLeast");
I.addMethod("least", Qa);
I.addMethod("gte", Qa);
I.addMethod("greaterThanOrEqual", Qa);
function Za(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "doLength"), a = B(this, "message"), i = a ? a + ": " : "", s = B(this, "ssfi"), l = Oe(r).toLowerCase(), c = Oe(e).toLowerCase(), u, p = !0;
  if (n && l !== "map" && l !== "set" && new I(r, a, s, !0).to.have.property("length"), !n && l === "date" && c !== "date")
    u = i + "the argument to below must be a date";
  else if (!Ge(e) && (n || Ge(r)))
    u = i + "the argument to below must be a number";
  else if (!n && l !== "date" && !Ge(r)) {
    let f = l === "string" ? "'" + r + "'" : r;
    u = i + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Te(u, void 0, s);
  if (n) {
    let f = "length", m;
    l === "map" || l === "set" ? (f = "size", m = r.size) : m = r.length, this.assert(
      m < e,
      "expected #{this} to have a " + f + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + f + " below #{exp}",
      e,
      m
    );
  } else
    this.assert(
      r < e,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      e
    );
}
o(Za, "assertBelow");
U(Za, "assertBelow");
I.addMethod("below", Za);
I.addMethod("lt", Za);
I.addMethod("lessThan", Za);
function ei(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "doLength"), a = B(this, "message"), i = a ? a + ": " : "", s = B(this, "ssfi"), l = Oe(r).toLowerCase(), c = Oe(e).toLowerCase(), u, p = !0;
  if (n && l !== "map" && l !== "set" && new I(r, a, s, !0).to.have.property("length"), !n && l === "date" && c !== "date")
    u = i + "the argument to most must be a date";
  else if (!Ge(e) && (n || Ge(r)))
    u = i + "the argument to most must be a number";
  else if (!n && l !== "date" && !Ge(r)) {
    let f = l === "string" ? "'" + r + "'" : r;
    u = i + "expected " + f + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Te(u, void 0, s);
  if (n) {
    let f = "length", m;
    l === "map" || l === "set" ? (f = "size", m = r.size) : m = r.length, this.assert(
      m <= e,
      "expected #{this} to have a " + f + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + f + " above #{exp}",
      e,
      m
    );
  } else
    this.assert(
      r <= e,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      e
    );
}
o(ei, "assertMost");
U(ei, "assertMost");
I.addMethod("most", ei);
I.addMethod("lte", ei);
I.addMethod("lessThanOrEqual", ei);
I.addMethod("within", function(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "object"), a = B(this, "doLength"), i = B(this, "message"), s = i ? i + ": " : "", l = B(this, "ssfi"), c = Oe(n).toLowerCase(), u = Oe(e).toLowerCase(), p = Oe(t).toLowerCase(), f, m = !0, y = u === "date" && p === "date" ? e.toISOString() + ".." + t.toISOString() : e + ".." + t;
  if (a && c !== "map" && c !== "set" && new I(n, i, l, !0).to.have.property("length"), !a && c === "date" && (u !== "date" || p !== "date"))
    f = s + "the arguments to within must be dates";
  else if ((!Ge(e) || !Ge(t)) && (a || Ge(n)))
    f = s + "the arguments to within must be numbers";
  else if (!a && c !== "date" && !Ge(n)) {
    let g = c === "string" ? "'" + n + "'" : n;
    f = s + "expected " + g + " to be a number or a date";
  } else
    m = !1;
  if (m)
    throw new Te(f, void 0, l);
  if (a) {
    let g = "length", v;
    c === "map" || c === "set" ? (g = "size", v = n.size) : v = n.length, this.assert(
      v >= e && v <= t,
      "expected #{this} to have a " + g + " within " + y,
      "expected #{this} to not have a " + g + " within " + y
    );
  } else
    this.assert(
      n >= e && n <= t,
      "expected #{this} to be within " + y,
      "expected #{this} to not be within " + y
    );
});
function El(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "ssfi"), a = B(this, "message"), i;
  try {
    i = r instanceof e;
  } catch (l) {
    throw l instanceof TypeError ? (a = a ? a + ": " : "", new Te(
      a + "The instanceof assertion needs a constructor but " + Oe(e) + " was given.",
      void 0,
      n
    )) : l;
  }
  let s = Ka(e);
  s == null && (s = "an unnamed constructor"), this.assert(
    i,
    "expected #{this} to be an instance of " + s,
    "expected #{this} to not be an instance of " + s
  );
}
o(El, "assertInstanceOf");
U(El, "assertInstanceOf");
I.addMethod("instanceof", El);
I.addMethod("instanceOf", El);
function xl(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "nested"), a = B(this, "own"), i = B(this, "message"), s = B(this, "object"), l = B(this, "ssfi"), c = typeof e;
  if (i = i ? i + ": " : "", n) {
    if (c !== "string")
      throw new Te(
        i + "the argument to property must be a string when using nested syntax",
        void 0,
        l
      );
  } else if (c !== "string" && c !== "number" && c !== "symbol")
    throw new Te(
      i + "the argument to property must be a string, number, or symbol",
      void 0,
      l
    );
  if (n && a)
    throw new Te(
      i + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      l
    );
  if (s == null)
    throw new Te(
      i + "Target cannot be null or undefined.",
      void 0,
      l
    );
  let u = B(this, "deep"), p = B(this, "negate"), f = n ? ll(s, e) : null, m = n ? f.value : s[e], y = u ? B(this, "eql") : (_, b) => _ === b, g = "";
  u && (g += "deep "), a && (g += "own "), n && (g += "nested "), g += "property ";
  let v;
  a ? v = Object.prototype.hasOwnProperty.call(s, e) : n ? v = f.exists : v = Ga(s, e), (!p || arguments.length === 1) && this.assert(
    v,
    "expected #{this} to have " + g + ve(e),
    "expected #{this} to not have " + g + ve(e)
  ), arguments.length > 1 && this.assert(
    v && y(t, m),
    "expected #{this} to have " + g + ve(e) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + g + ve(e) + " of #{act}",
    t,
    m
  ), B(this, "object", m);
}
o(xl, "assertProperty");
U(xl, "assertProperty");
I.addMethod("property", xl);
function Tl(e, t, r) {
  B(this, "own", !0), xl.apply(this, arguments);
}
o(Tl, "assertOwnProperty");
U(Tl, "assertOwnProperty");
I.addMethod("ownProperty", Tl);
I.addMethod("haveOwnProperty", Tl);
function Sl(e, t, r) {
  typeof t == "string" && (r = t, t = null), r && B(this, "message", r);
  let n = B(this, "object"), a = Object.getOwnPropertyDescriptor(Object(n), e), i = B(this, "eql");
  a && t ? this.assert(
    i(t, a),
    "expected the own property descriptor for " + ve(e) + " on #{this} to match " + ve(t) + ", got " + ve(a),
    "expected the own property descriptor for " + ve(e) + " on #{this} to not match " + ve(t),
    t,
    a,
    !0
  ) : this.assert(
    a,
    "expected #{this} to have an own property descriptor for " + ve(e),
    "expected #{this} to not have an own property descriptor for " + ve(e)
  ), B(this, "object", a);
}
o(Sl, "assertOwnPropertyDescriptor");
U(Sl, "assertOwnPropertyDescriptor");
I.addMethod("ownPropertyDescriptor", Sl);
I.addMethod("haveOwnPropertyDescriptor", Sl);
function Pl() {
  B(this, "doLength", !0);
}
o(Pl, "assertLengthChain");
U(Pl, "assertLengthChain");
function Ol(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = Oe(r).toLowerCase(), a = B(this, "message"), i = B(this, "ssfi"), s = "length", l;
  switch (n) {
    case "map":
    case "set":
      s = "size", l = r.size;
      break;
    default:
      new I(r, a, i, !0).to.have.property("length"), l = r.length;
  }
  this.assert(
    l == e,
    "expected #{this} to have a " + s + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + s + " of #{act}",
    e,
    l
  );
}
o(Ol, "assertLength");
U(Ol, "assertLength");
I.addChainableMethod("length", Ol, Pl);
I.addChainableMethod("lengthOf", Ol, Pl);
function Cl(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object");
  this.assert(
    e.exec(r),
    "expected #{this} to match " + e,
    "expected #{this} not to match " + e
  );
}
o(Cl, "assertMatch");
U(Cl, "assertMatch");
I.addMethod("match", Cl);
I.addMethod("matches", Cl);
I.addMethod("string", function(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "message"), a = B(this, "ssfi");
  new I(r, n, a, !0).is.a("string"), this.assert(
    ~r.indexOf(e),
    "expected #{this} to contain " + ve(e),
    "expected #{this} to not contain " + ve(e)
  );
});
function Al(e) {
  let t = B(this, "object"), r = Oe(t), n = Oe(e), a = B(this, "ssfi"), i = B(this, "deep"), s, l = "", c, u = !0, p = B(this, "message");
  p = p ? p + ": " : "";
  let f = p + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (r === "Map" || r === "Set")
    l = i ? "deeply " : "", c = [], t.forEach(function(b, E) {
      c.push(E);
    }), n !== "Array" && (e = Array.prototype.slice.call(arguments));
  else {
    switch (c = yl(t), n) {
      case "Array":
        if (arguments.length > 1)
          throw new Te(f, void 0, a);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new Te(f, void 0, a);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function(b) {
      return typeof b == "symbol" ? b : String(b);
    });
  }
  if (!e.length)
    throw new Te(p + "keys required", void 0, a);
  let m = e.length, y = B(this, "any"), g = B(this, "all"), v = e, _ = i ? B(this, "eql") : (b, E) => b === E;
  if (!y && !g && (g = !0), y && (u = v.some(function(b) {
    return c.some(function(E) {
      return _(b, E);
    });
  })), g && (u = v.every(function(b) {
    return c.some(function(E) {
      return _(b, E);
    });
  }), B(this, "contains") || (u = u && e.length == c.length)), m > 1) {
    e = e.map(function(E) {
      return ve(E);
    });
    let b = e.pop();
    g && (s = e.join(", ") + ", and " + b), y && (s = e.join(", ") + ", or " + b);
  } else
    s = ve(e[0]);
  s = (m > 1 ? "keys " : "key ") + s, s = (B(this, "contains") ? "contain " : "have ") + s, this.assert(
    u,
    "expected #{this} to " + l + s,
    "expected #{this} to not " + l + s,
    v.slice(0).sort(Ta),
    c.sort(Ta),
    !0
  );
}
o(Al, "assertKeys");
U(Al, "assertKeys");
I.addMethod("keys", Al);
I.addMethod("key", Al);
function ti(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "object"), a = B(this, "ssfi"), i = B(this, "message"), s = B(this, "negate") || !1;
  new I(n, i, a, !0).is.a("function"), (Sa(e) || typeof e == "string") && (t = e, e = null);
  let l, c = !1;
  try {
    n();
  } catch (y) {
    c = !0, l = y;
  }
  let u = e === void 0 && t === void 0, p = !!(e && t), f = !1, m = !1;
  if (u || !u && !s) {
    let y = "an error";
    e instanceof Error ? y = "#{exp}" : e && (y = bt.getConstructorName(e));
    let g = l;
    if (l instanceof Error)
      g = l.toString();
    else if (typeof l == "string")
      g = l;
    else if (l && (typeof l == "object" || typeof l == "function"))
      try {
        g = bt.getConstructorName(l);
      } catch {
      }
    this.assert(
      c,
      "expected #{this} to throw " + y,
      "expected #{this} to not throw an error but #{act} was thrown",
      e && e.toString(),
      g
    );
  }
  if (e && l && (e instanceof Error && bt.compatibleInstance(
    l,
    e
  ) === s && (p && s ? f = !0 : this.assert(
    s,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (l && !s ? " but #{act} was thrown" : ""),
    e.toString(),
    l.toString()
  )), bt.compatibleConstructor(
    l,
    e
  ) === s && (p && s ? f = !0 : this.assert(
    s,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (l ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && bt.getConstructorName(e),
    l instanceof Error ? l.toString() : l && bt.getConstructorName(l)
  ))), l && t !== void 0 && t !== null) {
    let y = "including";
    Sa(t) && (y = "matching"), bt.compatibleMessage(
      l,
      t
    ) === s && (p && s ? m = !0 : this.assert(
      s,
      "expected #{this} to throw error " + y + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + y + " #{exp}",
      t,
      bt.getMessage(l)
    ));
  }
  f && m && this.assert(
    s,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (l ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && bt.getConstructorName(e),
    l instanceof Error ? l.toString() : l && bt.getConstructorName(l)
  ), B(this, "object", l);
}
o(ti, "assertThrows");
U(ti, "assertThrows");
I.addMethod("throw", ti);
I.addMethod("throws", ti);
I.addMethod("Throw", ti);
function Rl(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "itself"), a = typeof r == "function" && !n ? r.prototype[e] : r[e];
  this.assert(
    typeof a == "function",
    "expected #{this} to respond to " + ve(e),
    "expected #{this} to not respond to " + ve(e)
  );
}
o(Rl, "respondTo");
U(Rl, "respondTo");
I.addMethod("respondTo", Rl);
I.addMethod("respondsTo", Rl);
I.addProperty("itself", function() {
  B(this, "itself", !0);
});
function kl(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = e(r);
  this.assert(
    n,
    "expected #{this} to satisfy " + Ur(e),
    "expected #{this} to not satisfy" + Ur(e),
    !B(this, "negate"),
    n
  );
}
o(kl, "satisfy");
U(kl, "satisfy");
I.addMethod("satisfy", kl);
I.addMethod("satisfies", kl);
function Il(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "object"), a = B(this, "message"), i = B(this, "ssfi");
  new I(n, a, i, !0).is.numeric;
  let s = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new Te(
      a ? `${a}: ${s}` : s,
      void 0,
      i
    );
  if (new I(t, a, i, !0).is.numeric, s = "A `expected` value is required for `closeTo`", e == null)
    throw new Te(
      a ? `${a}: ${s}` : s,
      void 0,
      i
    );
  new I(e, a, i, !0).is.numeric;
  const l = U((u) => u < 0n ? -u : u, "abs"), c = U((u) => parseFloat(parseFloat(u).toPrecision(12)), "strip");
  this.assert(
    c(l(n - e)) <= t,
    "expected #{this} to be close to " + e + " +/- " + t,
    "expected #{this} not to be close to " + e + " +/- " + t
  );
}
o(Il, "closeTo");
U(Il, "closeTo");
I.addMethod("closeTo", Il);
I.addMethod("approximately", Il);
function Hf(e, t, r, n, a) {
  let i = Array.from(t), s = Array.from(e);
  if (!n) {
    if (s.length !== i.length) return !1;
    i = i.slice();
  }
  return s.every(function(l, c) {
    if (a) return r ? r(l, i[c]) : l === i[c];
    if (!r) {
      let u = i.indexOf(l);
      return u === -1 ? !1 : (n || i.splice(u, 1), !0);
    }
    return i.some(function(u, p) {
      return r(l, u) ? (n || i.splice(p, 1), !0) : !1;
    });
  });
}
o(Hf, "isSubsetOf");
U(Hf, "isSubsetOf");
I.addMethod("members", function(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "message"), a = B(this, "ssfi");
  new I(r, n, a, !0).to.be.iterable, new I(e, n, a, !0).to.be.iterable;
  let i = B(this, "contains"), s = B(this, "ordered"), l, c, u;
  i ? (l = s ? "an ordered superset" : "a superset", c = "expected #{this} to be " + l + " of #{exp}", u = "expected #{this} to not be " + l + " of #{exp}") : (l = s ? "ordered members" : "members", c = "expected #{this} to have the same " + l + " as #{exp}", u = "expected #{this} to not have the same " + l + " as #{exp}");
  let p = B(this, "deep") ? B(this, "eql") : void 0;
  this.assert(
    Hf(e, r, p, i, s),
    c,
    u,
    e,
    r,
    !0
  );
});
I.addProperty("iterable", function(e) {
  e && B(this, "message", e);
  let t = B(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function Vf(e, t) {
  t && B(this, "message", t);
  let r = B(this, "object"), n = B(this, "message"), a = B(this, "ssfi"), i = B(this, "contains"), s = B(this, "deep"), l = B(this, "eql");
  new I(e, n, a, !0).to.be.an("array"), i ? this.assert(
    e.some(function(c) {
      return r.indexOf(c) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    e,
    r
  ) : s ? this.assert(
    e.some(function(c) {
      return l(r, c);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    e,
    r
  ) : this.assert(
    e.indexOf(r) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    e,
    r
  );
}
o(Vf, "oneOf");
U(Vf, "oneOf");
I.addMethod("oneOf", Vf);
function jl(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "object"), a = B(this, "message"), i = B(this, "ssfi");
  new I(n, a, i, !0).is.a("function");
  let s;
  t ? (new I(e, a, i, !0).to.have.property(t), s = e[t]) : (new I(e, a, i, !0).is.a("function"), s = e()), n();
  let l = t == null ? e() : e[t], c = t == null ? s : "." + t;
  B(this, "deltaMsgObj", c), B(this, "initialDeltaValue", s), B(this, "finalDeltaValue", l), B(this, "deltaBehavior", "change"), B(this, "realDelta", l !== s), this.assert(
    s !== l,
    "expected " + c + " to change",
    "expected " + c + " to not change"
  );
}
o(jl, "assertChanges");
U(jl, "assertChanges");
I.addMethod("change", jl);
I.addMethod("changes", jl);
function Nl(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "object"), a = B(this, "message"), i = B(this, "ssfi");
  new I(n, a, i, !0).is.a("function");
  let s;
  t ? (new I(e, a, i, !0).to.have.property(t), s = e[t]) : (new I(e, a, i, !0).is.a("function"), s = e()), new I(s, a, i, !0).is.a("number"), n();
  let l = t == null ? e() : e[t], c = t == null ? s : "." + t;
  B(this, "deltaMsgObj", c), B(this, "initialDeltaValue", s), B(this, "finalDeltaValue", l), B(this, "deltaBehavior", "increase"), B(this, "realDelta", l - s), this.assert(
    l - s > 0,
    "expected " + c + " to increase",
    "expected " + c + " to not increase"
  );
}
o(Nl, "assertIncreases");
U(Nl, "assertIncreases");
I.addMethod("increase", Nl);
I.addMethod("increases", Nl);
function ql(e, t, r) {
  r && B(this, "message", r);
  let n = B(this, "object"), a = B(this, "message"), i = B(this, "ssfi");
  new I(n, a, i, !0).is.a("function");
  let s;
  t ? (new I(e, a, i, !0).to.have.property(t), s = e[t]) : (new I(e, a, i, !0).is.a("function"), s = e()), new I(s, a, i, !0).is.a("number"), n();
  let l = t == null ? e() : e[t], c = t == null ? s : "." + t;
  B(this, "deltaMsgObj", c), B(this, "initialDeltaValue", s), B(this, "finalDeltaValue", l), B(this, "deltaBehavior", "decrease"), B(this, "realDelta", s - l), this.assert(
    l - s < 0,
    "expected " + c + " to decrease",
    "expected " + c + " to not decrease"
  );
}
o(ql, "assertDecreases");
U(ql, "assertDecreases");
I.addMethod("decrease", ql);
I.addMethod("decreases", ql);
function Jf(e, t) {
  t && B(this, "message", t);
  let r = B(this, "deltaMsgObj"), n = B(this, "initialDeltaValue"), a = B(this, "finalDeltaValue"), i = B(this, "deltaBehavior"), s = B(this, "realDelta"), l;
  i === "change" ? l = Math.abs(a - n) === Math.abs(e) : l = s === Math.abs(e), this.assert(
    l,
    "expected " + r + " to " + i + " by " + e,
    "expected " + r + " to not " + i + " by " + e
  );
}
o(Jf, "assertDelta");
U(Jf, "assertDelta");
I.addMethod("by", Jf);
I.addProperty("extensible", function() {
  let e = B(this, "object"), t = e === Object(e) && Object.isExtensible(e);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
I.addProperty("sealed", function() {
  let e = B(this, "object"), t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
I.addProperty("frozen", function() {
  let e = B(this, "object"), t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
I.addProperty("finite", function(e) {
  let t = B(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Pa(e, t) {
  return e === t ? !0 : typeof t != typeof e ? !1 : typeof e != "object" || e === null ? e === t : t ? Array.isArray(e) ? Array.isArray(t) ? e.every(function(r) {
    return t.some(function(n) {
      return Pa(r, n);
    });
  }) : !1 : e instanceof Date ? t instanceof Date ? e.getTime() === t.getTime() : !1 : Object.keys(e).every(function(r) {
    let n = e[r], a = t[r];
    return typeof n == "object" && n !== null && a !== null ? Pa(n, a) : typeof n == "function" ? n(a) : a === n;
  }) : !1;
}
o(Pa, "compareSubset");
U(Pa, "compareSubset");
I.addMethod("containSubset", function(e) {
  const t = pe(this, "object"), r = ut.showDiff;
  this.assert(
    Pa(e, t),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    e,
    t,
    r
  );
});
function Hr(e, t) {
  return new I(e, t);
}
o(Hr, "expect");
U(Hr, "expect");
Hr.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "expect.fail()", new Te(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    Hr.fail
  );
};
var xx = {};
sf(xx, {
  Should: /* @__PURE__ */ o(() => ZD, "Should"),
  should: /* @__PURE__ */ o(() => QD, "should")
});
function Ml() {
  function e() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new I(this.valueOf(), null, e) : new I(this, null, e);
  }
  o(e, "shouldGetter"), U(e, "shouldGetter");
  function t(n) {
    Object.defineProperty(this, "should", {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  o(t, "shouldSetter"), U(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: e,
    configurable: !0
  });
  let r = {};
  return r.fail = function(n, a, i, s) {
    throw arguments.length < 2 && (i = n, n = void 0), i = i || "should.fail()", new Te(
      i,
      {
        actual: n,
        expected: a,
        operator: s
      },
      r.fail
    );
  }, r.equal = function(n, a, i) {
    new I(n, i).to.equal(a);
  }, r.Throw = function(n, a, i, s) {
    new I(n, s).to.Throw(a, i);
  }, r.exist = function(n, a) {
    new I(n, a).to.exist;
  }, r.not = {}, r.not.equal = function(n, a, i) {
    new I(n, i).to.not.equal(a);
  }, r.not.Throw = function(n, a, i, s) {
    new I(n, s).to.not.Throw(a, i);
  }, r.not.exist = function(n, a) {
    new I(n, a).to.not.exist;
  }, r.throw = r.Throw, r.not.throw = r.not.Throw, r;
}
o(Ml, "loadShould");
U(Ml, "loadShould");
var QD = Ml, ZD = Ml;
function A(e, t) {
  new I(null, null, A, !0).assert(e, t, "[ negation message unavailable ]");
}
o(A, "assert");
U(A, "assert");
A.fail = function(e, t, r, n) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "assert.fail()", new Te(
    r,
    {
      actual: e,
      expected: t,
      operator: n
    },
    A.fail
  );
};
A.isOk = function(e, t) {
  new I(e, t, A.isOk, !0).is.ok;
};
A.isNotOk = function(e, t) {
  new I(e, t, A.isNotOk, !0).is.not.ok;
};
A.equal = function(e, t, r) {
  let n = new I(e, r, A.equal, !0);
  n.assert(
    t == pe(n, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    e,
    !0
  );
};
A.notEqual = function(e, t, r) {
  let n = new I(e, r, A.notEqual, !0);
  n.assert(
    t != pe(n, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    e,
    !0
  );
};
A.strictEqual = function(e, t, r) {
  new I(e, r, A.strictEqual, !0).to.equal(t);
};
A.notStrictEqual = function(e, t, r) {
  new I(e, r, A.notStrictEqual, !0).to.not.equal(t);
};
A.deepEqual = A.deepStrictEqual = function(e, t, r) {
  new I(e, r, A.deepEqual, !0).to.eql(t);
};
A.notDeepEqual = function(e, t, r) {
  new I(e, r, A.notDeepEqual, !0).to.not.eql(t);
};
A.isAbove = function(e, t, r) {
  new I(e, r, A.isAbove, !0).to.be.above(t);
};
A.isAtLeast = function(e, t, r) {
  new I(e, r, A.isAtLeast, !0).to.be.least(t);
};
A.isBelow = function(e, t, r) {
  new I(e, r, A.isBelow, !0).to.be.below(t);
};
A.isAtMost = function(e, t, r) {
  new I(e, r, A.isAtMost, !0).to.be.most(t);
};
A.isTrue = function(e, t) {
  new I(e, t, A.isTrue, !0).is.true;
};
A.isNotTrue = function(e, t) {
  new I(e, t, A.isNotTrue, !0).to.not.equal(!0);
};
A.isFalse = function(e, t) {
  new I(e, t, A.isFalse, !0).is.false;
};
A.isNotFalse = function(e, t) {
  new I(e, t, A.isNotFalse, !0).to.not.equal(!1);
};
A.isNull = function(e, t) {
  new I(e, t, A.isNull, !0).to.equal(null);
};
A.isNotNull = function(e, t) {
  new I(e, t, A.isNotNull, !0).to.not.equal(null);
};
A.isNaN = function(e, t) {
  new I(e, t, A.isNaN, !0).to.be.NaN;
};
A.isNotNaN = function(e, t) {
  new I(e, t, A.isNotNaN, !0).not.to.be.NaN;
};
A.exists = function(e, t) {
  new I(e, t, A.exists, !0).to.exist;
};
A.notExists = function(e, t) {
  new I(e, t, A.notExists, !0).to.not.exist;
};
A.isUndefined = function(e, t) {
  new I(e, t, A.isUndefined, !0).to.equal(void 0);
};
A.isDefined = function(e, t) {
  new I(e, t, A.isDefined, !0).to.not.equal(void 0);
};
A.isCallable = function(e, t) {
  new I(e, t, A.isCallable, !0).is.callable;
};
A.isNotCallable = function(e, t) {
  new I(e, t, A.isNotCallable, !0).is.not.callable;
};
A.isObject = function(e, t) {
  new I(e, t, A.isObject, !0).to.be.a("object");
};
A.isNotObject = function(e, t) {
  new I(e, t, A.isNotObject, !0).to.not.be.a("object");
};
A.isArray = function(e, t) {
  new I(e, t, A.isArray, !0).to.be.an("array");
};
A.isNotArray = function(e, t) {
  new I(e, t, A.isNotArray, !0).to.not.be.an("array");
};
A.isString = function(e, t) {
  new I(e, t, A.isString, !0).to.be.a("string");
};
A.isNotString = function(e, t) {
  new I(e, t, A.isNotString, !0).to.not.be.a("string");
};
A.isNumber = function(e, t) {
  new I(e, t, A.isNumber, !0).to.be.a("number");
};
A.isNotNumber = function(e, t) {
  new I(e, t, A.isNotNumber, !0).to.not.be.a("number");
};
A.isNumeric = function(e, t) {
  new I(e, t, A.isNumeric, !0).is.numeric;
};
A.isNotNumeric = function(e, t) {
  new I(e, t, A.isNotNumeric, !0).is.not.numeric;
};
A.isFinite = function(e, t) {
  new I(e, t, A.isFinite, !0).to.be.finite;
};
A.isBoolean = function(e, t) {
  new I(e, t, A.isBoolean, !0).to.be.a("boolean");
};
A.isNotBoolean = function(e, t) {
  new I(e, t, A.isNotBoolean, !0).to.not.be.a("boolean");
};
A.typeOf = function(e, t, r) {
  new I(e, r, A.typeOf, !0).to.be.a(t);
};
A.notTypeOf = function(e, t, r) {
  new I(e, r, A.notTypeOf, !0).to.not.be.a(t);
};
A.instanceOf = function(e, t, r) {
  new I(e, r, A.instanceOf, !0).to.be.instanceOf(t);
};
A.notInstanceOf = function(e, t, r) {
  new I(e, r, A.notInstanceOf, !0).to.not.be.instanceOf(
    t
  );
};
A.include = function(e, t, r) {
  new I(e, r, A.include, !0).include(t);
};
A.notInclude = function(e, t, r) {
  new I(e, r, A.notInclude, !0).not.include(t);
};
A.deepInclude = function(e, t, r) {
  new I(e, r, A.deepInclude, !0).deep.include(t);
};
A.notDeepInclude = function(e, t, r) {
  new I(e, r, A.notDeepInclude, !0).not.deep.include(t);
};
A.nestedInclude = function(e, t, r) {
  new I(e, r, A.nestedInclude, !0).nested.include(t);
};
A.notNestedInclude = function(e, t, r) {
  new I(e, r, A.notNestedInclude, !0).not.nested.include(
    t
  );
};
A.deepNestedInclude = function(e, t, r) {
  new I(e, r, A.deepNestedInclude, !0).deep.nested.include(
    t
  );
};
A.notDeepNestedInclude = function(e, t, r) {
  new I(
    e,
    r,
    A.notDeepNestedInclude,
    !0
  ).not.deep.nested.include(t);
};
A.ownInclude = function(e, t, r) {
  new I(e, r, A.ownInclude, !0).own.include(t);
};
A.notOwnInclude = function(e, t, r) {
  new I(e, r, A.notOwnInclude, !0).not.own.include(t);
};
A.deepOwnInclude = function(e, t, r) {
  new I(e, r, A.deepOwnInclude, !0).deep.own.include(t);
};
A.notDeepOwnInclude = function(e, t, r) {
  new I(e, r, A.notDeepOwnInclude, !0).not.deep.own.include(
    t
  );
};
A.match = function(e, t, r) {
  new I(e, r, A.match, !0).to.match(t);
};
A.notMatch = function(e, t, r) {
  new I(e, r, A.notMatch, !0).to.not.match(t);
};
A.property = function(e, t, r) {
  new I(e, r, A.property, !0).to.have.property(t);
};
A.notProperty = function(e, t, r) {
  new I(e, r, A.notProperty, !0).to.not.have.property(t);
};
A.propertyVal = function(e, t, r, n) {
  new I(e, n, A.propertyVal, !0).to.have.property(t, r);
};
A.notPropertyVal = function(e, t, r, n) {
  new I(e, n, A.notPropertyVal, !0).to.not.have.property(
    t,
    r
  );
};
A.deepPropertyVal = function(e, t, r, n) {
  new I(e, n, A.deepPropertyVal, !0).to.have.deep.property(
    t,
    r
  );
};
A.notDeepPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.notDeepPropertyVal,
    !0
  ).to.not.have.deep.property(t, r);
};
A.ownProperty = function(e, t, r) {
  new I(e, r, A.ownProperty, !0).to.have.own.property(t);
};
A.notOwnProperty = function(e, t, r) {
  new I(e, r, A.notOwnProperty, !0).to.not.have.own.property(
    t
  );
};
A.ownPropertyVal = function(e, t, r, n) {
  new I(e, n, A.ownPropertyVal, !0).to.have.own.property(
    t,
    r
  );
};
A.notOwnPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.notOwnPropertyVal,
    !0
  ).to.not.have.own.property(t, r);
};
A.deepOwnPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.deepOwnPropertyVal,
    !0
  ).to.have.deep.own.property(t, r);
};
A.notDeepOwnPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.notDeepOwnPropertyVal,
    !0
  ).to.not.have.deep.own.property(t, r);
};
A.nestedProperty = function(e, t, r) {
  new I(e, r, A.nestedProperty, !0).to.have.nested.property(
    t
  );
};
A.notNestedProperty = function(e, t, r) {
  new I(
    e,
    r,
    A.notNestedProperty,
    !0
  ).to.not.have.nested.property(t);
};
A.nestedPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.nestedPropertyVal,
    !0
  ).to.have.nested.property(t, r);
};
A.notNestedPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.notNestedPropertyVal,
    !0
  ).to.not.have.nested.property(t, r);
};
A.deepNestedPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.deepNestedPropertyVal,
    !0
  ).to.have.deep.nested.property(t, r);
};
A.notDeepNestedPropertyVal = function(e, t, r, n) {
  new I(
    e,
    n,
    A.notDeepNestedPropertyVal,
    !0
  ).to.not.have.deep.nested.property(t, r);
};
A.lengthOf = function(e, t, r) {
  new I(e, r, A.lengthOf, !0).to.have.lengthOf(t);
};
A.hasAnyKeys = function(e, t, r) {
  new I(e, r, A.hasAnyKeys, !0).to.have.any.keys(t);
};
A.hasAllKeys = function(e, t, r) {
  new I(e, r, A.hasAllKeys, !0).to.have.all.keys(t);
};
A.containsAllKeys = function(e, t, r) {
  new I(e, r, A.containsAllKeys, !0).to.contain.all.keys(
    t
  );
};
A.doesNotHaveAnyKeys = function(e, t, r) {
  new I(e, r, A.doesNotHaveAnyKeys, !0).to.not.have.any.keys(
    t
  );
};
A.doesNotHaveAllKeys = function(e, t, r) {
  new I(e, r, A.doesNotHaveAllKeys, !0).to.not.have.all.keys(
    t
  );
};
A.hasAnyDeepKeys = function(e, t, r) {
  new I(e, r, A.hasAnyDeepKeys, !0).to.have.any.deep.keys(
    t
  );
};
A.hasAllDeepKeys = function(e, t, r) {
  new I(e, r, A.hasAllDeepKeys, !0).to.have.all.deep.keys(
    t
  );
};
A.containsAllDeepKeys = function(e, t, r) {
  new I(
    e,
    r,
    A.containsAllDeepKeys,
    !0
  ).to.contain.all.deep.keys(t);
};
A.doesNotHaveAnyDeepKeys = function(e, t, r) {
  new I(
    e,
    r,
    A.doesNotHaveAnyDeepKeys,
    !0
  ).to.not.have.any.deep.keys(t);
};
A.doesNotHaveAllDeepKeys = function(e, t, r) {
  new I(
    e,
    r,
    A.doesNotHaveAllDeepKeys,
    !0
  ).to.not.have.all.deep.keys(t);
};
A.throws = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null);
  let a = new I(e, n, A.throws, !0).to.throw(
    t,
    r
  );
  return pe(a, "object");
};
A.doesNotThrow = function(e, t, r, n) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null), new I(e, n, A.doesNotThrow, !0).to.not.throw(
    t,
    r
  );
};
A.operator = function(e, t, r, n) {
  let a;
  switch (t) {
    case "==":
      a = e == r;
      break;
    case "===":
      a = e === r;
      break;
    case ">":
      a = e > r;
      break;
    case ">=":
      a = e >= r;
      break;
    case "<":
      a = e < r;
      break;
    case "<=":
      a = e <= r;
      break;
    case "!=":
      a = e != r;
      break;
    case "!==":
      a = e !== r;
      break;
    default:
      throw n = n && n + ": ", new Te(
        n + 'Invalid operator "' + t + '"',
        void 0,
        A.operator
      );
  }
  let i = new I(a, n, A.operator, !0);
  i.assert(
    pe(i, "object") === !0,
    "expected " + ve(e) + " to be " + t + " " + ve(r),
    "expected " + ve(e) + " to not be " + t + " " + ve(r)
  );
};
A.closeTo = function(e, t, r, n) {
  new I(e, n, A.closeTo, !0).to.be.closeTo(t, r);
};
A.approximately = function(e, t, r, n) {
  new I(e, n, A.approximately, !0).to.be.approximately(
    t,
    r
  );
};
A.sameMembers = function(e, t, r) {
  new I(e, r, A.sameMembers, !0).to.have.same.members(t);
};
A.notSameMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notSameMembers,
    !0
  ).to.not.have.same.members(t);
};
A.sameDeepMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.sameDeepMembers,
    !0
  ).to.have.same.deep.members(t);
};
A.notSameDeepMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notSameDeepMembers,
    !0
  ).to.not.have.same.deep.members(t);
};
A.sameOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.sameOrderedMembers,
    !0
  ).to.have.same.ordered.members(t);
};
A.notSameOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notSameOrderedMembers,
    !0
  ).to.not.have.same.ordered.members(t);
};
A.sameDeepOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.sameDeepOrderedMembers,
    !0
  ).to.have.same.deep.ordered.members(t);
};
A.notSameDeepOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notSameDeepOrderedMembers,
    !0
  ).to.not.have.same.deep.ordered.members(t);
};
A.includeMembers = function(e, t, r) {
  new I(e, r, A.includeMembers, !0).to.include.members(
    t
  );
};
A.notIncludeMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notIncludeMembers,
    !0
  ).to.not.include.members(t);
};
A.includeDeepMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.includeDeepMembers,
    !0
  ).to.include.deep.members(t);
};
A.notIncludeDeepMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notIncludeDeepMembers,
    !0
  ).to.not.include.deep.members(t);
};
A.includeOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.includeOrderedMembers,
    !0
  ).to.include.ordered.members(t);
};
A.notIncludeOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notIncludeOrderedMembers,
    !0
  ).to.not.include.ordered.members(t);
};
A.includeDeepOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.includeDeepOrderedMembers,
    !0
  ).to.include.deep.ordered.members(t);
};
A.notIncludeDeepOrderedMembers = function(e, t, r) {
  new I(
    e,
    r,
    A.notIncludeDeepOrderedMembers,
    !0
  ).to.not.include.deep.ordered.members(t);
};
A.oneOf = function(e, t, r) {
  new I(e, r, A.oneOf, !0).to.be.oneOf(t);
};
A.isIterable = function(e, t) {
  if (e == null || !e[Symbol.iterator])
    throw t = t ? `${t} expected ${ve(e)} to be an iterable` : `expected ${ve(e)} to be an iterable`, new Te(t, void 0, A.isIterable);
};
A.changes = function(e, t, r, n) {
  arguments.length === 3 && typeof t == "function" && (n = r, r = null), new I(e, n, A.changes, !0).to.change(t, r);
};
A.changesBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  new I(e, a, A.changesBy, !0).to.change(t, r).by(n);
};
A.doesNotChange = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new I(e, n, A.doesNotChange, !0).to.not.change(
    t,
    r
  );
};
A.changesButNotBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  new I(e, a, A.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
A.increases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new I(e, n, A.increases, !0).to.increase(t, r);
};
A.increasesBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  new I(e, a, A.increasesBy, !0).to.increase(t, r).by(n);
};
A.doesNotIncrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new I(e, n, A.doesNotIncrease, !0).to.not.increase(
    t,
    r
  );
};
A.increasesButNotBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  new I(e, a, A.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
A.decreases = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new I(e, n, A.decreases, !0).to.decrease(t, r);
};
A.decreasesBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  new I(e, a, A.decreasesBy, !0).to.decrease(t, r).by(n);
};
A.doesNotDecrease = function(e, t, r, n) {
  return arguments.length === 3 && typeof t == "function" && (n = r, r = null), new I(e, n, A.doesNotDecrease, !0).to.not.decrease(
    t,
    r
  );
};
A.doesNotDecreaseBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  return new I(e, a, A.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
A.decreasesButNotBy = function(e, t, r, n, a) {
  if (arguments.length === 4 && typeof t == "function") {
    let i = n;
    n = r, a = i;
  } else arguments.length === 3 && (n = r, r = null);
  new I(e, a, A.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
A.ifError = function(e) {
  if (e)
    throw e;
};
A.isExtensible = function(e, t) {
  new I(e, t, A.isExtensible, !0).to.be.extensible;
};
A.isNotExtensible = function(e, t) {
  new I(e, t, A.isNotExtensible, !0).to.not.be.extensible;
};
A.isSealed = function(e, t) {
  new I(e, t, A.isSealed, !0).to.be.sealed;
};
A.isNotSealed = function(e, t) {
  new I(e, t, A.isNotSealed, !0).to.not.be.sealed;
};
A.isFrozen = function(e, t) {
  new I(e, t, A.isFrozen, !0).to.be.frozen;
};
A.isNotFrozen = function(e, t) {
  new I(e, t, A.isNotFrozen, !0).to.not.be.frozen;
};
A.isEmpty = function(e, t) {
  new I(e, t, A.isEmpty, !0).to.be.empty;
};
A.isNotEmpty = function(e, t) {
  new I(e, t, A.isNotEmpty, !0).to.not.be.empty;
};
A.containsSubset = function(e, t, r) {
  new I(e, r).to.containSubset(t);
};
A.doesNotContainSubset = function(e, t, r) {
  new I(e, r).to.not.containSubset(t);
};
var eF = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (const [e, t] of eF)
  A[t] = A[e];
var ng = [];
function hn(e) {
  const t = {
    use: hn,
    AssertionError: Te,
    util: er,
    config: ut,
    expect: Hr,
    assert: A,
    Assertion: I,
    ...xx
  };
  return ~ng.indexOf(e) || (e(t, er), ng.push(e)), t;
}
o(hn, "use");
U(hn, "use");
var Tx = {};
Ua(Tx, {
  toBeChecked: () => Pm,
  toBeDisabled: () => bm,
  toBeEmpty: () => nm,
  toBeEmptyDOMElement: () => om,
  toBeEnabled: () => vm,
  toBeInTheDOM: () => ps,
  toBeInTheDocument: () => rm,
  toBeInvalid: () => Em,
  toBePartiallyChecked: () => Cm,
  toBePartiallyPressed: () => jm,
  toBePressed: () => Im,
  toBeRequired: () => wm,
  toBeValid: () => xm,
  toBeVisible: () => fm,
  toContainElement: () => fs,
  toContainHTML: () => am,
  toHaveAccessibleDescription: () => ms,
  toHaveAccessibleErrorMessage: () => sm,
  toHaveAccessibleName: () => ys,
  toHaveAttribute: () => lm,
  toHaveClass: () => um,
  toHaveDescription: () => Am,
  toHaveDisplayValue: () => Sm,
  toHaveErrorMessage: () => Rm,
  toHaveFocus: () => cm,
  toHaveFormValues: () => dm,
  toHaveRole: () => hs,
  toHaveSelection: () => km,
  toHaveStyle: () => gs,
  toHaveTextContent: () => im,
  toHaveValue: () => Tm
});
var og = Ye(gx(), 1), Sx = class extends Error {
  reason;
  filename;
  line;
  column;
  source;
  constructor(e, t, r, n, a) {
    super(`${e}:${r}:${n}: ${t}`), this.reason = t, this.filename = e, this.line = r, this.column = n, this.source = a;
  }
};
o(Sx, "t");
var tF = Sx, Px = class {
  start;
  end;
  source;
  constructor(e, t, r) {
    this.start = e, this.end = t, this.source = r;
  }
};
o(Px, "e");
var rF = Px, Je;
(function(e) {
  e.stylesheet = "stylesheet", e.rule = "rule", e.declaration = "declaration", e.comment = "comment", e.container = "container", e.charset = "charset", e.document = "document", e.customMedia = "custom-media", e.fontFace = "font-face", e.host = "host", e.import = "import", e.keyframes = "keyframes", e.keyframe = "keyframe", e.layer = "layer", e.media = "media", e.namespace = "namespace", e.page = "page", e.startingStyle = "starting-style", e.supports = "supports";
})(Je || (Je = {}));
var ag = /* @__PURE__ */ o((e, t, r) => {
  let n = r, a = 1e4;
  do {
    const i = t.map((c) => e.indexOf(c, n));
    i.push(e.indexOf("\\", n));
    const s = i.filter((c) => c !== -1);
    if (s.length === 0) return -1;
    const l = Math.min(...s);
    if (e[l] !== "\\") return l;
    n = l + 2, a--;
  } while (a > 0);
  throw new Error("Too many escaping");
}, "s"), Ac = /* @__PURE__ */ o((e, t, r) => {
  let n = r, a = 1e4;
  do {
    const i = t.map((c) => e.indexOf(c, n));
    i.push(e.indexOf("(", n)), i.push(e.indexOf('"', n)), i.push(e.indexOf("'", n)), i.push(e.indexOf("\\", n));
    const s = i.filter((c) => c !== -1);
    if (s.length === 0) return -1;
    const l = Math.min(...s);
    switch (e[l]) {
      case "\\":
        n = l + 2;
        break;
      case "(":
        {
          const c = Ac(e, [")"], l + 1);
          if (c === -1) return -1;
          n = c + 1;
        }
        break;
      case '"':
        {
          const c = ag(e, ['"'], l + 1);
          if (c === -1) return -1;
          n = c + 1;
        }
        break;
      case "'":
        {
          const c = ag(e, ["'"], l + 1);
          if (c === -1) return -1;
          n = c + 1;
        }
        break;
      default:
        return l;
    }
    a--;
  } while (a > 0);
  throw new Error("Too many escaping");
}, "n"), Bu = /\/\*[^]*?(?:\*\/|$)/g;
function yt(e) {
  return e ? e.trim() : "";
}
o(yt, "o");
function ds(e, t) {
  const r = e && typeof e.type == "string", n = r ? e : t;
  for (const a in e) {
    const i = e[a];
    Array.isArray(i) ? i.forEach((s) => {
      ds(s, n);
    }) : i && typeof i == "object" && ds(i, n);
  }
  return r && Object.defineProperty(e, "parent", { configurable: !0, writable: !0, enumerable: !1, value: t || null }), e;
}
o(ds, "c");
var nF = /* @__PURE__ */ o((e, t) => {
  t = t || {};
  let r = 1, n = 1;
  function a() {
    const w = { line: r, column: n };
    return (T) => (T.position = new rF(w, { line: r, column: n }, t?.source || ""), f(), T);
  }
  o(a, "u");
  const i = [];
  function s(w) {
    const T = new tF(t?.source || "", w, r, n, e);
    if (!t?.silent) throw T;
    i.push(T);
  }
  o(s, "l");
  function l() {
    const w = /^{\s*/.exec(e);
    return !!w && (p(w), !0);
  }
  o(l, "f");
  function c() {
    const w = /^}/.exec(e);
    return !!w && (p(w), !0);
  }
  o(c, "d");
  function u() {
    let w;
    const T = [];
    for (f(), m(T); e.length && e.charAt(0) !== "}" && (w = O() || S(), w); ) T.push(w), m(T);
    return T;
  }
  o(u, "y");
  function p(w) {
    const T = w[0];
    return (function(M) {
      const R = M.match(/\n/g);
      R && (r += R.length);
      const D = M.lastIndexOf(`
`);
      n = ~D ? M.length - D : n + M.length;
    })(T), e = e.slice(T.length), w;
  }
  o(p, "g");
  function f() {
    const w = /^\s*/.exec(e);
    w && p(w);
  }
  o(f, "$");
  function m(w) {
    w = w || [];
    let T = y();
    for (; T; ) w.push(T), T = y();
    return w;
  }
  o(m, "x");
  function y() {
    const w = a();
    if (e.charAt(0) !== "/" || e.charAt(1) !== "*") return;
    const T = /^\/\*[^]*?\*\//.exec(e);
    return T ? (p(T), w({ type: Je.comment, comment: T[0].slice(2, -2) })) : s("End of comment missing");
  }
  o(y, "V");
  function g() {
    const w = /^([^{]+)/.exec(e);
    if (w)
      return p(w), ((T, M) => {
        const R = [];
        let D = 0;
        for (; D < T.length; ) {
          const J = Ac(T, M, D);
          if (J === -1) return R.push(T.substring(D)), R;
          R.push(T.substring(D, J)), D = J + 1;
        }
        return R;
      })(yt(w[0]).replace(Bu, ""), [","]).map((T) => yt(T));
  }
  o(g, "k");
  function v() {
    const w = a(), T = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
    if (!T) return;
    p(T);
    const M = yt(T[0]), R = /^:\s*/.exec(e);
    if (!R) return s("property missing ':'");
    p(R);
    let D = "";
    const J = Ac(e, [";", "}"]);
    J !== -1 && (D = e.substring(0, J), p([D]), D = yt(D).replace(Bu, ""));
    const P = w({ type: Je.declaration, property: M.replace(Bu, ""), value: D }), q = /^[;\s]*/.exec(e);
    return q && p(q), P;
  }
  o(v, "v");
  function _() {
    const w = [];
    if (!l()) return s("missing '{'");
    m(w);
    let T = v();
    for (; T; ) w.push(T), m(w), T = v();
    return c() ? w : s("missing '}'");
  }
  o(_, "w");
  function b() {
    const w = [], T = a();
    let M = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
    for (; M; ) {
      const R = p(M);
      w.push(R[1]);
      const D = /^,\s*/.exec(e);
      D && p(D), M = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
    }
    if (w.length) return T({ type: Je.keyframe, values: w, declarations: _() || [] });
  }
  o(b, "b");
  const E = N("import"), C = N("charset"), k = N("namespace");
  function N(w) {
    const T = new RegExp("^@" + w + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`);
    return () => {
      const M = a(), R = T.exec(e);
      if (!R) return;
      const D = p(R), J = { type: w };
      return J[w] = D[1].trim(), M(J);
    };
  }
  o(N, "M");
  function O() {
    if (e[0] === "@") return (function() {
      const w = a(), T = /^@([-\w]+)?keyframes\s*/.exec(e);
      if (!T) return;
      const M = p(T)[1], R = /^([-\w]+)\s*/.exec(e);
      if (!R) return s("@keyframes missing name");
      const D = p(R)[1];
      if (!l()) return s("@keyframes missing '{'");
      let J = m(), P = b();
      for (; P; ) J.push(P), J = J.concat(m()), P = b();
      return c() ? w({ type: Je.keyframes, name: D, vendor: M, keyframes: J }) : s("@keyframes missing '}'");
    })() || (function() {
      const w = a(), T = /^@media *([^{]+)/.exec(e);
      if (!T) return;
      const M = yt(p(T)[1]);
      if (!l()) return s("@media missing '{'");
      const R = m().concat(u());
      return c() ? w({ type: Je.media, media: M, rules: R }) : s("@media missing '}'");
    })() || (function() {
      const w = a(), T = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
      if (!T) return;
      const M = p(T);
      return w({ type: Je.customMedia, name: yt(M[1]), media: yt(M[2]) });
    })() || (function() {
      const w = a(), T = /^@supports *([^{]+)/.exec(e);
      if (!T) return;
      const M = yt(p(T)[1]);
      if (!l()) return s("@supports missing '{'");
      const R = m().concat(u());
      return c() ? w({ type: Je.supports, supports: M, rules: R }) : s("@supports missing '}'");
    })() || E() || C() || k() || (function() {
      const w = a(), T = /^@([-\w]+)?document *([^{]+)/.exec(e);
      if (!T) return;
      const M = p(T), R = yt(M[1]), D = yt(M[2]);
      if (!l()) return s("@document missing '{'");
      const J = m().concat(u());
      return c() ? w({ type: Je.document, document: D, vendor: R, rules: J }) : s("@document missing '}'");
    })() || (function() {
      const w = a(), T = /^@page */.exec(e);
      if (!T) return;
      p(T);
      const M = g() || [];
      if (!l()) return s("@page missing '{'");
      let R = m(), D = v();
      for (; D; ) R.push(D), R = R.concat(m()), D = v();
      return c() ? w({ type: Je.page, selectors: M, declarations: R }) : s("@page missing '}'");
    })() || (function() {
      const w = a(), T = /^@host\s*/.exec(e);
      if (!T) return;
      if (p(T), !l()) return s("@host missing '{'");
      const M = m().concat(u());
      return c() ? w({ type: Je.host, rules: M }) : s("@host missing '}'");
    })() || (function() {
      const w = a(), T = /^@font-face\s*/.exec(e);
      if (!T) return;
      if (p(T), !l()) return s("@font-face missing '{'");
      let M = m(), R = v();
      for (; R; ) M.push(R), M = M.concat(m()), R = v();
      return c() ? w({ type: Je.fontFace, declarations: M }) : s("@font-face missing '}'");
    })() || (function() {
      const w = a(), T = /^@container *([^{]+)/.exec(e);
      if (!T) return;
      const M = yt(p(T)[1]);
      if (!l()) return s("@container missing '{'");
      const R = m().concat(u());
      return c() ? w({ type: Je.container, container: M, rules: R }) : s("@container missing '}'");
    })() || (function() {
      const w = a(), T = /^@starting-style\s*/.exec(e);
      if (!T) return;
      if (p(T), !l()) return s("@starting-style missing '{'");
      const M = m().concat(u());
      return c() ? w({ type: Je.startingStyle, rules: M }) : s("@starting-style missing '}'");
    })() || (function() {
      const w = a(), T = /^@layer *([^{;@]+)/.exec(e);
      if (!T) return;
      const M = yt(p(T)[1]);
      if (!l()) {
        const D = /^[;\s]*/.exec(e);
        return D && p(D), w({ type: Je.layer, layer: M });
      }
      const R = m().concat(u());
      return c() ? w({ type: Je.layer, layer: M, rules: R }) : s("@layer missing '}'");
    })();
  }
  o(O, "A");
  function S() {
    const w = a(), T = g();
    return T ? (m(), w({ type: Je.rule, selectors: T, declarations: _() || [] })) : s("selector missing");
  }
  return o(S, "S"), ds((function() {
    const w = u();
    return { type: Je.stylesheet, stylesheet: { source: t?.source, rules: w, parsingErrors: i } };
  })());
}, "m"), oF = Object.prototype.toString;
function Rc(e) {
  return typeof e == "function" || oF.call(e) === "[object Function]";
}
o(Rc, "isCallable");
function Ox(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
o(Ox, "toInteger");
var aF = Math.pow(2, 53) - 1;
function Cx(e) {
  var t = Ox(e);
  return Math.min(Math.max(t, 0), aF);
}
o(Cx, "toLength");
function It(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !Rc(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var a = Cx(n.length), i = Rc(r) ? Object(new r(a)) : new Array(a), s = 0, l; s < a; )
    l = n[s], t ? i[s] = t(l, s) : i[s] = l, s += 1;
  return i.length = a, i;
}
o(It, "arrayFrom");
function co(e) {
  "@babel/helpers - typeof";
  return co = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, co(e);
}
o(co, "_typeof");
function Ax(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
o(Ax, "_classCallCheck");
function kc(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, zf(n.key), n);
  }
}
o(kc, "_defineProperties");
function Rx(e, t, r) {
  return t && kc(e.prototype, t), r && kc(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
o(Rx, "_createClass");
function kx(e, t, r) {
  return t = zf(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
o(kx, "_defineProperty");
function zf(e) {
  var t = Ix(e, "string");
  return co(t) === "symbol" ? t : String(t);
}
o(zf, "_toPropertyKey");
function Ix(e, t) {
  if (co(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (co(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(Ix, "_toPrimitive");
var iF = (function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    Ax(this, e), kx(this, "items", void 0), this.items = t;
  }
  return o(e, "SetLike"), Rx(e, [{
    key: "add",
    value: /* @__PURE__ */ o(function(t) {
      return this.has(t) === !1 && this.items.push(t), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ o(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ o(function(t) {
      var r = this.items.length;
      return this.items = this.items.filter(function(n) {
        return n !== t;
      }), r !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ o(function(t) {
      var r = this;
      this.items.forEach(function(n) {
        t(n, n, r);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ o(function(t) {
      return this.items.indexOf(t) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ o(function() {
      return this.items.length;
    }, "get")
  }]), e;
})(), sF = typeof Set > "u" ? Set : iF;
function Ze(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
o(Ze, "getLocalName");
var lF = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, uF = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  none: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function jx(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-description",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = uF[t]) !== null && n !== void 0 && n.has(r));
  });
}
o(jx, "hasGlobalAriaAttributes");
function Wf(e, t) {
  return jx(e, t);
}
o(Wf, "ignorePresentationalRole");
function Nx(e) {
  var t = Mx(e);
  if (t === null || Ic.indexOf(t) !== -1) {
    var r = qx(e);
    if (Ic.indexOf(t || "") === -1 || Wf(e, r || ""))
      return r;
  }
  return t;
}
o(Nx, "getRole");
function qx(e) {
  var t = lF[Ze(e)];
  if (t !== void 0)
    return t;
  switch (Ze(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !Wf(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
o(qx, "getImplicitRole");
function Mx(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
o(Mx, "getExplicitRole");
var Ic = ["presentation", "none"];
function je(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
o(je, "isElement");
function Gf(e) {
  return je(e) && Ze(e) === "caption";
}
o(Gf, "isHTMLTableCaptionElement");
function ia(e) {
  return je(e) && Ze(e) === "input";
}
o(ia, "isHTMLInputElement");
function $x(e) {
  return je(e) && Ze(e) === "optgroup";
}
o($x, "isHTMLOptGroupElement");
function Lx(e) {
  return je(e) && Ze(e) === "select";
}
o(Lx, "isHTMLSelectElement");
function Dx(e) {
  return je(e) && Ze(e) === "table";
}
o(Dx, "isHTMLTableElement");
function Fx(e) {
  return je(e) && Ze(e) === "textarea";
}
o(Fx, "isHTMLTextAreaElement");
function Bx(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
o(Bx, "safeWindow");
function Ux(e) {
  return je(e) && Ze(e) === "fieldset";
}
o(Ux, "isHTMLFieldSetElement");
function Hx(e) {
  return je(e) && Ze(e) === "legend";
}
o(Hx, "isHTMLLegendElement");
function Vx(e) {
  return je(e) && Ze(e) === "slot";
}
o(Vx, "isHTMLSlotElement");
function Jx(e) {
  return je(e) && e.ownerSVGElement !== void 0;
}
o(Jx, "isSVGElement");
function zx(e) {
  return je(e) && Ze(e) === "svg";
}
o(zx, "isSVGSVGElement");
function Wx(e) {
  return Jx(e) && Ze(e) === "title";
}
o(Wx, "isSVGTitleElement");
function Oa(e, t) {
  if (je(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(a) {
      return n.getElementById(a);
    }).filter(
      function(a) {
        return a !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
o(Oa, "queryIdRefs");
function tr(e, t) {
  return je(e) ? t.indexOf(Nx(e)) !== -1 : !1;
}
o(tr, "hasAnyConcreteRoles");
function Gx(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
o(Gx, "asFlatString");
function Kx(e, t) {
  if (!je(e))
    return !1;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return !0;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
o(Kx, "isHidden");
function Yx(e) {
  return tr(e, ["button", "combobox", "listbox", "textbox"]) || Kf(e, "range");
}
o(Yx, "isControl");
function Kf(e, t) {
  if (!je(e))
    return !1;
  switch (t) {
    case "range":
      return tr(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
o(Kf, "hasAbstractRole");
function jc(e, t) {
  var r = It(e.querySelectorAll(t));
  return Oa(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, It(n.querySelectorAll(t)));
  }), r;
}
o(jc, "querySelectorAllSubtree");
function Xx(e) {
  return Lx(e) ? e.selectedOptions || jc(e, "[selected]") : jc(e, '[aria-selected="true"]');
}
o(Xx, "querySelectedOptions");
function Qx(e) {
  return tr(e, Ic);
}
o(Qx, "isMarkedPresentational");
function Zx(e) {
  return Gf(e);
}
o(Zx, "isNativeHostLanguageTextAlternativeElement");
function e0(e) {
  return tr(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
o(e0, "allowsNameFromContent");
function t0(e) {
  return !1;
}
o(t0, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function r0(e) {
  return ia(e) || Fx(e) ? e.value : e.textContent || "";
}
o(r0, "getValueOfTextbox");
function Nc(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
o(Nc, "getTextualContent");
function Yf(e) {
  var t = Ze(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
o(Yf, "isLabelableElement");
function Xf(e) {
  if (Yf(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && je(r)) {
      var n = Xf(r);
      n !== null && (t = n);
    }
  }), t;
}
o(Xf, "findLabelableElement");
function n0(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : Xf(e);
}
o(n0, "getControlOfLabel");
function o0(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return It(t);
  if (!Yf(e))
    return null;
  var r = e.ownerDocument;
  return It(r.querySelectorAll("label")).filter(function(n) {
    return n0(n) === e;
  });
}
o(o0, "getLabels");
function a0(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? It(e.childNodes) : t;
}
o(a0, "getSlotContents");
function Qf(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new sF(), n = Bx(e), a = t.compute, i = a === void 0 ? "name" : a, s = t.computedStyleSupportsPseudoElements, l = s === void 0 ? t.getComputedStyle !== void 0 : s, c = t.getComputedStyle, u = c === void 0 ? n.getComputedStyle.bind(n) : c, p = t.hidden, f = p === void 0 ? !1 : p;
  function m(b, E) {
    var C = "";
    if (je(b) && l) {
      var k = u(b, "::before"), N = Nc(k);
      C = "".concat(N, " ").concat(C);
    }
    var O = Vx(b) ? a0(b) : It(b.childNodes).concat(Oa(b, "aria-owns"));
    if (O.forEach(function(T) {
      var M = _(T, {
        isEmbeddedInLabel: E.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), R = je(T) ? u(T).getPropertyValue("display") : "inline", D = R !== "inline" ? " " : "";
      C += "".concat(D).concat(M).concat(D);
    }), je(b) && l) {
      var S = u(b, "::after"), w = Nc(S);
      C = "".concat(C, " ").concat(w);
    }
    return C.trim();
  }
  o(m, "computeMiscTextAlternative");
  function y(b, E) {
    var C = b.getAttributeNode(E);
    return C !== null && !r.has(C) && C.value.trim() !== "" ? (r.add(C), C.value) : null;
  }
  o(y, "useAttribute");
  function g(b) {
    return je(b) ? y(b, "title") : null;
  }
  o(g, "computeTooltipAttributeValue");
  function v(b) {
    if (!je(b))
      return null;
    if (Ux(b)) {
      r.add(b);
      for (var E = It(b.childNodes), C = 0; C < E.length; C += 1) {
        var k = E[C];
        if (Hx(k))
          return _(k, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (Dx(b)) {
      r.add(b);
      for (var N = It(b.childNodes), O = 0; O < N.length; O += 1) {
        var S = N[O];
        if (Gf(S))
          return _(S, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (zx(b)) {
      r.add(b);
      for (var w = It(b.childNodes), T = 0; T < w.length; T += 1) {
        var M = w[T];
        if (Wx(M))
          return M.textContent;
      }
      return null;
    } else if (Ze(b) === "img" || Ze(b) === "area") {
      var R = y(b, "alt");
      if (R !== null)
        return R;
    } else if ($x(b)) {
      var D = y(b, "label");
      if (D !== null)
        return D;
    }
    if (ia(b) && (b.type === "button" || b.type === "submit" || b.type === "reset")) {
      var J = y(b, "value");
      if (J !== null)
        return J;
      if (b.type === "submit")
        return "Submit";
      if (b.type === "reset")
        return "Reset";
    }
    var P = o0(b);
    if (P !== null && P.length !== 0)
      return r.add(b), It(P).map(function(z) {
        return _(z, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(z) {
        return z.length > 0;
      }).join(" ");
    if (ia(b) && b.type === "image") {
      var q = y(b, "alt");
      if (q !== null)
        return q;
      var $ = y(b, "title");
      return $ !== null ? $ : "Submit Query";
    }
    if (tr(b, ["button"])) {
      var H = m(b, {
        isEmbeddedInLabel: !1
      });
      if (H !== "")
        return H;
    }
    return null;
  }
  o(v, "computeElementTextAlternative");
  function _(b, E) {
    if (r.has(b))
      return "";
    if (!f && Kx(b, u) && !E.isReferenced)
      return r.add(b), "";
    var C = je(b) ? b.getAttributeNode("aria-labelledby") : null, k = C !== null && !r.has(C) ? Oa(b, "aria-labelledby") : [];
    if (i === "name" && !E.isReferenced && k.length > 0)
      return r.add(C), k.map(function(R) {
        return _(R, {
          isEmbeddedInLabel: E.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var N = E.recursion && Yx(b) && i === "name";
    if (!N) {
      var O = (je(b) && b.getAttribute("aria-label") || "").trim();
      if (O !== "" && i === "name")
        return r.add(b), O;
      if (!Qx(b)) {
        var S = v(b);
        if (S !== null)
          return r.add(b), S;
      }
    }
    if (tr(b, ["menu"]))
      return r.add(b), "";
    if (N || E.isEmbeddedInLabel || E.isReferenced) {
      if (tr(b, ["combobox", "listbox"])) {
        r.add(b);
        var w = Xx(b);
        return w.length === 0 ? ia(b) ? b.value : "" : It(w).map(function(R) {
          return _(R, {
            isEmbeddedInLabel: E.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (Kf(b, "range"))
        return r.add(b), b.hasAttribute("aria-valuetext") ? b.getAttribute("aria-valuetext") : b.hasAttribute("aria-valuenow") ? b.getAttribute("aria-valuenow") : b.getAttribute("value") || "";
      if (tr(b, ["textbox"]))
        return r.add(b), r0(b);
    }
    if (e0(b) || je(b) && E.isReferenced || Zx(b) || t0()) {
      var T = m(b, {
        isEmbeddedInLabel: E.isEmbeddedInLabel
      });
      if (T !== "")
        return r.add(b), T;
    }
    if (b.nodeType === b.TEXT_NODE)
      return r.add(b), b.textContent || "";
    if (E.recursion)
      return r.add(b), m(b, {
        isEmbeddedInLabel: E.isEmbeddedInLabel
      });
    var M = g(b);
    return M !== null ? (r.add(b), M) : (r.add(b), "");
  }
  return o(_, "computeTextAlternative"), Gx(_(e, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: i === "description",
    recursion: !1
  }));
}
o(Qf, "computeTextAlternative");
function po(e) {
  "@babel/helpers - typeof";
  return po = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, po(e);
}
o(po, "_typeof");
function qc(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
o(qc, "ownKeys");
function Mc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qc(Object(r), !0).forEach(function(n) {
      i0(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : qc(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
o(Mc, "_objectSpread");
function i0(e, t, r) {
  return t = s0(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
o(i0, "_defineProperty");
function s0(e) {
  var t = l0(e, "string");
  return po(t) === "symbol" ? t : String(t);
}
o(s0, "_toPropertyKey");
function l0(e, t) {
  if (po(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (po(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(l0, "_toPrimitive");
function u0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = Oa(e, "aria-describedby").map(function(i) {
    return Qf(i, Mc(Mc({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("aria-description");
    r = n === null ? "" : n;
  }
  if (r === "") {
    var a = e.getAttribute("title");
    r = a === null ? "" : a;
  }
  return r;
}
o(u0, "computeAccessibleDescription");
function c0(e) {
  return tr(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "none", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
o(c0, "prohibitsNaming");
function d0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return c0(e) ? "" : Qf(e, t);
}
o(d0, "computeAccessibleName");
var Zf = Ye(of(), 1), cF = Ye(P_(), 1), dF = Ye(bx(), 1), p0 = class extends Error {
  constructor(e, t, r, n) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, r);
    let a = "";
    try {
      a = n.utils.printWithType(
        "Received",
        t,
        n.utils.printReceived
      );
    } catch {
    }
    this.message = [
      n.utils.matcherHint(
        `${n.isNot ? ".not" : ""}.${r.name}`,
        "received",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      `${n.utils.RECEIVED_COLOR(
        "received"
      )} value must ${e}.`,
      a
    ].join(`
`);
  }
};
o(p0, "GenericTypeError");
var f0 = p0, m0 = class extends f0 {
  constructor(...e) {
    super("be an HTMLElement or an SVGElement", ...e);
  }
};
o(m0, "HtmlElementTypeError");
var ig = m0, h0 = class extends f0 {
  constructor(...e) {
    super("be a Node", ...e);
  }
};
o(h0, "NodeTypeError");
var sg = h0;
function em(e, t, ...r) {
  if (!e || !e.ownerDocument || !e.ownerDocument.defaultView)
    throw new t(e, ...r);
}
o(em, "checkHasWindow");
function y0(e, ...t) {
  em(e, sg, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.Node))
    throw new sg(e, ...t);
}
o(y0, "checkNode");
function Ee(e, ...t) {
  em(e, ig, ...t);
  const r = e.ownerDocument.defaultView;
  if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement))
    throw new ig(e, ...t);
}
o(Ee, "checkHtmlElement");
var g0 = class extends Error {
  constructor(e, t, r) {
    super(), Error.captureStackTrace && Error.captureStackTrace(this, t), this.message = [
      e.message,
      "",
      // eslint-disable-next-line new-cap
      r.utils.RECEIVED_COLOR("Failing css:"),
      // eslint-disable-next-line new-cap
      r.utils.RECEIVED_COLOR(`${e.css}`)
    ].join(`
`);
  }
};
o(g0, "InvalidCSSError");
var pF = g0;
function b0(e, ...t) {
  const r = nF(`selector { ${e} }`, { silent: !0 }).stylesheet;
  if (r.parsingErrors && r.parsingErrors.length > 0) {
    const { reason: n, line: a } = r.parsingErrors[0];
    throw new pF(
      {
        css: e,
        message: `Syntax error parsing expected css: ${n} on line: ${a}`
      },
      ...t
    );
  }
  return r.rules[0].declarations.filter((n) => n.type === "declaration").reduce(
    (n, { property: a, value: i }) => Object.assign(n, { [a]: i }),
    {}
  );
}
o(b0, "parseCSS");
function $c(e, t) {
  return typeof t == "string" ? t : e.utils.stringify(t);
}
o($c, "display");
function He(e, t, r, n, a, i) {
  return [
    `${t}
`,
    // eslint-disable-next-line new-cap
    `${r}:
${e.utils.EXPECTED_COLOR(
      (0, og.default)($c(e, n), 2)
    )}`,
    // eslint-disable-next-line new-cap
    `${a}:
${e.utils.RECEIVED_COLOR(
      (0, og.default)($c(e, i), 2)
    )}`
  ].join(`
`);
}
o(He, "getMessage");
function v0(e, t) {
  return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
o(v0, "matches");
function ri(e, t) {
  console.warn(
    `Warning: ${e} has been deprecated and will be removed in future updates.`,
    t
  );
}
o(ri, "deprecate");
function ni(e) {
  return e.replace(/\s+/g, " ").trim();
}
o(ni, "normalize");
function Or(e) {
  return e.tagName && e.tagName.toLowerCase();
}
o(Or, "getTag");
function w0({ multiple: e, options: t }) {
  const r = [...t].filter((n) => n.selected);
  if (e)
    return [...r].map((n) => n.value);
  if (r.length !== 0)
    return r[0].value;
}
o(w0, "getSelectValue");
function _0(e) {
  switch (e.type) {
    case "number":
      return e.value === "" ? null : Number(e.value);
    case "checkbox":
      return e.checked;
    default:
      return e.value;
  }
}
o(_0, "getInputValue");
var fF = ["meter", "progressbar", "slider", "spinbutton"];
function E0(e) {
  if (fF.includes(e.getAttribute("role")))
    return Number(e.getAttribute("aria-valuenow"));
}
o(E0, "getAccessibleValue");
function tm(e) {
  if (e)
    switch (e.tagName.toLowerCase()) {
      case "input":
        return _0(e);
      case "select":
        return w0(e);
      default:
        return e.value ?? E0(e);
    }
}
o(tm, "getSingleElementValue");
function x0(e, { wordConnector: t = ", ", lastWordConnector: r = " and " } = {}) {
  return [e.slice(0, -1).join(t), e[e.length - 1]].join(
    e.length > 1 ? r : ""
  );
}
o(x0, "toSentence");
function $l(e, t) {
  return Array.isArray(e) && Array.isArray(t) ? [...new Set(e)].every((r) => new Set(t).has(r)) : e === t;
}
o($l, "compareAsSet");
function ps(e, t) {
  return ri(
    "toBeInTheDOM",
    "Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container."
  ), e && Ee(e, ps, this), t && Ee(t, ps, this), {
    pass: t ? t.contains(e) : !!e,
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDOM`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(
        e && e.cloneNode(!1)
      )}`
    ].join(`
`), "message")
  };
}
o(ps, "toBeInTheDOM");
function rm(e) {
  (e !== null || !this.isNot) && Ee(e, rm, this);
  const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }), r = /* @__PURE__ */ o(() => `expected document not to contain element, found ${this.utils.stringify(
    e.cloneNode(!0)
  )} instead`, "errorFound"), n = /* @__PURE__ */ o(() => "element could not be found in the document", "errorNotFound");
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeInTheDocument`,
        "element",
        ""
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(this.isNot ? r() : n())
    ].join(`
`), "message")
  };
}
o(rm, "toBeInTheDocument");
function nm(e) {
  return ri(
    "toBeEmpty",
    "Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM."
  ), Ee(e, nm, this), {
    pass: e.innerHTML === "",
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmpty`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
o(nm, "toBeEmpty");
function om(e) {
  return Ee(e, om, this), {
    pass: T0(e),
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBeEmptyDOMElement`,
        "element",
        ""
      ),
      "",
      "Received:",
      `  ${this.utils.printReceived(e.innerHTML)}`
    ].join(`
`), "message")
  };
}
o(om, "toBeEmptyDOMElement");
function T0(e) {
  return [...e.childNodes].filter((t) => t.nodeType !== 8).length === 0;
}
o(T0, "isEmptyElement");
function fs(e, t) {
  return Ee(e, fs, this), t !== null && Ee(t, fs, this), {
    pass: e.contains(t),
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainElement`,
        "element",
        "element"
      ),
      "",
      // eslint-disable-next-line new-cap
      this.utils.RECEIVED_COLOR(`${this.utils.stringify(
        e.cloneNode(!1)
      )} ${this.isNot ? "contains:" : "does not contain:"} ${this.utils.stringify(t && t.cloneNode(!1))}
        `)
    ].join(`
`), "message")
  };
}
o(fs, "toContainElement");
function S0(e, t) {
  const r = e.ownerDocument.createElement("div");
  return r.innerHTML = t, r.innerHTML;
}
o(S0, "getNormalizedHtml");
function am(e, t) {
  if (Ee(e, am, this), typeof t != "string")
    throw new Error(`.toContainHTML() expects a string value, got ${t}`);
  return {
    pass: e.outerHTML.includes(S0(e, t)),
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toContainHTML`,
        "element",
        ""
      ),
      "Expected:",
      // eslint-disable-next-line new-cap
      `  ${this.utils.EXPECTED_COLOR(t)}`,
      "Received:",
      `  ${this.utils.printReceived(e.cloneNode(!0))}`
    ].join(`
`), "message")
  };
}
o(am, "toContainHTML");
function im(e, t, r = { normalizeWhitespace: !0 }) {
  y0(e, im, this);
  const n = r.normalizeWhitespace ? ni(e.textContent) : e.textContent.replace(/\u00a0/g, " "), a = n !== "" && t === "";
  return {
    pass: !a && v0(n, t),
    message: /* @__PURE__ */ o(() => {
      const i = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveTextContent`,
          "element",
          ""
        ),
        a ? "Checking with empty string will always match, use .toBeEmptyDOMElement() instead" : `Expected element ${i} have text content`,
        t,
        "Received",
        n
      );
    }, "message")
  };
}
o(im, "toHaveTextContent");
function ms(e, t) {
  Ee(e, ms, this);
  const r = u0(e), n = arguments.length === 1;
  let a = !1;
  return n ? a = r !== "" : a = t instanceof RegExp ? t.test(r) : this.equals(
    r,
    t
  ), {
    pass: a,
    message: /* @__PURE__ */ o(() => {
      const i = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${ms.name}`,
          "element",
          ""
        ),
        `Expected element ${i} have accessible description`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
o(ms, "toHaveAccessibleDescription");
var Jo = "aria-invalid", mF = ["false"];
function sm(e, t) {
  Ee(e, sm, this);
  const r = this.isNot ? "not to" : "to", n = this.isNot ? ".not.toHaveAccessibleErrorMessage" : ".toHaveAccessibleErrorMessage", a = e.getAttribute("aria-errormessage");
  if (a && /\s+/.test(a))
    return {
      pass: !1,
      message: /* @__PURE__ */ o(() => He(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
        "",
        "Received",
        `aria-errormessage="${a}"`
      ), "message")
    };
  const i = e.getAttribute(Jo);
  if (!e.hasAttribute(Jo) || mF.includes(i))
    return {
      pass: !1,
      message: /* @__PURE__ */ o(() => He(
        this,
        this.utils.matcherHint(n, "element"),
        "Expected element to be marked as invalid with attribute",
        `${Jo}="${String(!0)}"`,
        "Received",
        e.hasAttribute("aria-invalid") ? `${Jo}="${e.getAttribute(Jo)}` : null
      ), "message")
    };
  const s = ni(
    e.ownerDocument.getElementById(a)?.textContent ?? ""
  );
  return {
    pass: t === void 0 ? !!s : t instanceof RegExp ? t.test(s) : this.equals(s, t),
    message: /* @__PURE__ */ o(() => He(
      this,
      this.utils.matcherHint(n, "element"),
      `Expected element ${r} have accessible error message`,
      t ?? "",
      "Received",
      s
    ), "message")
  };
}
o(sm, "toHaveAccessibleErrorMessage");
var hF = C0(Zf.elementRoles);
function hs(e, t) {
  Ee(e, hs, this);
  const r = P0(e);
  return {
    pass: r.some((n) => n === t),
    message: /* @__PURE__ */ o(() => {
      const n = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${hs.name}`,
          "element",
          ""
        ),
        `Expected element ${n} have role`,
        t,
        "Received",
        r.join(", ")
      );
    }, "message")
  };
}
o(hs, "toHaveRole");
function P0(e) {
  return e.hasAttribute("role") ? e.getAttribute("role").split(" ").filter(Boolean) : O0(e);
}
o(P0, "getExplicitOrImplicitRoles");
function O0(e) {
  for (const { match: t, roles: r } of hF)
    if (t(e))
      return [...r];
  return [];
}
o(O0, "getImplicitAriaRoles");
function C0(e) {
  function t({ name: s, attributes: l }) {
    return `${s}${l.map(({ name: c, value: u, constraints: p = [] }) => p.indexOf("undefined") !== -1 ? `:not([${c}])` : u ? `[${c}="${u}"]` : `[${c}]`).join("")}`;
  }
  o(t, "makeElementSelector");
  function r({ attributes: s = [] }) {
    return s.length;
  }
  o(r, "getSelectorSpecificity");
  function n({ specificity: s }, { specificity: l }) {
    return l - s;
  }
  o(n, "bySelectorSpecificity");
  function a(s) {
    let { attributes: l = [] } = s;
    const c = l.findIndex(
      (p) => p.value && p.name === "type" && p.value === "text"
    );
    c >= 0 && (l = [
      ...l.slice(0, c),
      ...l.slice(c + 1)
    ]);
    const u = t({ ...s, attributes: l });
    return (p) => c >= 0 && p.type !== "text" ? !1 : p.matches(u);
  }
  o(a, "match");
  let i = [];
  for (const [s, l] of e.entries())
    i = [
      ...i,
      {
        match: a(s),
        roles: Array.from(l),
        specificity: r(s)
      }
    ];
  return i.sort(n);
}
o(C0, "buildElementRoleList");
function ys(e, t) {
  Ee(e, ys, this);
  const r = d0(e), n = arguments.length === 1;
  let a = !1;
  return n ? a = r !== "" : a = t instanceof RegExp ? t.test(r) : this.equals(r, t), {
    pass: a,
    message: /* @__PURE__ */ o(() => {
      const i = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.${ys.name}`,
          "element",
          ""
        ),
        `Expected element ${i} have accessible name`,
        t,
        "Received",
        r
      );
    }, "message")
  };
}
o(ys, "toHaveAccessibleName");
function Lc(e, t, r) {
  return r === void 0 ? t : `${t}=${e(r)}`;
}
o(Lc, "printAttribute");
function A0(e, t, r) {
  return r === void 0 ? `element.hasAttribute(${e(t)})` : `element.getAttribute(${e(t)}) === ${e(r)}`;
}
o(A0, "getAttributeComment");
function lm(e, t, r) {
  Ee(e, lm, this);
  const n = r !== void 0, a = e.hasAttribute(t), i = e.getAttribute(t);
  return {
    pass: n ? a && this.equals(i, r) : a,
    message: /* @__PURE__ */ o(() => {
      const s = this.isNot ? "not to" : "to", l = a ? Lc(this.utils.stringify, t, i) : null, c = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveAttribute`,
        "element",
        this.utils.printExpected(t),
        {
          secondArgument: n ? this.utils.printExpected(r) : void 0,
          comment: A0(
            this.utils.stringify,
            t,
            r
          )
        }
      );
      return He(
        this,
        c,
        `Expected the element ${s} have attribute`,
        Lc(this.utils.stringify, t, r),
        "Received",
        l
      );
    }, "message")
  };
}
o(lm, "toHaveAttribute");
function R0(e) {
  const t = e.pop();
  let r, n;
  return typeof t == "object" && !(t instanceof RegExp) ? (r = e, n = t) : (r = e.concat(t), n = { exact: !1 }), { expectedClassNames: r, options: n };
}
o(R0, "getExpectedClassNamesAndOptions");
function Dc(e) {
  return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
o(Dc, "splitClassNames");
function Fc(e, t) {
  return e.every(
    (r) => typeof r == "string" ? t.includes(r) : t.some((n) => r.test(n))
  );
}
o(Fc, "isSubset$1");
function um(e, ...t) {
  Ee(e, um, this);
  const { expectedClassNames: r, options: n } = R0(t), a = Dc(e.getAttribute("class")), i = r.reduce(
    (l, c) => l.concat(
      typeof c == "string" || !c ? Dc(c) : c
    ),
    []
  ), s = i.some((l) => l instanceof RegExp);
  if (n.exact && s)
    throw new Error("Exact option does not support RegExp expected class names");
  return n.exact ? {
    pass: Fc(i, a) && i.length === a.length,
    message: /* @__PURE__ */ o(() => {
      const l = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(i.join(" "))
        ),
        `Expected the element ${l} have EXACTLY defined classes`,
        i.join(" "),
        "Received",
        a.join(" ")
      );
    }, "message")
  } : i.length > 0 ? {
    pass: Fc(i, a),
    message: /* @__PURE__ */ o(() => {
      const l = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveClass`,
          "element",
          this.utils.printExpected(i.join(" "))
        ),
        `Expected the element ${l} have class`,
        i.join(" "),
        "Received",
        a.join(" ")
      );
    }, "message")
  } : {
    pass: this.isNot ? a.length > 0 : !1,
    message: /* @__PURE__ */ o(() => this.isNot ? He(
      this,
      this.utils.matcherHint(".not.toHaveClass", "element", ""),
      "Expected the element to have classes",
      "(none)",
      "Received",
      a.join(" ")
    ) : [
      this.utils.matcherHint(".toHaveClass", "element"),
      "At least one expected class must be provided."
    ].join(`
`), "message")
  };
}
o(um, "toHaveClass");
function k0(e, t) {
  const r = {}, n = e.createElement("div");
  return Object.keys(t).forEach((a) => {
    n.style[a] = t[a], r[a] = n.style[a];
  }), r;
}
o(k0, "getStyleDeclaration");
function I0(e, t) {
  return !!Object.keys(e).length && Object.entries(e).every(([r, n]) => {
    const a = r.startsWith("--"), i = [r];
    return a || i.push(r.toLowerCase()), i.some(
      (s) => t[s] === n || t.getPropertyValue(s) === n
    );
  });
}
o(I0, "isSubset");
function Bc(e) {
  return Object.keys(e).sort().map((t) => `${t}: ${e[t]};`).join(`
`);
}
o(Bc, "printoutStyles");
function j0(e, t, r) {
  const n = Array.from(r).filter((a) => t[a] !== void 0).reduce(
    (a, i) => Object.assign(a, { [i]: r.getPropertyValue(i) }),
    {}
  );
  return e(Bc(t), Bc(n)).replace(`${cF.default.red("+ Received")}
`, "");
}
o(j0, "expectedDiff");
function gs(e, t) {
  Ee(e, gs, this);
  const r = typeof t == "object" ? t : b0(t, gs, this), { getComputedStyle: n } = e.ownerDocument.defaultView, a = k0(e.ownerDocument, r), i = n(e);
  return {
    pass: I0(a, i),
    message: /* @__PURE__ */ o(() => {
      const s = `${this.isNot ? ".not" : ""}.toHaveStyle`;
      return [
        this.utils.matcherHint(s, "element", ""),
        j0(this.utils.diff, a, i)
      ].join(`

`);
    }, "message")
  };
}
o(gs, "toHaveStyle");
function cm(e) {
  return Ee(e, cm, this), {
    pass: e.ownerDocument.activeElement === e,
    message: /* @__PURE__ */ o(() => [
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveFocus`,
        "element",
        ""
      ),
      "",
      ...this.isNot ? [
        "Received element is focused:",
        `  ${this.utils.printReceived(e)}`
      ] : [
        "Expected element with focus:",
        `  ${this.utils.printExpected(e)}`,
        "Received element with focus:",
        `  ${this.utils.printReceived(
          e.ownerDocument.activeElement
        )}`
      ]
    ].join(`
`), "message")
  };
}
o(cm, "toHaveFocus");
function N0(e) {
  const t = [...new Set(e.map((r) => r.type))];
  if (t.length !== 1)
    throw new Error(
      "Multiple form elements with the same name must be of the same type"
    );
  switch (t[0]) {
    case "radio": {
      const r = e.find((n) => n.checked);
      return r ? r.value : void 0;
    }
    case "checkbox":
      return e.filter((r) => r.checked).map((r) => r.value);
    default:
      return e.map((r) => r.value);
  }
}
o(N0, "getMultiElementValue");
function q0(e, t) {
  const r = [...e.querySelectorAll(`[name="${(0, dF.default)(t)}"]`)];
  if (r.length !== 0)
    switch (r.length) {
      case 1:
        return tm(r[0]);
      default:
        return N0(r);
    }
}
o(q0, "getFormValue");
function M0(e) {
  return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
o(M0, "getPureName");
function $0(e) {
  return Array.from(e.elements).map((t) => t.name).reduce(
    (t, r) => ({
      ...t,
      [M0(r)]: q0(e, r)
    }),
    {}
  );
}
o($0, "getAllFormValues");
function dm(e, t) {
  if (Ee(e, dm, this), !e.elements)
    throw new Error("toHaveFormValues must be called on a form or a fieldset");
  const r = $0(e);
  return {
    pass: Object.entries(t).every(
      ([n, a]) => $l(r[n], a)
    ),
    message: /* @__PURE__ */ o(() => {
      const n = this.isNot ? "not to" : "to", a = `${this.isNot ? ".not" : ""}.toHaveFormValues`, i = Object.keys(r).filter((s) => t.hasOwnProperty(s)).reduce((s, l) => ({ ...s, [l]: r[l] }), {});
      return [
        this.utils.matcherHint(a, "element", ""),
        `Expected the element ${n} have form values`,
        this.utils.diff(t, i)
      ].join(`

`);
    }, "message")
  };
}
o(dm, "toHaveFormValues");
function L0(e) {
  const { getComputedStyle: t } = e.ownerDocument.defaultView, { display: r, visibility: n, opacity: a } = t(e);
  return r !== "none" && n !== "hidden" && n !== "collapse" && a !== "0" && a !== 0;
}
o(L0, "isStyleVisible");
function D0(e, t) {
  let r;
  return t ? r = e.nodeName === "DETAILS" && t.nodeName !== "SUMMARY" ? e.hasAttribute("open") : !0 : r = e.nodeName === "DETAILS" ? e.hasAttribute("open") : !0, !e.hasAttribute("hidden") && r;
}
o(D0, "isAttributeVisible");
function pm(e, t) {
  return L0(e) && D0(e, t) && (!e.parentElement || pm(e.parentElement, e));
}
o(pm, "isElementVisible");
function fm(e) {
  Ee(e, fm, this);
  const t = e.ownerDocument === e.getRootNode({ composed: !0 }), r = t && pm(e);
  return {
    pass: r,
    message: /* @__PURE__ */ o(() => {
      const n = r ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeVisible`,
          "element",
          ""
        ),
        "",
        `Received element ${n} visible${t ? "" : " (element is not in the document)"}:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(fm, "toBeVisible");
var yF = [
  "fieldset",
  "input",
  "select",
  "optgroup",
  "option",
  "button",
  "textarea"
];
function F0(e, t) {
  return Or(e) === "legend" && Or(t) === "fieldset" && e.isSameNode(
    Array.from(t.children).find((r) => Or(r) === "legend")
  );
}
o(F0, "isFirstLegendChildOfFieldset");
function B0(e, t) {
  return hm(t) && !F0(e, t);
}
o(B0, "isElementDisabledByParent");
function U0(e) {
  return e.includes("-");
}
o(U0, "isCustomElement");
function mm(e) {
  const t = Or(e);
  return yF.includes(t) || U0(t);
}
o(mm, "canElementBeDisabled");
function hm(e) {
  return mm(e) && e.hasAttribute("disabled");
}
o(hm, "isElementDisabled");
function ym(e) {
  const t = e.parentElement;
  return !!t && (B0(e, t) || ym(t));
}
o(ym, "isAncestorDisabled");
function gm(e) {
  return mm(e) && (hm(e) || ym(e));
}
o(gm, "isElementOrAncestorDisabled");
function bm(e) {
  Ee(e, bm, this);
  const t = gm(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeDisabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} disabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(bm, "toBeDisabled");
function vm(e) {
  Ee(e, vm, this);
  const t = !gm(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeEnabled`,
          "element",
          ""
        ),
        "",
        `Received element ${r} enabled:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(vm, "toBeEnabled");
var gF = ["select", "textarea"], bF = ["input", "select", "textarea"], vF = [
  "color",
  "hidden",
  "range",
  "submit",
  "image",
  "reset"
], wF = [
  "checkbox",
  "combobox",
  "gridcell",
  "listbox",
  "radiogroup",
  "spinbutton",
  "textbox",
  "tree"
];
function H0(e) {
  return gF.includes(Or(e)) && e.hasAttribute("required");
}
o(H0, "isRequiredOnFormTagsExceptInput");
function V0(e) {
  return Or(e) === "input" && e.hasAttribute("required") && (e.hasAttribute("type") && !vF.includes(e.getAttribute("type")) || !e.hasAttribute("type"));
}
o(V0, "isRequiredOnSupportedInput");
function J0(e) {
  return e.hasAttribute("aria-required") && e.getAttribute("aria-required") === "true" && (bF.includes(Or(e)) || e.hasAttribute("role") && wF.includes(e.getAttribute("role")));
}
o(J0, "isElementRequiredByARIA");
function wm(e) {
  Ee(e, wm, this);
  const t = H0(e) || V0(e) || J0(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeRequired`,
          "element",
          ""
        ),
        "",
        `Received element ${r} required:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(wm, "toBeRequired");
var _F = ["form", "input", "select", "textarea"];
function z0(e) {
  return e.hasAttribute("aria-invalid") && e.getAttribute("aria-invalid") !== "false";
}
o(z0, "isElementHavingAriaInvalid");
function W0(e) {
  return _F.includes(Or(e));
}
o(W0, "isSupportsValidityMethod");
function _m(e) {
  const t = z0(e);
  return W0(e) ? t || !e.checkValidity() : t;
}
o(_m, "isElementInvalid");
function Em(e) {
  Ee(e, Em, this);
  const t = _m(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeInvalid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently invalid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(Em, "toBeInvalid");
function xm(e) {
  Ee(e, xm, this);
  const t = !_m(e);
  return {
    pass: t,
    message: /* @__PURE__ */ o(() => {
      const r = t ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeValid`,
          "element",
          ""
        ),
        "",
        `Received element ${r} currently valid:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(xm, "toBeValid");
function Tm(e, t) {
  if (Ee(e, Tm, this), e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type))
    throw new Error(
      "input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead"
    );
  const r = tm(e), n = t !== void 0;
  let a = t, i = r;
  return t == r && t !== r && (a = `${t} (${typeof t})`, i = `${r} (${typeof r})`), {
    pass: n ? $l(r, t) : !!r,
    message: /* @__PURE__ */ o(() => {
      const s = this.isNot ? "not to" : "to", l = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveValue`,
        "element",
        t
      );
      return He(
        this,
        l,
        `Expected the element ${s} have value`,
        n ? a : "(any)",
        "Received",
        i
      );
    }, "message")
  };
}
o(Tm, "toHaveValue");
function Sm(e, t) {
  Ee(e, Sm, this);
  const r = e.tagName.toLowerCase();
  if (!["select", "input", "textarea"].includes(r))
    throw new Error(
      ".toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead."
    );
  if (r === "input" && ["radio", "checkbox"].includes(e.type))
    throw new Error(
      `.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`
    );
  const n = G0(r, e), a = K0(t), i = a.filter(
    (c) => n.some(
      (u) => c instanceof RegExp ? c.test(u) : this.equals(u, String(c))
    )
  ).length, s = i === n.length, l = i === a.length;
  return {
    pass: s && l,
    message: /* @__PURE__ */ o(() => He(
      this,
      this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveDisplayValue`,
        "element",
        ""
      ),
      `Expected element ${this.isNot ? "not " : ""}to have display value`,
      t,
      "Received",
      n
    ), "message")
  };
}
o(Sm, "toHaveDisplayValue");
function G0(e, t) {
  return e === "select" ? Array.from(t).filter((r) => r.selected).map((r) => r.textContent) : [t.value];
}
o(G0, "getValues");
function K0(e) {
  return e instanceof Array ? e : [e];
}
o(K0, "getExpectedValues");
function Pm(e) {
  Ee(e, Pm, this);
  const t = /* @__PURE__ */ o(() => e.tagName.toLowerCase() === "input" && ["checkbox", "radio"].includes(e.type), "isValidInput"), r = /* @__PURE__ */ o(() => Om(e.getAttribute("role")) && ["true", "false"].includes(e.getAttribute("aria-checked")), "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: !1,
      message: /* @__PURE__ */ o(() => `only inputs with type="checkbox" or type="radio" or elements with ${Y0()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`, "message")
    };
  const n = /* @__PURE__ */ o(() => t() ? e.checked : e.getAttribute("aria-checked") === "true", "isChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ o(() => {
      const a = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBeChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${a} checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(Pm, "toBeChecked");
function Y0() {
  return x0(
    X0().map((e) => `role="${e}"`),
    { lastWordConnector: " or " }
  );
}
o(Y0, "supportedRolesSentence");
function X0() {
  return Zf.roles.keys().filter(Om);
}
o(X0, "supportedRoles");
function Om(e) {
  return Zf.roles.get(e)?.props["aria-checked"] !== void 0;
}
o(Om, "roleSupportsChecked");
function Cm(e) {
  Ee(e, Cm, this);
  const t = /* @__PURE__ */ o(() => e.tagName.toLowerCase() === "input" && e.type === "checkbox", "isValidInput"), r = /* @__PURE__ */ o(() => e.getAttribute("role") === "checkbox", "isValidAriaElement");
  if (!t() && !r())
    return {
      pass: !1,
      message: /* @__PURE__ */ o(() => 'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead', "message")
    };
  const n = /* @__PURE__ */ o(() => {
    const a = e.getAttribute("aria-checked") === "mixed";
    return t() && e.indeterminate || a;
  }, "isPartiallyChecked");
  return {
    pass: n(),
    message: /* @__PURE__ */ o(() => {
      const a = n() ? "is" : "is not";
      return [
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toBePartiallyChecked`,
          "element",
          ""
        ),
        "",
        `Received element ${a} partially checked:`,
        `  ${this.utils.printReceived(e.cloneNode(!1))}`
      ].join(`
`);
    }, "message")
  };
}
o(Cm, "toBePartiallyChecked");
function Am(e, t) {
  ri(
    "toHaveDescription",
    "Please use toHaveAccessibleDescription."
  ), Ee(e, Am, this);
  const r = t !== void 0, n = (e.getAttribute("aria-describedby") || "").split(/\s+/).filter(Boolean);
  let a = "";
  if (n.length > 0) {
    const i = e.ownerDocument, s = n.map((l) => i.getElementById(l)).filter(Boolean);
    a = ni(s.map((l) => l.textContent).join(" "));
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(a) : this.equals(a, t) : !!a,
    message: /* @__PURE__ */ o(() => {
      const i = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveDescription`,
          "element",
          ""
        ),
        `Expected the element ${i} have description`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(a)
      );
    }, "message")
  };
}
o(Am, "toHaveDescription");
function Rm(e, t) {
  if (ri("toHaveErrorMessage", "Please use toHaveAccessibleErrorMessage."), Ee(e, Rm, this), !e.hasAttribute("aria-invalid") || e.getAttribute("aria-invalid") === "false") {
    const i = this.isNot ? ".not" : "";
    return {
      pass: !1,
      message: /* @__PURE__ */ o(() => He(
        this,
        this.utils.matcherHint(`${i}.toHaveErrorMessage`, "element", ""),
        "Expected the element to have invalid state indicated by",
        'aria-invalid="true"',
        "Received",
        e.hasAttribute("aria-invalid") ? `aria-invalid="${e.getAttribute("aria-invalid")}"` : this.utils.printReceived("")
      ), "message")
    };
  }
  const r = t !== void 0, n = (e.getAttribute("aria-errormessage") || "").split(/\s+/).filter(Boolean);
  let a = "";
  if (n.length > 0) {
    const i = e.ownerDocument, s = n.map((l) => i.getElementById(l)).filter(Boolean);
    a = ni(
      s.map((l) => l.textContent).join(" ")
    );
  }
  return {
    pass: r ? t instanceof RegExp ? t.test(a) : this.equals(a, t) : !!a,
    message: /* @__PURE__ */ o(() => {
      const i = this.isNot ? "not to" : "to";
      return He(
        this,
        this.utils.matcherHint(
          `${this.isNot ? ".not" : ""}.toHaveErrorMessage`,
          "element",
          ""
        ),
        `Expected the element ${i} have error message`,
        this.utils.printExpected(t),
        "Received",
        this.utils.printReceived(a)
      );
    }, "message")
  };
}
o(Rm, "toHaveErrorMessage");
function Q0(e) {
  const t = e.ownerDocument.getSelection();
  if (["input", "textarea"].includes(e.tagName.toLowerCase()))
    return ["radio", "checkbox"].includes(e.type) ? "" : e.value.toString().substring(e.selectionStart, e.selectionEnd);
  if (t.anchorNode === null || t.focusNode === null)
    return "";
  const r = t.getRangeAt(0), n = e.ownerDocument.createRange();
  if (t.containsNode(e, !1))
    n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n);
  else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
    const i = e === r.startContainer || e.contains(r.startContainer), s = e === r.endContainer || e.contains(r.endContainer);
    t.removeAllRanges(), (i || s) && (n.selectNodeContents(e), i && n.setStart(
      r.startContainer,
      r.startOffset
    ), s && n.setEnd(
      r.endContainer,
      r.endOffset
    ), t.addRange(n));
  }
  const a = t.toString();
  return t.removeAllRanges(), t.addRange(r), a;
}
o(Q0, "getSelection");
function km(e, t) {
  Ee(e, km, this);
  const r = t !== void 0;
  if (r && typeof t != "string")
    throw new Error("expected selection must be a string or undefined");
  const n = Q0(e);
  return {
    pass: r ? $l(n, t) : !!n,
    message: /* @__PURE__ */ o(() => {
      const a = this.isNot ? "not to" : "to", i = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toHaveSelection`,
        "element",
        t
      );
      return He(
        this,
        i,
        `Expected the element ${a} have selection`,
        r ? t : "(any)",
        "Received",
        n
      );
    }, "message")
  };
}
o(km, "toHaveSelection");
function Im(e) {
  Ee(e, Im, this);
  const t = (e.getAttribute("role") || "").split(" ").map((a) => a.trim()), r = e.tagName.toLowerCase() === "button" || e.tagName.toLowerCase() === "input" && e.type === "button" || t.includes("button"), n = e.getAttribute("aria-pressed");
  return !r || !(n === "true" || n === "false") ? {
    pass: !1,
    message: /* @__PURE__ */ o(() => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()', "message")
  } : {
    pass: r && n === "true",
    message: /* @__PURE__ */ o(() => {
      const a = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePressed`,
        "element",
        ""
      );
      return He(
        this,
        a,
        "Expected element to have",
        `aria-pressed="${this.isNot ? "false" : "true"}"`,
        "Received",
        `aria-pressed="${n}"`
      );
    }, "message")
  };
}
o(Im, "toBePressed");
function jm(e) {
  Ee(e, jm, this);
  const t = (e.getAttribute("role") || "").split(" ").map((a) => a.trim()), r = e.tagName.toLowerCase() === "button" || e.tagName.toLowerCase() === "input" && e.type === "button" || t.includes("button"), n = e.getAttribute("aria-pressed");
  return !r || !(n === "true" || n === "false" || n === "mixed") ? {
    pass: !1,
    message: /* @__PURE__ */ o(() => 'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()', "message")
  } : {
    pass: r && n === "mixed",
    message: /* @__PURE__ */ o(() => {
      const a = this.isNot ? "not to" : "to", i = this.utils.matcherHint(
        `${this.isNot ? ".not" : ""}.toBePartiallyPressed`,
        "element",
        ""
      );
      return He(
        this,
        i,
        `Expected element ${a} have`,
        'aria-pressed="mixed"',
        "Received",
        `aria-pressed="${n}"`
      );
    }, "message")
  };
}
o(jm, "toBePartiallyPressed");
Ye(gx(), 1);
Ye(of(), 1);
Ye(P_(), 1);
Ye(bx(), 1);
var Uu, lg;
function Z0() {
  if (lg) return Uu;
  lg = 1;
  var e, t, r, n, a, i, s, l, c, u, p, f, m, y, g, v, _, b, E;
  return m = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, f = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, e = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, p = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, v = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, E = /[\t\v\f\ufeff\p{Zs}]+/yu, l = /\r?\n|[\r\u2028\u2029]/y, c = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, y = /\/\/.*/y, r = /[<>.:={}]|\/(?![\/*])/y, t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, n = /(['"])(?:(?!\1)[^])*(\1)?/y, a = /[^<>{}]+/y, b = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, _ = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, i = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, s = /^(?:return|throw|yield)$/, u = RegExp(l.source), Uu = /* @__PURE__ */ o(function* (C, { jsx: k = !1 } = {}) {
    var N, O, S, w, T, M, R, D, J, P, q, $, H, z;
    for ({ length: M } = C, w = 0, T = "", z = [
      { tag: "JS" }
    ], N = [], q = 0, $ = !1; w < M; ) {
      switch (D = z[z.length - 1], D.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (C[w] === "/" && (b.test(T) || i.test(T)) && (m.lastIndex = w, R = m.exec(C))) {
            w = m.lastIndex, T = R[0], $ = !0, yield {
              type: "RegularExpressionLiteral",
              value: R[0],
              closed: R[1] !== void 0 && R[1] !== "\\"
            };
            continue;
          }
          if (f.lastIndex = w, R = f.exec(C)) {
            switch (H = R[0], J = f.lastIndex, P = H, H) {
              case "(":
                T === "?NonExpressionParenKeyword" && z.push({
                  tag: "JSNonExpressionParen",
                  nesting: q
                }), q++, $ = !1;
                break;
              case ")":
                q--, $ = !0, D.tag === "JSNonExpressionParen" && q === D.nesting && (z.pop(), P = "?NonExpressionParenEnd", $ = !1);
                break;
              case "{":
                f.lastIndex = 0, S = !_.test(T) && (b.test(T) || i.test(T)), N.push(S), $ = !1;
                break;
              case "}":
                switch (D.tag) {
                  case "InterpolationInTemplate":
                    if (N.length === D.nesting) {
                      v.lastIndex = w, R = v.exec(C), w = v.lastIndex, T = R[0], R[1] === "${" ? (T = "?InterpolationInTemplate", $ = !1, yield {
                        type: "TemplateMiddle",
                        value: R[0]
                      }) : (z.pop(), $ = !0, yield {
                        type: "TemplateTail",
                        value: R[0],
                        closed: R[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (N.length === D.nesting) {
                      z.pop(), w += 1, T = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                $ = N.pop(), P = $ ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                $ = !0;
                break;
              case "++":
              case "--":
                P = $ ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (k && (b.test(T) || i.test(T))) {
                  z.push({ tag: "JSXTag" }), w += 1, T = "<", yield {
                    type: "JSXPunctuator",
                    value: H
                  };
                  continue;
                }
                $ = !1;
                break;
              default:
                $ = !1;
            }
            w = J, T = P, yield {
              type: "Punctuator",
              value: H
            };
            continue;
          }
          if (e.lastIndex = w, R = e.exec(C)) {
            switch (w = e.lastIndex, P = R[0], R[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                T !== "." && T !== "?." && (P = "?NonExpressionParenKeyword");
            }
            T = P, $ = !i.test(R[0]), yield {
              type: R[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: R[0]
            };
            continue;
          }
          if (g.lastIndex = w, R = g.exec(C)) {
            w = g.lastIndex, T = R[0], $ = !0, yield {
              type: "StringLiteral",
              value: R[0],
              closed: R[2] !== void 0
            };
            continue;
          }
          if (p.lastIndex = w, R = p.exec(C)) {
            w = p.lastIndex, T = R[0], $ = !0, yield {
              type: "NumericLiteral",
              value: R[0]
            };
            continue;
          }
          if (v.lastIndex = w, R = v.exec(C)) {
            w = v.lastIndex, T = R[0], R[1] === "${" ? (T = "?InterpolationInTemplate", z.push({
              tag: "InterpolationInTemplate",
              nesting: N.length
            }), $ = !1, yield {
              type: "TemplateHead",
              value: R[0]
            }) : ($ = !0, yield {
              type: "NoSubstitutionTemplate",
              value: R[0],
              closed: R[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (r.lastIndex = w, R = r.exec(C)) {
            switch (w = r.lastIndex, P = R[0], R[0]) {
              case "<":
                z.push({ tag: "JSXTag" });
                break;
              case ">":
                z.pop(), T === "/" || D.tag === "JSXTagEnd" ? (P = "?JSX", $ = !0) : z.push({ tag: "JSXChildren" });
                break;
              case "{":
                z.push({
                  tag: "InterpolationInJSX",
                  nesting: N.length
                }), P = "?InterpolationInJSX", $ = !1;
                break;
              case "/":
                T === "<" && (z.pop(), z[z.length - 1].tag === "JSXChildren" && z.pop(), z.push({ tag: "JSXTagEnd" }));
            }
            T = P, yield {
              type: "JSXPunctuator",
              value: R[0]
            };
            continue;
          }
          if (t.lastIndex = w, R = t.exec(C)) {
            w = t.lastIndex, T = R[0], yield {
              type: "JSXIdentifier",
              value: R[0]
            };
            continue;
          }
          if (n.lastIndex = w, R = n.exec(C)) {
            w = n.lastIndex, T = R[0], yield {
              type: "JSXString",
              value: R[0],
              closed: R[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (a.lastIndex = w, R = a.exec(C)) {
            w = a.lastIndex, T = R[0], yield {
              type: "JSXText",
              value: R[0]
            };
            continue;
          }
          switch (C[w]) {
            case "<":
              z.push({ tag: "JSXTag" }), w++, T = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              z.push({
                tag: "InterpolationInJSX",
                nesting: N.length
              }), w++, T = "?InterpolationInJSX", $ = !1, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (E.lastIndex = w, R = E.exec(C)) {
        w = E.lastIndex, yield {
          type: "WhiteSpace",
          value: R[0]
        };
        continue;
      }
      if (l.lastIndex = w, R = l.exec(C)) {
        w = l.lastIndex, $ = !1, s.test(T) && (T = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: R[0]
        };
        continue;
      }
      if (c.lastIndex = w, R = c.exec(C)) {
        w = c.lastIndex, u.test(R[0]) && ($ = !1, s.test(T) && (T = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: R[0],
          closed: R[1] !== void 0
        };
        continue;
      }
      if (y.lastIndex = w, R = y.exec(C)) {
        w = y.lastIndex, $ = !1, yield {
          type: "SingleLineComment",
          value: R[0]
        };
        continue;
      }
      O = String.fromCodePoint(C.codePointAt(w)), w += O.length, T = O, $ = !1, yield {
        type: D.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: O
      };
    }
  }, "jsTokens_1"), Uu;
}
o(Z0, "requireJsTokens");
var EF = Z0();
Jp(EF);
var eT = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(eT.keyword);
new Set(eT.strict);
function sa(e, t) {
  if (!e)
    throw new Error(t);
}
o(sa, "assert");
function dn(e, t) {
  return typeof t === e;
}
o(dn, "isType");
function tT(e) {
  return e instanceof Promise;
}
o(tT, "isPromise");
function fo(e, t, r) {
  Object.defineProperty(e, t, r);
}
o(fo, "define");
function yn(e, t, r) {
  fo(e, t, { value: r, configurable: !0, writable: !0 });
}
o(yn, "defineValue");
var Vr = Symbol.for("tinyspy:spy"), xF = /* @__PURE__ */ new Set(), TF = /* @__PURE__ */ o((e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "reset"), SF = /* @__PURE__ */ o((e) => (fo(e, Vr, {
  value: { reset: /* @__PURE__ */ o(() => TF(e[Vr]), "reset") }
}), e[Vr]), "defineState"), Uc = /* @__PURE__ */ o((e) => e[Vr] || SF(e), "getInternalState");
function rT(e) {
  sa(
    dn("function", e) || dn("undefined", e),
    "cannot spy on a non-function value"
  );
  let t = /* @__PURE__ */ o(function(...n) {
    let a = Uc(t);
    a.called = !0, a.callCount++, a.calls.push(n);
    let i = a.next.shift();
    if (i) {
      a.results.push(i);
      let [p, f] = i;
      if (p === "ok")
        return f;
      throw f;
    }
    let s, l = "ok", c = a.results.length;
    if (a.impl)
      try {
        new.target ? s = Reflect.construct(a.impl, n, new.target) : s = a.impl.apply(this, n), l = "ok";
      } catch (p) {
        throw s = p, l = "error", a.results.push([l, p]), p;
      }
    let u = [l, s];
    return tT(s) && s.then(
      (p) => a.resolves[c] = ["ok", p],
      (p) => a.resolves[c] = ["error", p]
    ), a.results.push(u), s;
  }, "fn");
  yn(t, "_isMockFunction", !0), yn(t, "length", e ? e.length : 0), yn(t, "name", e && e.name || "spy");
  let r = Uc(t);
  return r.reset(), r.impl = e, t;
}
o(rT, "createInternalSpy");
function nT(e) {
  return !!e && e._isMockFunction === !0;
}
o(nT, "isMockFunction");
var oT = /* @__PURE__ */ o((e, t) => {
  let r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return [e, r];
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    let a = Object.getOwnPropertyDescriptor(n, t);
    if (a)
      return [n, a];
    n = Object.getPrototypeOf(n);
  }
}, "getDescriptor"), ug = /* @__PURE__ */ o((e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
}, "setPototype");
function Nm(e, t, r) {
  sa(
    !dn("undefined", e),
    "spyOn could not find an object to spy upon"
  ), sa(
    dn("object", e) || dn("function", e),
    "cannot spyOn on a primitive value"
  );
  let [n, a] = (() => {
    if (!dn("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [i, s] = oT(e, n) || [];
  sa(
    s || n in e,
    `${String(n)} does not exist`
  );
  let l = !1;
  a === "value" && s && !s.value && s.get && (a = "get", l = !0, r = s.get());
  let c;
  s ? c = s[a] : a !== "value" ? c = /* @__PURE__ */ o(() => e[n], "original") : c = e[n], c && sT(c) && (c = c[Vr].getOriginal());
  let u = /* @__PURE__ */ o((y) => {
    let { value: g, ...v } = s || {
      configurable: !0,
      writable: !0
    };
    a !== "value" && delete v.writable, v[a] = y, fo(e, n, v);
  }, "reassign"), p = /* @__PURE__ */ o(() => {
    i !== e ? Reflect.deleteProperty(e, n) : s && !c ? fo(e, n, s) : u(c);
  }, "restore");
  r || (r = c);
  let f = iT(rT(r), r);
  a === "value" && ug(f, c);
  let m = f[Vr];
  return yn(m, "restore", p), yn(m, "getOriginal", () => l ? c() : c), yn(m, "willCall", (y) => (m.impl = y, f)), u(
    l ? () => (ug(f, r), f) : f
  ), xF.add(f), f;
}
o(Nm, "internalSpyOn");
var PF = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function aT(e) {
  let t = /* @__PURE__ */ new Set(), r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype; ) {
    let n = [
      ...Object.getOwnPropertyNames(e),
      ...Object.getOwnPropertySymbols(e)
    ];
    for (let a of n)
      r[a] || PF.has(a) || (t.add(a), r[a] = Object.getOwnPropertyDescriptor(e, a));
    e = Object.getPrototypeOf(e);
  }
  return {
    properties: t,
    descriptors: r
  };
}
o(aT, "getAllProperties");
function iT(e, t) {
  if (!t || // the original is already a spy, so it has all the properties
  Vr in t)
    return e;
  let { properties: r, descriptors: n } = aT(t);
  for (let a of r) {
    let i = n[a];
    oT(e, a) || fo(e, a, i);
  }
  return e;
}
o(iT, "wrap");
function sT(e) {
  return nT(e) && "getOriginal" in e[Vr];
}
o(sT, "isSpyFunction");
var Ll = /* @__PURE__ */ new Set();
function Zn(e) {
  return typeof e == "function" && "_isMockFunction" in e && e._isMockFunction;
}
o(Zn, "isMockFunction");
function OF(e, t, r) {
  const n = r ? { [{
    get: "getter",
    set: "setter"
  }[r]]: t } : t;
  let a;
  const i = lT(e, t), s = i && i[r || "value"];
  Zn(s) && (a = s.mock._state());
  try {
    const l = Nm(e, n), c = qm(l);
    return a && c.mock._state(a), c;
  } catch (l) {
    throw l instanceof TypeError && Symbol.toStringTag && e[Symbol.toStringTag] === "Module" && (l.message.includes("Cannot redefine property") || l.message.includes("Cannot replace module namespace") || l.message.includes("can't redefine non-configurable property")) ? new TypeError(`Cannot spy on export "${String(n)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: l }) : l;
  }
}
o(OF, "spyOn");
var CF = 0;
function qm(e) {
  const t = e;
  let r, n = [], a = !1, i = [], s = [], l = [];
  const c = Uc(e), u = {
    get calls() {
      return c.calls;
    },
    get contexts() {
      return s;
    },
    get instances() {
      return i;
    },
    get invocationCallOrder() {
      return l;
    },
    get results() {
      return c.results.map(([y, g]) => ({
        type: y === "error" ? "throw" : "return",
        value: g
      }));
    },
    get settledResults() {
      return c.resolves.map(([y, g]) => ({
        type: y === "error" ? "rejected" : "fulfilled",
        value: g
      }));
    },
    get lastCall() {
      return c.calls[c.calls.length - 1];
    },
    _state(y) {
      return y && (r = y.implementation, n = y.onceImplementations, a = y.implementationChangedTemporarily), {
        implementation: r,
        onceImplementations: n,
        implementationChangedTemporarily: a
      };
    }
  };
  function p(...y) {
    return i.push(this), s.push(this), l.push(++CF), (a ? r : n.shift() || r || c.getOriginal() || (() => {
    })).apply(this, y);
  }
  o(p, "mockCall");
  let f = t.name;
  t.getMockName = () => f || "vi.fn()", t.mockName = (y) => (f = y, t), t.mockClear = () => (c.reset(), i = [], s = [], l = [], t), t.mockReset = () => (t.mockClear(), r = void 0, n = [], t), t.mockRestore = () => (t.mockReset(), c.restore(), t), Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()), t.getMockImplementation = () => a ? r : n.at(0) || r, t.mockImplementation = (y) => (r = y, c.willCall(p), t), t.mockImplementationOnce = (y) => (n.push(y), t);
  function m(y, g) {
    const v = r;
    r = y, c.willCall(p), a = !0;
    const _ = /* @__PURE__ */ o(() => {
      r = v, a = !1;
    }, "reset"), b = g();
    return typeof b == "object" && b && typeof b.then == "function" ? b.then(() => (_(), t)) : (_(), t);
  }
  return o(m, "withImplementation"), t.withImplementation = m, t.mockReturnThis = () => t.mockImplementation(function() {
    return this;
  }), t.mockReturnValue = (y) => t.mockImplementation(() => y), t.mockReturnValueOnce = (y) => t.mockImplementationOnce(() => y), t.mockResolvedValue = (y) => t.mockImplementation(() => Promise.resolve(y)), t.mockResolvedValueOnce = (y) => t.mockImplementationOnce(() => Promise.resolve(y)), t.mockRejectedValue = (y) => t.mockImplementation(() => Promise.reject(y)), t.mockRejectedValueOnce = (y) => t.mockImplementationOnce(() => Promise.reject(y)), Object.defineProperty(t, "mock", { get: /* @__PURE__ */ o(() => u, "get") }), c.willCall(p), Ll.add(t), t;
}
o(qm, "enhanceSpy");
function Hc(e) {
  const t = qm(Nm({ spy: e || function() {
  } }, "spy"));
  return e && t.mockImplementation(e), t;
}
o(Hc, "fn");
function lT(e, t) {
  const r = Object.getOwnPropertyDescriptor(e, t);
  if (r)
    return r;
  let n = Object.getPrototypeOf(e);
  for (; n !== null; ) {
    const a = Object.getOwnPropertyDescriptor(n, t);
    if (a)
      return a;
    n = Object.getPrototypeOf(n);
  }
}
o(lT, "getDescriptor");
var Ca = Symbol.for("matchers-object"), Aa = Symbol.for("$$jest-matchers-object-storybook"), Mm = Symbol.for("expect-global"), Vc = Symbol.for("asymmetric-matchers-object"), AF = {
  toSatisfy(e, t, r) {
    const { printReceived: n, printExpected: a, matcherHint: i } = this.utils, s = t(e);
    return {
      pass: s,
      message: /* @__PURE__ */ o(() => s ? `${i(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${r || a(t)}
Received:
${n(e)}` : `${i(".toSatisfy", "received", "")}

Expected value to satisfy:
${r || a(t)}

Received:
${n(e)}`, "message")
    };
  },
  toBeOneOf(e, t) {
    const { equals: r, customTesters: n } = this, { printReceived: a, printExpected: i, matcherHint: s } = this.utils;
    if (!Array.isArray(t))
      throw new TypeError(`You must provide an array to ${s(".toBeOneOf")}, not '${typeof t}'.`);
    const l = t.length === 0 || t.some((c) => r(c, e, n));
    return {
      pass: l,
      message: /* @__PURE__ */ o(() => l ? `${s(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${i(t)}
Received:
${a(e)}` : `${s(".toBeOneOf", "received", "")}

Expected value to be one of:
${i(t)}

Received:
${a(e)}`, "message")
    };
  }
}, bs = Be.green, $m = Be.red, RF = Be.inverse, kF = Be.bold, Nr = Be.dim;
function uT(e, t = "received", r = "expected", n = {}) {
  const { comment: a = "", isDirectExpectCall: i = !1, isNot: s = !1, promise: l = "", secondArgument: c = "", expectedColor: u = bs, receivedColor: p = $m, secondArgumentColor: f = bs } = n;
  let m = "", y = "expect";
  return !i && t !== "" && (m += Nr(`${y}(`) + p(t), y = ")"), l !== "" && (m += Nr(`${y}.`) + l, y = ""), s && (m += `${Nr(`${y}.`)}not`, y = ""), e.includes(".") ? y += e : (m += Nr(`${y}.`) + e, y = ""), r === "" ? y += "()" : (m += Nr(`${y}(`) + u(r), c && (m += Nr(", ") + f(c)), y = ")"), a !== "" && (y += ` // ${a}`), y !== "" && (m += Nr(y)), m;
}
o(uT, "matcherHint");
var IF = "Â·";
function Lm(e) {
  return e.replace(/\s+$/gm, (t) => IF.repeat(t.length));
}
o(Lm, "replaceTrailingSpaces");
function cT(e) {
  return $m(Lm(dt(e)));
}
o(cT, "printReceived");
function dT(e) {
  return bs(Lm(dt(e)));
}
o(dT, "printExpected");
function Dm() {
  return {
    EXPECTED_COLOR: bs,
    RECEIVED_COLOR: $m,
    INVERTED_COLOR: RF,
    BOLD_WEIGHT: kF,
    DIM_COLOR: Nr,
    diff: jn,
    matcherHint: uT,
    printReceived: cT,
    printExpected: dT,
    printDiffOrStringify: ef,
    printWithType: pT
  };
}
o(Dm, "getMatcherUtils");
function pT(e, t, r) {
  const n = wa(t), a = n !== "null" && n !== "undefined" ? `${e} has type:  ${n}
` : "", i = `${e} has value: ${r(t)}`;
  return a + i;
}
o(pT, "printWithType");
function Dl() {
  return globalThis[Aa].customEqualityTesters;
}
o(Dl, "getCustomEqualityTesters");
function xe(e, t, r, n) {
  return r = r || [], eo(e, t, [], [], r, n ? Fm : hT);
}
o(xe, "equals");
function Jc(e) {
  return !!e && typeof e == "object" && "asymmetricMatch" in e && Nt("Function", e.asymmetricMatch);
}
o(Jc, "isAsymmetric");
function fT(e, t) {
  const r = Jc(e), n = Jc(t);
  if (!(r && n)) {
    if (r)
      return e.asymmetricMatch(t);
    if (n)
      return t.asymmetricMatch(e);
  }
}
o(fT, "asymmetricMatch");
function eo(e, t, r, n, a, i) {
  let s = !0;
  const l = fT(e, t);
  if (l !== void 0)
    return l;
  const c = { equals: xe };
  for (let g = 0; g < a.length; g++) {
    const v = a[g].call(c, e, t, a);
    if (v !== void 0)
      return v;
  }
  if (typeof URL == "function" && e instanceof URL && t instanceof URL)
    return e.href === t.href;
  if (Object.is(e, t))
    return !0;
  if (e === null || t === null)
    return e === t;
  const u = Object.prototype.toString.call(e);
  if (u !== Object.prototype.toString.call(t))
    return !1;
  switch (u) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof e != typeof t ? !1 : typeof e != "object" && typeof t != "object" ? Object.is(e, t) : Object.is(e.valueOf(), t.valueOf());
    case "[object Date]": {
      const g = +e, v = +t;
      return g === v || Number.isNaN(g) && Number.isNaN(v);
    }
    case "[object RegExp]":
      return e.source === t.source && e.flags === t.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return e.equals(t);
    case "[object Temporal.Duration]":
      return e.toString() === t.toString();
  }
  if (typeof e != "object" || typeof t != "object")
    return !1;
  if (Wc(e) && Wc(t))
    return e.isEqualNode(t);
  let p = r.length;
  for (; p--; ) {
    if (r[p] === e)
      return n[p] === t;
    if (n[p] === t)
      return !1;
  }
  if (r.push(e), n.push(t), u === "[object Array]" && e.length !== t.length)
    return !1;
  if (e instanceof Error && t instanceof Error)
    try {
      return mT(e, t, r, n, a, i);
    } finally {
      r.pop(), n.pop();
    }
  const f = zc(e, i);
  let m, y = f.length;
  if (zc(t, i).length !== y)
    return !1;
  for (; y--; )
    if (m = f[y], s = i(t, m) && eo(e[m], t[m], r, n, a, i), !s)
      return !1;
  return r.pop(), n.pop(), s;
}
o(eo, "eq");
function mT(e, t, r, n, a, i) {
  let s = Object.getPrototypeOf(e) === Object.getPrototypeOf(t) && e.name === t.name && e.message === t.message;
  return typeof t.cause < "u" && s && (s = eo(e.cause, t.cause, r, n, a, i)), e instanceof AggregateError && t instanceof AggregateError && s && (s = eo(e.errors, t.errors, r, n, a, i)), s && (s = eo({ ...e }, { ...t }, r, n, a, i)), s;
}
o(mT, "isErrorEqual");
function zc(e, t) {
  const r = [];
  for (const n in e)
    t(e, n) && r.push(n);
  return r.concat(Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable));
}
o(zc, "keys");
function hT(e, t) {
  return Fm(e, t) && e[t] !== void 0;
}
o(hT, "hasDefinedKey");
function Fm(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
o(Fm, "hasKey");
function Nt(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
o(Nt, "isA");
function Wc(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && typeof e.nodeType == "number" && "nodeName" in e && typeof e.nodeName == "string" && "isEqualNode" in e && typeof e.isEqualNode == "function";
}
o(Wc, "isDomNode");
var yT = "@@__IMMUTABLE_KEYED__@@", gT = "@@__IMMUTABLE_SET__@@", jF = "@@__IMMUTABLE_LIST__@@", Fl = "@@__IMMUTABLE_ORDERED__@@", NF = "@@__IMMUTABLE_RECORD__@@";
function bT(e) {
  return !!(e && e[yT] && !e[Fl]);
}
o(bT, "isImmutableUnorderedKeyed");
function vT(e) {
  return !!(e && e[gT] && !e[Fl]);
}
o(vT, "isImmutableUnorderedSet");
function oi(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
o(oi, "isObjectLiteral");
function wT(e) {
  return !!(e && oi(e) && e[jF]);
}
o(wT, "isImmutableList");
function _T(e) {
  return !!(e && oi(e) && e[yT] && e[Fl]);
}
o(_T, "isImmutableOrderedKeyed");
function ET(e) {
  return !!(e && oi(e) && e[gT] && e[Fl]);
}
o(ET, "isImmutableOrderedSet");
function xT(e) {
  return !!(e && oi(e) && e[NF]);
}
o(xT, "isImmutableRecord");
var TT = Symbol.iterator;
function Gc(e) {
  return !!(e != null && e[TT]);
}
o(Gc, "hasIterator");
function wt(e, t, r = [], n = [], a = []) {
  if (typeof e != "object" || typeof t != "object" || Array.isArray(e) || Array.isArray(t) || !Gc(e) || !Gc(t))
    return;
  if (e.constructor !== t.constructor)
    return !1;
  let i = n.length;
  for (; i--; )
    if (n[i] === e)
      return a[i] === t;
  n.push(e), a.push(t);
  const s = [...r.filter((u) => u !== wt), l];
  function l(u, p) {
    return wt(u, p, [...r], [...n], [...a]);
  }
  if (o(l, "iterableEqualityWithStack"), e.size !== void 0) {
    if (e.size !== t.size)
      return !1;
    if (Nt("Set", e) || vT(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p)) {
          let f = !1;
          for (const m of t)
            xe(p, m, s) === !0 && (f = !0);
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return n.pop(), a.pop(), u;
    } else if (Nt("Map", e) || bT(e)) {
      let u = !0;
      for (const p of e)
        if (!t.has(p[0]) || !xe(p[1], t.get(p[0]), s)) {
          let f = !1;
          for (const m of t) {
            const y = xe(p[0], m[0], s);
            let g = !1;
            y === !0 && (g = xe(p[1], m[1], s)), g === !0 && (f = !0);
          }
          if (f === !1) {
            u = !1;
            break;
          }
        }
      return n.pop(), a.pop(), u;
    }
  }
  const c = t[TT]();
  for (const u of e) {
    const p = c.next();
    if (p.done || !xe(u, p.value, s))
      return !1;
  }
  if (!c.next().done)
    return !1;
  if (!wT(e) && !_T(e) && !ET(e) && !xT(e)) {
    const u = Object.entries(e), p = Object.entries(t);
    if (!xe(u, p, s))
      return !1;
  }
  return n.pop(), a.pop(), !0;
}
o(wt, "iterableEquality");
function Bl(e, t) {
  return !e || typeof e != "object" || e === Object.prototype ? !1 : Object.prototype.hasOwnProperty.call(e, t) || Bl(Object.getPrototypeOf(e), t);
}
o(Bl, "hasPropertyInObject");
function ST(e) {
  return aa(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
o(ST, "isObjectWithKeys");
function jo(e, t, r = []) {
  const n = r.filter((i) => i !== jo), a = /* @__PURE__ */ o((i = /* @__PURE__ */ new WeakMap()) => (s, l) => {
    if (ST(l))
      return Object.keys(l).every((c) => {
        if (l[c] != null && typeof l[c] == "object") {
          if (i.has(l[c]))
            return xe(s[c], l[c], n);
          i.set(l[c], !0);
        }
        const u = s != null && Bl(s, c) && xe(s[c], l[c], [...n, a(i)]);
        return i.delete(l[c]), u;
      });
  }, "subsetEqualityWithContext");
  return a()(e, t);
}
o(jo, "subsetEquality");
function Kc(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor))
    return !1;
}
o(Kc, "typeEquality");
function Yc(e, t) {
  let r = e, n = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer))
      return;
    try {
      r = new DataView(e), n = new DataView(t);
    } catch {
      return;
    }
  }
  if (r.byteLength !== n.byteLength)
    return !1;
  for (let a = 0; a < r.byteLength; a++)
    if (r.getUint8(a) !== n.getUint8(a))
      return !1;
  return !0;
}
o(Yc, "arrayBufferEquality");
function vs(e, t, r = []) {
  if (!Array.isArray(e) || !Array.isArray(t))
    return;
  const n = Object.keys(e), a = Object.keys(t), i = r.filter((s) => s !== vs);
  return xe(e, t, i, !0) && xe(n, a);
}
o(vs, "sparseArrayEquality");
function PT(e, t = "#{this}", r = "#{exp}") {
  const n = `expected ${t} to be ${r} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(e) ? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
` : n;
}
o(PT, "generateToBeMessage");
function OT(e, t) {
  return `${t} ${e}${t === 1 ? "" : "s"}`;
}
o(OT, "pluralize");
function Oi(e) {
  return [...Object.keys(e), ...Object.getOwnPropertySymbols(e).filter((t) => {
    var r;
    return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0 ? void 0 : r.enumerable;
  })];
}
o(Oi, "getObjectKeys");
function CT(e, t, r) {
  let n = 0;
  const a = /* @__PURE__ */ o((i = /* @__PURE__ */ new WeakMap()) => (s, l) => {
    if (Array.isArray(s)) {
      if (Array.isArray(l) && l.length === s.length)
        return l.map((c, u) => a(i)(s[u], c));
    } else {
      if (s instanceof Date)
        return s;
      if (aa(s) && aa(l)) {
        if (xe(s, l, [
          ...r,
          wt,
          jo
        ]))
          return l;
        const c = {};
        i.set(s, c), typeof s.constructor == "function" && typeof s.constructor.name == "string" && Object.defineProperty(c, "constructor", {
          enumerable: !1,
          value: s.constructor
        });
        for (const u of Oi(s))
          Bl(l, u) ? c[u] = i.has(s[u]) ? i.get(s[u]) : a(i)(s[u], l[u]) : i.has(s[u]) || (n += 1, aa(s[u]) && (n += Oi(s[u]).length), a(i)(s[u], l[u]));
        if (Oi(c).length > 0)
          return c;
      }
    }
    return s;
  }, "getObjectSubsetWithContext");
  return {
    subset: a()(e, t),
    stripped: n
  };
}
o(CT, "getObjectSubset");
if (!Object.prototype.hasOwnProperty.call(globalThis, Ca)) {
  const e = /* @__PURE__ */ new WeakMap();
  Object.defineProperty(globalThis, Ca, { get: /* @__PURE__ */ o(() => e, "get") });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Aa)) {
  const e = /* @__PURE__ */ Object.create(null), t = [];
  Object.defineProperty(globalThis, Aa, {
    configurable: !0,
    get: /* @__PURE__ */ o(() => ({
      state: globalThis[Ca].get(globalThis[Mm]),
      matchers: e,
      customEqualityTesters: t
    }), "get")
  });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Vc)) {
  const e = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, Vc, { get: /* @__PURE__ */ o(() => e, "get") });
}
function Ra(e) {
  return globalThis[Ca].get(e);
}
o(Ra, "getState");
function Ci(e, t) {
  const r = globalThis[Ca], n = r.get(t) || {}, a = Object.defineProperties(n, {
    ...Object.getOwnPropertyDescriptors(n),
    ...Object.getOwnPropertyDescriptors(e)
  });
  r.set(t, a);
}
o(Ci, "setState");
var AT = class {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(e, t = !1) {
    this.sample = e, this.inverse = t;
  }
  getMatcherContext(e) {
    return {
      ...Ra(e || globalThis[Mm]),
      equals: xe,
      isNot: this.inverse,
      customTesters: Dl(),
      utils: {
        ...Dm(),
        diff: jn,
        stringify: dt,
        iterableEquality: wt,
        subsetEquality: jo
      }
    };
  }
};
o(AT, "AsymmetricMatcher");
var Rr = AT;
Rr.prototype[Symbol.for("chai/inspect")] = function(e) {
  const t = dt(this, e.depth, { min: !0 });
  return t.length <= e.truncate ? t : `${this.toString()}{â€¦}`;
};
var RT = class extends Rr {
  constructor(e, t = !1) {
    if (!Nt("String", e))
      throw new Error("Expected is not a string");
    super(e, t);
  }
  asymmetricMatch(e) {
    const t = Nt("String", e) && e.includes(this.sample);
    return this.inverse ? !t : t;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
};
o(RT, "StringContaining");
var cg = RT, kT = class extends Rr {
  asymmetricMatch(e) {
    return e != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
};
o(kT, "Anything");
var qF = kT, IT = class extends Rr {
  constructor(e, t = !1) {
    super(e, t);
  }
  getPrototype(e) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.constructor.prototype === e ? null : e.constructor.prototype;
  }
  hasProperty(e, t) {
    return e ? Object.prototype.hasOwnProperty.call(e, t) ? !0 : this.hasProperty(this.getPrototype(e), t) : !1;
  }
  asymmetricMatch(e) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let t = !0;
    const r = this.getMatcherContext();
    for (const n in this.sample)
      if (!this.hasProperty(e, n) || !xe(this.sample[n], e[n], r.customTesters)) {
        t = !1;
        break;
      }
    return this.inverse ? !t : t;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
};
o(IT, "ObjectContaining");
var dg = IT, jT = class extends Rr {
  constructor(e, t = !1) {
    super(e, t);
  }
  asymmetricMatch(e) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    const t = this.getMatcherContext(), r = this.sample.length === 0 || Array.isArray(e) && this.sample.every((n) => e.some((a) => xe(n, a, t.customTesters)));
    return this.inverse ? !r : r;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
};
o(jT, "ArrayContaining");
var pg = jT, NT = class extends Rr {
  constructor(e) {
    if (typeof e > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(e);
  }
  fnNameFor(e) {
    if (e.name)
      return e.name;
    const t = Function.prototype.toString.call(e).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return t ? t[1] : "<anonymous>";
  }
  asymmetricMatch(e) {
    return this.sample === String ? typeof e == "string" || e instanceof String : this.sample === Number ? typeof e == "number" || e instanceof Number : this.sample === Function ? typeof e == "function" || typeof e == "function" : this.sample === Boolean ? typeof e == "boolean" || e instanceof Boolean : this.sample === BigInt ? typeof e == "bigint" || e instanceof BigInt : this.sample === Symbol ? typeof e == "symbol" || e instanceof Symbol : this.sample === Object ? typeof e == "object" : e instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
};
o(NT, "Any");
var MF = NT, qT = class extends Rr {
  constructor(e, t = !1) {
    if (!Nt("String", e) && !Nt("RegExp", e))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(e), t);
  }
  asymmetricMatch(e) {
    const t = Nt("String", e) && this.sample.test(e);
    return this.inverse ? !t : t;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
};
o(qT, "StringMatching");
var fg = qT, MT = class extends Rr {
  precision;
  constructor(e, t = 2, r = !1) {
    if (!Nt("Number", e))
      throw new Error("Expected is not a Number");
    if (!Nt("Number", t))
      throw new Error("Precision is not a Number");
    super(e), this.inverse = r, this.precision = t;
  }
  asymmetricMatch(e) {
    if (!Nt("Number", e))
      return !1;
    let t = !1;
    return e === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? t = !0 : t = Math.abs(this.sample - e) < 10 ** -this.precision / 2, this.inverse ? !t : t;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${OT("digit", this.precision)})`
    ].join(" ");
  }
};
o(MT, "CloseTo");
var mg = MT, $F = /* @__PURE__ */ o((e, t) => {
  t.addMethod(e.expect, "anything", () => new qF()), t.addMethod(e.expect, "any", (r) => new MF(r)), t.addMethod(e.expect, "stringContaining", (r) => new cg(r)), t.addMethod(e.expect, "objectContaining", (r) => new dg(r)), t.addMethod(e.expect, "arrayContaining", (r) => new pg(r)), t.addMethod(e.expect, "stringMatching", (r) => new fg(r)), t.addMethod(e.expect, "closeTo", (r, n) => new mg(r, n)), e.expect.not = {
    stringContaining: /* @__PURE__ */ o((r) => new cg(r, !0), "stringContaining"),
    objectContaining: /* @__PURE__ */ o((r) => new dg(r, !0), "objectContaining"),
    arrayContaining: /* @__PURE__ */ o((r) => new pg(r, !0), "arrayContaining"),
    stringMatching: /* @__PURE__ */ o((r) => new fg(r, !0), "stringMatching"),
    closeTo: /* @__PURE__ */ o((r, n) => new mg(r, n, !0), "closeTo")
  };
}, "JestAsymmetricMatchers");
function Xc(e, t, r) {
  const n = e.flag(t, "negate") ? "not." : "", a = `${e.flag(t, "_name")}(${r ? "expected" : ""})`, i = e.flag(t, "promise");
  return `expect(actual)${i ? `.${i}` : ""}.${n}${a}`;
}
o(Xc, "createAssertionMessage");
function Qc(e, t, r, n) {
  const a = e;
  if (a && t instanceof Promise) {
    t = t.finally(() => {
      if (!a.promises)
        return;
      const s = a.promises.indexOf(t);
      s !== -1 && a.promises.splice(s, 1);
    }), a.promises || (a.promises = []), a.promises.push(t);
    let i = !1;
    return a.onFinished ?? (a.onFinished = []), a.onFinished.push(() => {
      if (!i) {
        var s;
        const l = (((s = globalThis.__vitest_worker__) === null || s === void 0 ? void 0 : s.onFilterStackTrace) || ((c) => c || ""))(n.stack);
        console.warn([
          `Promise returned by \`${r}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          l
        ].join(""));
      }
    }), {
      then(s, l) {
        return i = !0, t.then(s, l);
      },
      catch(s) {
        return t.catch(s);
      },
      finally(s) {
        return t.finally(s);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return t;
}
o(Qc, "recordAsyncExpect");
function Zc(e, t) {
  var r;
  e.result || (e.result = { state: "fail" }), e.result.state = "fail", (r = e.result).errors || (r.errors = []), e.result.errors.push(el(t));
}
o(Zc, "handleTestError");
function Bm(e, t, r) {
  return function(...n) {
    if (t !== "withTest" && e.flag(this, "_name", t), !e.flag(this, "soft"))
      return r.apply(this, n);
    const a = e.flag(this, "vitest-test");
    if (!a)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      const i = r.apply(this, n);
      return i && typeof i == "object" && typeof i.then == "function" ? i.then(qE, (s) => {
        Zc(a, s);
      }) : i;
    } catch (i) {
      Zc(a, i);
    }
  };
}
o(Bm, "wrapAssertion");
var LF = /* @__PURE__ */ o((e, t) => {
  const { AssertionError: r } = e, n = Dl();
  function a(u, p) {
    const f = /* @__PURE__ */ o((m) => {
      const y = Bm(t, m, p);
      t.addMethod(e.Assertion.prototype, m, y), t.addMethod(globalThis[Aa].matchers, m, y);
    }, "addMethod");
    Array.isArray(u) ? u.forEach((m) => f(m)) : f(u);
  }
  o(a, "def"), [
    "throw",
    "throws",
    "Throw"
  ].forEach((u) => {
    t.overwriteMethod(e.Assertion.prototype, u, (p) => function(...f) {
      const m = t.flag(this, "promise"), y = t.flag(this, "object"), g = t.flag(this, "negate");
      if (m === "rejects")
        t.flag(this, "object", () => {
          throw y;
        });
      else if (m === "resolves" && typeof y != "function") {
        if (g)
          return;
        {
          const v = t.flag(this, "message") || "expected promise to throw an error, but it didn't", _ = { showDiff: !1 };
          throw new r(v, _, t.flag(this, "ssfi"));
        }
      }
      p.apply(this, f);
    });
  }), a("withTest", function(u) {
    return t.flag(this, "vitest-test", u), this;
  }), a("toEqual", function(u) {
    const p = t.flag(this, "object"), f = xe(p, u, [...n, wt]);
    return this.assert(f, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", u, p);
  }), a("toStrictEqual", function(u) {
    const p = t.flag(this, "object"), f = xe(p, u, [
      ...n,
      wt,
      Kc,
      vs,
      Yc
    ], !0);
    return this.assert(f, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", u, p);
  }), a("toBe", function(u) {
    const p = this._obj, f = Object.is(p, u);
    let m = "";
    return f || (xe(p, u, [
      ...n,
      wt,
      Kc,
      vs,
      Yc
    ], !0) ? m = "toStrictEqual" : xe(p, u, [...n, wt]) && (m = "toEqual")), this.assert(f, PT(m), "expected #{this} not to be #{exp} // Object.is equality", u, p);
  }), a("toMatchObject", function(u) {
    const p = this._obj, f = xe(p, u, [
      ...n,
      wt,
      jo
    ]), m = t.flag(this, "negate"), { subset: y, stripped: g } = CT(p, u, n);
    if (f && m || !f && !m) {
      const v = t.getMessage(this, [
        f,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        u,
        y,
        !1
      ]), _ = g === 0 ? v : `${v}
(${g} matching ${g === 1 ? "property" : "properties"} omitted from actual)`;
      throw new r(_, {
        showDiff: !0,
        expected: u,
        actual: y
      });
    }
  }), a("toMatch", function(u) {
    const p = this._obj;
    if (typeof p != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
    return this.assert(typeof u == "string" ? p.includes(u) : p.match(u), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", u, p);
  }), a("toContain", function(u) {
    const p = this._obj;
    if (typeof Node < "u" && p instanceof Node) {
      if (!(u instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof u}`);
      return this.assert(p.contains(u), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", u, p);
    }
    if (typeof DOMTokenList < "u" && p instanceof DOMTokenList) {
      Qt(u, "class name", ["string"]);
      const f = t.flag(this, "negate") ? p.value.replace(u, "").trim() : `${p.value} ${u}`;
      return this.assert(p.contains(u), `expected "${p.value}" to contain "${u}"`, `expected "${p.value}" not to contain "${u}"`, f, p.value);
    }
    return typeof p == "string" && typeof u == "string" ? this.assert(p.includes(u), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", u, p) : (p != null && typeof p != "string" && t.flag(this, "object", Array.from(p)), this.contain(u));
  }), a("toContainEqual", function(u) {
    const p = t.flag(this, "object"), f = Array.from(p).findIndex((m) => xe(m, u, n));
    this.assert(f !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", u);
  }), a("toBeTruthy", function() {
    const u = t.flag(this, "object");
    this.assert(!!u, "expected #{this} to be truthy", "expected #{this} to not be truthy", !0, u);
  }), a("toBeFalsy", function() {
    const u = t.flag(this, "object");
    this.assert(!u, "expected #{this} to be falsy", "expected #{this} to not be falsy", !1, u);
  }), a("toBeGreaterThan", function(u) {
    const p = this._obj;
    return Qt(p, "actual", ["number", "bigint"]), Qt(u, "expected", ["number", "bigint"]), this.assert(p > u, `expected ${p} to be greater than ${u}`, `expected ${p} to be not greater than ${u}`, u, p, !1);
  }), a("toBeGreaterThanOrEqual", function(u) {
    const p = this._obj;
    return Qt(p, "actual", ["number", "bigint"]), Qt(u, "expected", ["number", "bigint"]), this.assert(p >= u, `expected ${p} to be greater than or equal to ${u}`, `expected ${p} to be not greater than or equal to ${u}`, u, p, !1);
  }), a("toBeLessThan", function(u) {
    const p = this._obj;
    return Qt(p, "actual", ["number", "bigint"]), Qt(u, "expected", ["number", "bigint"]), this.assert(p < u, `expected ${p} to be less than ${u}`, `expected ${p} to be not less than ${u}`, u, p, !1);
  }), a("toBeLessThanOrEqual", function(u) {
    const p = this._obj;
    return Qt(p, "actual", ["number", "bigint"]), Qt(u, "expected", ["number", "bigint"]), this.assert(p <= u, `expected ${p} to be less than or equal to ${u}`, `expected ${p} to be not less than or equal to ${u}`, u, p, !1);
  }), a("toBeNaN", function() {
    const u = t.flag(this, "object");
    this.assert(Number.isNaN(u), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, u);
  }), a("toBeUndefined", function() {
    const u = t.flag(this, "object");
    this.assert(u === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, u);
  }), a("toBeNull", function() {
    const u = t.flag(this, "object");
    this.assert(u === null, "expected #{this} to be null", "expected #{this} not to be null", null, u);
  }), a("toBeDefined", function() {
    const u = t.flag(this, "object");
    this.assert(typeof u < "u", "expected #{this} to be defined", "expected #{this} to be undefined", u);
  }), a("toBeTypeOf", function(u) {
    const p = typeof this._obj, f = u === p;
    return this.assert(f, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", u, p);
  }), a("toBeInstanceOf", function(u) {
    return this.instanceOf(u);
  }), a("toHaveLength", function(u) {
    return this.have.length(u);
  }), a("toHaveProperty", function(...u) {
    Array.isArray(u[0]) && (u[0] = u[0].map((E) => String(E).replace(/([.[\]])/g, "\\$1")).join("."));
    const p = this._obj, [f, m] = u, y = /* @__PURE__ */ o(() => Object.prototype.hasOwnProperty.call(p, f) ? {
      value: p[f],
      exists: !0
    } : t.getPathInfo(p, f), "getValue"), { value: g, exists: v } = y(), _ = v && (u.length === 1 || xe(m, g, n)), b = u.length === 1 ? "" : ` with value ${t.objDisplay(m)}`;
    return this.assert(_, `expected #{this} to have property "${f}"${b}`, `expected #{this} to not have property "${f}"${b}`, m, v ? g : void 0);
  }), a("toBeCloseTo", function(u, p = 2) {
    const f = this._obj;
    let m = !1, y = 0, g = 0;
    return u === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY || u === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY ? m = !0 : (y = 10 ** -p / 2, g = Math.abs(f - u), m = g < y), this.assert(m, `expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${y}`, `expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${y}`, u, f, !1);
  });
  function i(u) {
    if (!Zn(u._obj))
      throw new TypeError(`${t.inspect(u._obj)} is not a spy or a call to a spy!`);
  }
  o(i, "assertIsMock");
  function s(u) {
    return i(u), u._obj;
  }
  o(s, "getSpy"), a(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(u) {
    const p = s(this), f = p.getMockName(), m = p.mock.calls.length;
    return this.assert(m === u, `expected "${f}" to be called #{exp} times, but got ${m} times`, `expected "${f}" to not be called #{exp} times`, u, m, !1);
  }), a("toHaveBeenCalledOnce", function() {
    const u = s(this), p = u.getMockName(), f = u.mock.calls.length;
    return this.assert(f === 1, `expected "${p}" to be called once, but got ${f} times`, `expected "${p}" to not be called once`, 1, f, !1);
  }), a(["toHaveBeenCalled", "toBeCalled"], function() {
    const u = s(this), p = u.getMockName(), f = u.mock.calls.length, m = f > 0, y = t.flag(this, "negate");
    let g = t.getMessage(this, [
      m,
      `expected "${p}" to be called at least once`,
      `expected "${p}" to not be called at all, but actually been called ${f} times`,
      !0,
      m
    ]);
    if (m && y && (g = Ai(u, g)), m && y || !m && !y)
      throw new r(g);
  });
  function l(u, p) {
    return u.length === p.length && u.every((f, m) => xe(f, p[m], [...n, wt]));
  }
  o(l, "equalsArgumentArray"), a(["toHaveBeenCalledWith", "toBeCalledWith"], function(...u) {
    const p = s(this), f = p.getMockName(), m = p.mock.calls.some((v) => l(v, u)), y = t.flag(this, "negate"), g = t.getMessage(this, [
      m,
      `expected "${f}" to be called with arguments: #{exp}`,
      `expected "${f}" to not be called with arguments: #{exp}`,
      u
    ]);
    if (m && y || !m && !y)
      throw new r(Ai(p, g, u));
  }), a("toHaveBeenCalledExactlyOnceWith", function(...u) {
    const p = s(this), f = p.getMockName(), m = p.mock.calls.length, y = p.mock.calls.some((_) => l(_, u)) && m === 1, g = t.flag(this, "negate"), v = t.getMessage(this, [
      y,
      `expected "${f}" to be called once with arguments: #{exp}`,
      `expected "${f}" to not be called once with arguments: #{exp}`,
      u
    ]);
    if (y && g || !y && !g)
      throw new r(Ai(p, v, u));
  }), a(["toHaveBeenNthCalledWith", "nthCalledWith"], function(u, ...p) {
    const f = s(this), m = f.getMockName(), y = f.mock.calls[u - 1], g = f.mock.calls.length, v = u <= g;
    this.assert(y && l(y, p), `expected ${to(u)} "${m}" call to have been called with #{exp}${v ? "" : `, but called only ${g} times`}`, `expected ${to(u)} "${m}" call to not have been called with #{exp}`, p, y, v);
  }), a(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...u) {
    const p = s(this), f = p.getMockName(), m = p.mock.calls[p.mock.calls.length - 1];
    this.assert(m && l(m, u), `expected last "${f}" call to have been called with #{exp}`, `expected last "${f}" call to not have been called with #{exp}`, u, m);
  });
  function c(u, p, f) {
    const m = u.mock.invocationCallOrder, y = p.mock.invocationCallOrder;
    return m.length === 0 ? !f : y.length === 0 ? !1 : m[0] < y[0];
  }
  o(c, "isSpyCalledBeforeAnotherSpy"), a(["toHaveBeenCalledBefore"], function(u, p = !0) {
    const f = s(this);
    if (!Zn(u))
      throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
    this.assert(c(f, u, p), `expected "${f.getMockName()}" to have been called before "${u.getMockName()}"`, `expected "${f.getMockName()}" to not have been called before "${u.getMockName()}"`, u, f);
  }), a(["toHaveBeenCalledAfter"], function(u, p = !0) {
    const f = s(this);
    if (!Zn(u))
      throw new TypeError(`${t.inspect(u)} is not a spy or a call to a spy`);
    this.assert(c(u, f, p), `expected "${f.getMockName()}" to have been called after "${u.getMockName()}"`, `expected "${f.getMockName()}" to not have been called after "${u.getMockName()}"`, u, f);
  }), a(["toThrow", "toThrowError"], function(u) {
    if (typeof u == "string" || typeof u > "u" || u instanceof RegExp)
      return this.throws(u === "" ? /^$/ : u);
    const p = this._obj, f = t.flag(this, "promise"), m = t.flag(this, "negate");
    let y = null;
    if (f === "rejects")
      y = p;
    else if (f === "resolves" && typeof p != "function") {
      if (m)
        return;
      {
        const g = t.flag(this, "message") || "expected promise to throw an error, but it didn't", v = { showDiff: !1 };
        throw new r(g, v, t.flag(this, "ssfi"));
      }
    } else {
      let g = !1;
      try {
        p();
      } catch (v) {
        g = !0, y = v;
      }
      if (!g && !m) {
        const v = t.flag(this, "message") || "expected function to throw an error, but it didn't", _ = { showDiff: !1 };
        throw new r(v, _, t.flag(this, "ssfi"));
      }
    }
    if (typeof u == "function") {
      const g = u.name || u.prototype.constructor.name;
      return this.assert(y && y instanceof u, `expected error to be instance of ${g}`, `expected error not to be instance of ${g}`, u, y);
    }
    if (u instanceof Error) {
      const g = xe(y, u, [...n, wt]);
      return this.assert(g, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", u, y);
    }
    if (typeof u == "object" && "asymmetricMatch" in u && typeof u.asymmetricMatch == "function") {
      const g = u;
      return this.assert(y && g.asymmetricMatch(y), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", g, y);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof u}"`);
  }), [{
    name: "toHaveResolved",
    condition: /* @__PURE__ */ o((u) => u.mock.settledResults.length > 0 && u.mock.settledResults.some(({ type: p }) => p === "fulfilled"), "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: /* @__PURE__ */ o((u) => u.mock.calls.length > 0 && u.mock.results.some(({ type: p }) => p !== "throw"), "condition"),
    action: "called"
  }].forEach(({ name: u, condition: p, action: f }) => {
    a(u, function() {
      const m = s(this), y = m.getMockName(), g = p(m);
      this.assert(g, `expected "${y}" to be successfully ${f} at least once`, `expected "${y}" to not be successfully ${f}`, g, !g, !1);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: /* @__PURE__ */ o((u, p) => u.mock.settledResults.reduce((f, { type: m }) => m === "fulfilled" ? ++f : f, 0) === p, "condition"),
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: /* @__PURE__ */ o((u, p) => u.mock.results.reduce((f, { type: m }) => m === "throw" ? f : ++f, 0) === p, "condition"),
    action: "called"
  }].forEach(({ name: u, condition: p, action: f }) => {
    a(u, function(m) {
      const y = s(this), g = y.getMockName(), v = p(y, m);
      this.assert(v, `expected "${g}" to be successfully ${f} ${m} times`, `expected "${g}" to not be successfully ${f} ${m} times`, `expected resolved times: ${m}`, `received resolved times: ${v}`, !1);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: /* @__PURE__ */ o((u, p) => u.mock.settledResults.some(({ type: f, value: m }) => f === "fulfilled" && xe(p, m)), "condition"),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: /* @__PURE__ */ o((u, p) => u.mock.results.some(({ type: f, value: m }) => f === "return" && xe(p, m)), "condition"),
    action: "return"
  }].forEach(({ name: u, condition: p, action: f }) => {
    a(u, function(m) {
      const y = s(this), g = p(y, m), v = t.flag(this, "negate");
      if (g && v || !g && !v) {
        const _ = y.getMockName(), b = t.getMessage(this, [
          g,
          `expected "${_}" to ${f} with: #{exp} at least once`,
          `expected "${_}" to not ${f} with: #{exp}`,
          m
        ]), E = f === "return" ? y.mock.results : y.mock.settledResults;
        throw new r($T(y, E, b, m));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: /* @__PURE__ */ o((u, p) => {
      const f = u.mock.settledResults[u.mock.settledResults.length - 1];
      return f && f.type === "fulfilled" && xe(f.value, p);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: /* @__PURE__ */ o((u, p) => {
      const f = u.mock.results[u.mock.results.length - 1];
      return f && f.type === "return" && xe(f.value, p);
    }, "condition"),
    action: "return"
  }].forEach(({ name: u, condition: p, action: f }) => {
    a(u, function(m) {
      const y = s(this), g = f === "return" ? y.mock.results : y.mock.settledResults, v = g[g.length - 1], _ = y.getMockName();
      this.assert(p(y, m), `expected last "${_}" call to ${f} #{exp}`, `expected last "${_}" call to not ${f} #{exp}`, m, v?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: /* @__PURE__ */ o((u, p, f) => {
      const m = u.mock.settledResults[p - 1];
      return m && m.type === "fulfilled" && xe(m.value, f);
    }, "condition"),
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: /* @__PURE__ */ o((u, p, f) => {
      const m = u.mock.results[p - 1];
      return m && m.type === "return" && xe(m.value, f);
    }, "condition"),
    action: "return"
  }].forEach(({ name: u, condition: p, action: f }) => {
    a(u, function(m, y) {
      const g = s(this), v = g.getMockName(), _ = (f === "return" ? g.mock.results : g.mock.settledResults)[m - 1], b = `${to(m)} call`;
      this.assert(p(g, m, y), `expected ${b} "${v}" call to ${f} #{exp}`, `expected ${b} "${v}" call to not ${f} #{exp}`, y, _?.value);
    });
  }), a("withContext", function(u) {
    for (const p in u)
      t.flag(this, p, u[p]);
    return this;
  }), t.addProperty(e.Assertion.prototype, "resolves", /* @__PURE__ */ o(function() {
    const u = new Error("resolves");
    t.flag(this, "promise", "resolves"), t.flag(this, "error", u);
    const p = t.flag(this, "vitest-test"), f = t.flag(this, "object");
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof f?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof f}'.`);
    const m = new Proxy(this, { get: /* @__PURE__ */ o((y, g, v) => {
      const _ = Reflect.get(y, g, v);
      return typeof _ != "function" ? _ instanceof e.Assertion ? m : _ : (...b) => {
        t.flag(this, "_name", g);
        const E = f.then((C) => (t.flag(this, "object", C), _.call(this, ...b)), (C) => {
          const k = new r(`promise rejected "${t.inspect(C)}" instead of resolving`, { showDiff: !1 });
          throw k.cause = C, k.stack = u.stack.replace(u.message, k.message), k;
        });
        return Qc(p, E, Xc(t, this, !!b.length), u);
      };
    }, "get") });
    return m;
  }, "__VITEST_RESOLVES__")), t.addProperty(e.Assertion.prototype, "rejects", /* @__PURE__ */ o(function() {
    const u = new Error("rejects");
    t.flag(this, "promise", "rejects"), t.flag(this, "error", u);
    const p = t.flag(this, "vitest-test"), f = t.flag(this, "object"), m = typeof f == "function" ? f() : f;
    if (t.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof m?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof m}'.`);
    const y = new Proxy(this, { get: /* @__PURE__ */ o((g, v, _) => {
      const b = Reflect.get(g, v, _);
      return typeof b != "function" ? b instanceof e.Assertion ? y : b : (...E) => {
        t.flag(this, "_name", v);
        const C = m.then((k) => {
          const N = new r(`promise resolved "${t.inspect(k)}" instead of rejecting`, {
            showDiff: !0,
            expected: new Error("rejected promise"),
            actual: k
          });
          throw N.stack = u.stack.replace(u.message, N.message), N;
        }, (k) => (t.flag(this, "object", k), b.call(this, ...E)));
        return Qc(p, C, Xc(t, this, !!E.length), u);
      };
    }, "get") });
    return y;
  }, "__VITEST_REJECTS__"));
}, "JestChaiExpect");
function to(e) {
  const t = e % 10, r = e % 100;
  return t === 1 && r !== 11 ? `${e}st` : t === 2 && r !== 12 ? `${e}nd` : t === 3 && r !== 13 ? `${e}rd` : `${e}th`;
}
o(to, "ordinalOf");
function Ai(e, t, r) {
  return e.mock.calls.length && (t += Be.gray(`

Received: 

${e.mock.calls.map((n, a) => {
    let i = Be.bold(`  ${to(a + 1)} ${e.getMockName()} call:

`);
    return r ? i += jn(r, n, { omitAnnotationLines: !0 }) : i += dt(n).split(`
`).map((s) => `    ${s}`).join(`
`), i += `
`, i;
  }).join(`
`)}`)), t += Be.gray(`

Number of calls: ${Be.bold(e.mock.calls.length)}
`), t;
}
o(Ai, "formatCalls");
function $T(e, t, r, n) {
  return t.length && (r += Be.gray(`

Received: 

${t.map((a, i) => {
    let s = Be.bold(`  ${to(i + 1)} ${e.getMockName()} call return:

`);
    return n ? s += jn(n, a.value, { omitAnnotationLines: !0 }) : s += dt(a).split(`
`).map((l) => `    ${l}`).join(`
`), s += `
`, s;
  }).join(`
`)}`)), r += Be.gray(`

Number of calls: ${Be.bold(e.mock.calls.length)}
`), r;
}
o($T, "formatReturns");
function LT(e, t) {
  const r = e._obj, n = er.flag(e, "negate"), a = er.flag(e, "promise") || "", i = {
    ...Dm(),
    diff: jn,
    stringify: dt,
    iterableEquality: wt,
    subsetEquality: jo
  };
  return {
    state: {
      ...Ra(t),
      customTesters: Dl(),
      isNot: n,
      utils: i,
      promise: a,
      equals: xe,
      suppressedErrors: [],
      soft: er.flag(e, "soft"),
      poll: er.flag(e, "poll")
    },
    isNot: n,
    obj: r
  };
}
o(LT, "getMatcherState");
var DT = class extends Error {
  constructor(e, t, r) {
    super(e), this.actual = t, this.expected = r;
  }
};
o(DT, "JestExtendError");
var hg = DT;
function FT(e, t, r) {
  return (n, a) => {
    Object.entries(r).forEach(([i, s]) => {
      function l(...m) {
        const { state: y, isNot: g, obj: v } = LT(this, t), _ = s.call(y, v, ...m);
        if (_ && typeof _ == "object" && typeof _.then == "function")
          return _.then(({ pass: N, message: O, actual: S, expected: w }) => {
            if (N && g || !N && !g)
              throw new hg(O(), S, w);
          });
        const { pass: b, message: E, actual: C, expected: k } = _;
        if (b && g || !b && !g)
          throw new hg(E(), C, k);
      }
      o(l, "expectWrapper");
      const c = Bm(a, i, l);
      a.addMethod(globalThis[Aa].matchers, i, c), a.addMethod(e.Assertion.prototype, i, c);
      const u = class extends Rr {
        constructor(m = !1, ...y) {
          super(y, m);
        }
        asymmetricMatch(m) {
          const { pass: y } = s.call(this.getMatcherContext(t), m, ...this.sample);
          return this.inverse ? !y : y;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${i}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((m) => dt(m)).join(", ")}>`;
        }
      };
      o(u, "CustomMatcher");
      let p = u;
      const f = /* @__PURE__ */ o((...m) => new p(!1, ...m), "customMatcher");
      Object.defineProperty(t, i, {
        configurable: !0,
        enumerable: !0,
        value: f,
        writable: !0
      }), Object.defineProperty(t.not, i, {
        configurable: !0,
        enumerable: !0,
        value: /* @__PURE__ */ o((...m) => new p(!0, ...m), "value"),
        writable: !0
      }), Object.defineProperty(globalThis[Vc], i, {
        configurable: !0,
        enumerable: !0,
        value: f,
        writable: !0
      });
    });
  };
}
o(FT, "JestExtendPlugin");
var DF = /* @__PURE__ */ o((e, t) => {
  t.addMethod(e.expect, "extend", (r, n) => {
    hn(FT(e, r, n));
  });
}, "JestExtend");
function BT() {
  hn(DF), hn(LF), hn($F);
  const e = /* @__PURE__ */ o((n, a) => {
    const { assertionCalls: i } = Ra(e);
    return Ci({ assertionCalls: i + 1, soft: !1 }, e), Hr(n, a);
  }, "expect");
  Object.assign(e, Hr), e.getState = () => Ra(e), e.setState = (n) => Ci(n, e), e.extend = (n) => Hr.extend(e, n), e.soft = (...n) => {
    const a = e(...n);
    return e.setState({
      soft: !0
    }), a;
  }, e.extend(AF), e.unreachable = (n) => {
    A.fail(`expected${n ? ` "${n}" ` : " "}not to be reached`);
  };
  function t(n) {
    const a = /* @__PURE__ */ o(() => new Error(
      `expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`
    ), "errorGen");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(a(), t), e.setState({
      expectedAssertionsNumber: n,
      expectedAssertionsNumberErrorGen: a
    });
  }
  o(t, "assertions");
  function r() {
    const n = new Error("expected any number of assertion, but got none");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, r), e.setState({
      isExpectingAssertions: !0,
      isExpectingAssertionsError: n
    });
  }
  return o(r, "hasAssertions"), Ci(
    {
      // this should also add "snapshotState" that is added conditionally
      assertionCalls: 0,
      isExpectingAssertions: !1,
      isExpectingAssertionsError: null,
      expectedAssertionsNumber: null,
      expectedAssertionsNumberErrorGen: null
    },
    e
  ), er.addMethod(e, "assertions", t), er.addMethod(e, "hasAssertions", r), e.extend(Tx), e;
}
o(BT, "createExpect");
var UT = BT();
Object.defineProperty(globalThis, Mm, {
  value: UT,
  writable: !0,
  configurable: !0
});
function HT(e, t, r) {
  Object.defineProperty(e, t, r);
}
o(HT, "f");
var Ri = Symbol.for("tinyspy:spy"), FF = /* @__PURE__ */ o((e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, "P"), BF = /* @__PURE__ */ o((e) => (HT(e, Ri, { value: { reset: /* @__PURE__ */ o(() => FF(e[Ri]), "reset") } }), e[Ri]), "K"), UF = /* @__PURE__ */ o((e) => e[Ri] || BF(e), "T"), ed = /* @__PURE__ */ new Set();
function VT(e) {
  return ed.add(e), () => void ed.delete(e);
}
o(VT, "onMockCall");
function JT(e) {
  const t = e ? Hc(e) : Hc();
  return zT(t);
}
o(JT, "fn");
function zT(e) {
  const t = td(e), r = t.mockImplementation.bind(null);
  return t.mockImplementation = (n) => td(r(n)), t;
}
o(zT, "reactiveMock");
function td(e) {
  const t = UF(e), r = t.impl;
  return t.willCall(function(...n) {
    return ed.forEach((a) => a(e, n)), r?.apply(this, n);
  }), e;
}
o(td, "listenWhenCalled");
function WT() {
  Ll.forEach((e) => e.mockClear());
}
o(WT, "clearAllMocks");
function GT() {
  Ll.forEach((e) => e.mockReset());
}
o(GT, "resetAllMocks");
function KT() {
  Ll.forEach((e) => e.mockRestore());
}
o(KT, "restoreAllMocks");
function HF(e, t = {}) {
  return e;
}
o(HF, "mocked");
var YT = {};
Ua(YT, {
  buildQueries: () => ur,
  configure: () => GS,
  createEvent: () => ua,
  findAllByAltText: () => UP,
  findAllByDisplayValue: () => MP,
  findAllByLabelText: () => hP,
  findAllByPlaceholderText: () => TP,
  findAllByRole: () => rO,
  findAllByTestId: () => lO,
  findAllByText: () => RP,
  findAllByTitle: () => GP,
  findByAltText: () => HP,
  findByDisplayValue: () => $P,
  findByLabelText: () => yP,
  findByPlaceholderText: () => SP,
  findByRole: () => nO,
  findByTestId: () => uO,
  findByText: () => kP,
  findByTitle: () => KP,
  fireEvent: () => go,
  getAllByAltText: () => FP,
  getAllByDisplayValue: () => NP,
  getAllByLabelText: () => gP,
  getAllByPlaceholderText: () => EP,
  getAllByRole: () => eO,
  getAllByTestId: () => iO,
  getAllByText: () => CP,
  getAllByTitle: () => zP,
  getByAltText: () => BP,
  getByDisplayValue: () => qP,
  getByLabelText: () => bP,
  getByPlaceholderText: () => xP,
  getByRole: () => tO,
  getByTestId: () => sO,
  getByText: () => AP,
  getByTitle: () => WP,
  getConfig: () => ge,
  getDefaultNormalizer: () => Vl,
  getElementError: () => ii,
  getMultipleElementsFoundError: () => si,
  getNodeText: () => No,
  getQueriesForElement: () => Es,
  getRoles: () => sh,
  getSuggestedQuery: () => Ia,
  isInaccessible: () => ai,
  logDOM: () => ld,
  logRoles: () => pB,
  makeFindQuery: () => En,
  makeGetAllQuery: () => Wl,
  makeSingleQuery: () => _n,
  prettyDOM: () => yo,
  prettyFormat: () => Um,
  queries: () => _s,
  queryAllByAltText: () => LP,
  queryAllByAttribute: () => nn,
  queryAllByDisplayValue: () => IP,
  queryAllByLabelText: () => vP,
  queryAllByPlaceholderText: () => wP,
  queryAllByRole: () => QP,
  queryAllByTestId: () => oO,
  queryAllByText: () => PP,
  queryAllByTitle: () => VP,
  queryByAltText: () => DP,
  queryByAttribute: () => uh,
  queryByDisplayValue: () => jP,
  queryByLabelText: () => fP,
  queryByPlaceholderText: () => _P,
  queryByRole: () => ZP,
  queryByTestId: () => aO,
  queryByText: () => OP,
  queryByTitle: () => JP,
  queryHelpers: () => fB,
  screen: () => jB,
  waitFor: () => zl,
  waitForElementToBeRemoved: () => dO,
  within: () => Es,
  wrapAllByQueryWithSuggestion: () => pt,
  wrapSingleQueryWithSuggestion: () => Jr
});
var Um = Ye(jD()), VF = Object.prototype.toString;
function rd(e) {
  return typeof e == "function" || VF.call(e) === "[object Function]";
}
o(rd, "isCallable");
function XT(e) {
  var t = Number(e);
  return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
o(XT, "toInteger");
var JF = Math.pow(2, 53) - 1;
function QT(e) {
  var t = XT(e);
  return Math.min(Math.max(t, 0), JF);
}
o(QT, "toLength");
function jt(e, t) {
  var r = Array, n = Object(e);
  if (e == null)
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  if (typeof t < "u" && !rd(t))
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  for (var a = QT(n.length), i = rd(r) ? Object(new r(a)) : new Array(a), s = 0, l; s < a; )
    l = n[s], t ? i[s] = t(l, s) : i[s] = l, s += 1;
  return i.length = a, i;
}
o(jt, "arrayFrom");
function mo(e) {
  "@babel/helpers - typeof";
  return mo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mo(e);
}
o(mo, "_typeof");
function ZT(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
o(ZT, "_classCallCheck");
function nd(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, Hm(n.key), n);
  }
}
o(nd, "_defineProperties");
function eS(e, t, r) {
  return t && nd(e.prototype, t), r && nd(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
o(eS, "_createClass");
function tS(e, t, r) {
  return t = Hm(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
o(tS, "_defineProperty");
function Hm(e) {
  var t = rS(e, "string");
  return mo(t) === "symbol" ? t : String(t);
}
o(Hm, "_toPropertyKey");
function rS(e, t) {
  if (mo(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (mo(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(rS, "_toPrimitive");
var zF = (function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    ZT(this, e), tS(this, "items", void 0), this.items = t;
  }
  return o(e, "SetLike"), eS(e, [{
    key: "add",
    value: /* @__PURE__ */ o(function(t) {
      return this.has(t) === !1 && this.items.push(t), this;
    }, "add")
  }, {
    key: "clear",
    value: /* @__PURE__ */ o(function() {
      this.items = [];
    }, "clear")
  }, {
    key: "delete",
    value: /* @__PURE__ */ o(function(t) {
      var r = this.items.length;
      return this.items = this.items.filter(function(n) {
        return n !== t;
      }), r !== this.items.length;
    }, "_delete")
  }, {
    key: "forEach",
    value: /* @__PURE__ */ o(function(t) {
      var r = this;
      this.items.forEach(function(n) {
        t(n, n, r);
      });
    }, "forEach")
  }, {
    key: "has",
    value: /* @__PURE__ */ o(function(t) {
      return this.items.indexOf(t) !== -1;
    }, "has")
  }, {
    key: "size",
    get: /* @__PURE__ */ o(function() {
      return this.items.length;
    }, "get")
  }]), e;
})(), WF = typeof Set > "u" ? Set : zF;
function et(e) {
  var t;
  return (
    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
    (t = e.localName) !== null && t !== void 0 ? t : (
      // eslint-disable-next-line no-restricted-properties -- required for the fallback
      e.tagName.toLowerCase()
    )
  );
}
o(et, "getLocalName");
var GF = {
  article: "article",
  aside: "complementary",
  button: "button",
  datalist: "listbox",
  dd: "definition",
  details: "group",
  dialog: "dialog",
  dt: "term",
  fieldset: "group",
  figure: "figure",
  // WARNING: Only with an accessible name
  form: "form",
  footer: "contentinfo",
  h1: "heading",
  h2: "heading",
  h3: "heading",
  h4: "heading",
  h5: "heading",
  h6: "heading",
  header: "banner",
  hr: "separator",
  html: "document",
  legend: "legend",
  li: "listitem",
  math: "math",
  main: "main",
  menu: "list",
  nav: "navigation",
  ol: "list",
  optgroup: "group",
  // WARNING: Only in certain context
  option: "option",
  output: "status",
  progress: "progressbar",
  // WARNING: Only with an accessible name
  section: "region",
  summary: "button",
  table: "table",
  tbody: "rowgroup",
  textarea: "textbox",
  tfoot: "rowgroup",
  // WARNING: Only in certain context
  td: "cell",
  th: "columnheader",
  thead: "rowgroup",
  tr: "row",
  ul: "list"
}, KF = {
  caption: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  code: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  deletion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  emphasis: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  generic: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
  insertion: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  paragraph: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  presentation: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  strong: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  subscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"]),
  superscript: /* @__PURE__ */ new Set(["aria-label", "aria-labelledby"])
};
function nS(e, t) {
  return [
    "aria-atomic",
    "aria-busy",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    // "disabled",
    "aria-dropeffect",
    // "errormessage",
    "aria-flowto",
    "aria-grabbed",
    // "haspopup",
    "aria-hidden",
    // "invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-live",
    "aria-owns",
    "aria-relevant",
    "aria-roledescription"
  ].some(function(r) {
    var n;
    return e.hasAttribute(r) && !((n = KF[t]) !== null && n !== void 0 && n.has(r));
  });
}
o(nS, "hasGlobalAriaAttributes");
function Vm(e, t) {
  return nS(e, t);
}
o(Vm, "ignorePresentationalRole");
function oS(e) {
  var t = iS(e);
  if (t === null || t === "presentation") {
    var r = aS(e);
    if (t !== "presentation" || Vm(e, r || ""))
      return r;
  }
  return t;
}
o(oS, "getRole");
function aS(e) {
  var t = GF[et(e)];
  if (t !== void 0)
    return t;
  switch (et(e)) {
    case "a":
    case "area":
    case "link":
      if (e.hasAttribute("href"))
        return "link";
      break;
    case "img":
      return e.getAttribute("alt") === "" && !Vm(e, "img") ? "presentation" : "img";
    case "input": {
      var r = e, n = r.type;
      switch (n) {
        case "button":
        case "image":
        case "reset":
        case "submit":
          return "button";
        case "checkbox":
        case "radio":
          return n;
        case "range":
          return "slider";
        case "email":
        case "tel":
        case "text":
        case "url":
          return e.hasAttribute("list") ? "combobox" : "textbox";
        case "search":
          return e.hasAttribute("list") ? "combobox" : "searchbox";
        case "number":
          return "spinbutton";
        default:
          return null;
      }
    }
    case "select":
      return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox";
  }
  return null;
}
o(aS, "getImplicitRole");
function iS(e) {
  var t = e.getAttribute("role");
  if (t !== null) {
    var r = t.trim().split(" ")[0];
    if (r.length > 0)
      return r;
  }
  return null;
}
o(iS, "getExplicitRole");
function Ne(e) {
  return e !== null && e.nodeType === e.ELEMENT_NODE;
}
o(Ne, "isElement");
function Jm(e) {
  return Ne(e) && et(e) === "caption";
}
o(Jm, "isHTMLTableCaptionElement");
function la(e) {
  return Ne(e) && et(e) === "input";
}
o(la, "isHTMLInputElement");
function sS(e) {
  return Ne(e) && et(e) === "optgroup";
}
o(sS, "isHTMLOptGroupElement");
function lS(e) {
  return Ne(e) && et(e) === "select";
}
o(lS, "isHTMLSelectElement");
function uS(e) {
  return Ne(e) && et(e) === "table";
}
o(uS, "isHTMLTableElement");
function cS(e) {
  return Ne(e) && et(e) === "textarea";
}
o(cS, "isHTMLTextAreaElement");
function dS(e) {
  var t = e.ownerDocument === null ? e : e.ownerDocument, r = t.defaultView;
  if (r === null)
    throw new TypeError("no window available");
  return r;
}
o(dS, "safeWindow");
function pS(e) {
  return Ne(e) && et(e) === "fieldset";
}
o(pS, "isHTMLFieldSetElement");
function fS(e) {
  return Ne(e) && et(e) === "legend";
}
o(fS, "isHTMLLegendElement");
function mS(e) {
  return Ne(e) && et(e) === "slot";
}
o(mS, "isHTMLSlotElement");
function hS(e) {
  return Ne(e) && e.ownerSVGElement !== void 0;
}
o(hS, "isSVGElement");
function yS(e) {
  return Ne(e) && et(e) === "svg";
}
o(yS, "isSVGSVGElement");
function gS(e) {
  return hS(e) && et(e) === "title";
}
o(gS, "isSVGTitleElement");
function ka(e, t) {
  if (Ne(e) && e.hasAttribute(t)) {
    var r = e.getAttribute(t).split(" "), n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return r.map(function(a) {
      return n.getElementById(a);
    }).filter(
      function(a) {
        return a !== null;
      }
      // TODO: why does this not narrow?
    );
  }
  return [];
}
o(ka, "queryIdRefs");
function rr(e, t) {
  return Ne(e) ? t.indexOf(oS(e)) !== -1 : !1;
}
o(rr, "hasAnyConcreteRoles");
function bS(e) {
  return e.trim().replace(/\s\s+/g, " ");
}
o(bS, "asFlatString");
function vS(e, t) {
  if (!Ne(e))
    return !1;
  if (e.hasAttribute("hidden") || e.getAttribute("aria-hidden") === "true")
    return !0;
  var r = t(e);
  return r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}
o(vS, "isHidden");
function wS(e) {
  return rr(e, ["button", "combobox", "listbox", "textbox"]) || zm(e, "range");
}
o(wS, "isControl");
function zm(e, t) {
  if (!Ne(e))
    return !1;
  switch (t) {
    case "range":
      return rr(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
    default:
      throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("));
  }
}
o(zm, "hasAbstractRole");
function od(e, t) {
  var r = jt(e.querySelectorAll(t));
  return ka(e, "aria-owns").forEach(function(n) {
    r.push.apply(r, jt(n.querySelectorAll(t)));
  }), r;
}
o(od, "querySelectorAllSubtree");
function _S(e) {
  return lS(e) ? e.selectedOptions || od(e, "[selected]") : od(e, '[aria-selected="true"]');
}
o(_S, "querySelectedOptions");
function ES(e) {
  return rr(e, ["none", "presentation"]);
}
o(ES, "isMarkedPresentational");
function xS(e) {
  return Jm(e);
}
o(xS, "isNativeHostLanguageTextAlternativeElement");
function TS(e) {
  return rr(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
}
o(TS, "allowsNameFromContent");
function SS(e) {
  return !1;
}
o(SS, "isDescendantOfNativeHostLanguageTextAlternativeElement");
function PS(e) {
  return la(e) || cS(e) ? e.value : e.textContent || "";
}
o(PS, "getValueOfTextbox");
function ad(e) {
  var t = e.getPropertyValue("content");
  return /^["'].*["']$/.test(t) ? t.slice(1, -1) : "";
}
o(ad, "getTextualContent");
function Wm(e) {
  var t = et(e);
  return t === "button" || t === "input" && e.getAttribute("type") !== "hidden" || t === "meter" || t === "output" || t === "progress" || t === "select" || t === "textarea";
}
o(Wm, "isLabelableElement");
function Gm(e) {
  if (Wm(e))
    return e;
  var t = null;
  return e.childNodes.forEach(function(r) {
    if (t === null && Ne(r)) {
      var n = Gm(r);
      n !== null && (t = n);
    }
  }), t;
}
o(Gm, "findLabelableElement");
function OS(e) {
  if (e.control !== void 0)
    return e.control;
  var t = e.getAttribute("for");
  return t !== null ? e.ownerDocument.getElementById(t) : Gm(e);
}
o(OS, "getControlOfLabel");
function CS(e) {
  var t = e.labels;
  if (t === null)
    return t;
  if (t !== void 0)
    return jt(t);
  if (!Wm(e))
    return null;
  var r = e.ownerDocument;
  return jt(r.querySelectorAll("label")).filter(function(n) {
    return OS(n) === e;
  });
}
o(CS, "getLabels");
function AS(e) {
  var t = e.assignedNodes();
  return t.length === 0 ? jt(e.childNodes) : t;
}
o(AS, "getSlotContents");
function Km(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = new WF(), n = dS(e), a = t.compute, i = a === void 0 ? "name" : a, s = t.computedStyleSupportsPseudoElements, l = s === void 0 ? t.getComputedStyle !== void 0 : s, c = t.getComputedStyle, u = c === void 0 ? n.getComputedStyle.bind(n) : c, p = t.hidden, f = p === void 0 ? !1 : p;
  function m(b, E) {
    var C = "";
    if (Ne(b) && l) {
      var k = u(b, "::before"), N = ad(k);
      C = "".concat(N, " ").concat(C);
    }
    var O = mS(b) ? AS(b) : jt(b.childNodes).concat(ka(b, "aria-owns"));
    if (O.forEach(function(T) {
      var M = _(T, {
        isEmbeddedInLabel: E.isEmbeddedInLabel,
        isReferenced: !1,
        recursion: !0
      }), R = Ne(T) ? u(T).getPropertyValue("display") : "inline", D = R !== "inline" ? " " : "";
      C += "".concat(D).concat(M).concat(D);
    }), Ne(b) && l) {
      var S = u(b, "::after"), w = ad(S);
      C = "".concat(C, " ").concat(w);
    }
    return C.trim();
  }
  o(m, "computeMiscTextAlternative");
  function y(b, E) {
    var C = b.getAttributeNode(E);
    return C !== null && !r.has(C) && C.value.trim() !== "" ? (r.add(C), C.value) : null;
  }
  o(y, "useAttribute");
  function g(b) {
    return Ne(b) ? y(b, "title") : null;
  }
  o(g, "computeTooltipAttributeValue");
  function v(b) {
    if (!Ne(b))
      return null;
    if (pS(b)) {
      r.add(b);
      for (var E = jt(b.childNodes), C = 0; C < E.length; C += 1) {
        var k = E[C];
        if (fS(k))
          return _(k, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (uS(b)) {
      r.add(b);
      for (var N = jt(b.childNodes), O = 0; O < N.length; O += 1) {
        var S = N[O];
        if (Jm(S))
          return _(S, {
            isEmbeddedInLabel: !1,
            isReferenced: !1,
            recursion: !1
          });
      }
    } else if (yS(b)) {
      r.add(b);
      for (var w = jt(b.childNodes), T = 0; T < w.length; T += 1) {
        var M = w[T];
        if (gS(M))
          return M.textContent;
      }
      return null;
    } else if (et(b) === "img" || et(b) === "area") {
      var R = y(b, "alt");
      if (R !== null)
        return R;
    } else if (sS(b)) {
      var D = y(b, "label");
      if (D !== null)
        return D;
    }
    if (la(b) && (b.type === "button" || b.type === "submit" || b.type === "reset")) {
      var J = y(b, "value");
      if (J !== null)
        return J;
      if (b.type === "submit")
        return "Submit";
      if (b.type === "reset")
        return "Reset";
    }
    var P = CS(b);
    if (P !== null && P.length !== 0)
      return r.add(b), jt(P).map(function(z) {
        return _(z, {
          isEmbeddedInLabel: !0,
          isReferenced: !1,
          recursion: !0
        });
      }).filter(function(z) {
        return z.length > 0;
      }).join(" ");
    if (la(b) && b.type === "image") {
      var q = y(b, "alt");
      if (q !== null)
        return q;
      var $ = y(b, "title");
      return $ !== null ? $ : "Submit Query";
    }
    if (rr(b, ["button"])) {
      var H = m(b, {
        isEmbeddedInLabel: !1
      });
      if (H !== "")
        return H;
    }
    return null;
  }
  o(v, "computeElementTextAlternative");
  function _(b, E) {
    if (r.has(b))
      return "";
    if (!f && vS(b, u) && !E.isReferenced)
      return r.add(b), "";
    var C = Ne(b) ? b.getAttributeNode("aria-labelledby") : null, k = C !== null && !r.has(C) ? ka(b, "aria-labelledby") : [];
    if (i === "name" && !E.isReferenced && k.length > 0)
      return r.add(C), k.map(function(R) {
        return _(R, {
          isEmbeddedInLabel: E.isEmbeddedInLabel,
          isReferenced: !0,
          // this isn't recursion as specified, otherwise we would skip
          // `aria-label` in
          // <input id="myself" aria-label="foo" aria-labelledby="myself"
          recursion: !1
        });
      }).join(" ");
    var N = E.recursion && wS(b) && i === "name";
    if (!N) {
      var O = (Ne(b) && b.getAttribute("aria-label") || "").trim();
      if (O !== "" && i === "name")
        return r.add(b), O;
      if (!ES(b)) {
        var S = v(b);
        if (S !== null)
          return r.add(b), S;
      }
    }
    if (rr(b, ["menu"]))
      return r.add(b), "";
    if (N || E.isEmbeddedInLabel || E.isReferenced) {
      if (rr(b, ["combobox", "listbox"])) {
        r.add(b);
        var w = _S(b);
        return w.length === 0 ? la(b) ? b.value : "" : jt(w).map(function(R) {
          return _(R, {
            isEmbeddedInLabel: E.isEmbeddedInLabel,
            isReferenced: !1,
            recursion: !0
          });
        }).join(" ");
      }
      if (zm(b, "range"))
        return r.add(b), b.hasAttribute("aria-valuetext") ? b.getAttribute("aria-valuetext") : b.hasAttribute("aria-valuenow") ? b.getAttribute("aria-valuenow") : b.getAttribute("value") || "";
      if (rr(b, ["textbox"]))
        return r.add(b), PS(b);
    }
    if (TS(b) || Ne(b) && E.isReferenced || xS(b) || SS()) {
      var T = m(b, {
        isEmbeddedInLabel: E.isEmbeddedInLabel
      });
      if (T !== "")
        return r.add(b), T;
    }
    if (b.nodeType === b.TEXT_NODE)
      return r.add(b), b.textContent || "";
    if (E.recursion)
      return r.add(b), m(b, {
        isEmbeddedInLabel: E.isEmbeddedInLabel
      });
    var M = g(b);
    return M !== null ? (r.add(b), M) : (r.add(b), "");
  }
  return o(_, "computeTextAlternative"), bS(_(e, {
    isEmbeddedInLabel: !1,
    // by spec computeAccessibleDescription starts with the referenced elements as roots
    isReferenced: i === "description",
    recursion: !1
  }));
}
o(Km, "computeTextAlternative");
function ho(e) {
  "@babel/helpers - typeof";
  return ho = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ho(e);
}
o(ho, "_typeof");
function id(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
o(id, "ownKeys");
function sd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? id(Object(r), !0).forEach(function(n) {
      RS(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : id(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
o(sd, "_objectSpread");
function RS(e, t, r) {
  return t = kS(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
o(RS, "_defineProperty");
function kS(e) {
  var t = IS(e, "string");
  return ho(t) === "symbol" ? t : String(t);
}
o(kS, "_toPropertyKey");
function IS(e, t) {
  if (ho(e) !== "object" || e === null) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (ho(n) !== "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
o(IS, "_toPrimitive");
function Ym(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = ka(e, "aria-describedby").map(function(a) {
    return Km(a, sd(sd({}, t), {}, {
      compute: "description"
    }));
  }).join(" ");
  if (r === "") {
    var n = e.getAttribute("title");
    r = n === null ? "" : n;
  }
  return r;
}
o(Ym, "computeAccessibleDescription");
function jS(e) {
  return rr(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]);
}
o(jS, "prohibitsNaming");
function Ul(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return jS(e) ? "" : Km(e, t);
}
o(Ul, "computeAccessibleName");
var Rt = Ye(of()), YF = Ye(ND());
function Xm(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
o(Xm, "escapeHTML");
var XF = /* @__PURE__ */ o((e, t, r, n, a, i, s) => {
  const l = n + r.indent, c = r.colors;
  return e.map((u) => {
    const p = t[u];
    let f = s(p, r, l, a, i);
    return typeof p != "string" && (f.indexOf(`
`) !== -1 && (f = r.spacingOuter + l + f + r.spacingOuter + n), f = "{" + f + "}"), r.spacingInner + n + c.prop.open + u + c.prop.close + "=" + c.value.open + f + c.value.close;
  }).join("");
}, "printProps"), QF = 3, ZF = /* @__PURE__ */ o((e, t, r, n, a, i) => e.map((s) => {
  const l = typeof s == "string" ? NS(s, t) : i(s, t, r, n, a);
  return l === "" && typeof s == "object" && s !== null && s.nodeType !== QF ? "" : t.spacingOuter + r + l;
}).join(""), "printChildren"), NS = /* @__PURE__ */ o((e, t) => {
  const r = t.colors.content;
  return r.open + Xm(e) + r.close;
}, "printText"), eB = /* @__PURE__ */ o((e, t) => {
  const r = t.colors.comment;
  return r.open + "<!--" + Xm(e) + "-->" + r.close;
}, "printComment"), tB = /* @__PURE__ */ o((e, t, r, n, a) => {
  const i = n.colors.tag;
  return i.open + "<" + e + (t && i.close + t + n.spacingOuter + a + i.open) + (r ? ">" + i.close + r + n.spacingOuter + a + i.open + "</" + e : (t && !n.min ? "" : " ") + "/") + ">" + i.close;
}, "printElement"), rB = /* @__PURE__ */ o((e, t) => {
  const r = t.colors.tag;
  return r.open + "<" + e + r.close + " â€¦" + r.open + " />" + r.close;
}, "printElementAsLeaf"), nB = 1, qS = 3, MS = 8, $S = 11, oB = /^((HTML|SVG)\w*)?Element$/, LS = /* @__PURE__ */ o((e) => {
  const {
    tagName: t
  } = e;
  return !!(typeof t == "string" && t.includes("-") || typeof e.hasAttribute == "function" && e.hasAttribute("is"));
}, "isCustomElement"), aB = /* @__PURE__ */ o((e) => {
  const t = e.constructor.name, {
    nodeType: r
  } = e;
  return r === nB && (oB.test(t) || LS(e)) || r === qS && t === "Text" || r === MS && t === "Comment" || r === $S && t === "DocumentFragment";
}, "testNode");
function DS(e) {
  return e.nodeType === qS;
}
o(DS, "nodeIsText");
function FS(e) {
  return e.nodeType === MS;
}
o(FS, "nodeIsComment");
function ki(e) {
  return e.nodeType === $S;
}
o(ki, "nodeIsFragment");
function BS(e) {
  return {
    test: /* @__PURE__ */ o((t) => {
      var r;
      return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || LS(t)) && aB(t);
    }, "test"),
    serialize: /* @__PURE__ */ o((t, r, n, a, i, s) => {
      if (DS(t))
        return NS(t.data, r);
      if (FS(t))
        return eB(t.data, r);
      const l = ki(t) ? "DocumentFragment" : t.tagName.toLowerCase();
      return ++a > r.maxDepth ? rB(l, r) : tB(l, XF(ki(t) ? [] : Array.from(t.attributes).map((c) => c.name).sort(), ki(t) ? {} : Array.from(t.attributes).reduce((c, u) => (c[u.name] = u.value, c), {}), r, n + r.indent, a, i, s), ZF(Array.prototype.slice.call(t.childNodes || t.children).filter(e), r, n + r.indent, a, i, s), r, n);
    }, "serialize")
  };
}
o(BS, "createDOMElementFilter");
var US = null, Qm = null, Zm = null;
try {
  const e = module && module.require;
  Qm = e.call(module, "fs").readFileSync, Zm = e.call(module, "@babel/code-frame").codeFrameColumns, US = e.call(module, "picocolors");
} catch {
}
function HS(e) {
  const t = e.indexOf("(") + 1, r = e.indexOf(")"), n = e.slice(t, r), a = n.split(":"), [i, s, l] = [a[0], parseInt(a[1], 10), parseInt(a[2], 10)];
  let c = "";
  try {
    c = Qm(i, "utf-8");
  } catch {
    return "";
  }
  const u = Zm(c, {
    start: {
      line: s,
      column: l
    }
  }, {
    highlightCode: !0,
    linesBelow: 0
  });
  return US.dim(n) + `
` + u + `
`;
}
o(HS, "getCodeFrame");
function VS() {
  if (!Qm || !Zm)
    return "";
  const e = new Error().stack.split(`
`).slice(1).find((t) => !t.includes("node_modules/"));
  return HS(e);
}
o(VS, "getUserCodeFrame");
var JS = 3;
function Ii() {
  return typeof jest < "u" && jest !== null ? (
    // legacy timers
    setTimeout._isMockFunction === !0 || // modern timers
    // eslint-disable-next-line prefer-object-has-own -- not supported by our support matrix
    Object.prototype.hasOwnProperty.call(setTimeout, "clock")
  ) : !1;
}
o(Ii, "jestFakeTimersAreEnabled");
function Hl() {
  if (typeof window > "u")
    throw new Error("Could not find default container");
  return window.document;
}
o(Hl, "getDocument");
function eh(e) {
  if (e.defaultView)
    return e.defaultView;
  if (e.ownerDocument && e.ownerDocument.defaultView)
    return e.ownerDocument.defaultView;
  if (e.window)
    return e.window;
  throw e.ownerDocument && e.ownerDocument.defaultView === null ? new Error("It looks like the window object is not available for the provided node.") : e.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(e) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : typeof e.debug == "function" && typeof e.logTestingPlaygroundURL == "function" ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof e + ".");
}
o(eh, "getWindowFromNode");
function lr(e) {
  if (!e || typeof e.querySelector != "function" || typeof e.querySelectorAll != "function")
    throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + t(e) + ".");
  function t(r) {
    return typeof r == "object" ? r === null ? "null" : r.constructor.name : typeof r;
  }
  o(t, "getTypeName");
}
o(lr, "checkContainerType");
var iB = /* @__PURE__ */ o(() => {
  if (typeof process > "u")
    return !1;
  let e;
  try {
    var t;
    const r = (t = Fi) == null ? void 0 : t.COLORS;
    r && (e = JSON.parse(r));
  } catch {
  }
  return typeof e == "boolean" ? e : process.versions !== void 0 && process.versions.node !== void 0;
}, "shouldHighlight"), {
  DOMCollection: sB
} = Um.plugins, lB = 1, uB = 8;
function zS(e) {
  return e.nodeType !== uB && (e.nodeType !== lB || !e.matches(ge().defaultIgnore));
}
o(zS, "filterCommentsAndDefaultIgnoreTagsTags");
function yo(e, t, r) {
  if (r === void 0 && (r = {}), e || (e = Hl().body), typeof t != "number" && (t = typeof process < "u" && typeof Fi < "u" && Fi.DEBUG_PRINT_LIMIT || 7e3), t === 0)
    return "";
  e.documentElement && (e = e.documentElement);
  let n = typeof e;
  if (n === "object" ? n = e.constructor.name : e = {}, !("outerHTML" in e))
    throw new TypeError("Expected an element or document but got " + n);
  const {
    filterNode: a = zS,
    ...i
  } = r, s = Um.format(e, {
    plugins: [BS(a), sB],
    printFunctionName: !1,
    highlight: iB(),
    ...i
  });
  return t !== void 0 && e.outerHTML.length > t ? s.slice(0, t) + "..." : s;
}
o(yo, "prettyDOM");
var ld = /* @__PURE__ */ o(function() {
  const e = VS();
  console.log(e ? yo(...arguments) + `

` + e : yo(...arguments));
}, "logDOM"), gn = {
  testIdAttribute: "data-testid",
  asyncUtilTimeout: 1e3,
  // asyncWrapper and advanceTimersWrapper is to support React's async `act` function.
  // forcing react-testing-library to wrap all async functions would've been
  // a total nightmare (consider wrapping every findBy* query and then also
  // updating `within` so those would be wrapped too. Total nightmare).
  // so we have this config option that's really only intended for
  // react-testing-library to use. For that reason, this feature will remain
  // undocumented.
  asyncWrapper: /* @__PURE__ */ o((e) => e(), "asyncWrapper"),
  unstable_advanceTimersWrapper: /* @__PURE__ */ o((e) => e(), "unstable_advanceTimersWrapper"),
  eventWrapper: /* @__PURE__ */ o((e) => e(), "eventWrapper"),
  // default value for the `hidden` option in `ByRole` queries
  defaultHidden: !1,
  // default value for the `ignore` option in `ByText` queries
  defaultIgnore: "script, style",
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: !1,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: !1,
  // called when getBy* queries fail. (message, container) => Error
  getElementError(e, t) {
    const r = yo(t), n = new Error([e, "Ignored nodes: comments, " + gn.defaultIgnore + `
` + r].filter(Boolean).join(`

`));
    return n.name = "TestingLibraryElementError", n;
  },
  _disableExpensiveErrorDiagnostics: !1,
  computedStyleSupportsPseudoElements: !1
};
function WS(e) {
  try {
    return gn._disableExpensiveErrorDiagnostics = !0, e();
  } finally {
    gn._disableExpensiveErrorDiagnostics = !1;
  }
}
o(WS, "runWithExpensiveErrorDiagnosticsDisabled");
function GS(e) {
  typeof e == "function" && (e = e(gn)), gn = {
    ...gn,
    ...e
  };
}
o(GS, "configure");
function ge() {
  return gn;
}
o(ge, "getConfig");
var cB = ["button", "meter", "output", "progress", "select", "textarea", "input"];
function th(e) {
  return cB.includes(e.nodeName.toLowerCase()) ? "" : e.nodeType === JS ? e.textContent : Array.from(e.childNodes).map((t) => th(t)).join("");
}
o(th, "getTextContent");
function ws(e) {
  let t;
  return e.tagName.toLowerCase() === "label" ? t = th(e) : t = e.value || e.textContent, t;
}
o(ws, "getLabelContent");
function rh(e) {
  if (e.labels !== void 0) {
    var t;
    return (t = e.labels) != null ? t : [];
  }
  if (!KS(e)) return [];
  const r = e.ownerDocument.querySelectorAll("label");
  return Array.from(r).filter((n) => n.control === e);
}
o(rh, "getRealLabels");
function KS(e) {
  return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) || e.tagName === "INPUT" && e.getAttribute("type") !== "hidden";
}
o(KS, "isLabelable");
function nh(e, t, r) {
  let {
    selector: n = "*"
  } = r === void 0 ? {} : r;
  const a = t.getAttribute("aria-labelledby"), i = a ? a.split(" ") : [];
  return i.length ? i.map((s) => {
    const l = e.querySelector('[id="' + s + '"]');
    return l ? {
      content: ws(l),
      formControl: null
    } : {
      content: "",
      formControl: null
    };
  }) : Array.from(rh(t)).map((s) => {
    const l = ws(s), c = Array.from(s.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((u) => u.matches(n))[0];
    return {
      content: l,
      formControl: c
    };
  });
}
o(nh, "getLabels");
function oh(e) {
  if (e == null)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
      "It looks like " + e + " was passed instead of a matcher. Did you do something like getByText(" + e + ")?"
    );
}
o(oh, "assertNotNullOrUndefined");
function qn(e, t, r, n) {
  if (typeof e != "string")
    return !1;
  oh(r);
  const a = n(e);
  return typeof r == "string" || typeof r == "number" ? a.toLowerCase().includes(r.toString().toLowerCase()) : typeof r == "function" ? r(a, t) : ah(r, a);
}
o(qn, "fuzzyMatches");
function or(e, t, r, n) {
  if (typeof e != "string")
    return !1;
  oh(r);
  const a = n(e);
  return r instanceof Function ? r(a, t) : r instanceof RegExp ? ah(r, a) : a === String(r);
}
o(or, "matches");
function Vl(e) {
  let {
    trim: t = !0,
    collapseWhitespace: r = !0
  } = e === void 0 ? {} : e;
  return (n) => {
    let a = n;
    return a = t ? a.trim() : a, a = r ? a.replace(/\s+/g, " ") : a, a;
  };
}
o(Vl, "getDefaultNormalizer");
function rn(e) {
  let {
    trim: t,
    collapseWhitespace: r,
    normalizer: n
  } = e;
  if (!n)
    return Vl({
      trim: t,
      collapseWhitespace: r
    });
  if (typeof t < "u" || typeof r < "u")
    throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
  return n;
}
o(rn, "makeNormalizer");
function ah(e, t) {
  const r = e.test(t);
  return e.global && e.lastIndex !== 0 && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), e.lastIndex = 0), r;
}
o(ah, "matchRegExp");
function No(e) {
  return e.matches("input[type=submit], input[type=button], input[type=reset]") ? e.value : Array.from(e.childNodes).filter((t) => t.nodeType === JS && !!t.textContent).map((t) => t.textContent).join("");
}
o(No, "getNodeText");
var dB = YS(Rt.elementRoles);
function ih(e) {
  return e.hidden === !0 || e.getAttribute("aria-hidden") === "true" || e.ownerDocument.defaultView.getComputedStyle(e).display === "none";
}
o(ih, "isSubtreeInaccessible");
function ai(e, t) {
  t === void 0 && (t = {});
  const {
    isSubtreeInaccessible: r = ih
  } = t;
  if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === "hidden")
    return !0;
  let n = e;
  for (; n; ) {
    if (r(n))
      return !0;
    n = n.parentElement;
  }
  return !1;
}
o(ai, "isInaccessible");
function Jl(e) {
  for (const {
    match: t,
    roles: r
  } of dB)
    if (t(e))
      return [...r];
  return [];
}
o(Jl, "getImplicitAriaRoles");
function YS(e) {
  function t(s) {
    let {
      name: l,
      attributes: c
    } = s;
    return "" + l + c.map((u) => {
      let {
        name: p,
        value: f,
        constraints: m = []
      } = u;
      const y = m.indexOf("undefined") !== -1, g = m.indexOf("set") !== -1;
      return typeof f < "u" ? "[" + p + '="' + f + '"]' : y ? ":not([" + p + "])" : g ? "[" + p + "]:not([" + p + '=""])' : "[" + p + "]";
    }).join("");
  }
  o(t, "makeElementSelector");
  function r(s) {
    let {
      attributes: l = []
    } = s;
    return l.length;
  }
  o(r, "getSelectorSpecificity");
  function n(s, l) {
    let {
      specificity: c
    } = s, {
      specificity: u
    } = l;
    return u - c;
  }
  o(n, "bySelectorSpecificity");
  function a(s) {
    let {
      attributes: l = []
    } = s;
    const c = l.findIndex((p) => p.value && p.name === "type" && p.value === "text");
    c >= 0 && (l = [...l.slice(0, c), ...l.slice(c + 1)]);
    const u = t({
      ...s,
      attributes: l
    });
    return (p) => c >= 0 && p.type !== "text" ? !1 : p.matches(u);
  }
  o(a, "match");
  let i = [];
  for (const [s, l] of e.entries())
    i = [...i, {
      match: a(s),
      roles: Array.from(l),
      specificity: r(s)
    }];
  return i.sort(n);
}
o(YS, "buildElementRoleList");
function sh(e, t) {
  let {
    hidden: r = !1
  } = t === void 0 ? {} : t;
  function n(a) {
    return [a, ...Array.from(a.children).reduce((i, s) => [...i, ...n(s)], [])];
  }
  return o(n, "flattenDOM"), n(e).filter((a) => r === !1 ? ai(a) === !1 : !0).reduce((a, i) => {
    let s = [];
    return i.hasAttribute("role") ? s = i.getAttribute("role").split(" ").slice(0, 1) : s = Jl(i), s.reduce((l, c) => Array.isArray(l[c]) ? {
      ...l,
      [c]: [...l[c], i]
    } : {
      ...l,
      [c]: [i]
    }, a);
  }, {});
}
o(sh, "getRoles");
function lh(e, t) {
  let {
    hidden: r,
    includeDescription: n
  } = t;
  const a = sh(e, {
    hidden: r
  });
  return Object.entries(a).filter((i) => {
    let [s] = i;
    return s !== "generic";
  }).map((i) => {
    let [s, l] = i;
    const c = "-".repeat(50), u = l.map((p) => {
      const f = 'Name "' + Ul(p, {
        computedStyleSupportsPseudoElements: ge().computedStyleSupportsPseudoElements
      }) + `":
`, m = yo(p.cloneNode(!1));
      if (n) {
        const y = 'Description "' + Ym(p, {
          computedStyleSupportsPseudoElements: ge().computedStyleSupportsPseudoElements
        }) + `":
`;
        return "" + f + y + m;
      }
      return "" + f + m;
    }).join(`

`);
    return s + `:

` + u + `

` + c;
  }).join(`
`);
}
o(lh, "prettyRoles");
var pB = /* @__PURE__ */ o(function(e, t) {
  let {
    hidden: r = !1
  } = t === void 0 ? {} : t;
  return console.log(lh(e, {
    hidden: r
  }));
}, "logRoles");
function XS(e) {
  return e.tagName === "OPTION" ? e.selected : qo(e, "aria-selected");
}
o(XS, "computeAriaSelected");
function QS(e) {
  return e.getAttribute("aria-busy") === "true";
}
o(QS, "computeAriaBusy");
function ZS(e) {
  if (!("indeterminate" in e && e.indeterminate))
    return "checked" in e ? e.checked : qo(e, "aria-checked");
}
o(ZS, "computeAriaChecked");
function eP(e) {
  return qo(e, "aria-pressed");
}
o(eP, "computeAriaPressed");
function tP(e) {
  var t, r;
  return (t = (r = qo(e, "aria-current")) != null ? r : e.getAttribute("aria-current")) != null ? t : !1;
}
o(tP, "computeAriaCurrent");
function rP(e) {
  return qo(e, "aria-expanded");
}
o(rP, "computeAriaExpanded");
function qo(e, t) {
  const r = e.getAttribute(t);
  if (r === "true")
    return !0;
  if (r === "false")
    return !1;
}
o(qo, "checkBooleanAttribute");
function nP(e) {
  const t = {
    H1: 1,
    H2: 2,
    H3: 3,
    H4: 4,
    H5: 5,
    H6: 6
  };
  return e.getAttribute("aria-level") && Number(e.getAttribute("aria-level")) || t[e.tagName];
}
o(nP, "computeHeadingLevel");
function oP(e) {
  const t = e.getAttribute("aria-valuenow");
  return t === null ? void 0 : +t;
}
o(oP, "computeAriaValueNow");
function aP(e) {
  const t = e.getAttribute("aria-valuemax");
  return t === null ? void 0 : +t;
}
o(aP, "computeAriaValueMax");
function iP(e) {
  const t = e.getAttribute("aria-valuemin");
  return t === null ? void 0 : +t;
}
o(iP, "computeAriaValueMin");
function sP(e) {
  const t = e.getAttribute("aria-valuetext");
  return t === null ? void 0 : t;
}
o(sP, "computeAriaValueText");
var yg = Vl();
function lP(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
o(lP, "escapeRegExp");
function ud(e) {
  return new RegExp(lP(e.toLowerCase()), "i");
}
o(ud, "getRegExpMatcher");
function gr(e, t, r, n) {
  let {
    variant: a,
    name: i
  } = n, s = "";
  const l = {}, c = [["Role", "TestId"].includes(e) ? r : ud(r)];
  i && (l.name = ud(i)), e === "Role" && ai(t) && (l.hidden = !0, s = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `), Object.keys(l).length > 0 && c.push(l);
  const u = a + "By" + e;
  return {
    queryName: e,
    queryMethod: u,
    queryArgs: c,
    variant: a,
    warning: s,
    toString() {
      s && console.warn(s);
      let [p, f] = c;
      return p = typeof p == "string" ? "'" + p + "'" : p, f = f ? ", { " + Object.entries(f).map((m) => {
        let [y, g] = m;
        return y + ": " + g;
      }).join(", ") + " }" : "", u + "(" + p + f + ")";
    }
  };
}
o(gr, "makeSuggestion");
function br(e, t, r) {
  return r && (!t || t.toLowerCase() === e.toLowerCase());
}
o(br, "canSuggest");
function Ia(e, t, r) {
  var n, a;
  if (t === void 0 && (t = "get"), e.matches(ge().defaultIgnore))
    return;
  const i = (n = e.getAttribute("role")) != null ? n : (a = Jl(e)) == null ? void 0 : a[0];
  if (i !== "generic" && br("Role", r, i))
    return gr("Role", e, i, {
      variant: t,
      name: Ul(e, {
        computedStyleSupportsPseudoElements: ge().computedStyleSupportsPseudoElements
      })
    });
  const s = nh(document, e).map((m) => m.content).join(" ");
  if (br("LabelText", r, s))
    return gr("LabelText", e, s, {
      variant: t
    });
  const l = e.getAttribute("placeholder");
  if (br("PlaceholderText", r, l))
    return gr("PlaceholderText", e, l, {
      variant: t
    });
  const c = yg(No(e));
  if (br("Text", r, c))
    return gr("Text", e, c, {
      variant: t
    });
  if (br("DisplayValue", r, e.value))
    return gr("DisplayValue", e, yg(e.value), {
      variant: t
    });
  const u = e.getAttribute("alt");
  if (br("AltText", r, u))
    return gr("AltText", e, u, {
      variant: t
    });
  const p = e.getAttribute("title");
  if (br("Title", r, p))
    return gr("Title", e, p, {
      variant: t
    });
  const f = e.getAttribute(ge().testIdAttribute);
  if (br("TestId", r, f))
    return gr("TestId", e, f, {
      variant: t
    });
}
o(Ia, "getSuggestedQuery");
function Ko(e, t) {
  e.stack = t.stack.replace(t.message, e.message);
}
o(Ko, "copyStackTrace");
function uP(e, t) {
  let {
    container: r = Hl(),
    timeout: n = ge().asyncUtilTimeout,
    showOriginalStackTrace: a = ge().showOriginalStackTrace,
    stackTraceError: i,
    interval: s = 50,
    onTimeout: l = /* @__PURE__ */ o((u) => (Object.defineProperty(u, "message", {
      value: ge().getElementError(u.message, r).message
    }), u), "onTimeout"),
    mutationObserverOptions: c = {
      subtree: !0,
      childList: !0,
      attributes: !0,
      characterData: !0
    }
  } = t;
  if (typeof e != "function")
    throw new TypeError("Received `callback` arg must be a function");
  return new Promise(async (u, p) => {
    let f, m, y, g = !1, v = "idle";
    const _ = setTimeout(N, n), b = Ii();
    if (b) {
      const {
        unstable_advanceTimersWrapper: O
      } = ge();
      for (k(); !g; ) {
        if (!Ii()) {
          const S = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
          a || Ko(S, i), p(S);
          return;
        }
        if (await O(async () => {
          jest.advanceTimersByTime(s);
        }), g)
          break;
        k();
      }
    } else {
      try {
        lr(r);
      } catch (S) {
        p(S);
        return;
      }
      m = setInterval(C, s);
      const {
        MutationObserver: O
      } = eh(r);
      y = new O(C), y.observe(r, c), k();
    }
    function E(O, S) {
      g = !0, clearTimeout(_), b || (clearInterval(m), y.disconnect()), O ? p(O) : u(S);
    }
    o(E, "onDone");
    function C() {
      if (Ii()) {
        const O = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
        return a || Ko(O, i), p(O);
      } else
        return k();
    }
    o(C, "checkRealTimersCallback");
    function k() {
      if (v !== "pending")
        try {
          const O = WS(e);
          typeof O?.then == "function" ? (v = "pending", O.then((S) => {
            v = "resolved", E(null, S);
          }, (S) => {
            v = "rejected", f = S;
          })) : E(null, O);
        } catch (O) {
          f = O;
        }
    }
    o(k, "checkCallback");
    function N() {
      let O;
      f ? (O = f, !a && O.name === "TestingLibraryElementError" && Ko(O, i)) : (O = new Error("Timed out in waitFor."), a || Ko(O, i)), E(l(O), null);
    }
    o(N, "handleTimeout");
  });
}
o(uP, "waitFor");
function zl(e, t) {
  const r = new Error("STACK_TRACE_MESSAGE");
  return ge().asyncWrapper(() => uP(e, {
    stackTraceError: r,
    ...t
  }));
}
o(zl, "waitForWrapper");
function ii(e, t) {
  return ge().getElementError(e, t);
}
o(ii, "getElementError");
function si(e, t) {
  return ii(e + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", t);
}
o(si, "getMultipleElementsFoundError");
function nn(e, t, r, n) {
  let {
    exact: a = !0,
    collapseWhitespace: i,
    trim: s,
    normalizer: l
  } = n === void 0 ? {} : n;
  const c = a ? or : qn, u = rn({
    collapseWhitespace: i,
    trim: s,
    normalizer: l
  });
  return Array.from(t.querySelectorAll("[" + e + "]")).filter((p) => c(p.getAttribute(e), p, r, u));
}
o(nn, "queryAllByAttribute");
function uh(e, t, r, n) {
  const a = nn(e, t, r, n);
  if (a.length > 1)
    throw si("Found multiple elements by [" + e + "=" + r + "]", t);
  return a[0] || null;
}
o(uh, "queryByAttribute");
function _n(e, t) {
  return function(r) {
    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      a[i - 1] = arguments[i];
    const s = e(r, ...a);
    if (s.length > 1) {
      const l = s.map((c) => ii(null, c).message).join(`

`);
      throw si(t(r, ...a) + `

Here are the matching elements:

` + l, r);
    }
    return s[0] || null;
  };
}
o(_n, "makeSingleQuery");
function ch(e, t) {
  return ge().getElementError(`A better query is available, try this:
` + e.toString() + `
`, t);
}
o(ch, "getSuggestionError");
function Wl(e, t) {
  return function(r) {
    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      a[i - 1] = arguments[i];
    const s = e(r, ...a);
    if (!s.length)
      throw ge().getElementError(t(r, ...a), r);
    return s;
  };
}
o(Wl, "makeGetAllQuery");
function En(e) {
  return (t, r, n, a) => zl(() => e(t, r, n), {
    container: t,
    ...a
  });
}
o(En, "makeFindQuery");
var Jr = /* @__PURE__ */ o((e, t, r) => function(n) {
  for (var a = arguments.length, i = new Array(a > 1 ? a - 1 : 0), s = 1; s < a; s++)
    i[s - 1] = arguments[s];
  const l = e(n, ...i), [{
    suggest: c = ge().throwSuggestions
  } = {}] = i.slice(-1);
  if (l && c) {
    const u = Ia(l, r);
    if (u && !t.endsWith(u.queryName))
      throw ch(u.toString(), n);
  }
  return l;
}, "wrapSingleQueryWithSuggestion"), pt = /* @__PURE__ */ o((e, t, r) => function(n) {
  for (var a = arguments.length, i = new Array(a > 1 ? a - 1 : 0), s = 1; s < a; s++)
    i[s - 1] = arguments[s];
  const l = e(n, ...i), [{
    suggest: c = ge().throwSuggestions
  } = {}] = i.slice(-1);
  if (l.length && c) {
    const u = [...new Set(l.map((p) => {
      var f;
      return (f = Ia(p, r)) == null ? void 0 : f.toString();
    }))];
    if (
      // only want to suggest if all the els have the same suggestion.
      u.length === 1 && !t.endsWith(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- TODO: Can this be null at runtime?
        Ia(l[0], r).queryName
      )
    )
      throw ch(u[0], n);
  }
  return l;
}, "wrapAllByQueryWithSuggestion");
function ur(e, t, r) {
  const n = Jr(_n(e, t), e.name, "query"), a = Wl(e, r), i = _n(a, t), s = Jr(i, e.name, "get"), l = pt(a, e.name.replace("query", "get"), "getAll"), c = En(pt(a, e.name, "findAll")), u = En(Jr(i, e.name, "find"));
  return [n, l, s, c, u];
}
o(ur, "buildQueries");
var fB = Object.freeze({
  __proto__: null,
  getElementError: ii,
  wrapAllByQueryWithSuggestion: pt,
  wrapSingleQueryWithSuggestion: Jr,
  getMultipleElementsFoundError: si,
  queryAllByAttribute: nn,
  queryByAttribute: uh,
  makeSingleQuery: _n,
  makeGetAllQuery: Wl,
  makeFindQuery: En,
  buildQueries: ur
});
function cP(e) {
  return Array.from(e.querySelectorAll("label,input")).map((t) => ({
    node: t,
    textToMatch: ws(t)
  })).filter((t) => {
    let {
      textToMatch: r
    } = t;
    return r !== null;
  });
}
o(cP, "queryAllLabels");
var mB = /* @__PURE__ */ o(function(e, t, r) {
  let {
    exact: n = !0,
    trim: a,
    collapseWhitespace: i,
    normalizer: s
  } = r === void 0 ? {} : r;
  const l = n ? or : qn, c = rn({
    collapseWhitespace: i,
    trim: a,
    normalizer: s
  });
  return cP(e).filter((u) => {
    let {
      node: p,
      textToMatch: f
    } = u;
    return l(f, p, t, c);
  }).map((u) => {
    let {
      node: p
    } = u;
    return p;
  });
}, "queryAllLabelsByText"), ja = /* @__PURE__ */ o(function(e, t, r) {
  let {
    selector: n = "*",
    exact: a = !0,
    collapseWhitespace: i,
    trim: s,
    normalizer: l
  } = r === void 0 ? {} : r;
  lr(e);
  const c = a ? or : qn, u = rn({
    collapseWhitespace: i,
    trim: s,
    normalizer: l
  }), p = Array.from(e.querySelectorAll("*")).filter((f) => rh(f).length || f.hasAttribute("aria-labelledby")).reduce((f, m) => {
    const y = nh(e, m, {
      selector: n
    });
    y.filter((v) => !!v.formControl).forEach((v) => {
      c(v.content, v.formControl, t, u) && v.formControl && f.push(v.formControl);
    });
    const g = y.filter((v) => !!v.content).map((v) => v.content);
    return c(g.join(" "), m, t, u) && f.push(m), g.length > 1 && g.forEach((v, _) => {
      c(v, m, t, u) && f.push(m);
      const b = [...g];
      b.splice(_, 1), b.length > 1 && c(b.join(" "), m, t, u) && f.push(m);
    }), f;
  }, []).concat(nn("aria-label", e, t, {
    exact: a,
    normalizer: u
  }));
  return Array.from(new Set(p)).filter((f) => f.matches(n));
}, "queryAllByLabelText"), xn = /* @__PURE__ */ o(function(e, t) {
  for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), a = 2; a < r; a++)
    n[a - 2] = arguments[a];
  const i = ja(e, t, ...n);
  if (!i.length) {
    const s = mB(e, t, ...n);
    if (s.length) {
      const l = s.map((c) => dP(e, c)).filter((c) => !!c);
      throw l.length ? ge().getElementError(l.map((c) => "Found a label with the text of: " + t + ", however the element associated with this label (<" + c + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + c + " />, you can use aria-label or aria-labelledby instead.").join(`

`), e) : ge().getElementError("Found a label with the text of: " + t + `, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`, e);
    } else
      throw ge().getElementError("Unable to find a label with the text of: " + t, e);
  }
  return i;
}, "getAllByLabelText");
function dP(e, t) {
  const r = t.getAttribute("for");
  if (!r)
    return null;
  const n = e.querySelector('[id="' + r + '"]');
  return n ? n.tagName.toLowerCase() : null;
}
o(dP, "getTagNameOfElementAssociatedWithLabelViaFor");
var pP = /* @__PURE__ */ o((e, t) => "Found multiple elements with the text of: " + t, "getMultipleError$7"), fP = Jr(_n(ja, pP), ja.name, "query"), mP = _n(xn, pP), hP = En(pt(xn, xn.name, "findAll")), yP = En(Jr(mP, xn.name, "find")), gP = pt(xn, xn.name, "getAll"), bP = Jr(mP, xn.name, "get"), vP = pt(ja, ja.name, "queryAll"), cd = /* @__PURE__ */ o(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return lr(t[0]), nn("placeholder", ...t);
}, "queryAllByPlaceholderText"), hB = /* @__PURE__ */ o((e, t) => "Found multiple elements with the placeholder text of: " + t, "getMultipleError$6"), yB = /* @__PURE__ */ o((e, t) => "Unable to find an element with the placeholder text of: " + t, "getMissingError$6"), wP = pt(cd, cd.name, "queryAll"), [_P, EP, xP, TP, SP] = ur(cd, hB, yB), dd = /* @__PURE__ */ o(function(e, t, r) {
  let {
    selector: n = "*",
    exact: a = !0,
    collapseWhitespace: i,
    trim: s,
    ignore: l = ge().defaultIgnore,
    normalizer: c
  } = r === void 0 ? {} : r;
  lr(e);
  const u = a ? or : qn, p = rn({
    collapseWhitespace: i,
    trim: s,
    normalizer: c
  });
  let f = [];
  return typeof e.matches == "function" && e.matches(n) && (f = [e]), [...f, ...Array.from(e.querySelectorAll(n))].filter((m) => !l || !m.matches(l)).filter((m) => u(No(m), m, t, p));
}, "queryAllByText"), gB = /* @__PURE__ */ o((e, t) => "Found multiple elements with the text: " + t, "getMultipleError$5"), bB = /* @__PURE__ */ o(function(e, t, r) {
  r === void 0 && (r = {});
  const {
    collapseWhitespace: n,
    trim: a,
    normalizer: i,
    selector: s
  } = r, l = rn({
    collapseWhitespace: n,
    trim: a,
    normalizer: i
  })(t.toString()), c = l !== t.toString(), u = (s ?? "*") !== "*";
  return "Unable to find an element with the text: " + (c ? l + " (normalized from '" + t + "')" : t) + (u ? ", which matches selector '" + s + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.";
}, "getMissingError$5"), PP = pt(dd, dd.name, "queryAll"), [OP, CP, AP, RP, kP] = ur(dd, gB, bB), pd = /* @__PURE__ */ o(function(e, t, r) {
  let {
    exact: n = !0,
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  } = r === void 0 ? {} : r;
  lr(e);
  const l = n ? or : qn, c = rn({
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  });
  return Array.from(e.querySelectorAll("input,textarea,select")).filter((u) => u.tagName === "SELECT" ? Array.from(u.options).filter((p) => p.selected).some((p) => l(No(p), p, t, c)) : l(u.value, u, t, c));
}, "queryAllByDisplayValue"), vB = /* @__PURE__ */ o((e, t) => "Found multiple elements with the display value: " + t + ".", "getMultipleError$4"), wB = /* @__PURE__ */ o((e, t) => "Unable to find an element with the display value: " + t + ".", "getMissingError$4"), IP = pt(pd, pd.name, "queryAll"), [jP, NP, qP, MP, $P] = ur(pd, vB, wB), _B = /^(img|input|area|.+-.+)$/i, fd = /* @__PURE__ */ o(function(e, t, r) {
  return r === void 0 && (r = {}), lr(e), nn("alt", e, t, r).filter((n) => _B.test(n.tagName));
}, "queryAllByAltText"), EB = /* @__PURE__ */ o((e, t) => "Found multiple elements with the alt text: " + t, "getMultipleError$3"), xB = /* @__PURE__ */ o((e, t) => "Unable to find an element with the alt text: " + t, "getMissingError$3"), LP = pt(fd, fd.name, "queryAll"), [DP, FP, BP, UP, HP] = ur(fd, EB, xB), TB = /* @__PURE__ */ o((e) => {
  var t;
  return e.tagName.toLowerCase() === "title" && ((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === "svg";
}, "isSvgTitle"), md = /* @__PURE__ */ o(function(e, t, r) {
  let {
    exact: n = !0,
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  } = r === void 0 ? {} : r;
  lr(e);
  const l = n ? or : qn, c = rn({
    collapseWhitespace: a,
    trim: i,
    normalizer: s
  });
  return Array.from(e.querySelectorAll("[title], svg > title")).filter((u) => l(u.getAttribute("title"), u, t, c) || TB(u) && l(No(u), u, t, c));
}, "queryAllByTitle"), SB = /* @__PURE__ */ o((e, t) => "Found multiple elements with the title: " + t + ".", "getMultipleError$2"), PB = /* @__PURE__ */ o((e, t) => "Unable to find an element with the title: " + t + ".", "getMissingError$2"), VP = pt(md, md.name, "queryAll"), [JP, zP, WP, GP, KP] = ur(md, SB, PB), hd = /* @__PURE__ */ o(function(e, t, r) {
  let {
    hidden: n = ge().defaultHidden,
    name: a,
    description: i,
    queryFallbacks: s = !1,
    selected: l,
    busy: c,
    checked: u,
    pressed: p,
    current: f,
    level: m,
    expanded: y,
    value: {
      now: g,
      min: v,
      max: _,
      text: b
    } = {}
  } = r === void 0 ? {} : r;
  if (lr(e), l !== void 0) {
    var E;
    if (((E = Rt.roles.get(t)) == null ? void 0 : E.props["aria-selected"]) === void 0)
      throw new Error('"aria-selected" is not supported on role "' + t + '".');
  }
  if (c !== void 0) {
    var C;
    if (((C = Rt.roles.get(t)) == null ? void 0 : C.props["aria-busy"]) === void 0)
      throw new Error('"aria-busy" is not supported on role "' + t + '".');
  }
  if (u !== void 0) {
    var k;
    if (((k = Rt.roles.get(t)) == null ? void 0 : k.props["aria-checked"]) === void 0)
      throw new Error('"aria-checked" is not supported on role "' + t + '".');
  }
  if (p !== void 0) {
    var N;
    if (((N = Rt.roles.get(t)) == null ? void 0 : N.props["aria-pressed"]) === void 0)
      throw new Error('"aria-pressed" is not supported on role "' + t + '".');
  }
  if (f !== void 0) {
    var O;
    if (((O = Rt.roles.get(t)) == null ? void 0 : O.props["aria-current"]) === void 0)
      throw new Error('"aria-current" is not supported on role "' + t + '".');
  }
  if (m !== void 0 && t !== "heading")
    throw new Error('Role "' + t + '" cannot have "level" property.');
  if (g !== void 0) {
    var S;
    if (((S = Rt.roles.get(t)) == null ? void 0 : S.props["aria-valuenow"]) === void 0)
      throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
  }
  if (_ !== void 0) {
    var w;
    if (((w = Rt.roles.get(t)) == null ? void 0 : w.props["aria-valuemax"]) === void 0)
      throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
  }
  if (v !== void 0) {
    var T;
    if (((T = Rt.roles.get(t)) == null ? void 0 : T.props["aria-valuemin"]) === void 0)
      throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
  }
  if (b !== void 0) {
    var M;
    if (((M = Rt.roles.get(t)) == null ? void 0 : M.props["aria-valuetext"]) === void 0)
      throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
  }
  if (y !== void 0) {
    var R;
    if (((R = Rt.roles.get(t)) == null ? void 0 : R.props["aria-expanded"]) === void 0)
      throw new Error('"aria-expanded" is not supported on role "' + t + '".');
  }
  const D = /* @__PURE__ */ new WeakMap();
  function J(P) {
    return D.has(P) || D.set(P, ih(P)), D.get(P);
  }
  return o(J, "cachedIsSubtreeInaccessible"), Array.from(e.querySelectorAll(
    // Only query elements that can be matched by the following filters
    YP(t)
  )).filter((P) => {
    if (P.hasAttribute("role")) {
      const q = P.getAttribute("role");
      if (s)
        return q.split(" ").filter(Boolean).some((H) => H === t);
      const [$] = q.split(" ");
      return $ === t;
    }
    return Jl(P).some((q) => q === t);
  }).filter((P) => {
    if (l !== void 0)
      return l === XS(P);
    if (c !== void 0)
      return c === QS(P);
    if (u !== void 0)
      return u === ZS(P);
    if (p !== void 0)
      return p === eP(P);
    if (f !== void 0)
      return f === tP(P);
    if (y !== void 0)
      return y === rP(P);
    if (m !== void 0)
      return m === nP(P);
    if (g !== void 0 || _ !== void 0 || v !== void 0 || b !== void 0) {
      let $ = !0;
      if (g !== void 0 && $ && ($ = g === oP(P)), _ !== void 0 && $ && ($ = _ === aP(P)), v !== void 0 && $ && ($ = v === iP(P)), b !== void 0) {
        var q;
        $ && ($ = or((q = sP(P)) != null ? q : null, P, b, (H) => H));
      }
      return $;
    }
    return !0;
  }).filter((P) => a === void 0 ? !0 : or(Ul(P, {
    computedStyleSupportsPseudoElements: ge().computedStyleSupportsPseudoElements
  }), P, a, (q) => q)).filter((P) => i === void 0 ? !0 : or(Ym(P, {
    computedStyleSupportsPseudoElements: ge().computedStyleSupportsPseudoElements
  }), P, i, (q) => q)).filter((P) => n === !1 ? ai(P, {
    isSubtreeInaccessible: J
  }) === !1 : !0);
}, "queryAllByRole");
function YP(e) {
  var t;
  const r = '*[role~="' + e + '"]', n = (t = Rt.roleElements.get(e)) != null ? t : /* @__PURE__ */ new Set(), a = new Set(Array.from(n).map((i) => {
    let {
      name: s
    } = i;
    return s;
  }));
  return [r].concat(Array.from(a)).join(",");
}
o(YP, "makeRoleSelector");
var XP = /* @__PURE__ */ o((e) => {
  let t = "";
  return e === void 0 ? t = "" : typeof e == "string" ? t = ' and name "' + e + '"' : t = " and name `" + e + "`", t;
}, "getNameHint"), OB = /* @__PURE__ */ o(function(e, t, r) {
  let {
    name: n
  } = r === void 0 ? {} : r;
  return 'Found multiple elements with the role "' + t + '"' + XP(n);
}, "getMultipleError$1"), CB = /* @__PURE__ */ o(function(e, t, r) {
  let {
    hidden: n = ge().defaultHidden,
    name: a,
    description: i
  } = r === void 0 ? {} : r;
  if (ge()._disableExpensiveErrorDiagnostics)
    return 'Unable to find role="' + t + '"' + XP(a);
  let s = "";
  Array.from(e.children).forEach((p) => {
    s += lh(p, {
      hidden: n,
      includeDescription: i !== void 0
    });
  });
  let l;
  s.length === 0 ? n === !1 ? l = "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : l = "There are no available roles." : l = (`
Here are the ` + (n === !1 ? "accessible" : "available") + ` roles:

  ` + s.replace(/\n/g, `
  `).replace(/\n\s\s\n/g, `

`) + `
`).trim();
  let c = "";
  a === void 0 ? c = "" : typeof a == "string" ? c = ' and name "' + a + '"' : c = " and name `" + a + "`";
  let u = "";
  return i === void 0 ? u = "" : typeof i == "string" ? u = ' and description "' + i + '"' : u = " and description `" + i + "`", (`
Unable to find an ` + (n === !1 ? "accessible " : "") + 'element with the role "' + t + '"' + c + u + `

` + l).trim();
}, "getMissingError$1"), QP = pt(hd, hd.name, "queryAll"), [ZP, eO, tO, rO, nO] = ur(hd, OB, CB), dh = /* @__PURE__ */ o(() => ge().testIdAttribute, "getTestIdAttribute"), yd = /* @__PURE__ */ o(function() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return lr(t[0]), nn(dh(), ...t);
}, "queryAllByTestId"), AB = /* @__PURE__ */ o((e, t) => "Found multiple elements by: [" + dh() + '="' + t + '"]', "getMultipleError"), RB = /* @__PURE__ */ o((e, t) => "Unable to find an element by: [" + dh() + '="' + t + '"]', "getMissingError"), oO = pt(yd, yd.name, "queryAll"), [aO, iO, sO, lO, uO] = ur(yd, AB, RB), _s = Object.freeze({
  __proto__: null,
  queryAllByLabelText: vP,
  queryByLabelText: fP,
  getAllByLabelText: gP,
  getByLabelText: bP,
  findAllByLabelText: hP,
  findByLabelText: yP,
  queryByPlaceholderText: _P,
  queryAllByPlaceholderText: wP,
  getByPlaceholderText: xP,
  getAllByPlaceholderText: EP,
  findAllByPlaceholderText: TP,
  findByPlaceholderText: SP,
  queryByText: OP,
  queryAllByText: PP,
  getByText: AP,
  getAllByText: CP,
  findAllByText: RP,
  findByText: kP,
  queryByDisplayValue: jP,
  queryAllByDisplayValue: IP,
  getByDisplayValue: qP,
  getAllByDisplayValue: NP,
  findAllByDisplayValue: MP,
  findByDisplayValue: $P,
  queryByAltText: DP,
  queryAllByAltText: LP,
  getByAltText: BP,
  getAllByAltText: FP,
  findAllByAltText: UP,
  findByAltText: HP,
  queryByTitle: JP,
  queryAllByTitle: VP,
  getByTitle: WP,
  getAllByTitle: zP,
  findAllByTitle: GP,
  findByTitle: KP,
  queryByRole: ZP,
  queryAllByRole: QP,
  getAllByRole: eO,
  getByRole: tO,
  findAllByRole: rO,
  findByRole: nO,
  queryByTestId: aO,
  queryAllByTestId: oO,
  getByTestId: sO,
  getAllByTestId: iO,
  findAllByTestId: lO,
  findByTestId: uO
});
function Es(e, t, r) {
  return t === void 0 && (t = _s), r === void 0 && (r = {}), Object.keys(t).reduce((n, a) => {
    const i = t[a];
    return n[a] = i.bind(null, e), n;
  }, r);
}
o(Es, "getQueriesForElement");
var cO = /* @__PURE__ */ o((e) => !e || Array.isArray(e) && !e.length, "isRemoved");
function gd(e) {
  if (cO(e))
    throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.");
}
o(gd, "initialCheck");
async function dO(e, t) {
  const r = new Error("Timed out in waitForElementToBeRemoved.");
  if (typeof e != "function") {
    gd(e);
    const n = (Array.isArray(e) ? e : [e]).map((a) => {
      let i = a.parentElement;
      if (i === null) return () => null;
      for (; i.parentElement; ) i = i.parentElement;
      return () => i.contains(a) ? a : null;
    });
    e = /* @__PURE__ */ o(() => n.map((a) => a()).filter(Boolean), "callback");
  }
  return gd(e()), zl(() => {
    let n;
    try {
      n = e();
    } catch (a) {
      if (a.name === "TestingLibraryElementError")
        return;
      throw a;
    }
    if (!cO(n))
      throw r;
  }, t);
}
o(dO, "waitForElementToBeRemoved");
var gg = {
  // Clipboard Events
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Composition Events
  compositionEnd: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionStart: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  compositionUpdate: {
    EventType: "CompositionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Keyboard Events
  keyDown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyPress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  keyUp: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      charCode: 0,
      composed: !0
    }
  },
  // Focus Events
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusIn: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusOut: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // Form Events
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  invalid: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !0
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  reset: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  // Mouse Events
  click: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      button: 0,
      composed: !0
    }
  },
  contextMenu: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblClick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drag: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragEnd: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragEnter: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragExit: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragLeave: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  dragOver: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dragStart: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  drop: {
    EventType: "DragEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseDown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseEnter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseLeave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseMove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOut: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseOver: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseUp: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Selection Events
  select: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Touch Events
  touchCancel: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  touchEnd: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchMove: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  touchStart: {
    EventType: "TouchEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // UI Events
  resize: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  scroll: {
    EventType: "UIEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Wheel Events
  wheel: {
    EventType: "WheelEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  // Media Events
  abort: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlay: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  canPlayThrough: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  durationChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  emptied: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  encrypted: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  ended: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedData: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadedMetadata: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  loadStart: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pause: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  play: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  playing: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  progress: {
    EventType: "ProgressEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  rateChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeked: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  seeking: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  stalled: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  suspend: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  timeUpdate: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  volumeChange: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  waiting: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Events
  load: {
    // TODO: load events can be UIEvent or Event depending on what generated them
    // This is where this abstraction breaks down.
    // But the common targets are <img />, <script /> and window.
    // Neither of these targets receive a UIEvent
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  error: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  // Animation Events
  animationStart: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationEnd: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  animationIteration: {
    EventType: "AnimationEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // Transition Events
  transitionCancel: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionEnd: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  transitionRun: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  transitionStart: {
    EventType: "TransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // pointer events
  pointerOver: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerEnter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerDown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerMove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerUp: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerCancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerOut: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerLeave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  gotPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  lostPointerCapture: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  // history events
  popState: {
    EventType: "PopStateEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  // window events
  offline: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  online: {
    EventType: "Event",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pageHide: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  },
  pageShow: {
    EventType: "PageTransitionEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
}, bg = {
  doubleClick: "dblClick"
};
function go(e, t) {
  return ge().eventWrapper(() => {
    if (!t)
      throw new Error("Unable to fire an event - please provide an event object.");
    if (!e)
      throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
    return e.dispatchEvent(t);
  });
}
o(go, "fireEvent");
function ua(e, t, r, n) {
  let {
    EventType: a = "Event",
    defaultInit: i = {}
  } = n === void 0 ? {} : n;
  if (!t)
    throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
  const s = {
    ...i,
    ...r
  }, {
    target: {
      value: l,
      files: c,
      ...u
    } = {}
  } = s;
  l !== void 0 && pO(t, l), c !== void 0 && Object.defineProperty(t, "files", {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    value: c
  }), Object.assign(t, u);
  const p = eh(t), f = p[a] || p.Event;
  let m;
  if (typeof f == "function")
    m = new f(e, s);
  else {
    m = p.document.createEvent(a);
    const {
      bubbles: y,
      cancelable: g,
      detail: v,
      ..._
    } = s;
    m.initEvent(e, y, g, v), Object.keys(_).forEach((b) => {
      m[b] = _[b];
    });
  }
  return ["dataTransfer", "clipboardData"].forEach((y) => {
    const g = s[y];
    typeof g == "object" && (typeof p.DataTransfer == "function" ? Object.defineProperty(m, y, {
      value: Object.getOwnPropertyNames(g).reduce((v, _) => (Object.defineProperty(v, _, {
        value: g[_]
      }), v), new p.DataTransfer())
    }) : Object.defineProperty(m, y, {
      value: g
    }));
  }), m;
}
o(ua, "createEvent");
Object.keys(gg).forEach((e) => {
  const {
    EventType: t,
    defaultInit: r
  } = gg[e], n = e.toLowerCase();
  ua[e] = (a, i) => ua(n, a, i, {
    EventType: t,
    defaultInit: r
  }), go[e] = (a, i) => go(a, ua[e](a, i));
});
function pO(e, t) {
  const {
    set: r
  } = Object.getOwnPropertyDescriptor(e, "value") || {}, n = Object.getPrototypeOf(e), {
    set: a
  } = Object.getOwnPropertyDescriptor(n, "value") || {};
  if (a && r !== a)
    a.call(e, t);
  else if (r)
    r.call(e, t);
  else
    throw new Error("The given element does not have a value setter");
}
o(pO, "setNativeValue");
Object.keys(bg).forEach((e) => {
  const t = bg[e];
  go[e] = function() {
    return go[t](...arguments);
  };
});
function fO(e) {
  return e.replace(/[ \t]*[\n][ \t]*/g, `
`);
}
o(fO, "unindent");
function mO(e) {
  return YF.default.compressToEncodedURIComponent(fO(e));
}
o(mO, "encode");
function hO(e) {
  return "https://testing-playground.com/#markup=" + mO(e);
}
o(hO, "getPlaygroundUrl");
var kB = /* @__PURE__ */ o((e, t, r) => Array.isArray(e) ? e.forEach((n) => ld(n, t, r)) : ld(e, t, r), "debug"), IB = /* @__PURE__ */ o(function(e) {
  if (e === void 0 && (e = Hl().body), !e || !("innerHTML" in e)) {
    console.log("The element you're providing isn't a valid DOM element.");
    return;
  }
  if (!e.innerHTML) {
    console.log("The provided element doesn't have any children.");
    return;
  }
  const t = hO(e.innerHTML);
  return console.log(`Open this URL in your browser

` + t), t;
}, "logTestingPlaygroundURL"), vg = {
  debug: kB,
  logTestingPlaygroundURL: IB
}, jB = typeof document < "u" && document.body ? Es(document.body, _s, vg) : Object.keys(_s).reduce((e, t) => (e[t] = () => {
  throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error");
}, e), vg);
function fe(e, t, r) {
  return e.namespaceURI && e.namespaceURI !== "http://www.w3.org/1999/xhtml" || (t = Array.isArray(t) ? t : [
    t
  ], !t.includes(e.tagName.toLowerCase())) ? !1 : r ? Object.entries(r).every(([n, a]) => e[n] === a) : !0;
}
o(fe, "isElementType");
function Ot(e) {
  var t;
  if (yO(e) && e.defaultView)
    return e.defaultView;
  if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
    return e.ownerDocument.defaultView;
  throw new Error(`Could not determine window of node. Node was ${gO(e)}`);
}
o(Ot, "getWindow");
function yO(e) {
  return e.nodeType === 9;
}
o(yO, "isDocument");
function gO(e) {
  return typeof e == "function" ? `function ${e.name}` : e === null ? "null" : String(e);
}
o(gO, "describe");
function ph(e, t) {
  return new Promise((r, n) => {
    const a = new t();
    a.onerror = n, a.onabort = n, a.onload = () => {
      r(String(a.result));
    }, a.readAsText(e);
  });
}
o(ph, "readBlobText");
function Gl(e, t) {
  const r = {
    ...t,
    length: t.length,
    item: /* @__PURE__ */ o((n) => r[n], "item"),
    [Symbol.iterator]: /* @__PURE__ */ o(function* () {
      for (let n = 0; n < r.length; n++)
        yield r[n];
    }, "nextFile")
  };
  return r.constructor = e.FileList, e.FileList && Object.setPrototypeOf(r, e.FileList.prototype), Object.freeze(r), r;
}
o(Gl, "createFileList");
function xr(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(xr, "_define_property");
var bO = class {
  getAsFile() {
    return this.file;
  }
  getAsString(e) {
    typeof this.data == "string" && e(this.data);
  }
  /* istanbul ignore next */
  webkitGetAsEntry() {
    throw new Error("not implemented");
  }
  constructor(e, t) {
    xr(this, "kind", void 0), xr(this, "type", void 0), xr(this, "file", null), xr(this, "data", void 0), typeof e == "string" ? (this.kind = "string", this.type = String(t), this.data = e) : (this.kind = "file", this.type = e.type, this.file = e);
  }
};
o(bO, "DataTransferItemStub");
var vO = bO, wO = class extends Array {
  add(...e) {
    const t = new vO(e[0], e[1]);
    return this.push(t), t;
  }
  clear() {
    this.splice(0, this.length);
  }
  remove(e) {
    this.splice(e, 1);
  }
};
o(wO, "DataTransferItemListStub");
var NB = wO;
function Yo(e, t) {
  const [r, n] = e.split("/"), a = !n || n === "*";
  return (i) => t ? i.type === (a ? r : e) : a ? i.type.startsWith(`${r}/`) : i.type === r;
}
o(Yo, "getTypeMatcher");
function _O(e) {
  var t;
  return new (t = class {
    getData(r) {
      var n;
      const a = (n = this.items.find(Yo(r, !0))) !== null && n !== void 0 ? n : this.items.find(Yo(r, !1));
      let i = "";
      return a?.getAsString((s) => {
        i = s;
      }), i;
    }
    setData(r, n) {
      const a = this.items.findIndex(Yo(r, !0)), i = new vO(n, r);
      a >= 0 ? this.items.splice(a, 1, i) : this.items.push(i);
    }
    clearData(r) {
      if (r) {
        const n = this.items.findIndex(Yo(r, !0));
        n >= 0 && this.items.remove(n);
      } else
        this.items.clear();
    }
    get types() {
      const r = [];
      return this.files.length && r.push("Files"), this.items.forEach((n) => r.push(n.type)), Object.freeze(r), r;
    }
    /* istanbul ignore next */
    setDragImage() {
    }
    constructor() {
      xr(this, "dropEffect", "none"), xr(this, "effectAllowed", "uninitialized"), xr(this, "items", new NB()), xr(this, "files", Gl(e, []));
    }
  }, o(t, "DataTransferStub"), t)();
}
o(_O, "createDataTransferStub");
function Kl(e, t = []) {
  const r = typeof e.DataTransfer > "u" ? _O(e) : (
    /* istanbul ignore next */
    new e.DataTransfer()
  );
  return Object.defineProperty(r, "files", {
    get: /* @__PURE__ */ o(() => Gl(e, t), "get")
  }), r;
}
o(Kl, "createDataTransfer");
async function EO(e, t) {
  return t.kind === "file" ? t.getAsFile() : new e.Blob([
    await new Promise((r) => t.getAsString(r))
  ], {
    type: t.type
  });
}
o(EO, "getBlobFromDataTransferItem");
function fh(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(fh, "_define_property");
function mh(e, ...t) {
  var r;
  const n = Object.fromEntries(t.map((a) => [
    typeof a == "string" ? "text/plain" : a.type,
    Promise.resolve(a)
  ]));
  return typeof e.ClipboardItem < "u" ? new e.ClipboardItem(n) : new (r = class {
    get types() {
      return Array.from(Object.keys(this.data));
    }
    async getType(a) {
      const i = await this.data[a];
      if (!i)
        throw new Error(`${a} is not one of the available MIME types on this item.`);
      return i instanceof e.Blob ? i : new e.Blob([
        i
      ], {
        type: a
      });
    }
    constructor(a) {
      fh(this, "data", void 0), this.data = a;
    }
  }, o(r, "ClipboardItem"), r)(n);
}
o(mh, "createClipboardItem");
var bo = Symbol("Manage ClipboardSub");
function bd(e, t) {
  var r;
  return Object.assign(new (r = class extends e.EventTarget {
    async read() {
      return Array.from(this.items);
    }
    async readText() {
      let n = "";
      for (const a of this.items) {
        const i = a.types.includes("text/plain") ? "text/plain" : a.types.find((s) => s.startsWith("text/"));
        i && (n += await a.getType(i).then((s) => ph(s, e.FileReader)));
      }
      return n;
    }
    async write(n) {
      this.items = n;
    }
    async writeText(n) {
      this.items = [
        mh(e, n)
      ];
    }
    constructor(...n) {
      super(...n), fh(this, "items", []);
    }
  }, o(r, "Clipboard"), r)(), {
    [bo]: t
  });
}
o(bd, "createClipboardStub");
function Yl(e) {
  return !!e?.[bo];
}
o(Yl, "isClipboardStub");
function xO(e) {
  if (Yl(e.navigator.clipboard))
    return e.navigator.clipboard[bo];
  const t = Object.getOwnPropertyDescriptor(e.navigator, "clipboard");
  let r;
  const n = {
    resetClipboardStub: /* @__PURE__ */ o(() => {
      r = bd(e, n);
    }, "resetClipboardStub"),
    detachClipboardStub: /* @__PURE__ */ o(() => {
      t ? Object.defineProperty(e.navigator, "clipboard", t) : Object.defineProperty(e.navigator, "clipboard", {
        value: void 0,
        configurable: !0
      });
    }, "detachClipboardStub")
  };
  return r = bd(e, n), Object.defineProperty(e.navigator, "clipboard", {
    get: /* @__PURE__ */ o(() => r, "get"),
    configurable: !0
  }), r[bo];
}
o(xO, "attachClipboardStubToView");
function TO(e) {
  Yl(e.navigator.clipboard) && e.navigator.clipboard[bo].resetClipboardStub();
}
o(TO, "resetClipboardStubOnView");
function SO(e) {
  Yl(e.navigator.clipboard) && e.navigator.clipboard[bo].detachClipboardStub();
}
o(SO, "detachClipboardStubFromView");
async function PO(e) {
  const t = e.defaultView, r = t?.navigator.clipboard, n = r && await r.read();
  if (!n)
    throw new Error("The Clipboard API is unavailable.");
  const a = Kl(t);
  for (const i of n)
    for (const s of i.types)
      a.setData(s, await i.getType(s).then((l) => ph(l, t.FileReader)));
  return a;
}
o(PO, "readDataTransferFromClipboard");
async function hh(e, t) {
  const r = Ot(e), n = r.navigator.clipboard, a = [];
  for (let i = 0; i < t.items.length; i++) {
    const s = t.items[i], l = await EO(r, s);
    a.push(mh(r, l));
  }
  if (!(n && await n.write(a).then(
    () => !0,
    // Can happen with other implementations that e.g. require permissions
    /* istanbul ignore next */
    () => !1
  )))
    throw new Error("The Clipboard API is unavailable.");
}
o(hh, "writeDataTransferToClipboard");
var xs = globalThis;
typeof xs.afterEach == "function" && xs.afterEach(() => {
  typeof globalThis.window < "u" && TO(globalThis.window);
});
typeof xs.afterAll == "function" && xs.afterAll(() => {
  typeof globalThis.window < "u" && SO(globalThis.window);
});
var OO = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");
function Xl(e) {
  return e.matches(OO);
}
o(Xl, "isFocusable");
function CO(e) {
  return new e.constructor(e.type, e);
}
o(CO, "cloneEvent");
function ar(e) {
  for (let r = e; r; r = r.parentElement)
    if (fe(r, [
      "button",
      "input",
      "select",
      "textarea",
      "optgroup",
      "option"
    ])) {
      if (r.hasAttribute("disabled"))
        return !0;
    } else if (fe(r, "fieldset")) {
      var t;
      if (r.hasAttribute("disabled") && !(!((t = r.querySelector(":scope > legend")) === null || t === void 0) && t.contains(e)))
        return !0;
    } else if (r.tagName.includes("-") && r.constructor.formAssociated && r.hasAttribute("disabled"))
      return !0;
  return !1;
}
o(ar, "isDisabled");
function Mo(e) {
  const t = e.activeElement;
  return t?.shadowRoot ? Mo(t.shadowRoot) : ar(t) ? e.ownerDocument ? (
    /* istanbul ignore next */
    e.ownerDocument.body
  ) : e.body : t;
}
o(Mo, "getActiveElement");
function ji(e) {
  var t;
  return (t = Mo(e)) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  );
}
o(ji, "getActiveElementOrBody");
function AO(e, t) {
  let r = e;
  do {
    if (t(r))
      return r;
    r = r.parentElement;
  } while (r && r !== e.ownerDocument.body);
}
o(AO, "findClosest");
function Kr(e) {
  return e.hasAttribute("contenteditable") && (e.getAttribute("contenteditable") == "true" || e.getAttribute("contenteditable") == "");
}
o(Kr, "isContentEditable");
function vo(e) {
  const t = RO(e);
  return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
o(vo, "getContentEditable");
function RO(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
o(RO, "getElement");
var kO = (function(e) {
  return e.button = "button", e.color = "color", e.file = "file", e.image = "image", e.reset = "reset", e.submit = "submit", e.checkbox = "checkbox", e.radio = "radio", e;
})(kO || {});
function yh(e) {
  return fe(e, "button") || fe(e, "input") && e.type in kO;
}
o(yh, "isClickableInput");
function Tn(e) {
  return gh(e) && !e.readOnly || Kr(e);
}
o(Tn, "isEditable");
var IO = (function(e) {
  return e.text = "text", e.date = "date", e["datetime-local"] = "datetime-local", e.email = "email", e.month = "month", e.number = "number", e.password = "password", e.search = "search", e.tel = "tel", e.time = "time", e.url = "url", e.week = "week", e;
})(IO || {});
function gh(e) {
  return fe(e, "textarea") || fe(e, "input") && e.type in IO;
}
o(gh, "isEditableInputOrTextArea");
function Wt(e) {
  return bh(e) && gh(e);
}
o(Wt, "hasOwnSelection");
function jO(e) {
  return bh(e) && yh(e);
}
o(jO, "hasNoSelection");
function bh(e) {
  return e.nodeType === 1;
}
o(bh, "isElement");
function NO(e) {
  const t = e.ownerDocument.getSelection();
  if (t?.focusNode && Wt(e)) {
    const n = vo(t.focusNode);
    if (n) {
      if (!t.isCollapsed) {
        var r;
        const a = ((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3 ? n.firstChild : n;
        t.setBaseAndExtent(a, 0, a, 0);
      }
    } else
      t.setBaseAndExtent(e, 0, e, 0);
  }
}
o(NO, "updateSelectionOnFocus");
function wo(e, t) {
  return ge().eventWrapper(e);
}
o(wo, "wrapEvent");
function Cr(e) {
  const t = AO(e, Xl), r = Mo(e.ownerDocument);
  (t ?? e.ownerDocument.body) !== r && (wo(t ? () => t.focus() : () => r?.blur()), NO(t ?? e.ownerDocument.body));
}
o(Cr, "focusElement");
function qO(e) {
  !Xl(e) || Mo(e.ownerDocument) !== e || wo(() => e.blur());
}
o(qO, "blurElement");
var Yr = {};
Yr.click = (e, t, r) => {
  const n = t.closest("button,input,label,select,textarea"), a = n && fe(n, "label") && n.control;
  if (a && a !== t)
    return () => {
      Xl(a) && (Cr(a), r.dispatchEvent(a, CO(e)));
    };
  if (fe(t, "input", {
    type: "file"
  }))
    return () => {
      qO(t), t.dispatchEvent(new (Ot(t)).Event("fileDialog")), Cr(t);
    };
};
var _o = Symbol("Displayed value in UI"), Tr = Symbol("Displayed selection in UI"), Ts = Symbol("Initial value to compare on blur");
function MO(e) {
  return typeof e == "object" && _o in e;
}
o(MO, "isUIValue");
function $O(e) {
  return !!e && typeof e == "object" && Tr in e;
}
o($O, "isUISelectionStart");
function LO(e, t) {
  e[Ts] === void 0 && (e[Ts] = e.value), e[_o] = t, e.value = Object.assign(new String(t), {
    [_o]: !0
  });
}
o(LO, "setUIValue");
function Gt(e) {
  return e[_o] === void 0 ? e.value : String(e[_o]);
}
o(Gt, "getUIValue");
function Ql(e) {
  e[_o] = void 0;
}
o(Ql, "setUIValueClean");
function vh(e) {
  e[Ts] = void 0;
}
o(vh, "clearInitialValue");
function DO(e) {
  return e[Ts];
}
o(DO, "getInitialValue");
function FO(e, t) {
  e[Tr] = t;
}
o(FO, "setUISelectionRaw");
function Mn(e, { focusOffset: t, anchorOffset: r = t }, n = "replace") {
  const a = Gt(e).length, i = /* @__PURE__ */ o((f) => Math.max(0, Math.min(a, f)), "sanitizeOffset"), s = n === "replace" || e[Tr] === void 0 ? i(r) : e[Tr].anchorOffset, l = i(t), c = Math.min(s, l), u = Math.max(s, l);
  if (e[Tr] = {
    anchorOffset: s,
    focusOffset: l
  }, e.selectionStart === c && e.selectionEnd === u)
    return;
  const p = Object.assign(new Number(c), {
    [Tr]: !0
  });
  try {
    e.setSelectionRange(p, u);
  } catch {
  }
}
o(Mn, "setUISelection");
function Eo(e) {
  var t, r, n;
  const a = (n = e[Tr]) !== null && n !== void 0 ? n : {
    anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
    focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0
  };
  return {
    ...a,
    startOffset: Math.min(a.anchorOffset, a.focusOffset),
    endOffset: Math.max(a.anchorOffset, a.focusOffset)
  };
}
o(Eo, "getUISelection");
function BO(e) {
  return !!e[Tr];
}
o(BO, "hasUISelection");
function ca(e) {
  e[Tr] = void 0;
}
o(ca, "setUISelectionClean");
var Ss = globalThis.parseInt;
function UO(e) {
  const t = e.replace(/\D/g, "");
  if (t.length < 2)
    return e;
  const r = Ss(t[0], 10), n = Ss(t[1], 10);
  if (r >= 3 || r === 2 && n >= 4) {
    let a;
    return r >= 3 ? a = 1 : a = 2, vd(t, a);
  }
  return e.length === 2 ? e : vd(t, 2);
}
o(UO, "buildTimeValue");
function vd(e, t) {
  const r = e.slice(0, t), n = Math.min(Ss(r, 10), 23), a = e.slice(t), i = Ss(a, 10), s = Math.min(i, 59);
  return `${n.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
}
o(vd, "build");
function wh(e, t) {
  const r = e.cloneNode();
  return r.value = t, r.value === t;
}
o(wh, "isValidDateOrTimeValue");
var HO = (function(e) {
  return e.email = "email", e.password = "password", e.search = "search", e.telephone = "telephone", e.text = "text", e.url = "url", e;
})(HO || {});
function VO(e) {
  var t;
  const r = (t = e.getAttribute("maxlength")) !== null && t !== void 0 ? t : "";
  return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
o(VO, "getMaxLength");
function JO(e) {
  return fe(e, "textarea") || fe(e, "input") && e.type in HO;
}
o(JO, "supportsMaxLength");
function _h(e, t, r, n) {
  if (da(e) && t + r >= 0 && t + r <= e.nodeValue.length)
    return {
      node: e,
      offset: t + r
    };
  const a = wd(e, t, r);
  if (a) {
    if (da(a))
      return {
        node: a,
        offset: r > 0 ? Math.min(1, a.nodeValue.length) : Math.max(a.nodeValue.length - 1, 0)
      };
    if (fe(a, "br")) {
      const i = wd(a, void 0, r);
      return i ? da(i) ? {
        node: i,
        offset: r > 0 ? 0 : i.nodeValue.length
      } : r < 0 && fe(i, "br") ? {
        node: a.parentNode,
        offset: Xo(a)
      } : {
        node: i.parentNode,
        offset: Xo(i) + (r > 0 ? 0 : 1)
      } : r < 0 && n === "deleteContentBackward" ? {
        node: a.parentNode,
        offset: Xo(a)
      } : void 0;
    } else
      return {
        node: a.parentNode,
        offset: Xo(a) + (r > 0 ? 1 : 0)
      };
  }
}
o(_h, "getNextCursorPosition");
function wd(e, t, r) {
  const n = Number(t) + (r < 0 ? -1 : 0);
  return t !== void 0 && Zl(e) && n >= 0 && n < e.children.length && (e = e.children[n]), WO(e, r === 1 ? "next" : "previous", zO);
}
o(wd, "getNextCharacterContentNode");
function zO(e) {
  if (da(e))
    return !0;
  if (Zl(e)) {
    if (fe(e, [
      "input",
      "textarea"
    ]))
      return e.type !== "hidden";
    if (fe(e, "br"))
      return !0;
  }
  return !1;
}
o(zO, "isTreatedAsCharacterContent");
function Xo(e) {
  let t = 0;
  for (; e.previousSibling; )
    t++, e = e.previousSibling;
  return t;
}
o(Xo, "getOffset");
function Zl(e) {
  return e.nodeType === 1;
}
o(Zl, "isElement");
function da(e) {
  return e.nodeType === 3;
}
o(da, "isTextNode");
function WO(e, t, r) {
  for (; ; ) {
    var n;
    const a = e[`${t}Sibling`];
    if (a) {
      if (e = GO(a, t === "next" ? "first" : "last"), r(e))
        return e;
    } else if (e.parentNode && (!Zl(e.parentNode) || !Kr(e.parentNode) && e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
      e = e.parentNode;
    else
      break;
  }
}
o(WO, "walkNodes");
function GO(e, t) {
  for (; e.hasChildNodes(); )
    e = e[`${t}Child`];
  return e;
}
o(GO, "getDescendant");
var Na = Symbol("Track programmatic changes for React workaround");
function KO(e) {
  return Object.getOwnPropertyNames(e).some((t) => t.startsWith("__react")) && Ot(e).REACT_VERSION === 17;
}
o(KO, "isReact17Element");
function YO(e) {
  KO(e) && (e[Na] = {
    previousValue: String(e.value),
    tracked: []
  });
}
o(YO, "startTrackValue");
function XO(e, t) {
  var r, n;
  (n = e[Na]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t), e[Na] || (Ql(e), Mn(e, {
    focusOffset: t.length
  }));
}
o(XO, "trackOrSetValue");
function QO(e, t) {
  var r;
  const n = e[Na];
  if (e[Na] = void 0, !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length))
    return;
  const a = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
  a || Ql(e), BO(e) && Mn(e, {
    focusOffset: a ? t : e.value.length
  });
}
o(QO, "commitValueAfterInput");
function Eh(e) {
  const t = ZO(e);
  if (t && Wt(t))
    return {
      type: "input",
      selection: Eo(t)
    };
  const r = t?.ownerDocument.getSelection();
  return {
    type: vo(e) && r?.anchorNode && vo(r.anchorNode) ? "contenteditable" : "default",
    selection: r
  };
}
o(Eh, "getTargetTypeAndSelection");
function ZO(e) {
  return e.nodeType === 1 ? e : e.parentElement;
}
o(ZO, "getElement");
function eC(e) {
  const t = Eh(e);
  if (t.type === "input")
    return t.selection;
  if (t.type === "contenteditable") {
    var r;
    return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
  }
}
o(eC, "getInputRange");
function Xr({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
  var a, i;
  if (Eh(e).type === "input")
    return Mn(e, {
      anchorOffset: n,
      focusOffset: t
    });
  (i = r.ownerDocument) === null || i === void 0 || (a = i.getSelection()) === null || a === void 0 || a.setBaseAndExtent(r, n, e, t);
}
o(Xr, "setSelection");
function xh(e) {
  return fe(e, "input") && [
    "date",
    "time"
  ].includes(e.type);
}
o(xh, "isDateOrTime");
function Sn(e, t, r, n = "insertText") {
  const a = eC(t);
  a && (!xh(t) && !e.dispatchUIEvent(t, "beforeinput", {
    inputType: n,
    data: r
  }) || ("startContainer" in a ? tC(e, t, a, r, n) : rC(e, t, a, r, n)));
}
o(Sn, "input");
function tC(e, t, r, n, a) {
  let i = !1;
  if (!r.collapsed)
    i = !0, r.deleteContents();
  else if ([
    "deleteContentBackward",
    "deleteContentForward"
  ].includes(a)) {
    const s = _h(r.startContainer, r.startOffset, a === "deleteContentBackward" ? -1 : 1, a);
    if (s) {
      i = !0;
      const l = r.cloneRange();
      l.comparePoint(s.node, s.offset) < 0 ? l.setStart(s.node, s.offset) : l.setEnd(s.node, s.offset), l.deleteContents();
    }
  }
  if (n)
    if (r.endContainer.nodeType === 3) {
      const s = r.endOffset;
      r.endContainer.insertData(s, n), r.setStart(r.endContainer, s + n.length), r.setEnd(r.endContainer, s + n.length);
    } else {
      const s = t.ownerDocument.createTextNode(n);
      r.insertNode(s), r.setStart(s, n.length), r.setEnd(s, n.length);
    }
  (i || n) && e.dispatchUIEvent(t, "input", {
    inputType: a
  });
}
o(tC, "editContenteditable");
function rC(e, t, r, n, a) {
  let i = n;
  if (JO(t)) {
    const u = VO(t);
    if (u !== void 0 && n.length > 0) {
      const p = u - t.value.length;
      if (p > 0)
        i = n.substring(0, p);
      else
        return;
    }
  }
  const { newValue: s, newOffset: l, oldValue: c } = nC(i, t, r, a);
  s === c && l === r.startOffset && l === r.endOffset || fe(t, "input", {
    type: "number"
  }) && !oC(s) || (LO(t, s), Xr({
    focusNode: t,
    anchorOffset: l,
    focusOffset: l
  }), xh(t) ? wh(t, s) && (_d(e, t, l, {}), e.dispatchUIEvent(t, "change"), vh(t)) : _d(e, t, l, {
    data: n,
    inputType: a
  }));
}
o(rC, "editInputElement");
function nC(e, t, { startOffset: r, endOffset: n }, a) {
  const i = Gt(t), s = Math.max(0, r === n && a === "deleteContentBackward" ? r - 1 : r), l = i.substring(0, s), c = Math.min(i.length, r === n && a === "deleteContentForward" ? r + 1 : n), u = i.substring(c, i.length);
  let p = `${l}${e}${u}`, f = s + e.length;
  if (fe(t, "input", {
    type: "time"
  })) {
    const m = UO(p);
    m !== "" && wh(t, m) && (p = m, f = m.length);
  }
  return {
    oldValue: i,
    newValue: p,
    newOffset: f
  };
}
o(nC, "calculateNewValue");
function _d(e, t, r, n) {
  e.dispatchUIEvent(t, "input", n), QO(t, r);
}
o(_d, "commitInput");
function oC(e) {
  var t, r;
  const n = e.split("e", 2);
  return !(/[^\d.\-e]/.test(e) || Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 || Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 || n[1] && !/^-?\d*$/.test(n[1]));
}
o(oC, "isValidNumberInput");
Yr.cut = (e, t, r) => () => {
  Tn(t) && Sn(r, t, "", "deleteByCut");
};
function aC(e) {
  return e ? Kr(e) ? e.textContent : Gt(e) : null;
}
o(aC, "getValueOrTextContent");
function iC(e) {
  const t = Ot(e);
  for (let r = e; r?.ownerDocument; r = r.parentElement) {
    const { display: n, visibility: a } = t.getComputedStyle(r);
    if (n === "none" || a === "hidden")
      return !1;
  }
  return !0;
}
o(iC, "isVisible");
function sC(e, t) {
  const r = e.ownerDocument, n = r.querySelectorAll(OO), a = Array.from(n).filter((c) => c === e || !(Number(c.getAttribute("tabindex")) < 0 || ar(c)));
  Number(e.getAttribute("tabindex")) >= 0 && a.sort((c, u) => {
    const p = Number(c.getAttribute("tabindex")), f = Number(u.getAttribute("tabindex"));
    return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
  });
  const i = {};
  let s = [
    r.body
  ];
  const l = fe(e, "input", {
    type: "radio"
  }) ? e.name : void 0;
  a.forEach((c) => {
    const u = c;
    if (fe(u, "input", {
      type: "radio"
    }) && u.name) {
      if (u === e) {
        s.push(u);
        return;
      } else if (u.name === l)
        return;
      if (u.checked) {
        s = s.filter((p) => !fe(p, "input", {
          type: "radio",
          name: u.name
        })), s.push(u), i[u.name] = u;
        return;
      }
      if (typeof i[u.name] < "u")
        return;
    }
    s.push(u);
  });
  for (let c = s.findIndex((u) => u === e); ; )
    if (c += t ? -1 : 1, c === s.length ? c = 0 : c === -1 && (c = s.length - 1), s[c] === e || s[c] === r.body || iC(s[c]))
      return s[c];
}
o(sC, "getTabDestination");
function Ed(e, t) {
  if (Wt(e)) {
    const r = Eo(e);
    Xr({
      focusNode: e,
      focusOffset: r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset
    });
  } else {
    const r = e.ownerDocument.getSelection();
    if (!r?.focusNode)
      return;
    if (r.isCollapsed) {
      const n = _h(r.focusNode, r.focusOffset, t);
      n && Xr({
        focusNode: n.node,
        focusOffset: n.offset
      });
    } else
      r[t < 0 ? "collapseToStart" : "collapseToEnd"]();
  }
}
o(Ed, "moveSelection");
function Th(e) {
  if (Wt(e))
    return Xr({
      focusNode: e,
      anchorOffset: 0,
      focusOffset: Gt(e).length
    });
  var t;
  const r = (t = vo(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
  Xr({
    focusNode: r,
    anchorOffset: 0,
    focusOffset: r.childNodes.length
  });
}
o(Th, "selectAll");
function lC(e) {
  if (Wt(e))
    return Eo(e).startOffset === 0 && Eo(e).endOffset === Gt(e).length;
  var t;
  const r = (t = vo(e)) !== null && t !== void 0 ? t : e.ownerDocument.body, n = e.ownerDocument.getSelection();
  return n?.anchorNode === r && n.focusNode === r && n.anchorOffset === 0 && n.focusOffset === r.childNodes.length;
}
o(lC, "isAllSelected");
function Gn(e, t, r) {
  var n;
  if (Wt(e))
    return Xr({
      focusNode: e,
      anchorOffset: t,
      focusOffset: r
    });
  if (Kr(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
    return Xr({
      focusNode: e.firstChild,
      anchorOffset: t,
      focusOffset: r
    });
  throw new Error("Not implemented. The result of this interaction is unreliable.");
}
o(Gn, "setSelectionRange");
function Qo(e, t, r) {
  const n = Ot(t), a = Array.from(t.ownerDocument.querySelectorAll(t.name ? `input[type="radio"][name="${n.CSS.escape(t.name)}"]` : 'input[type="radio"][name=""], input[type="radio"]:not([name])'));
  for (let i = a.findIndex((s) => s === t) + r; ; i += r) {
    if (a[i] || (i = r > 0 ? 0 : a.length - 1), a[i] === t)
      return;
    if (!ar(a[i])) {
      Cr(a[i]), e.dispatchUIEvent(a[i], "click");
      return;
    }
  }
}
o(Qo, "walkRadio");
Yr.keydown = (e, t, r) => {
  var n, a;
  return (a = (n = wg[e.key]) === null || n === void 0 ? void 0 : n.call(wg, e, t, r)) !== null && a !== void 0 ? a : qB(e, t, r);
};
var wg = {
  ArrowDown: /* @__PURE__ */ o((e, t, r) => {
    if (fe(t, "input", {
      type: "radio"
    }))
      return () => Qo(r, t, 1);
  }, "ArrowDown"),
  ArrowLeft: /* @__PURE__ */ o((e, t, r) => fe(t, "input", {
    type: "radio"
  }) ? () => Qo(r, t, -1) : () => Ed(t, -1), "ArrowLeft"),
  ArrowRight: /* @__PURE__ */ o((e, t, r) => fe(t, "input", {
    type: "radio"
  }) ? () => Qo(r, t, 1) : () => Ed(t, 1), "ArrowRight"),
  ArrowUp: /* @__PURE__ */ o((e, t, r) => {
    if (fe(t, "input", {
      type: "radio"
    }))
      return () => Qo(r, t, -1);
  }, "ArrowUp"),
  Backspace: /* @__PURE__ */ o((e, t, r) => {
    if (Tn(t))
      return () => {
        Sn(r, t, "", "deleteContentBackward");
      };
  }, "Backspace"),
  Delete: /* @__PURE__ */ o((e, t, r) => {
    if (Tn(t))
      return () => {
        Sn(r, t, "", "deleteContentForward");
      };
  }, "Delete"),
  End: /* @__PURE__ */ o((e, t) => {
    if (fe(t, [
      "input",
      "textarea"
    ]) || Kr(t))
      return () => {
        var r, n;
        const a = (n = (r = aC(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0 ? n : (
          /* istanbul ignore next */
          0
        );
        Gn(t, a, a);
      };
  }, "End"),
  Home: /* @__PURE__ */ o((e, t) => {
    if (fe(t, [
      "input",
      "textarea"
    ]) || Kr(t))
      return () => {
        Gn(t, 0, 0);
      };
  }, "Home"),
  PageDown: /* @__PURE__ */ o((e, t) => {
    if (fe(t, [
      "input"
    ]))
      return () => {
        const r = Gt(t).length;
        Gn(t, r, r);
      };
  }, "PageDown"),
  PageUp: /* @__PURE__ */ o((e, t) => {
    if (fe(t, [
      "input"
    ]))
      return () => {
        Gn(t, 0, 0);
      };
  }, "PageUp"),
  Tab: /* @__PURE__ */ o((e, t, r) => () => {
    const n = sC(t, r.system.keyboard.modifiers.Shift);
    Cr(n), Wt(n) && Mn(n, {
      anchorOffset: 0,
      focusOffset: n.value.length
    });
  }, "Tab")
}, qB = /* @__PURE__ */ o((e, t, r) => {
  if (e.code === "KeyA" && r.system.keyboard.modifiers.Control)
    return () => Th(t);
}, "combinationBehavior");
Yr.keypress = (e, t, r) => {
  if (e.key === "Enter") {
    if (fe(t, "button") || fe(t, "input") && MB.includes(t.type) || fe(t, "a") && t.href)
      return () => {
        r.dispatchUIEvent(t, "click");
      };
    if (fe(t, "input")) {
      const n = t.form, a = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
      return a ? () => r.dispatchUIEvent(a, "click") : n && $B.includes(t.type) && n.querySelectorAll("input").length === 1 ? () => r.dispatchUIEvent(n, "submit") : void 0;
    }
  }
  if (Tn(t)) {
    const n = e.key === "Enter" ? Kr(t) && !r.system.keyboard.modifiers.Shift ? "insertParagraph" : "insertLineBreak" : "insertText", a = e.key === "Enter" ? `
` : e.key;
    return () => Sn(r, t, a, n);
  }
};
var MB = [
  "button",
  "color",
  "file",
  "image",
  "reset",
  "submit"
], $B = [
  "email",
  "month",
  "password",
  "search",
  "tel",
  "text",
  "url",
  "week"
];
Yr.keyup = (e, t, r) => {
  var n;
  return (n = _g[e.key]) === null || n === void 0 ? void 0 : n.call(_g, e, t, r);
};
var _g = {
  " ": /* @__PURE__ */ o((e, t, r) => {
    if (yh(t))
      return () => r.dispatchUIEvent(t, "click");
  }, " ")
};
Yr.paste = (e, t, r) => {
  if (Tn(t))
    return () => {
      var n;
      const a = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData("text");
      a && Sn(r, t, a, "insertFromPaste");
    };
};
var uC = {
  auxclick: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  beforeinput: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  blur: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  click: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  contextmenu: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  copy: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  change: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !1
    }
  },
  cut: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  dblclick: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  focus: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  focusin: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  focusout: {
    EventType: "FocusEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  keydown: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keypress: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  keyup: {
    EventType: "KeyboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  paste: {
    EventType: "ClipboardEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  input: {
    EventType: "InputEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  mousedown: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseenter: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mouseleave: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1,
      composed: !0
    }
  },
  mousemove: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseout: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseover: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  mouseup: {
    EventType: "MouseEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerover: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerenter: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  pointerdown: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointermove: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerup: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointercancel: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }
  },
  pointerout: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !0,
      cancelable: !0,
      composed: !0
    }
  },
  pointerleave: {
    EventType: "PointerEvent",
    defaultInit: {
      bubbles: !1,
      cancelable: !1
    }
  },
  submit: {
    EventType: "Event",
    defaultInit: {
      bubbles: !0,
      cancelable: !0
    }
  }
};
function Sh(e) {
  return uC[e].EventType;
}
o(Sh, "getEventClass");
var LB = [
  "MouseEvent",
  "PointerEvent"
];
function cC(e) {
  return LB.includes(Sh(e));
}
o(cC, "isMouseEvent");
function dC(e) {
  return Sh(e) === "KeyboardEvent";
}
o(dC, "isKeyboardEvent");
var DB = {
  ClipboardEvent: [
    fC
  ],
  Event: [],
  FocusEvent: [
    Un,
    mC
  ],
  InputEvent: [
    Un,
    hC
  ],
  MouseEvent: [
    Un,
    Ni,
    xd
  ],
  PointerEvent: [
    Un,
    Ni,
    xd,
    gC
  ],
  KeyboardEvent: [
    Un,
    Ni,
    yC
  ]
};
function Ph(e, t, r) {
  const n = Ot(t), { EventType: a, defaultInit: i } = uC[e], s = new (pC(n))[a](e, i);
  return DB[a].forEach((l) => l(s, r ?? {})), s;
}
o(Ph, "createEvent");
function pC(e) {
  var t, r, n, a, i, s, l, c, u, p, f, m, y, g, v, _;
  const b = (_ = e.Event) !== null && _ !== void 0 ? _ : (t = class {
  }, o(t, "Event"), t);
  var E;
  const C = (E = e.AnimationEvent) !== null && E !== void 0 ? E : (r = class extends b {
  }, o(r, "AnimationEvent"), r);
  var k;
  const N = (k = e.ClipboardEvent) !== null && k !== void 0 ? k : (n = class extends b {
  }, o(n, "ClipboardEvent"), n);
  var O;
  const S = (O = e.PopStateEvent) !== null && O !== void 0 ? O : (a = class extends b {
  }, o(a, "PopStateEvent"), a);
  var w;
  const T = (w = e.ProgressEvent) !== null && w !== void 0 ? w : (i = class extends b {
  }, o(i, "ProgressEvent"), i);
  var M;
  const R = (M = e.TransitionEvent) !== null && M !== void 0 ? M : (s = class extends b {
  }, o(s, "TransitionEvent"), s);
  var D;
  const J = (D = e.UIEvent) !== null && D !== void 0 ? D : (l = class extends b {
  }, o(l, "UIEvent"), l);
  var P;
  const q = (P = e.CompositionEvent) !== null && P !== void 0 ? P : (c = class extends J {
  }, o(c, "CompositionEvent"), c);
  var $;
  const H = ($ = e.FocusEvent) !== null && $ !== void 0 ? $ : (u = class extends J {
  }, o(u, "FocusEvent"), u);
  var z;
  const Z = (z = e.InputEvent) !== null && z !== void 0 ? z : (p = class extends J {
  }, o(p, "InputEvent"), p);
  var oe;
  const ie = (oe = e.KeyboardEvent) !== null && oe !== void 0 ? oe : (f = class extends J {
  }, o(f, "KeyboardEvent"), f);
  var Y;
  const be = (Y = e.MouseEvent) !== null && Y !== void 0 ? Y : (m = class extends J {
  }, o(m, "MouseEvent"), m);
  var we;
  const le = (we = e.DragEvent) !== null && we !== void 0 ? we : (y = class extends be {
  }, o(y, "DragEvent"), y);
  var X;
  const Re = (X = e.PointerEvent) !== null && X !== void 0 ? X : (g = class extends be {
  }, o(g, "PointerEvent"), g);
  var Pe;
  const lt = (Pe = e.TouchEvent) !== null && Pe !== void 0 ? Pe : (v = class extends J {
  }, o(v, "TouchEvent"), v);
  return {
    Event: b,
    AnimationEvent: C,
    ClipboardEvent: N,
    PopStateEvent: S,
    ProgressEvent: T,
    TransitionEvent: R,
    UIEvent: J,
    CompositionEvent: q,
    FocusEvent: H,
    InputEvent: Z,
    KeyboardEvent: ie,
    MouseEvent: be,
    DragEvent: le,
    PointerEvent: Re,
    TouchEvent: lt
  };
}
o(pC, "getEventConstructors");
function kr(e, t) {
  for (const [r, n] of Object.entries(t))
    Object.defineProperty(e, r, {
      get: /* @__PURE__ */ o(() => n ?? null, "get")
    });
}
o(kr, "assignProps");
function $e(e) {
  return Number(e ?? 0);
}
o($e, "sanitizeNumber");
function fC(e, { clipboardData: t }) {
  kr(e, {
    clipboardData: t
  });
}
o(fC, "initClipboardEvent");
function mC(e, { relatedTarget: t }) {
  kr(e, {
    relatedTarget: t
  });
}
o(mC, "initFocusEvent");
function hC(e, { data: t, inputType: r, isComposing: n }) {
  kr(e, {
    data: t,
    isComposing: !!n,
    inputType: String(r)
  });
}
o(hC, "initInputEvent");
function Un(e, { view: t, detail: r }) {
  kr(e, {
    view: t,
    detail: $e(r ?? 0)
  });
}
o(Un, "initUIEvent");
function Ni(e, { altKey: t, ctrlKey: r, metaKey: n, shiftKey: a, modifierAltGraph: i, modifierCapsLock: s, modifierFn: l, modifierFnLock: c, modifierNumLock: u, modifierScrollLock: p, modifierSymbol: f, modifierSymbolLock: m }) {
  kr(e, {
    altKey: !!t,
    ctrlKey: !!r,
    metaKey: !!n,
    shiftKey: !!a,
    getModifierState(y) {
      return !!{
        Alt: t,
        AltGraph: i,
        CapsLock: s,
        Control: r,
        Fn: l,
        FnLock: c,
        Meta: n,
        NumLock: u,
        ScrollLock: p,
        Shift: a,
        Symbol: f,
        SymbolLock: m
      }[y];
    }
  });
}
o(Ni, "initUIEventModifiers");
function yC(e, { key: t, code: r, location: n, repeat: a, isComposing: i, charCode: s }) {
  kr(e, {
    key: String(t),
    code: String(r),
    location: $e(n),
    repeat: !!a,
    isComposing: !!i,
    charCode: s
  });
}
o(yC, "initKeyboardEvent");
function xd(e, { x: t, y: r, screenX: n, screenY: a, clientX: i = t, clientY: s = r, button: l, buttons: c, relatedTarget: u, offsetX: p, offsetY: f, pageX: m, pageY: y }) {
  kr(e, {
    screenX: $e(n),
    screenY: $e(a),
    clientX: $e(i),
    x: $e(i),
    clientY: $e(s),
    y: $e(s),
    button: $e(l),
    buttons: $e(c),
    relatedTarget: u,
    offsetX: $e(p),
    offsetY: $e(f),
    pageX: $e(m),
    pageY: $e(y)
  });
}
o(xd, "initMouseEvent");
function gC(e, { pointerId: t, width: r, height: n, pressure: a, tangentialPressure: i, tiltX: s, tiltY: l, twist: c, pointerType: u, isPrimary: p }) {
  kr(e, {
    pointerId: $e(t),
    width: $e(r ?? 1),
    height: $e(n ?? 1),
    pressure: $e(a),
    tangentialPressure: $e(i),
    tiltX: $e(s),
    tiltY: $e(l),
    twist: $e(c),
    pointerType: String(u),
    isPrimary: !!p
  });
}
o(gC, "initPointerEvent");
function bC(e, t, r, n = !1) {
  (cC(t) || dC(t)) && (r = {
    ...r,
    ...this.system.getUIEventModifiers()
  });
  const a = Ph(t, e, r);
  return Oh.call(this, e, a, n);
}
o(bC, "dispatchUIEvent");
function Oh(e, t, r = !1) {
  var n;
  const a = t.type, i = r ? () => {
  } : (n = Yr[a]) === null || n === void 0 ? void 0 : n.call(Yr, t, e, this);
  if (i) {
    t.preventDefault();
    let s = !1;
    return Object.defineProperty(t, "defaultPrevented", {
      get: /* @__PURE__ */ o(() => s, "get")
    }), Object.defineProperty(t, "preventDefault", {
      value: /* @__PURE__ */ o(() => {
        s = t.cancelable;
      }, "value")
    }), wo(() => e.dispatchEvent(t)), s || i(), !s;
  }
  return wo(() => e.dispatchEvent(t));
}
o(Oh, "dispatchEvent");
function Dr(e, t, r) {
  const n = Ph(t, e, r);
  wo(() => e.dispatchEvent(n));
}
o(Dr, "dispatchDOMEvent");
var Eg = Symbol("patched focus/blur methods");
function Ch(e) {
  if (e.prototype[Eg])
    return;
  const { focus: t, blur: r } = e.prototype;
  Object.defineProperties(e.prototype, {
    focus: {
      configurable: !0,
      get: /* @__PURE__ */ o(() => a, "get")
    },
    blur: {
      configurable: !0,
      get: /* @__PURE__ */ o(() => i, "get")
    },
    [Eg]: {
      configurable: !0,
      get: /* @__PURE__ */ o(() => ({
        focus: t,
        blur: r
      }), "get")
    }
  });
  let n;
  function a(s) {
    if (this.ownerDocument.visibilityState !== "hidden")
      return t.call(this, s);
    const l = Td(this.ownerDocument);
    if (l === this)
      return;
    const c = Symbol("focus call");
    n = c, l && (r.call(l), Dr(l, "blur", {
      relatedTarget: this
    }), Dr(l, "focusout", {
      relatedTarget: n === c ? this : null
    })), n === c && (t.call(this, s), Dr(this, "focus", {
      relatedTarget: l
    })), n === c && Dr(this, "focusin", {
      relatedTarget: l
    });
  }
  o(a, "patchedFocus");
  function i() {
    if (this.ownerDocument.visibilityState !== "hidden")
      return r.call(this);
    const s = Td(this.ownerDocument);
    s === this && (n = Symbol("blur call"), r.call(this), Dr(s, "blur", {
      relatedTarget: null
    }), Dr(s, "focusout", {
      relatedTarget: null
    }));
  }
  o(i, "patchedBlur");
}
o(Ch, "patchFocus");
function Td(e) {
  const t = Mo(e);
  return t?.tagName === "BODY" ? null : t;
}
o(Td, "getActiveTarget");
var Hu = Symbol("Interceptor for programmatical calls");
function pn(e, t, r) {
  const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), a = Object.getOwnPropertyDescriptor(e, t), i = n?.set ? "set" : "value";
  if (typeof n?.[i] != "function" || n[i][Hu])
    throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
  function s(...l) {
    const { applyNative: c = !1, realArgs: u, then: p } = r.call(this, ...l), f = (!c && a || n)[i];
    i === "set" ? f.call(this, u) : f.call(this, ...u), p?.();
  }
  o(s, "intercept"), s[Hu] = Hu, Object.defineProperty(e, t, {
    ...a ?? n,
    [i]: s
  });
}
o(pn, "prepareInterceptor");
function vC(e) {
  pn(e, "value", /* @__PURE__ */ o(function(t) {
    const r = MO(t);
    return r && YO(this), {
      applyNative: !!r,
      realArgs: wC(this, t),
      then: r ? void 0 : () => XO(this, String(t))
    };
  }, "interceptorImpl"));
}
o(vC, "prepareValueInterceptor");
function wC(e, t) {
  return fe(e, "input", {
    type: "number"
  }) && String(t) !== "" && !Number.isNaN(Number(t)) ? String(Number(t)) : String(t);
}
o(wC, "sanitizeValue");
function _C(e) {
  pn(e, "setSelectionRange", /* @__PURE__ */ o(function(t, ...r) {
    const n = $O(t);
    return {
      applyNative: !!n,
      realArgs: [
        Number(t),
        ...r
      ],
      then: /* @__PURE__ */ o(() => n ? void 0 : ca(e), "then")
    };
  }, "interceptorImpl")), pn(e, "selectionStart", /* @__PURE__ */ o(function(t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ o(() => ca(e), "then")
    };
  }, "interceptorImpl")), pn(e, "selectionEnd", /* @__PURE__ */ o(function(t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ o(() => ca(e), "then")
    };
  }, "interceptorImpl")), pn(e, "select", /* @__PURE__ */ o(function() {
    return {
      realArgs: [],
      then: /* @__PURE__ */ o(() => FO(e, {
        anchorOffset: 0,
        focusOffset: Gt(e).length
      }), "then")
    };
  }, "interceptorImpl"));
}
o(_C, "prepareSelectionInterceptor");
function EC(e) {
  pn(e, "setRangeText", /* @__PURE__ */ o(function(...t) {
    return {
      realArgs: t,
      then: /* @__PURE__ */ o(() => {
        Ql(e), ca(e);
      }, "then")
    };
  }, "interceptorImpl"));
}
o(EC, "prepareRangeTextInterceptor");
var ro = Symbol("Node prepared with document state workarounds");
function Ah(e) {
  e[ro] || (e.addEventListener("focus", (t) => {
    const r = t.target;
    Sd(r);
  }, {
    capture: !0,
    passive: !0
  }), e.activeElement && Sd(e.activeElement), e.addEventListener("blur", (t) => {
    const r = t.target, n = DO(r);
    n !== void 0 && (r.value !== n && Dr(r, "change"), vh(r));
  }, {
    capture: !0,
    passive: !0
  }), e[ro] = ro);
}
o(Ah, "prepareDocument");
function Sd(e) {
  e[ro] || (fe(e, [
    "input",
    "textarea"
  ]) && (vC(e), _C(e), EC(e)), e[ro] = ro);
}
o(Sd, "prepareElement");
function xC(e) {
  return TC(e) ? e : e.ownerDocument;
}
o(xC, "getDocumentFromNode");
function TC(e) {
  return e.nodeType === 9;
}
o(TC, "isDocument");
var vt = (function(e) {
  return e[e.Trigger = 2] = "Trigger", e[e.Call = 1] = "Call", e;
})({});
function Kn(e, t) {
  e.levelRefs[t] = {};
}
o(Kn, "setLevelRef");
function Zo(e, t) {
  return e.levelRefs[t];
}
o(Zo, "getLevelRef");
function Pn(e) {
  const t = e.delay;
  if (typeof t == "number")
    return Promise.all([
      new Promise((r) => globalThis.setTimeout(() => r(), t)),
      e.advanceTimers(t)
    ]);
}
o(Pn, "wait");
var qi = (function(e) {
  return e[e.EachTrigger = 4] = "EachTrigger", e[e.EachApiCall = 2] = "EachApiCall", e[e.EachTarget = 1] = "EachTarget", e[e.Never = 0] = "Never", e;
})({});
function qr(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(qr, "_define_property");
var Yt = (function(e) {
  return e[e.STANDARD = 0] = "STANDARD", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.NUMPAD = 3] = "NUMPAD", e;
})({}), FB = [
  "Alt",
  "AltGraph",
  "Control",
  "Fn",
  "Meta",
  "Shift",
  "Symbol"
];
function Pd(e) {
  return FB.includes(e);
}
o(Pd, "isModifierKey");
var BB = [
  "CapsLock",
  "FnLock",
  "NumLock",
  "ScrollLock",
  "SymbolLock"
];
function Od(e) {
  return BB.includes(e);
}
o(Od, "isModifierLock");
var SC = class {
  isKeyPressed(e) {
    return this.pressed.has(String(e.code));
  }
  getPressedKeys() {
    return this.pressed.values().map((e) => e.keyDef);
  }
  /** Press a key */
  async keydown(e, t) {
    const r = String(t.key), n = String(t.code), a = ji(e.config.document);
    this.setKeydownTarget(a), this.pressed.add(n, t), Pd(r) && (this.modifiers[r] = !0);
    const i = e.dispatchUIEvent(a, "keydown", {
      key: r,
      code: n
    });
    Od(r) && !this.modifiers[r] && (this.modifiers[r] = !0, this.modifierLockStart[r] = !0), i && this.pressed.setUnprevented(n), i && this.hasKeyPress(r) && e.dispatchUIEvent(ji(e.config.document), "keypress", {
      key: r,
      code: n,
      charCode: t.key === "Enter" ? 13 : String(t.key).charCodeAt(0)
    });
  }
  /** Release a key */
  async keyup(e, t) {
    const r = String(t.key), n = String(t.code), a = this.pressed.isUnprevented(n);
    this.pressed.delete(n), Pd(r) && !this.pressed.values().find((i) => i.keyDef.key === r) && (this.modifiers[r] = !1), e.dispatchUIEvent(ji(e.config.document), "keyup", {
      key: r,
      code: n
    }, !a), Od(r) && this.modifiers[r] && (this.modifierLockStart[r] ? this.modifierLockStart[r] = !1 : this.modifiers[r] = !1);
  }
  setKeydownTarget(e) {
    e !== this.lastKeydownTarget && (this.carryChar = ""), this.lastKeydownTarget = e;
  }
  hasKeyPress(e) {
    return (e.length === 1 || e === "Enter") && !this.modifiers.Control && !this.modifiers.Alt;
  }
  constructor(e) {
    qr(this, "system", void 0), qr(this, "modifiers", {
      Alt: !1,
      AltGraph: !1,
      CapsLock: !1,
      Control: !1,
      Fn: !1,
      FnLock: !1,
      Meta: !1,
      NumLock: !1,
      ScrollLock: !1,
      Shift: !1,
      Symbol: !1,
      SymbolLock: !1
    }), qr(this, "pressed", new class {
      add(t, r) {
        var n, a, i;
        (i = (n = this.registry)[a = t]) !== null && i !== void 0 || (n[a] = {
          keyDef: r,
          unpreventedDefault: !1
        });
      }
      has(t) {
        return !!this.registry[t];
      }
      setUnprevented(t) {
        const r = this.registry[t];
        r && (r.unpreventedDefault = !0);
      }
      isUnprevented(t) {
        var r;
        return !!(!((r = this.registry[t]) === null || r === void 0) && r.unpreventedDefault);
      }
      delete(t) {
        delete this.registry[t];
      }
      values() {
        return Object.values(this.registry);
      }
      constructor() {
        qr(this, "registry", {});
      }
    }()), qr(this, "carryChar", ""), qr(this, "lastKeydownTarget", void 0), qr(this, "modifierLockStart", {}), this.system = e;
  }
};
o(SC, "KeyboardHost");
var UB = SC, HB = [
  // alphanumeric block - writing system
  ..."0123456789".split("").map((e) => ({
    code: `Digit${e}`,
    key: e
  })),
  ...")!@#$%^&*(".split("").map((e, t) => ({
    code: `Digit${t}`,
    key: e,
    shiftKey: !0
  })),
  ..."abcdefghijklmnopqrstuvwxyz".split("").map((e) => ({
    code: `Key${e.toUpperCase()}`,
    key: e
  })),
  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((e) => ({
    code: `Key${e}`,
    key: e,
    shiftKey: !0
  })),
  {
    code: "BracketLeft",
    key: "["
  },
  {
    code: "BracketLeft",
    key: "{",
    shiftKey: !0
  },
  {
    code: "BracketRight",
    key: "]"
  },
  {
    code: "BracketRight",
    key: "}",
    shiftKey: !0
  },
  // alphanumeric block - functional
  {
    code: "Space",
    key: " "
  },
  {
    code: "AltLeft",
    key: "Alt",
    location: Yt.LEFT
  },
  {
    code: "AltRight",
    key: "Alt",
    location: Yt.RIGHT
  },
  {
    code: "ShiftLeft",
    key: "Shift",
    location: Yt.LEFT
  },
  {
    code: "ShiftRight",
    key: "Shift",
    location: Yt.RIGHT
  },
  {
    code: "ControlLeft",
    key: "Control",
    location: Yt.LEFT
  },
  {
    code: "ControlRight",
    key: "Control",
    location: Yt.RIGHT
  },
  {
    code: "MetaLeft",
    key: "Meta",
    location: Yt.LEFT
  },
  {
    code: "MetaRight",
    key: "Meta",
    location: Yt.RIGHT
  },
  {
    code: "OSLeft",
    key: "OS",
    location: Yt.LEFT
  },
  {
    code: "OSRight",
    key: "OS",
    location: Yt.RIGHT
  },
  {
    code: "ContextMenu",
    key: "ContextMenu"
  },
  {
    code: "Tab",
    key: "Tab"
  },
  {
    code: "CapsLock",
    key: "CapsLock"
  },
  {
    code: "Backspace",
    key: "Backspace"
  },
  {
    code: "Enter",
    key: "Enter"
  },
  // function
  {
    code: "Escape",
    key: "Escape"
  },
  // arrows
  {
    code: "ArrowUp",
    key: "ArrowUp"
  },
  {
    code: "ArrowDown",
    key: "ArrowDown"
  },
  {
    code: "ArrowLeft",
    key: "ArrowLeft"
  },
  {
    code: "ArrowRight",
    key: "ArrowRight"
  },
  // control pad
  {
    code: "Home",
    key: "Home"
  },
  {
    code: "End",
    key: "End"
  },
  {
    code: "Delete",
    key: "Delete"
  },
  {
    code: "PageUp",
    key: "PageUp"
  },
  {
    code: "PageDown",
    key: "PageDown"
  },
  // Special keys that are not part of a default US-layout but included for specific behavior
  {
    code: "Fn",
    key: "Fn"
  },
  {
    code: "Symbol",
    key: "Symbol"
  },
  {
    code: "AltRight",
    key: "AltGraph"
  }
], VB = [
  {
    name: "MouseLeft",
    pointerType: "mouse",
    button: "primary"
  },
  {
    name: "MouseRight",
    pointerType: "mouse",
    button: "secondary"
  },
  {
    name: "MouseMiddle",
    pointerType: "mouse",
    button: "auxiliary"
  },
  {
    name: "TouchA",
    pointerType: "touch"
  },
  {
    name: "TouchB",
    pointerType: "touch"
  },
  {
    name: "TouchC",
    pointerType: "touch"
  }
];
function PC(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(PC, "_define_property");
var OC = class {
  getButtons() {
    let e = 0;
    for (const t of Object.keys(this.pressed))
      e |= 2 ** Number(t);
    return e;
  }
  down(e) {
    const t = Ps(e.button);
    if (t in this.pressed) {
      this.pressed[t].push(e);
      return;
    }
    return this.pressed[t] = [
      e
    ], t;
  }
  up(e) {
    const t = Ps(e.button);
    if (t in this.pressed && (this.pressed[t] = this.pressed[t].filter((r) => r.name !== e.name), this.pressed[t].length === 0))
      return delete this.pressed[t], t;
  }
  constructor() {
    PC(this, "pressed", {});
  }
};
o(OC, "Buttons");
var CC = OC, xg = {
  primary: 0,
  secondary: 1,
  auxiliary: 2,
  back: 3,
  X1: 3,
  forward: 4,
  X2: 4
};
function Ps(e = 0) {
  return e in xg ? xg[e] : Number(e);
}
o(Ps, "getMouseButtonId");
var Tg = {
  1: 2,
  2: 1
};
function Os(e) {
  return e = Ps(e), e in Tg ? Tg[e] : e;
}
o(Os, "getMouseEventButton");
function AC(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(AC, "_define_property");
var RC = class {
  get countPressed() {
    return this.pressedKeys.size;
  }
  isPressed(e) {
    return this.pressedKeys.has(e.name);
  }
  addPressed(e) {
    return this.pressedKeys.add(e.name);
  }
  removePressed(e) {
    return this.pressedKeys.delete(e.name);
  }
  constructor() {
    AC(this, "pressedKeys", /* @__PURE__ */ new Set());
  }
};
o(RC, "Device");
var JB = RC;
function no(e, t) {
  const r = [];
  for (let i = e; i; i = i.parentElement)
    r.push(i);
  const n = [];
  for (let i = t; i; i = i.parentElement)
    n.push(i);
  let a = 0;
  for (; !(a >= r.length || a >= n.length || r[r.length - 1 - a] !== n[n.length - 1 - a]); a++)
    ;
  return [
    r.slice(0, r.length - a),
    n.slice(0, n.length - a),
    n.slice(n.length - a)
  ];
}
o(no, "getTreeDiff");
function Cs({ target: e, node: t, offset: r }) {
  return Wt(e) ? {
    node: e,
    offset: r ?? Gt(e).length
  } : t ? {
    node: t,
    offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length)
  } : Rh(e, r);
}
o(Cs, "resolveCaretPosition");
function Rh(e, t, r = !0) {
  let n = t === void 0 ? e.childNodes.length - 1 : 0;
  const a = t === void 0 ? -1 : 1;
  for (; t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length; ) {
    if (t && n === e.childNodes.length)
      throw new Error("The given offset is out of bounds.");
    const i = e.childNodes.item(n), s = String(i.textContent);
    if (s.length)
      if (t !== void 0 && s.length < t)
        t -= s.length;
      else {
        if (i.nodeType === 1)
          return Rh(i, t, !1);
        if (i.nodeType === 3)
          return {
            node: i,
            offset: t ?? i.nodeValue.length
          };
      }
    n += a;
  }
  return {
    node: e,
    offset: e.childNodes.length
  };
}
o(Rh, "findNodeAtTextOffset");
function kC({ document: e, target: t, clickCount: r, node: n, offset: a }) {
  if (jO(t))
    return;
  const i = Wt(t), s = String(i ? Gt(t) : t.textContent), [l, c] = n ? (
    // which elements might be considered in the same line of text.
    // TODO: support expanding initial range on multiple clicks if node is given
    [
      a,
      a
    ]
  ) : IC(s, a, r);
  if (i)
    return Mn(t, {
      anchorOffset: l ?? s.length,
      focusOffset: c ?? s.length
    }), {
      node: t,
      start: l ?? 0,
      end: c ?? s.length
    };
  {
    const { node: u, offset: p } = Cs({
      target: t,
      node: n,
      offset: l
    }), { node: f, offset: m } = Cs({
      target: t,
      node: n,
      offset: c
    }), y = t.ownerDocument.createRange();
    try {
      y.setStart(u, p), y.setEnd(f, m);
    } catch {
      throw new Error("The given offset is out of bounds.");
    }
    const g = e.getSelection();
    return g?.removeAllRanges(), g?.addRange(y.cloneRange()), y;
  }
}
o(kC, "setSelectionPerMouseDown");
function IC(e, t, r) {
  if (r % 3 === 1 || e.length === 0)
    return [
      t,
      t
    ];
  const n = t ?? e.length;
  return r % 3 === 2 ? [
    n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length
  ] : [
    n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
    t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length
  ];
}
o(IC, "getTextRange");
function jC(e, { document: t, target: r, node: n, offset: a }) {
  const i = Cs({
    target: r,
    node: n,
    offset: a
  });
  if ("node" in e) {
    if (i.node === e.node) {
      const s = i.offset < e.start ? e.end : e.start, l = i.offset > e.end || i.offset < e.start ? i.offset : e.end;
      Mn(e.node, {
        anchorOffset: s,
        focusOffset: l
      });
    }
  } else {
    const s = e.cloneRange(), l = s.comparePoint(i.node, i.offset);
    l < 0 ? s.setStart(i.node, i.offset) : l > 0 && s.setEnd(i.node, i.offset);
    const c = t.getSelection();
    c?.removeAllRanges(), c?.addRange(s.cloneRange());
  }
}
o(jC, "modifySelectionPerMouseMove");
function kh(e, t) {
  var r, n, a, i, s, l, c, u, p, f, m, y, g, v, _, b, E, C, k, N, O, S, w, T;
  return e.target !== t.target || ((r = e.coords) === null || r === void 0 ? void 0 : r.x) !== ((n = t.coords) === null || n === void 0 ? void 0 : n.x) || ((a = e.coords) === null || a === void 0 ? void 0 : a.y) !== ((i = t.coords) === null || i === void 0 ? void 0 : i.y) || ((s = e.coords) === null || s === void 0 ? void 0 : s.clientX) !== ((l = t.coords) === null || l === void 0 ? void 0 : l.clientX) || ((c = e.coords) === null || c === void 0 ? void 0 : c.clientY) !== ((u = t.coords) === null || u === void 0 ? void 0 : u.clientY) || ((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !== ((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) || ((m = e.coords) === null || m === void 0 ? void 0 : m.offsetY) !== ((y = t.coords) === null || y === void 0 ? void 0 : y.offsetY) || ((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !== ((v = t.coords) === null || v === void 0 ? void 0 : v.pageX) || ((_ = e.coords) === null || _ === void 0 ? void 0 : _.pageY) !== ((b = t.coords) === null || b === void 0 ? void 0 : b.pageY) || ((E = e.coords) === null || E === void 0 ? void 0 : E.screenX) !== ((C = t.coords) === null || C === void 0 ? void 0 : C.screenX) || ((k = e.coords) === null || k === void 0 ? void 0 : k.screenY) !== ((N = t.coords) === null || N === void 0 ? void 0 : N.screenY) || ((O = e.caret) === null || O === void 0 ? void 0 : O.node) !== ((S = t.caret) === null || S === void 0 ? void 0 : S.node) || ((w = e.caret) === null || w === void 0 ? void 0 : w.offset) !== ((T = t.caret) === null || T === void 0 ? void 0 : T.offset);
}
o(kh, "isDifferentPointerPosition");
function Mr(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(Mr, "_define_property");
var NC = class {
  move(e, t, r) {
    const n = this.position, a = this.getTarget(e);
    if (this.position = t, !kh(n, t))
      return;
    const i = this.getTarget(e), s = this.getEventInit("mousemove"), [l, c] = no(a, i);
    return {
      leave: /* @__PURE__ */ o(() => {
        a !== i && (e.dispatchUIEvent(a, "mouseout", s), l.forEach((u) => e.dispatchUIEvent(u, "mouseleave", s)));
      }, "leave"),
      enter: /* @__PURE__ */ o(() => {
        a !== i && (e.dispatchUIEvent(i, "mouseover", s), c.forEach((u) => e.dispatchUIEvent(u, "mouseenter", s)));
      }, "enter"),
      move: /* @__PURE__ */ o(() => {
        r || (e.dispatchUIEvent(i, "mousemove", s), this.modifySelecting(e));
      }, "move")
    };
  }
  down(e, t, r) {
    const n = this.buttons.down(t);
    if (n === void 0)
      return;
    const a = this.getTarget(e);
    this.buttonDownTarget[n] = a;
    const i = this.getEventInit("mousedown", t.button), s = ar(a);
    !r && (s || e.dispatchUIEvent(a, "mousedown", i)) && (this.startSelecting(e, i.detail), Cr(a)), !s && Os(t.button) === 2 && e.dispatchUIEvent(a, "contextmenu", this.getEventInit("contextmenu", t.button));
  }
  up(e, t, r) {
    const n = this.buttons.up(t);
    if (n === void 0)
      return;
    const a = this.getTarget(e);
    if (!ar(a)) {
      if (!r) {
        const s = this.getEventInit("mouseup", t.button);
        e.dispatchUIEvent(a, "mouseup", s), this.endSelecting();
      }
      const i = no(this.buttonDownTarget[n], a)[2][0];
      if (i) {
        const s = this.getEventInit("click", t.button);
        s.detail && (e.dispatchUIEvent(i, s.button === 0 ? "click" : "auxclick", s), s.button === 0 && s.detail === 2 && e.dispatchUIEvent(i, "dblclick", {
          ...this.getEventInit("dblclick", t.button),
          detail: s.detail
        }));
      }
    }
  }
  resetClickCount() {
    this.clickCount.reset();
  }
  getEventInit(e, t) {
    const r = {
      ...this.position.coords
    };
    return r.button = Os(t), r.buttons = this.buttons.getButtons(), e === "mousedown" ? r.detail = this.clickCount.getOnDown(r.button) : e === "mouseup" ? r.detail = this.clickCount.getOnUp(r.button) : (e === "click" || e === "auxclick") && (r.detail = this.clickCount.incOnClick(r.button)), r;
  }
  getTarget(e) {
    var t;
    return (t = this.position.target) !== null && t !== void 0 ? t : e.config.document.body;
  }
  startSelecting(e, t) {
    var r, n;
    this.selecting = kC({
      document: e.config.document,
      target: this.getTarget(e),
      node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset,
      clickCount: t
    });
  }
  modifySelecting(e) {
    var t, r;
    this.selecting && jC(this.selecting, {
      document: e.config.document,
      target: this.getTarget(e),
      node: (t = this.position.caret) === null || t === void 0 ? void 0 : t.node,
      offset: (r = this.position.caret) === null || r === void 0 ? void 0 : r.offset
    });
  }
  endSelecting() {
    this.selecting = void 0;
  }
  constructor() {
    Mr(this, "position", {}), Mr(this, "buttons", new CC()), Mr(this, "selecting", void 0), Mr(this, "buttonDownTarget", {}), Mr(this, "clickCount", new class {
      incOnClick(e) {
        const t = this.down[e] === void 0 ? void 0 : Number(this.down[e]) + 1;
        return this.count = this.count[e] === void 0 ? {} : {
          [e]: Number(this.count[e]) + 1
        }, t;
      }
      getOnDown(e) {
        var t;
        this.down = {
          [e]: (t = this.count[e]) !== null && t !== void 0 ? t : 0
        };
        var r;
        return this.count = {
          [e]: (r = this.count[e]) !== null && r !== void 0 ? r : 0
        }, Number(this.count[e]) + 1;
      }
      getOnUp(e) {
        return this.down[e] === void 0 ? void 0 : Number(this.down[e]) + 1;
      }
      reset() {
        this.count = {};
      }
      constructor() {
        Mr(this, "down", {}), Mr(this, "count", {});
      }
    }());
  }
};
o(NC, "Mouse");
var zB = NC;
function qa(e, t) {
  var r;
  return ((r = Ih(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== "none";
}
o(qa, "hasPointerEvents");
function qC(e) {
  const t = Ot(e);
  for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
    n.push(r);
    const a = t.getComputedStyle(r).pointerEvents;
    if (a && ![
      "inherit",
      "unset"
    ].includes(a))
      return {
        pointerEvents: a,
        tree: n
      };
  }
}
o(qC, "closestPointerEventsDeclaration");
var Sg = Symbol("Last check for pointer-events");
function Ih(e, t) {
  const r = t[Sg];
  if (!(e.config.pointerEventsCheck !== qi.Never && (!r || Cd(e.config.pointerEventsCheck, qi.EachApiCall) && r[vt.Call] !== Zo(e, vt.Call) || Cd(e.config.pointerEventsCheck, qi.EachTrigger) && r[vt.Trigger] !== Zo(e, vt.Trigger))))
    return r?.result;
  const n = qC(t);
  return t[Sg] = {
    [vt.Call]: Zo(e, vt.Call),
    [vt.Trigger]: Zo(e, vt.Trigger),
    result: n
  }, n;
}
o(Ih, "checkPointerEvents");
function Yn(e, t) {
  const r = Ih(e, t);
  if (r?.pointerEvents === "none")
    throw new Error([
      `Unable to perform pointer interaction as the element ${r.tree.length > 1 ? "inherits" : "has"} \`pointer-events: none\`:`,
      "",
      MC(r.tree)
    ].join(`
`));
}
o(Yn, "assertPointerEvents");
function MC(e) {
  return e.reverse().map((t, r) => [
    "".padEnd(r),
    t.tagName,
    t.id && `#${t.id}`,
    t.hasAttribute("data-testid") && `(testId=${t.getAttribute("data-testid")})`,
    $C(t),
    e.length > 1 && r === 0 && "  <-- This element declared `pointer-events: none`",
    e.length > 1 && r === e.length - 1 && "  <-- Asserted pointer events here"
  ].filter(Boolean).join("")).join(`
`);
}
o(MC, "printTree");
function $C(e) {
  var t;
  let r;
  if (e.hasAttribute("aria-label"))
    r = e.getAttribute("aria-label");
  else if (e.hasAttribute("aria-labelledby")) {
    var n, a;
    r = (a = e.ownerDocument.getElementById(e.getAttribute("aria-labelledby"))) === null || a === void 0 || (n = a.textContent) === null || n === void 0 ? void 0 : n.trim();
  } else if (fe(e, [
    "button",
    "input",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]) && !((t = e.labels) === null || t === void 0) && t.length)
    r = Array.from(e.labels).map((s) => {
      var l;
      return (l = s.textContent) === null || l === void 0 ? void 0 : l.trim();
    }).join("|");
  else if (fe(e, "button")) {
    var i;
    r = (i = e.textContent) === null || i === void 0 ? void 0 : i.trim();
  }
  return r = r?.replace(/\n/g, "  "), Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}â€¦`), r ? `(label=${r})` : "";
}
o($C, "getLabelDescr");
function Cd(e, t) {
  return (e & t) > 0;
}
o(Cd, "hasBitFlag");
function Zt(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(Zt, "_define_property");
var LC = class {
  init(e) {
    const t = this.getTarget(e), [, r] = no(null, t), n = this.getEventInit();
    return Yn(e, t), e.dispatchUIEvent(t, "pointerover", n), r.forEach((a) => e.dispatchUIEvent(a, "pointerenter", n)), this;
  }
  move(e, t) {
    const r = this.position, n = this.getTarget(e);
    if (this.position = t, !kh(r, t))
      return;
    const a = this.getTarget(e), i = this.getEventInit(-1), [s, l] = no(n, a);
    return {
      leave: /* @__PURE__ */ o(() => {
        qa(e, n) && n !== a && (e.dispatchUIEvent(n, "pointerout", i), s.forEach((c) => e.dispatchUIEvent(c, "pointerleave", i)));
      }, "leave"),
      enter: /* @__PURE__ */ o(() => {
        Yn(e, a), n !== a && (e.dispatchUIEvent(a, "pointerover", i), l.forEach((c) => e.dispatchUIEvent(c, "pointerenter", i)));
      }, "enter"),
      move: /* @__PURE__ */ o(() => {
        e.dispatchUIEvent(a, "pointermove", i);
      }, "move")
    };
  }
  down(e, t = 0) {
    if (this.isDown)
      return;
    const r = this.getTarget(e);
    Yn(e, r), this.isDown = !0, this.isPrevented = !e.dispatchUIEvent(r, "pointerdown", this.getEventInit(t));
  }
  up(e, t = 0) {
    if (!this.isDown)
      return;
    const r = this.getTarget(e);
    Yn(e, r), this.isPrevented = !1, this.isDown = !1, e.dispatchUIEvent(r, "pointerup", this.getEventInit(t));
  }
  release(e) {
    const t = this.getTarget(e), [r] = no(t, null), n = this.getEventInit();
    qa(e, t) && (e.dispatchUIEvent(t, "pointerout", n), r.forEach((a) => e.dispatchUIEvent(a, "pointerleave", n))), this.isCancelled = !0;
  }
  getTarget(e) {
    var t;
    return (t = this.position.target) !== null && t !== void 0 ? t : e.config.document.body;
  }
  getEventInit(e) {
    return {
      ...this.position.coords,
      pointerId: this.pointerId,
      pointerType: this.pointerType,
      isPrimary: this.isPrimary,
      button: Os(e),
      buttons: this.buttons.getButtons()
    };
  }
  constructor({ pointerId: e, pointerType: t, isPrimary: r }, n) {
    Zt(this, "pointerId", void 0), Zt(this, "pointerType", void 0), Zt(this, "isPrimary", void 0), Zt(this, "buttons", void 0), Zt(this, "isMultitouch", !1), Zt(this, "isCancelled", !1), Zt(this, "isDown", !1), Zt(this, "isPrevented", !1), Zt(this, "position", {}), this.pointerId = e, this.pointerType = t, this.isPrimary = r, this.isMultitouch = !r, this.buttons = n;
  }
};
o(LC, "Pointer");
var WB = LC;
function vr(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(vr, "_define_property");
var DC = class {
  isKeyPressed(e) {
    return this.devices.get(e.pointerType).isPressed(e);
  }
  async press(e, t, r) {
    this.devices.get(t.pointerType).addPressed(t), this.buttons.down(t);
    const n = this.getPointerName(t), a = t.pointerType === "touch" ? this.pointers.new(n, t.pointerType, this.buttons) : this.pointers.get(n);
    a.position = r, a.pointerType !== "touch" && (this.mouse.position = r), a.pointerType === "touch" && a.init(e), a.down(e, t.button), a.pointerType !== "touch" && this.mouse.down(e, t, a.isPrevented);
  }
  async move(e, t, r) {
    const n = this.pointers.get(t), a = n.move(e, r), i = n.pointerType === "touch" ? void 0 : this.mouse.move(e, r, n.isPrevented);
    a?.leave(), i?.leave(), a?.enter(), i?.enter(), a?.move(), i?.move();
  }
  async release(e, t, r) {
    const n = this.devices.get(t.pointerType);
    n.removePressed(t), this.buttons.up(t);
    const a = this.pointers.get(this.getPointerName(t)), i = a.isPrevented;
    if (a.position = r, a.pointerType !== "touch" && (this.mouse.position = r), n.countPressed === 0 && a.up(e, t.button), a.pointerType === "touch" && a.release(e), a.pointerType === "touch" && !a.isMultitouch) {
      const s = this.mouse.move(e, r, i);
      s?.leave(), s?.enter(), s?.move(), this.mouse.down(e, t, i);
    }
    if (!a.isMultitouch) {
      const s = this.mouse.move(e, r, i);
      s?.leave(), s?.enter(), s?.move(), this.mouse.up(e, t, i);
    }
  }
  getPointerName(e) {
    return e.pointerType === "touch" ? e.name : e.pointerType;
  }
  getPreviousPosition(e) {
    return this.pointers.has(e) ? this.pointers.get(e).position : void 0;
  }
  resetClickCount() {
    this.mouse.resetClickCount();
  }
  getMouseTarget(e) {
    var t;
    return (t = this.mouse.position.target) !== null && t !== void 0 ? t : e.config.document.body;
  }
  setMousePosition(e) {
    this.mouse.position = e, this.pointers.get("mouse").position = e;
  }
  constructor(e) {
    vr(this, "system", void 0), vr(this, "mouse", void 0), vr(this, "buttons", void 0), vr(this, "devices", new class {
      get(t) {
        var r, n, a;
        return (a = (r = this.registry)[n = t]) !== null && a !== void 0 ? a : r[n] = new JB();
      }
      constructor() {
        vr(this, "registry", {});
      }
    }()), vr(this, "pointers", new class {
      new(t, r, n) {
        const a = r !== "touch" || !Object.values(this.registry).some((i) => i.pointerType === "touch" && !i.isCancelled);
        return a || Object.values(this.registry).forEach((i) => {
          i.pointerType === r && !i.isCancelled && (i.isMultitouch = !0);
        }), this.registry[t] = new WB({
          pointerId: this.nextId++,
          pointerType: r,
          isPrimary: a
        }, n), this.registry[t];
      }
      get(t) {
        if (!this.has(t))
          throw new Error(`Trying to access pointer "${t}" which does not exist.`);
        return this.registry[t];
      }
      has(t) {
        return t in this.registry;
      }
      constructor() {
        vr(this, "registry", {}), vr(this, "nextId", 1);
      }
    }()), this.system = e, this.buttons = new CC(), this.mouse = new zB(), this.pointers.new("mouse", "mouse", this.buttons);
  }
};
o(DC, "PointerHost");
var GB = DC;
function Ad(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
o(Ad, "_define_property");
var FC = class {
  getUIEventModifiers() {
    return {
      altKey: this.keyboard.modifiers.Alt,
      ctrlKey: this.keyboard.modifiers.Control,
      metaKey: this.keyboard.modifiers.Meta,
      shiftKey: this.keyboard.modifiers.Shift,
      modifierAltGraph: this.keyboard.modifiers.AltGraph,
      modifierCapsLock: this.keyboard.modifiers.CapsLock,
      modifierFn: this.keyboard.modifiers.Fn,
      modifierFnLock: this.keyboard.modifiers.FnLock,
      modifierNumLock: this.keyboard.modifiers.NumLock,
      modifierScrollLock: this.keyboard.modifiers.ScrollLock,
      modifierSymbol: this.keyboard.modifiers.Symbol,
      modifierSymbolLock: this.keyboard.modifiers.SymbolLock
    };
  }
  constructor() {
    Ad(this, "keyboard", new UB(this)), Ad(this, "pointer", new GB(this));
  }
};
o(FC, "System");
var BC = FC;
async function UC(e) {
  const t = [];
  return this.config.skipHover || t.push({
    target: e
  }), t.push({
    keys: "[MouseLeft]",
    target: e
  }), this.pointer(t);
}
o(UC, "click");
async function HC(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft]"
  ]);
}
o(HC, "dblClick");
async function VC(e) {
  return this.pointer([
    {
      target: e
    },
    "[MouseLeft][MouseLeft][MouseLeft]"
  ]);
}
o(VC, "tripleClick");
async function JC(e) {
  return this.pointer({
    target: e
  });
}
o(JC, "hover");
async function zC(e) {
  return Yn(this, this.system.pointer.getMouseTarget(this)), this.pointer({
    target: e.ownerDocument.body
  });
}
o(zC, "unhover");
async function WC({ shift: e } = {}) {
  return this.keyboard(e === !0 ? "{Shift>}{Tab}{/Shift}" : e === !1 ? "[/ShiftLeft][/ShiftRight]{Tab}" : "{Tab}");
}
o(WC, "tab");
var jh = (function(e) {
  return e["{"] = "}", e["["] = "]", e;
})(jh || {});
function Nh(e, t) {
  let r = 0;
  const n = e[r] in jh ? e[r] : "";
  r += n.length;
  const a = new RegExp(`^\\${n}{2}`).test(e) ? "" : n;
  return {
    type: a,
    ...a === "" ? GC(e, r, t) : KC(e, r, a, t)
  };
}
o(Nh, "readNextDescriptor");
function GC(e, t, r) {
  const n = e[t];
  return qh(n, e, t, r), t += n.length, {
    consumedLength: t,
    descriptor: n,
    releasePrevious: !1,
    releaseSelf: !0,
    repeat: 1
  };
}
o(GC, "readPrintableChar");
function KC(e, t, r, n) {
  var a, i;
  const s = e[t] === "/" ? "/" : "";
  t += s.length;
  const l = r === "{" && e[t] === "\\";
  t += Number(l);
  const c = l ? e[t] : (a = e.slice(t).match(r === "{" ? /^\w+|^[^}>/]/ : /^\w+/)) === null || a === void 0 ? void 0 : a[0];
  qh(c, e, t, n), t += c.length;
  var u;
  const p = (u = (i = e.slice(t).match(/^>\d+/)) === null || i === void 0 ? void 0 : i[0]) !== null && u !== void 0 ? u : "";
  t += p.length;
  const f = e[t] === "/" || !p && e[t] === ">" ? e[t] : "";
  t += f.length;
  const m = jh[r], y = e[t] === m ? m : "";
  if (!y)
    throw new Error(Mh([
      !p && "repeat modifier",
      !f && "release modifier",
      `"${m}"`
    ].filter(Boolean).join(" or "), e[t], e, n));
  return t += y.length, {
    consumedLength: t,
    descriptor: c,
    releasePrevious: !!s,
    repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
    releaseSelf: YC(f, p)
  };
}
o(KC, "readTag");
function qh(e, t, r, n) {
  if (!e)
    throw new Error(Mh("key descriptor", t[r], t, n));
}
o(qh, "assertDescriptor");
function YC(e, t) {
  if (e)
    return e === "/";
  if (t)
    return !1;
}
o(YC, "hasReleaseSelf");
function Mh(e, t, r, n) {
  return `Expected ${e} but found "${t ?? ""}" in "${r}"
    See ${n === "pointer" ? "https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen" : "https://testing-library.com/docs/user-event/keyboard"}
    for more information about how userEvent parses your input.`;
}
o(Mh, "getErrorMessage");
function XC(e, t) {
  const r = [];
  do {
    const { type: a, descriptor: i, consumedLength: s, releasePrevious: l, releaseSelf: c = !0, repeat: u } = Nh(t, "keyboard");
    var n;
    const p = (n = e.find((f) => {
      if (a === "[") {
        var m;
        return ((m = f.code) === null || m === void 0 ? void 0 : m.toLowerCase()) === i.toLowerCase();
      } else if (a === "{") {
        var y;
        return ((y = f.key) === null || y === void 0 ? void 0 : y.toLowerCase()) === i.toLowerCase();
      }
      return f.key === i;
    })) !== null && n !== void 0 ? n : {
      key: "Unknown",
      code: "Unknown",
      [a === "[" ? "code" : "key"]: i
    };
    r.push({
      keyDef: p,
      releasePrevious: l,
      releaseSelf: c,
      repeat: u
    }), t = t.slice(s);
  } while (t);
  return r;
}
o(XC, "parseKeyDef");
async function QC(e) {
  const t = XC(this.config.keyboardMap, e);
  for (let r = 0; r < t.length; r++)
    await Pn(this.config), await ZC(this, t[r]);
}
o(QC, "keyboard");
async function ZC(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: a }) {
  const { system: i } = e;
  if (i.keyboard.isKeyPressed(t) && await i.keyboard.keyup(e, t), !r) {
    for (let s = 1; s <= a; s++)
      await i.keyboard.keydown(e, t), s < a && await Pn(e.config);
    n && await i.keyboard.keyup(e, t);
  }
}
o(ZC, "keyboardAction");
async function eA(e) {
  for (const t of e.system.keyboard.getPressedKeys())
    await e.system.keyboard.keyup(e, t);
}
o(eA, "releaseAllKeys");
function $h(e) {
  const t = Wt(e) ? {
    "text/plain": tA(e)
  } : {
    "text/plain": String(e.ownerDocument.getSelection())
  }, r = Kl(Ot(e));
  for (const n in t)
    t[n] && r.setData(n, t[n]);
  return r;
}
o($h, "copySelection");
function tA(e) {
  const t = Eo(e);
  return Gt(e).substring(t.startOffset, t.endOffset);
}
o(tA, "readSelectedValueFromInput");
async function rA() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = $h(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "copy", {
      clipboardData: n
    }) && this.config.writeToClipboard && await hh(e, n), n;
}
o(rA, "copy");
async function nA() {
  const e = this.config.document;
  var t;
  const r = (t = e.activeElement) !== null && t !== void 0 ? t : (
    /* istanbul ignore next */
    e.body
  ), n = $h(r);
  if (n.items.length !== 0)
    return this.dispatchUIEvent(r, "cut", {
      clipboardData: n
    }) && this.config.writeToClipboard && await hh(r.ownerDocument, n), n;
}
o(nA, "cut");
async function oA(e) {
  const t = this.config.document;
  var r;
  const n = (r = t.activeElement) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    t.body
  );
  var a;
  const i = (a = typeof e == "string" ? aA(t, e) : e) !== null && a !== void 0 ? a : await PO(t).catch(() => {
    throw new Error("`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.");
  });
  this.dispatchUIEvent(n, "paste", {
    clipboardData: i
  });
}
o(oA, "paste");
function aA(e, t) {
  const r = Kl(Ot(e));
  return r.setData("text", t), r;
}
o(aA, "getClipboardDataFromString");
function Rd(e, t) {
  const r = [];
  do {
    const { descriptor: n, consumedLength: a, releasePrevious: i, releaseSelf: s = !0 } = Nh(t, "pointer"), l = e.find((c) => c.name === n);
    l && r.push({
      keyDef: l,
      releasePrevious: i,
      releaseSelf: s
    }), t = t.slice(a);
  } while (t);
  return r;
}
o(Rd, "parseKeyDef");
async function iA(e) {
  const { pointerMap: t } = this.config, r = [];
  (Array.isArray(e) ? e : [
    e
  ]).forEach((n) => {
    typeof n == "string" ? r.push(...Rd(t, n)) : "keys" in n ? r.push(...Rd(t, n.keys).map((a) => ({
      ...n,
      ...a
    }))) : r.push(n);
  });
  for (let n = 0; n < r.length; n++)
    await Pn(this.config), await sA(this, r[n]);
  this.system.pointer.resetClickCount();
}
o(iA, "pointer");
async function sA(e, t) {
  var r, n;
  const a = "pointerName" in t && t.pointerName ? t.pointerName : "keyDef" in t ? e.system.pointer.getPointerName(t.keyDef) : "mouse", i = e.system.pointer.getPreviousPosition(a);
  var s, l, c, u;
  const p = {
    target: (s = t.target) !== null && s !== void 0 ? s : lA(e, i),
    coords: (l = t.coords) !== null && l !== void 0 ? l : i?.coords,
    caret: {
      node: (c = t.node) !== null && c !== void 0 ? c : kd(t) || i == null || (r = i.caret) === null || r === void 0 ? void 0 : r.node,
      offset: (u = t.offset) !== null && u !== void 0 ? u : kd(t) || i == null || (n = i.caret) === null || n === void 0 ? void 0 : n.offset
    }
  };
  "keyDef" in t ? (e.system.pointer.isKeyPressed(t.keyDef) && (Kn(e, vt.Trigger), await e.system.pointer.release(e, t.keyDef, p)), t.releasePrevious || (Kn(e, vt.Trigger), await e.system.pointer.press(e, t.keyDef, p), t.releaseSelf && (Kn(e, vt.Trigger), await e.system.pointer.release(e, t.keyDef, p)))) : (Kn(e, vt.Trigger), await e.system.pointer.move(e, a, p));
}
o(sA, "pointerAction");
function kd(e) {
  var t, r;
  return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0 ? r : e.offset !== void 0);
}
o(kd, "hasCaretPosition");
function lA(e, t) {
  if (!t)
    throw new Error("This pointer has no previous position. Provide a target property!");
  var r;
  return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
o(lA, "getPrevTarget");
async function uA(e) {
  if (!Tn(e) || ar(e))
    throw new Error("clear()` is only supported on editable elements.");
  if (Cr(e), e.ownerDocument.activeElement !== e)
    throw new Error("The element to be cleared could not be focused.");
  if (Th(e), !lC(e))
    throw new Error("The element content to be cleared could not be selected.");
  Sn(this, e, "", "deleteContentBackward");
}
o(uA, "clear");
async function cA(e, t) {
  return Lh.call(this, !0, e, t);
}
o(cA, "selectOptions");
async function dA(e, t) {
  return Lh.call(this, !1, e, t);
}
o(dA, "deselectOptions");
async function Lh(e, t, r) {
  if (!e && !t.multiple)
    throw ge().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", t);
  const n = Array.isArray(r) ? r : [
    r
  ], a = Array.from(t.querySelectorAll('option, [role="option"]')), i = n.map((l) => {
    if (typeof l != "string" && a.includes(l))
      return l;
    {
      const c = a.find((u) => u.value === l || u.innerHTML === l);
      if (c)
        return c;
      throw ge().getElementError(`Value "${String(l)}" not found in options`, t);
    }
  }).filter((l) => !ar(l));
  if (ar(t) || !i.length) return;
  const s = /* @__PURE__ */ o((l) => {
    l.selected = e, this.dispatchUIEvent(t, "input", {
      bubbles: !0,
      cancelable: !1,
      composed: !0
    }), this.dispatchUIEvent(t, "change");
  }, "selectOption");
  if (fe(t, "select"))
    if (t.multiple)
      for (const l of i) {
        const c = this.config.pointerEventsCheck === 0 ? !0 : qa(this, l);
        c && (this.dispatchUIEvent(l, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(l, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(l, "pointermove"), this.dispatchUIEvent(l, "mousemove"), this.dispatchUIEvent(l, "pointerdown"), this.dispatchUIEvent(l, "mousedown")), Cr(t), c && (this.dispatchUIEvent(l, "pointerup"), this.dispatchUIEvent(l, "mouseup")), s(l), c && this.dispatchUIEvent(l, "click"), await Pn(this.config);
      }
    else if (i.length === 1) {
      const l = this.config.pointerEventsCheck === 0 ? !0 : qa(this, t);
      l ? await this.click(t) : Cr(t), s(i[0]), l && (this.dispatchUIEvent(t, "pointerover"), this.dispatchUIEvent(t, "pointerenter"), this.dispatchUIEvent(t, "mouseover"), this.dispatchUIEvent(t, "mouseenter"), this.dispatchUIEvent(t, "pointerup"), this.dispatchUIEvent(t, "mouseup"), this.dispatchUIEvent(t, "click")), await Pn(this.config);
    } else
      throw ge().getElementError("Cannot select multiple options on a non-multiple select", t);
  else if (t.getAttribute("role") === "listbox")
    for (const l of i)
      await this.click(l), await this.unhover(l);
  else
    throw ge().getElementError("Cannot select options on elements that are neither select nor listbox elements", t);
}
o(Lh, "selectOptionsBase");
async function pA(e, t, { skipClick: r = this.config.skipClick, skipAutoClose: n = this.config.skipAutoClose, initialSelectionStart: a, initialSelectionEnd: i } = {}) {
  e.disabled || (r || await this.click(e), a !== void 0 && Gn(e, a, i ?? a), await this.keyboard(t), n || await eA(this));
}
o(pA, "type");
var Pg = Symbol("files and value properties are mocked");
function Mi(e, t, r) {
  r ? Object.defineProperty(e, t, r) : delete e[t];
}
o(Mi, "restoreProperty");
function fA(e, t) {
  var r;
  (r = e[Pg]) === null || r === void 0 || r.restore();
  const n = Object.getOwnPropertyDescriptor(e, "type"), a = Object.getOwnPropertyDescriptor(e, "value"), i = Object.getOwnPropertyDescriptor(e, "files");
  function s() {
    Mi(e, "type", n), Mi(e, "value", a), Mi(e, "files", i);
  }
  o(s, "restore"), e[Pg] = {
    restore: s
  }, Object.defineProperties(e, {
    files: {
      configurable: !0,
      get: /* @__PURE__ */ o(() => t, "get")
    },
    value: {
      configurable: !0,
      get: /* @__PURE__ */ o(() => t.length ? `C:\\fakepath\\${t[0].name}` : "", "get"),
      set(l) {
        if (l === "")
          s();
        else {
          var c;
          a == null || (c = a.set) === null || c === void 0 || c.call(e, l);
        }
      }
    },
    type: {
      configurable: !0,
      get: /* @__PURE__ */ o(() => "file", "get"),
      set(l) {
        l !== "file" && (s(), e.type = l);
      }
    }
  });
}
o(fA, "setFiles");
async function mA(e, t) {
  const r = fe(e, "label") ? e.control : e;
  if (!r || !fe(r, "input", {
    type: "file"
  }))
    throw new TypeError(`The ${r === e ? "given" : "associated"} ${r?.tagName} element does not accept file uploads`);
  if (ar(e)) return;
  const n = (Array.isArray(t) ? t : [
    t
  ]).filter((i) => !this.config.applyAccept || hA(i, r.accept)).slice(0, r.multiple ? void 0 : 1), a = /* @__PURE__ */ o(() => {
    var i;
    n.length === ((i = r.files) === null || i === void 0 ? void 0 : i.length) && n.every((s, l) => {
      var c;
      return s === ((c = r.files) === null || c === void 0 ? void 0 : c.item(l));
    }) || (fA(r, Gl(Ot(e), n)), this.dispatchUIEvent(r, "input"), this.dispatchUIEvent(r, "change"));
  }, "fileDialog");
  r.addEventListener("fileDialog", a), await this.click(e), r.removeEventListener("fileDialog", a);
}
o(mA, "upload");
function ea(e) {
  return e.toLowerCase().replace(/(\.|\/)jpg\b/g, "$1jpeg");
}
o(ea, "normalize");
function hA(e, t) {
  if (!t)
    return !0;
  const r = [
    "audio/*",
    "image/*",
    "video/*"
  ];
  return ea(t).trim().split(/\s*,\s*/).some((n) => n.startsWith(".") ? ea(e.name).endsWith(n) : r.includes(n) ? ea(e.type).startsWith(n.replace("*", "")) : ea(e.type) === n);
}
o(hA, "isAcceptableFile");
var Og = {
  click: UC,
  dblClick: HC,
  tripleClick: VC,
  hover: JC,
  unhover: zC,
  tab: WC,
  keyboard: QC,
  copy: rA,
  cut: nA,
  paste: oA,
  pointer: iA,
  clear: uA,
  deselectOptions: dA,
  selectOptions: cA,
  type: pA,
  upload: mA
};
function yA(e) {
  return ge().asyncWrapper(e);
}
o(yA, "wrapAsync");
var gA = {
  applyAccept: !0,
  autoModify: !0,
  delay: 0,
  document: globalThis.document,
  keyboardMap: HB,
  pointerMap: VB,
  pointerEventsCheck: qi.EachApiCall,
  skipAutoClose: !1,
  skipClick: !1,
  skipHover: !1,
  writeToClipboard: !1,
  advanceTimers: /* @__PURE__ */ o(() => Promise.resolve(), "advanceTimers")
}, KB = {
  ...gA,
  writeToClipboard: !0
};
function Dh(e = {}, t = KB, r) {
  const n = _A(e, r, t);
  return {
    ...t,
    ...e,
    document: n
  };
}
o(Dh, "createConfig");
function bA(e = {}) {
  const t = Dh(e);
  Ah(t.document), Ch(Ot(t.document).HTMLElement);
  var r;
  const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : (
    /* istanbul ignore next */
    globalThis.window
  );
  return xO(n), eu(t).api;
}
o(bA, "setupMain");
function tt({ keyboardState: e, pointerState: t, ...r } = {}, n) {
  const a = Dh(r, gA, n);
  Ah(a.document), Ch(Ot(a.document).HTMLElement);
  var i;
  const s = (i = t ?? e) !== null && i !== void 0 ? i : new BC();
  return {
    api: eu(a, s).api,
    system: s
  };
}
o(tt, "setupDirect");
function vA(e) {
  return eu({
    ...this.config,
    ...e
  }, this.system).api;
}
o(vA, "setupSub");
function wA(e, t) {
  function r(...n) {
    return Kn(e, vt.Call), yA(() => t.apply(e, n).then(async (a) => (await Pn(e.config), a)));
  }
  return o(r, "method"), Object.defineProperty(r, "name", {
    get: /* @__PURE__ */ o(() => t.name, "get")
  }), r;
}
o(wA, "wrapAndBindImpl");
function eu(e, t = new BC()) {
  const r = {};
  return Object.assign(r, {
    config: e,
    dispatchEvent: Oh.bind(r),
    dispatchUIEvent: bC.bind(r),
    system: t,
    levelRefs: {},
    ...Og
  }), {
    instance: r,
    api: {
      ...Object.fromEntries(Object.entries(Og).map(([n, a]) => [
        n,
        wA(r, a)
      ])),
      setup: vA.bind(r)
    }
  };
}
o(eu, "createInstance");
function _A(e, t, r) {
  var n, a;
  return (a = (n = e.document) !== null && n !== void 0 ? n : t && xC(t)) !== null && a !== void 0 ? a : r.document;
}
o(_A, "getDocument");
var EA = {};
Ua(EA, {
  clear: () => xA,
  click: () => TA,
  copy: () => SA,
  cut: () => PA,
  dblClick: () => OA,
  deselectOptions: () => CA,
  hover: () => AA,
  keyboard: () => RA,
  paste: () => IA,
  pointer: () => kA,
  selectOptions: () => jA,
  tab: () => LA,
  tripleClick: () => NA,
  type: () => qA,
  unhover: () => MA,
  upload: () => $A
});
function xA(e) {
  return tt().api.clear(e);
}
o(xA, "clear");
function TA(e, t = {}) {
  return tt(t, e).api.click(e);
}
o(TA, "click");
function SA(e = {}) {
  return tt(e).api.copy();
}
o(SA, "copy");
function PA(e = {}) {
  return tt(e).api.cut();
}
o(PA, "cut");
function OA(e, t = {}) {
  return tt(t).api.dblClick(e);
}
o(OA, "dblClick");
function CA(e, t, r = {}) {
  return tt(r).api.deselectOptions(e, t);
}
o(CA, "deselectOptions");
function AA(e, t = {}) {
  return tt(t).api.hover(e);
}
o(AA, "hover");
async function RA(e, t = {}) {
  const { api: r, system: n } = tt(t);
  return r.keyboard(e).then(() => n);
}
o(RA, "keyboard");
async function kA(e, t = {}) {
  const { api: r, system: n } = tt(t);
  return r.pointer(e).then(() => n);
}
o(kA, "pointer");
function IA(e, t) {
  return tt(t).api.paste(e);
}
o(IA, "paste");
function jA(e, t, r = {}) {
  return tt(r).api.selectOptions(e, t);
}
o(jA, "selectOptions");
function NA(e, t = {}) {
  return tt(t).api.tripleClick(e);
}
o(NA, "tripleClick");
function qA(e, t, r = {}) {
  return tt(r, e).api.type(e, t, r);
}
o(qA, "type");
function MA(e, t = {}) {
  const { api: r, system: n } = tt(t);
  return n.pointer.setMousePosition({
    target: e
  }), r.unhover(e);
}
o(MA, "unhover");
function $A(e, t, r = {}) {
  return tt(r).api.upload(e, t);
}
o($A, "upload");
function LA(e = {}) {
  return tt().api.tab(e);
}
o(LA, "tab");
var DA = {
  ...EA,
  setup: bA
}, Id = Oo(
  { ...YT },
  {
    getKeys: /* @__PURE__ */ o((e) => Object.keys(e).filter((t) => t !== "eventWrapper"), "getKeys"),
    intercept: /* @__PURE__ */ o((e, t) => t[0] === "fireEvent" || e.startsWith("find") || e.startsWith("waitFor"), "intercept")
  }
);
Id.screen = new Proxy(Id.screen, {
  get(e, t, r) {
    return typeof window < "u" && globalThis.location?.href?.includes("viewMode=docs") && Ue.warn(ye`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `), Reflect.get(e, t, r);
  }
});
var {
  buildQueries: V5,
  configure: J5,
  createEvent: z5,
  fireEvent: W5,
  findAllByAltText: G5,
  findAllByDisplayValue: K5,
  findAllByLabelText: Y5,
  findAllByPlaceholderText: X5,
  findAllByRole: Q5,
  findAllByTestId: Z5,
  findAllByText: eH,
  findAllByTitle: tH,
  findByAltText: rH,
  findByDisplayValue: nH,
  findByLabelText: oH,
  findByPlaceholderText: aH,
  findByRole: iH,
  findByTestId: sH,
  findByText: lH,
  findByTitle: uH,
  getAllByAltText: cH,
  getAllByDisplayValue: dH,
  getAllByLabelText: pH,
  getAllByPlaceholderText: fH,
  getAllByRole: mH,
  getAllByTestId: hH,
  getAllByText: yH,
  getAllByTitle: gH,
  getByAltText: bH,
  getByDisplayValue: vH,
  getByLabelText: wH,
  getByPlaceholderText: _H,
  getByRole: EH,
  getByTestId: xH,
  getByText: TH,
  getByTitle: SH,
  getConfig: PH,
  getDefaultNormalizer: OH,
  getElementError: CH,
  getNodeText: AH,
  getQueriesForElement: RH,
  getRoles: kH,
  getSuggestedQuery: IH,
  isInaccessible: jH,
  logDOM: NH,
  logRoles: qH,
  prettyDOM: MH,
  queries: $H,
  queryAllByAltText: LH,
  queryAllByAttribute: DH,
  queryAllByDisplayValue: FH,
  queryAllByLabelText: BH,
  queryAllByPlaceholderText: UH,
  queryAllByRole: HH,
  queryAllByTestId: VH,
  queryAllByText: JH,
  queryAllByTitle: zH,
  queryByAltText: WH,
  queryByAttribute: GH,
  queryByDisplayValue: KH,
  queryByLabelText: YH,
  queryByPlaceholderText: XH,
  queryByRole: QH,
  queryByTestId: ZH,
  queryByText: eV,
  queryByTitle: tV,
  queryHelpers: rV,
  screen: nV,
  waitFor: oV,
  waitForElementToBeRemoved: aV,
  within: YB,
  prettyFormat: iV
} = Id, XB = DA, { userEvent: sV } = Oo(
  { userEvent: DA },
  { intercept: !0, getKeys: /* @__PURE__ */ o((e) => Object.keys(e).filter((t) => t !== "eventWrapper"), "getKeys") }
), { expect: lV } = Oo(
  { expect: UT },
  {
    getKeys: /* @__PURE__ */ o((e, t) => {
      if ("constructor" in e && e.constructor === I) {
        const r = ["assert", "__methods", "__flags", "_obj"], n = Object.keys(Object.getPrototypeOf(e)).filter(
          (a) => !r.includes(a)
        );
        return t > 2 ? n : [...n, "not"];
      }
      return "any" in e ? Object.keys(e).filter((r) => r !== "any") : Object.keys(e);
    }, "getKeys"),
    mutate: !0,
    intercept: /* @__PURE__ */ o((e) => e !== "expect", "intercept")
  }
), QB = F({
  "../node_modules/@ngard/tiny-isequal/index.js"(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.isEqual = /* @__PURE__ */ (function() {
      var t = Object.prototype.toString, r = Object.getPrototypeOf, n = Object.getOwnPropertySymbols ? function(a) {
        return Object.keys(a).concat(Object.getOwnPropertySymbols(a));
      } : Object.keys;
      return function(a, i) {
        return (/* @__PURE__ */ o(function s(l, c, u) {
          var p, f, m, y = t.call(l), g = t.call(c);
          if (l === c) return !0;
          if (l == null || c == null) return !1;
          if (u.indexOf(l) > -1 && u.indexOf(c) > -1) return !0;
          if (u.push(l, c), y != g || (p = n(l), f = n(c), p.length != f.length || p.some(function(v) {
            return !s(l[v], c[v], u);
          }))) return !1;
          switch (y.slice(8, -1)) {
            case "Symbol":
              return l.valueOf() == c.valueOf();
            case "Date":
            case "Number":
              return +l == +c || +l != +l && +c != +c;
            case "RegExp":
            case "Function":
            case "String":
            case "Boolean":
              return "" + l == "" + c;
            case "Set":
            case "Map":
              p = l.entries(), f = c.entries();
              do
                if (!s((m = p.next()).value, f.next().value, u)) return !1;
              while (!m.done);
              return !0;
            case "ArrayBuffer":
              l = new Uint8Array(l), c = new Uint8Array(c);
            case "DataView":
              l = new Uint8Array(l.buffer), c = new Uint8Array(c.buffer);
            case "Float32Array":
            case "Float64Array":
            case "Int8Array":
            case "Int16Array":
            case "Int32Array":
            case "Uint8Array":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8ClampedArray":
            case "Arguments":
            case "Array":
              if (l.length != c.length) return !1;
              for (m = 0; m < l.length; m++) if ((m in l || m in c) && (m in l != m in c || !s(l[m], c[m], u))) return !1;
              return !0;
            case "Object":
              return s(r(l), r(c), u);
            default:
              return !1;
          }
        }, "n"))(a, i, []);
      };
    })();
  }
});
function FA(e) {
  return e.replace(/_/g, " ").replace(/-/g, " ").replace(/\./g, " ").replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, a) => `${r} ${n}${a}`).replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`).replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`).replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`).replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`).replace(/ +/g, " ").trim();
}
o(FA, "toStartCaseStr");
var Cg = Ye(QB(), 1), BA = /* @__PURE__ */ o((e) => e.map((t) => typeof t < "u").filter(Boolean).length, "count"), ZB = /* @__PURE__ */ o((e, t) => {
  const { exists: r, eq: n, neq: a, truthy: i } = e;
  if (BA([r, n, a, i]) > 1)
    throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: a })}`);
  if (typeof n < "u")
    return (0, Cg.isEqual)(t, n);
  if (typeof a < "u")
    return !(0, Cg.isEqual)(t, a);
  if (typeof r < "u") {
    const s = typeof t < "u";
    return r ? s : !s;
  }
  return typeof i > "u" || i ? !!t : !t;
}, "testValue"), e2 = /* @__PURE__ */ o((e, t, r) => {
  if (!e.if)
    return !0;
  const { arg: n, global: a } = e.if;
  if (BA([n, a]) !== 1)
    throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: a })}`);
  const i = n ? t[n] : r[a];
  return ZB(e.if, i);
}, "includeConditionalArg"), UA = {};
Ua(UA, {
  argsEnhancers: () => n2
});
var HA = /* @__PURE__ */ o((e, t) => typeof t[e] > "u" && !(e in t), "isInInitialArgs"), t2 = /* @__PURE__ */ o((e) => {
  const {
    initialArgs: t,
    argTypes: r,
    id: n,
    parameters: { actions: a }
  } = e;
  if (!a || a.disable || !a.argTypesRegex || !r)
    return {};
  const i = new RegExp(a.argTypesRegex);
  return Object.entries(r).filter(
    ([s]) => !!i.test(s)
  ).reduce((s, [l, c]) => (HA(l, t) && (s[l] = Vs(l, { implicit: !0, id: n })), s), {});
}, "inferActionsFromArgTypesRegex"), r2 = /* @__PURE__ */ o((e) => {
  const {
    initialArgs: t,
    argTypes: r,
    parameters: { actions: n }
  } = e;
  return n?.disable || !r ? {} : Object.entries(r).filter(([a, i]) => !!i.action).reduce((a, [i, s]) => (HA(i, t) && (a[i] = Vs(typeof s.action == "string" ? s.action : i)), a), {});
}, "addActionsFromArgTypes"), n2 = [
  r2,
  t2
], VA = {};
Ua(VA, {
  loaders: () => a2
});
var Ag = !1, o2 = /* @__PURE__ */ o((e) => {
  const { parameters: t } = e;
  t?.actions?.disable || Ag || (VT((r, n) => {
    const a = r.getMockName();
    a !== "spy" && a !== "vi.fn()" && (!/^next\/.*::/.test(a) || [
      "next/router::useRouter()",
      "next/navigation::useRouter()",
      "next/navigation::redirect",
      "next/cache::",
      "next/headers::cookies().set",
      "next/headers::cookies().delete",
      "next/headers::headers().set",
      "next/headers::headers().delete"
    ].some((i) => a.startsWith(i))) && Vs(a)(n);
  }), Ag = !0);
}, "logActionsWhenMockCalled"), a2 = [o2], Rg = /* @__PURE__ */ o(() => ({
  ...UA,
  ...VA
}), "default"), { document: Vt } = globalThis, i2 = /* @__PURE__ */ o(() => globalThis?.matchMedia ? !!globalThis.matchMedia("(prefers-reduced-motion: reduce)")?.matches : !1, "isReduceMotionEnabled"), kg = /* @__PURE__ */ o((e) => {
  (Array.isArray(e) ? e : [e]).forEach(s2);
}, "clearStyles"), s2 = /* @__PURE__ */ o((e) => {
  if (!Vt)
    return;
  const t = Vt.getElementById(e);
  t && t.parentElement && t.parentElement.removeChild(t);
}, "clearStyle"), l2 = /* @__PURE__ */ o((e, t) => {
  if (!Vt)
    return;
  const r = Vt.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    const n = Vt.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, Vt.head.appendChild(n);
  }
}, "addGridStyle"), u2 = /* @__PURE__ */ o((e, t, r) => {
  if (!Vt)
    return;
  const n = Vt.getElementById(e);
  if (n)
    n.innerHTML !== t && (n.innerHTML = t);
  else {
    const a = Vt.createElement("style");
    a.setAttribute("id", e), a.innerHTML = t;
    const i = `addon-backgrounds-grid${r ? `-docs-${r}` : ""}`, s = Vt.getElementById(i);
    s ? s.parentElement?.insertBefore(a, s) : Vt.head.appendChild(a);
  }
}, "addBackgroundStyle"), c2 = {
  cellSize: 100,
  cellAmount: 10,
  opacity: 0.8
}, Ig = "addon-backgrounds", jg = "addon-backgrounds-grid", d2 = i2() ? "" : "transition: background-color 0.3s;", p2 = /* @__PURE__ */ o((e, t) => {
  const { globals: r = {}, parameters: n = {}, viewMode: a, id: i } = t, {
    options: s = VN,
    disable: l,
    grid: c = c2
  } = n[Ji] || {}, u = r[Ji] || {}, p = typeof u == "string" ? u : u?.value, f = p ? s[p] : void 0, m = typeof f == "string" ? f : f?.value || "transparent", y = typeof u == "string" ? !1 : u.grid || !1, g = !!f && !l, v = a === "docs" ? `#anchor--${i} .docs-story` : ".sb-show-main", _ = a === "docs" ? `#anchor--${i} .docs-story` : ".sb-show-main", b = n.layout === void 0 || n.layout === "padded", E = a === "docs" ? 20 : b ? 16 : 0, { cellAmount: C, cellSize: k, opacity: N, offsetX: O = E, offsetY: S = E } = c, w = a === "docs" ? `${Ig}-docs-${i}` : `${Ig}-color`, T = a === "docs" ? i : null;
  On(() => {
    const R = `
    ${v} {
      background: ${m} !important;
      ${d2}
      }`;
    if (!g) {
      kg(w);
      return;
    }
    u2(w, R, T);
  }, [v, w, T, g, m]);
  const M = a === "docs" ? `${jg}-docs-${i}` : `${jg}`;
  return On(() => {
    if (!y) {
      kg(M);
      return;
    }
    const R = [
      `${k * C}px ${k * C}px`,
      `${k * C}px ${k * C}px`,
      `${k}px ${k}px`,
      `${k}px ${k}px`
    ].join(", "), D = `
        ${_} {
          background-size: ${R} !important;
          background-position: ${O}px ${S}px, ${O}px ${S}px, ${O}px ${S}px, ${O}px ${S}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${N}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${N}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${N / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${N / 2}) 1px, transparent 1px) !important;
        }
      `;
    l2(M, D);
  }, [C, k, _, M, y, O, S, N]), e();
}, "withBackgroundAndGrid"), f2 = globalThis.FEATURES?.backgrounds ? [p2] : [], m2 = {
  [Ji]: {
    grid: {
      cellSize: 20,
      opacity: 0.5,
      cellAmount: 5
    },
    disable: !1
  }
}, h2 = {
  [Ji]: { value: void 0, grid: !1 }
}, Ng = /* @__PURE__ */ o(() => ({
  decorators: f2,
  parameters: m2,
  initialGlobals: h2
}), "default"), { step: y2 } = Oo(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: /* @__PURE__ */ o(async (e, t, r) => t(r), "step")
  },
  { intercept: !0 }
), qg = /* @__PURE__ */ o(() => ({
  parameters: {
    throwPlayFunctionExceptions: !1
  },
  runStep: y2
}), "default"), Mg = {
  chevronLeft: [
    "M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z"
  ],
  chevronRight: [
    "M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z"
  ],
  info: [
    "M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z",
    "M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z"
  ],
  shareAlt: [
    "M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z",
    "M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z"
  ]
}, g2 = "svg,path,rect,circle,line,polyline,polygon,ellipse,text".split(","), ze = /* @__PURE__ */ o((e, t = {}, r) => {
  const n = g2.includes(e) ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e);
  return Object.entries(t).forEach(([a, i]) => {
    /[A-Z]/.test(a) ? (a === "onClick" && (n.addEventListener("click", i), n.addEventListener("keydown", (s) => {
      (s.key === "Enter" || s.key === " ") && (s.preventDefault(), i());
    })), a === "onMouseEnter" && n.addEventListener("mouseenter", i), a === "onMouseLeave" && n.addEventListener("mouseleave", i)) : n.setAttribute(a, i);
  }), r?.forEach((a) => {
    if (!(a == null || a === !1))
      try {
        n.appendChild(a);
      } catch {
        n.appendChild(document.createTextNode(String(a)));
      }
  }), n;
}, "createElement"), bi = /* @__PURE__ */ o((e) => Mg[e] && ze(
  "svg",
  { width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" },
  Mg[e].map(
    (t) => ze("path", {
      fill: "currentColor",
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: t
    })
  )
), "createIcon"), b2 = /* @__PURE__ */ o((e) => {
  if ("elements" in e) {
    const { elements: n, color: a, style: i } = e;
    return {
      id: void 0,
      priority: 0,
      selectors: n,
      styles: {
        outline: `2px ${i} ${a}`,
        outlineOffset: "2px",
        boxShadow: "0 0 0 6px rgba(255,255,255,0.6)"
      },
      menu: void 0
    };
  }
  const { menu: t, ...r } = e;
  return {
    id: void 0,
    priority: 0,
    styles: {
      outline: "2px dashed #029cfd"
    },
    ...r,
    menu: Array.isArray(t) ? t.every(Array.isArray) ? t : [t] : void 0
  };
}, "normalizeOptions"), v2 = /* @__PURE__ */ o((e) => e instanceof Function, "isFunction"), zo = /* @__PURE__ */ new Map(), an = /* @__PURE__ */ new Map(), vi = /* @__PURE__ */ new Map(), hr = /* @__PURE__ */ o((e) => {
  const t = Symbol();
  return an.set(t, []), zo.set(t, e), { get: /* @__PURE__ */ o(() => zo.get(t), "get"), set: /* @__PURE__ */ o((r) => {
    const n = zo.get(t), a = v2(r) ? r(n) : r;
    a !== n && (zo.set(t, a), an.get(t)?.forEach((i) => {
      vi.get(i)?.(), vi.set(i, i(a));
    }));
  }, "set"), subscribe: /* @__PURE__ */ o((r) => (an.get(t)?.push(r), () => {
    const n = an.get(t);
    n && an.set(
      t,
      n.filter((a) => a !== r)
    );
  }), "subscribe"), teardown: /* @__PURE__ */ o(() => {
    an.get(t)?.forEach((r) => {
      vi.get(r)?.(), vi.delete(r);
    }), an.delete(t), zo.delete(t);
  }, "teardown") };
}, "useStore"), $g = /* @__PURE__ */ o((e) => {
  const t = document.getElementById("storybook-root"), r = /* @__PURE__ */ new Map();
  for (const n of e) {
    const { priority: a = 0 } = n;
    for (const i of n.selectors) {
      const s = [
        ...document.querySelectorAll(
          // Elements matching the selector, excluding storybook elements and their descendants.
          // Necessary to find portaled elements (e.g. children of `body`).
          `:is(${i}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
        ),
        // Elements matching the selector inside the storybook root, as these were excluded above.
        ...t?.querySelectorAll(i) || []
      ];
      for (const l of s) {
        const c = r.get(l);
        (!c || c.priority <= a) && r.set(l, {
          ...n,
          priority: a,
          selectors: Array.from(new Set((c?.selectors || []).concat(i)))
        });
      }
    }
  }
  return r;
}, "mapElements"), w2 = /* @__PURE__ */ o((e) => Array.from(e.entries()).map(([t, { selectors: r, styles: n, hoverStyles: a, focusStyles: i, menu: s }]) => {
  const { top: l, left: c, width: u, height: p } = t.getBoundingClientRect(), { position: f } = getComputedStyle(t);
  return {
    element: t,
    selectors: r,
    styles: n,
    hoverStyles: a,
    focusStyles: i,
    menu: s,
    top: f === "fixed" ? l : l + window.scrollY,
    left: f === "fixed" ? c : c + window.scrollX,
    width: u,
    height: p
  };
}).sort((t, r) => r.width * r.height - t.width * t.height), "mapBoxes"), Lg = /* @__PURE__ */ o((e, t) => {
  const r = e.getBoundingClientRect(), { x: n, y: a } = t;
  return r?.top && r?.left && n >= r.left && n <= r.left + r.width && a >= r.top && a <= r.top + r.height;
}, "isOverMenu"), Dg = /* @__PURE__ */ o((e, t, r) => {
  if (!t || !r)
    return !1;
  let { left: n, top: a, width: i, height: s } = e;
  s < Lr && (a = a - Math.round((Lr - s) / 2), s = Lr), i < Lr && (n = n - Math.round((Lr - i) / 2), i = Lr), t.style.position === "fixed" && (n += window.scrollX, a += window.scrollY);
  const { x: l, y: c } = r;
  return l >= n && l <= n + i && c >= a && c <= a + s;
}, "isTargeted"), _2 = /* @__PURE__ */ o((e, t, r = {}) => {
  const { x: n, y: a } = t, { margin: i = 5, topOffset: s = 0, centered: l = !1 } = r, { scrollX: c, scrollY: u, innerHeight: p, innerWidth: f } = window, m = Math.min(
    e.style.position === "fixed" ? a - u : a,
    p - e.clientHeight - i - s + u
  ), y = l ? e.clientWidth / 2 : 0, g = e.style.position === "fixed" ? Math.max(Math.min(n - c, f - y - i), y + i) : Math.max(
    Math.min(n, f - y - i + c),
    y + i + c
  );
  Object.assign(e.style, {
    ...g !== n && { left: `${g}px` },
    ...m !== a && { top: `${m}px` }
  });
}, "keepInViewport"), Fg = /* @__PURE__ */ o((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.showPopover();
}, "showPopover"), E2 = /* @__PURE__ */ o((e) => {
  window.HTMLElement.prototype.hasOwnProperty("showPopover") && e.hidePopover();
}, "hidePopover"), x2 = /* @__PURE__ */ o((e) => ({
  top: e.top,
  left: e.left,
  width: e.width,
  height: e.height,
  selectors: e.selectors,
  element: {
    attributes: Object.fromEntries(
      Array.from(e.element.attributes).map((t) => [t.name, t.value])
    ),
    localName: e.element.localName,
    tagName: e.element.tagName,
    outerHTML: e.element.outerHTML
  }
}), "getEventDetails"), Ie = "storybook-highlights-menu", Bg = "storybook-highlights-root", T2 = "storybook-root", S2 = /* @__PURE__ */ o((e) => {
  if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED)
    return;
  globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
  const { document: t } = globalThis, r = hr([]), n = hr(/* @__PURE__ */ new Map()), a = hr([]), i = hr(), s = hr(), l = hr([]), c = hr([]), u = hr(), p = hr();
  let f = t.getElementById(Bg);
  r.subscribe(() => {
    f || (f = ze("div", { id: Bg }), t.body.appendChild(f));
  }), r.subscribe((S) => {
    const w = t.getElementById(T2);
    if (!w)
      return;
    n.set($g(S));
    const T = new MutationObserver(() => n.set($g(S)));
    return T.observe(w, { subtree: !0, childList: !0 }), () => {
      T.disconnect();
    };
  }), n.subscribe((S) => {
    const w = /* @__PURE__ */ o(() => requestAnimationFrame(() => a.set(w2(S))), "updateBoxes"), T = new ResizeObserver(w);
    T.observe(t.body), Array.from(S.keys()).forEach((R) => T.observe(R));
    const M = Array.from(t.body.querySelectorAll("*")).filter((R) => {
      const { overflow: D, overflowX: J, overflowY: P } = window.getComputedStyle(R);
      return ["auto", "scroll"].some((q) => [D, J, P].includes(q));
    });
    return M.forEach((R) => R.addEventListener("scroll", w)), () => {
      T.disconnect(), M.forEach((R) => R.removeEventListener("scroll", w));
    };
  }), n.subscribe((S) => {
    const w = Array.from(S.keys()).filter(({ style: M }) => M.position === "sticky"), T = /* @__PURE__ */ o(() => requestAnimationFrame(() => {
      a.set(
        (M) => M.map((R) => {
          if (w.includes(R.element)) {
            const { top: D, left: J } = R.element.getBoundingClientRect();
            return { ...R, top: D + window.scrollY, left: J + window.scrollX };
          }
          return R;
        })
      );
    }), "updateBoxes");
    return t.addEventListener("scroll", T), () => t.removeEventListener("scroll", T);
  }), n.subscribe((S) => {
    l.set((w) => w.filter(({ element: T }) => S.has(T)));
  }), l.subscribe((S) => {
    S.length ? (p.set((w) => S.some((T) => T.element === w?.element) ? w : void 0), u.set((w) => S.some((T) => T.element === w?.element) ? w : void 0)) : (p.set(void 0), u.set(void 0), i.set(void 0));
  });
  const m = new Map(/* @__PURE__ */ new Map());
  r.subscribe((S) => {
    S.forEach(({ keyframes: w }) => {
      if (w) {
        let T = m.get(w);
        T || (T = t.createElement("style"), T.setAttribute("data-highlight", "keyframes"), m.set(w, T), t.head.appendChild(T)), T.innerHTML = w;
      }
    }), m.forEach((w, T) => {
      S.some((M) => M.keyframes === T) || (w.remove(), m.delete(T));
    });
  });
  const y = new Map(/* @__PURE__ */ new Map());
  a.subscribe((S) => {
    S.forEach((w) => {
      let T = y.get(w.element);
      if (f && !T) {
        const M = {
          popover: "manual",
          "data-highlight-dimensions": `w${w.width.toFixed(0)}h${w.height.toFixed(0)}`,
          "data-highlight-coordinates": `x${w.left.toFixed(0)}y${w.top.toFixed(0)}`
        };
        T = f.appendChild(
          ze("div", M, [ze("div")])
        ), y.set(w.element, T);
      }
    }), y.forEach((w, T) => {
      S.some(({ element: M }) => M === T) || (w.remove(), y.delete(T));
    });
  }), a.subscribe((S) => {
    const w = S.filter((M) => M.menu);
    if (!w.length)
      return;
    const T = /* @__PURE__ */ o((M) => {
      requestAnimationFrame(() => {
        const R = t.getElementById(Ie), D = { x: M.pageX, y: M.pageY };
        if (R && !Lg(R, D)) {
          const J = w.filter((P) => {
            const q = y.get(P.element);
            return Dg(P, q, D);
          });
          i.set(J.length ? D : void 0), l.set(J);
        }
      });
    }, "onClick");
    return t.addEventListener("click", T), () => t.removeEventListener("click", T);
  });
  const g = /* @__PURE__ */ o(() => {
    const S = t.getElementById(Ie), w = s.get();
    !w || S && Lg(S, w) || c.set((T) => {
      const M = a.get().filter((P) => {
        const q = y.get(P.element);
        return Dg(P, q, w);
      }), R = T.filter((P) => M.includes(P)), D = M.filter((P) => !T.includes(P)), J = T.length - R.length;
      return D.length || J ? [...R, ...D] : T;
    });
  }, "updateHovered");
  s.subscribe(g), a.subscribe(g);
  const v = /* @__PURE__ */ o(() => {
    const S = p.get(), w = S ? [S] : l.get(), T = w.length === 1 ? w[0] : u.get(), M = i.get() !== void 0;
    a.get().forEach((R) => {
      const D = y.get(R.element);
      if (D) {
        const J = T === R, P = M ? T ? J : w.includes(R) : c.get()?.includes(R);
        Object.assign(D.style, {
          animation: "none",
          background: "transparent",
          border: "none",
          boxSizing: "border-box",
          outline: "none",
          outlineOffset: "0px",
          ...R.styles,
          ...P ? R.hoverStyles : {},
          ...J ? R.focusStyles : {},
          position: getComputedStyle(R.element).position === "fixed" ? "fixed" : "absolute",
          zIndex: Sy - 10,
          top: `${R.top}px`,
          left: `${R.left}px`,
          width: `${R.width}px`,
          height: `${R.height}px`,
          margin: 0,
          padding: 0,
          cursor: R.menu && P ? "pointer" : "default",
          pointerEvents: R.menu ? "auto" : "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "visible"
        }), Object.assign(D.children[0].style, {
          width: "100%",
          height: "100%",
          minHeight: `${Lr}px`,
          minWidth: `${Lr}px`,
          boxSizing: "content-box",
          padding: D.style.outlineWidth || "0px"
        }), Fg(D);
      }
    });
  }, "updateBoxStyles");
  a.subscribe(v), l.subscribe(v), c.subscribe(v), u.subscribe(v), p.subscribe(v);
  const _ = /* @__PURE__ */ o(() => {
    if (!f)
      return;
    let S = t.getElementById(Ie);
    if (S)
      S.innerHTML = "";
    else {
      const R = { id: Ie, popover: "manual" };
      S = f.appendChild(ze("div", R)), f.appendChild(
        ze("style", {}, [
          `
            #${Ie} {
              position: absolute;
              z-index: ${Sy};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${Ie} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${Ie} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${Ie} li {
              padding: 0 4px;
              margin: 0;
            }
            #${Ie} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${Ie} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${Ie} button:focus-visible {
              outline-color: #029CFD;
            }
            #${Ie} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${Ie} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${Ie} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${Ie} li > button:hover svg, #${Ie} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${Ie} .element-list li svg {
              display: none;
            }
            #${Ie} li.selectable svg, #${Ie} li.selected svg {
              display: block;
            }
            #${Ie} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Ie} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Ie} .menu-items, #${Ie} .menu-items li {
              padding: 0;
            }
            #${Ie} .menu-item {
              display: flex;
            }
            #${Ie} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
        ])
      );
    }
    const w = p.get(), T = w ? [w] : l.get();
    if (T.length && (S.style.position = getComputedStyle(T[0].element).position === "fixed" ? "fixed" : "absolute", S.appendChild(
      ze(
        "ul",
        { class: "element-list" },
        T.map((R) => {
          const D = T.length > 1 && !!R.menu?.some(
            (q) => q.some(
              ($) => !$.selectors || $.selectors.some((H) => R.selectors.includes(H))
            )
          ), J = D ? {
            class: "selectable",
            onClick: /* @__PURE__ */ o(() => p.set(R), "onClick"),
            onMouseEnter: /* @__PURE__ */ o(() => u.set(R), "onMouseEnter"),
            onMouseLeave: /* @__PURE__ */ o(() => u.set(void 0), "onMouseLeave")
          } : w ? { class: "selected", onClick: /* @__PURE__ */ o(() => p.set(void 0), "onClick") } : {}, P = D || w;
          return ze("li", J, [
            ze(P ? "button" : "div", P ? { type: "button" } : {}, [
              w ? bi("chevronLeft") : null,
              ze("code", {}, [R.element.outerHTML]),
              D ? bi("chevronRight") : null
            ])
          ]);
        })
      )
    )), p.get() || l.get().length === 1) {
      const R = p.get() || l.get()[0], D = R.menu?.filter(
        (J) => J.some(
          (P) => !P.selectors || P.selectors.some((q) => R.selectors.includes(q))
        )
      );
      D?.length && S.appendChild(
        ze(
          "ul",
          { class: "menu-list" },
          D.map(
            (J) => ze("li", {}, [
              ze(
                "ul",
                { class: "menu-items" },
                J.map(
                  ({ id: P, title: q, description: $, iconLeft: H, iconRight: z, clickEvent: Z }) => {
                    const oe = Z && (() => e.emit(Z, P, x2(R)));
                    return ze("li", {}, [
                      ze(
                        oe ? "button" : "div",
                        oe ? { class: "menu-item", type: "button", onClick: oe } : { class: "menu-item" },
                        [
                          H ? bi(H) : null,
                          ze("div", { class: "menu-item-content" }, [
                            ze($ ? "strong" : "span", {}, [q]),
                            $ && ze("span", {}, [$])
                          ]),
                          z ? bi(z) : null
                        ]
                      )
                    ]);
                  }
                )
              )
            ])
          )
        )
      );
    }
    const M = i.get();
    M ? (Object.assign(S.style, {
      display: "block",
      left: `${S.style.position === "fixed" ? M.x - window.scrollX : M.x}px`,
      top: `${S.style.position === "fixed" ? M.y - window.scrollY : M.y}px`
    }), Fg(S), requestAnimationFrame(() => _2(S, M, { topOffset: 15, centered: !0 }))) : (E2(S), Object.assign(S.style, { display: "none" }));
  }, "renderMenu");
  l.subscribe(_), p.subscribe(_);
  const b = /* @__PURE__ */ o((S) => {
    const w = b2(S);
    r.set((T) => {
      const M = w.id ? T.filter((R) => R.id !== w.id) : T;
      return w.selectors?.length ? [...M, w] : M;
    });
  }, "addHighlight"), E = /* @__PURE__ */ o((S) => {
    S && r.set((w) => w.filter((T) => T.id !== S));
  }, "removeHighlight"), C = /* @__PURE__ */ o(() => {
    r.set([]), n.set(/* @__PURE__ */ new Map()), a.set([]), i.set(void 0), s.set(void 0), l.set([]), c.set([]), u.set(void 0), p.set(void 0);
  }, "resetState");
  let k;
  const N = /* @__PURE__ */ o((S, w) => {
    const T = "scrollIntoView-highlight";
    clearTimeout(k), E(T);
    const M = t.querySelector(S);
    if (!M) {
      console.warn(`Cannot scroll into view: ${S} not found`);
      return;
    }
    M.scrollIntoView({ behavior: "smooth", block: "center", ...w });
    const R = `kf-${Math.random().toString(36).substring(2, 15)}`;
    r.set((D) => [
      ...D,
      {
        id: T,
        priority: 1e3,
        selectors: [S],
        styles: {
          outline: "2px solid #1EA7FD",
          outlineOffset: "-1px",
          animation: `${R} 3s linear forwards`
        },
        keyframes: `@keyframes ${R} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
      }
    ]), k = setTimeout(() => E(T), 3500);
  }, "scrollIntoView"), O = /* @__PURE__ */ o((S) => {
    requestAnimationFrame(() => s.set({ x: S.pageX, y: S.pageY }));
  }, "onMouseMove");
  t.body.addEventListener("mousemove", O), e.on(JN, b), e.on(zN, E), e.on(WN, C), e.on(GN, N), e.on(vn, ({ newPhase: S }) => {
    S === "loading" && C();
  });
}, "useHighlights");
globalThis?.FEATURES?.highlight && zt?.ready && zt.ready().then(S2);
var Ug = /* @__PURE__ */ o(() => ({}), "default");
function Fh() {
  const e = ee.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
o(Fh, "getDocumentWidthAndHeight");
function JA() {
  const e = ee.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  const t = e.getContext("2d");
  nr(t != null);
  const { width: r, height: n } = Fh();
  return As(e, t, { width: r, height: n }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "2147483647", e.style.pointerEvents = "none", ee.document.body.appendChild(e), { canvas: e, context: t, width: r, height: n };
}
o(JA, "createCanvas");
function As(e, t, { width: r, height: n }) {
  e.style.width = `${r}px`, e.style.height = `${n}px`;
  const a = ee.window.devicePixelRatio;
  e.width = Math.floor(r * a), e.height = Math.floor(n * a), t.scale(a, a);
}
o(As, "setCanvasWidthAndHeight");
var We = {};
function zA() {
  We.canvas || (We = JA());
}
o(zA, "init");
function Bh() {
  We.context && We.context.clearRect(0, 0, We.width ?? 0, We.height ?? 0);
}
o(Bh, "clear");
function WA(e) {
  Bh(), e(We.context);
}
o(WA, "draw");
function GA() {
  nr(We.canvas), nr(We.context), As(We.canvas, We.context, { width: 0, height: 0 });
  const { width: e, height: t } = Fh();
  As(We.canvas, We.context, { width: e, height: t }), We.width = e, We.height = t;
}
o(GA, "rescale");
function KA() {
  We.canvas && (Bh(), We.canvas.parentNode?.removeChild(We.canvas), We = {});
}
o(KA, "destroy");
var Dn = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, Sr = 6;
function jd(e, { x: t, y: r, w: n, h: a, r: i }) {
  t = t - n / 2, r = r - a / 2, n < 2 * i && (i = n / 2), a < 2 * i && (i = a / 2), e.beginPath(), e.moveTo(t + i, r), e.arcTo(t + n, r, t + n, r + a, i), e.arcTo(t + n, r + a, t, r + a, i), e.arcTo(t, r + a, t, r, i), e.arcTo(t, r, t + n, r, i), e.closePath();
}
o(jd, "roundedRect");
function YA(e, { padding: t, border: r, width: n, height: a, top: i, left: s }) {
  const l = n - r.left - r.right - t.left - t.right, c = a - t.top - t.bottom - r.top - r.bottom;
  let u = s + r.left + t.left, p = i + r.top + t.top;
  return e === "top" ? u += l / 2 : e === "right" ? (u += l, p += c / 2) : e === "bottom" ? (u += l / 2, p += c) : e === "left" ? p += c / 2 : e === "center" && (u += l / 2, p += c / 2), { x: u, y: p };
}
o(YA, "positionCoordinate");
function XA(e, t, { margin: r, border: n, padding: a }, i, s) {
  let l = /* @__PURE__ */ o((m) => 0, "shift"), c = 0, u = 0;
  const p = s ? 1 : 0.5, f = s ? i * 2 : 0;
  return e === "padding" ? l = /* @__PURE__ */ o((m) => a[m] * p + f, "shift") : e === "border" ? l = /* @__PURE__ */ o((m) => a[m] + n[m] * p + f, "shift") : e === "margin" && (l = /* @__PURE__ */ o((m) => a[m] + n[m] + r[m] * p + f, "shift")), t === "top" ? u = -l("top") : t === "right" ? c = l("right") : t === "bottom" ? u = l("bottom") : t === "left" && (c = -l("left")), { offsetX: c, offsetY: u };
}
o(XA, "offset");
function QA(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
o(QA, "collide");
function ZA(e, t, r) {
  return e === "top" ? t.y = r.y - r.h - Sr : e === "right" ? t.x = r.x + r.w / 2 + Sr + t.w / 2 : e === "bottom" ? t.y = r.y + r.h + Sr : e === "left" && (t.x = r.x - r.w / 2 - Sr - t.w / 2), { x: t.x, y: t.y };
}
o(ZA, "overlapAdjustment");
function Uh(e, t, { x: r, y: n, w: a, h: i }, s) {
  return jd(e, { x: r, y: n, w: a, h: i, r: 3 }), e.fillStyle = `${Dn[t]}dd`, e.fill(), e.strokeStyle = Dn[t], e.stroke(), e.fillStyle = Dn.text, e.fillText(s, r, n), jd(e, { x: r, y: n, w: a, h: i, r: 3 }), e.fillStyle = `${Dn[t]}dd`, e.fill(), e.strokeStyle = Dn[t], e.stroke(), e.fillStyle = Dn.text, e.fillText(s, r, n), { x: r, y: n, w: a, h: i };
}
o(Uh, "textWithRect");
function Hh(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  const r = e.measureText(t), n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent, a = r.width + Sr * 2, i = n + Sr * 2;
  return { w: a, h: i };
}
o(Hh, "configureText");
function eR(e, t, { type: r, position: n = "center", text: a }, i, s = !1) {
  let { x: l, y: c } = YA(n, t);
  const { offsetX: u, offsetY: p } = XA(r, n, t, Sr + 1, s);
  l += u, c += p;
  const { w: f, h: m } = Hh(e, a);
  if (i && QA({ x: l, y: c, w: f, h: m }, i)) {
    const y = ZA(n, { x: l, y: c, w: f }, i);
    l = y.x, c = y.y;
  }
  return Uh(e, r, { x: l, y: c, w: f, h: m }, a);
}
o(eR, "drawLabel");
function tR(e, { w: t, h: r }) {
  const n = t * 0.5 + Sr, a = r * 0.5 + Sr;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * n,
    offsetY: (e.y === "top" ? -1 : 1) * a
  };
}
o(tR, "floatingOffset");
function rR(e, t, { type: r, text: n }) {
  const { floatingAlignment: a, extremities: i } = t;
  let s = i[a.x], l = i[a.y];
  const { w: c, h: u } = Hh(e, n), { offsetX: p, offsetY: f } = tR(a, {
    w: c,
    h: u
  });
  return s += p, l += f, Uh(e, r, { x: s, y: l, w: c, h: u }, n);
}
o(rR, "drawFloatingLabel");
function Hn(e, t, r, n) {
  const a = [];
  r.forEach((i, s) => {
    const l = n && i.position === "center" ? rR(e, t, i) : eR(e, t, i, a[s - 1], n);
    a[s] = l;
  });
}
o(Hn, "drawStack");
function nR(e, t, r, n) {
  const a = r.reduce((i, s) => (Object.prototype.hasOwnProperty.call(i, s.position) || (i[s.position] = []), i[s.position]?.push(s), i), {});
  a.top && Hn(e, t, a.top, n), a.right && Hn(e, t, a.right, n), a.bottom && Hn(e, t, a.bottom, n), a.left && Hn(e, t, a.left, n), a.center && Hn(e, t, a.center, n);
}
o(nR, "labelStacks");
var tu = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, Hg = 30;
function gt(e) {
  return parseInt(e.replace("px", ""), 10);
}
o(gt, "pxToNumber");
function fn(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
o(fn, "round");
function ru(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
o(ru, "filterZeroValues");
function oR(e) {
  const t = {
    top: ee.window.scrollY,
    bottom: ee.window.scrollY + ee.window.innerHeight,
    left: ee.window.scrollX,
    right: ee.window.scrollX + ee.window.innerWidth
  }, r = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: r.left > r.right ? "left" : "right",
    y: r.top > r.bottom ? "top" : "bottom"
  };
}
o(oR, "floatingAlignment");
function aR(e) {
  const t = ee.getComputedStyle(e);
  let { top: r, left: n, right: a, bottom: i, width: s, height: l } = e.getBoundingClientRect();
  const {
    marginTop: c,
    marginBottom: u,
    marginLeft: p,
    marginRight: f,
    paddingTop: m,
    paddingBottom: y,
    paddingLeft: g,
    paddingRight: v,
    borderBottomWidth: _,
    borderTopWidth: b,
    borderLeftWidth: E,
    borderRightWidth: C
  } = t;
  r = r + ee.window.scrollY, n = n + ee.window.scrollX, i = i + ee.window.scrollY, a = a + ee.window.scrollX;
  const k = {
    top: gt(c),
    bottom: gt(u),
    left: gt(p),
    right: gt(f)
  }, N = {
    top: gt(m),
    bottom: gt(y),
    left: gt(g),
    right: gt(v)
  }, O = {
    top: gt(b),
    bottom: gt(_),
    left: gt(E),
    right: gt(C)
  }, S = {
    top: r - k.top,
    bottom: i + k.bottom,
    left: n - k.left,
    right: a + k.right
  };
  return {
    margin: k,
    padding: N,
    border: O,
    top: r,
    left: n,
    bottom: i,
    right: a,
    width: s,
    height: l,
    extremities: S,
    floatingAlignment: oR(S)
  };
}
o(aR, "measureElement");
function iR(e, { margin: t, width: r, height: n, top: a, left: i, bottom: s, right: l }) {
  const c = n + t.bottom + t.top;
  e.fillStyle = tu.margin, e.fillRect(i, a - t.top, r, t.top), e.fillRect(l, a - t.top, t.right, c), e.fillRect(i, s, r, t.bottom), e.fillRect(i - t.left, a - t.top, t.left, c);
  const u = [
    {
      type: "margin",
      text: fn(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: fn(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: fn(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: fn(t.left),
      position: "left"
    }
  ];
  return ru(u);
}
o(iR, "drawMargin");
function sR(e, { padding: t, border: r, width: n, height: a, top: i, left: s, bottom: l, right: c }) {
  const u = n - r.left - r.right, p = a - t.top - t.bottom - r.top - r.bottom;
  e.fillStyle = tu.padding, e.fillRect(s + r.left, i + r.top, u, t.top), e.fillRect(
    c - t.right - r.right,
    i + t.top + r.top,
    t.right,
    p
  ), e.fillRect(
    s + r.left,
    l - t.bottom - r.bottom,
    u,
    t.bottom
  ), e.fillRect(s + r.left, i + t.top + r.top, t.left, p);
  const f = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return ru(f);
}
o(sR, "drawPadding");
function lR(e, { border: t, width: r, height: n, top: a, left: i, bottom: s, right: l }) {
  const c = n - t.top - t.bottom;
  e.fillStyle = tu.border, e.fillRect(i, a, r, t.top), e.fillRect(i, s - t.bottom, r, t.bottom), e.fillRect(i, a + t.top, t.left, c), e.fillRect(l - t.right, a + t.top, t.right, c);
  const u = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return ru(u);
}
o(lR, "drawBorder");
function uR(e, { padding: t, border: r, width: n, height: a, top: i, left: s }) {
  const l = n - r.left - r.right - t.left - t.right, c = a - t.top - t.bottom - r.top - r.bottom;
  return e.fillStyle = tu.content, e.fillRect(
    s + r.left + t.left,
    i + r.top + t.top,
    l,
    c
  ), [
    {
      type: "content",
      position: "center",
      text: `${fn(l)} x ${fn(c)}`
    }
  ];
}
o(uR, "drawContent");
function cR(e) {
  return (t) => {
    if (e && t) {
      const r = aR(e), n = iR(t, r), a = sR(t, r), i = lR(t, r), s = uR(t, r), l = r.width <= Hg * 3 || r.height <= Hg;
      nR(
        t,
        r,
        [...s, ...a, ...i, ...n],
        l
      );
    }
  };
}
o(cR, "drawBoxModel");
function dR(e) {
  WA(cR(e));
}
o(dR, "drawSelectedElement");
var P2 = /* @__PURE__ */ o((e, t) => {
  const r = ee.document.elementFromPoint(e, t), n = /* @__PURE__ */ o((a) => {
    if (a && a.shadowRoot) {
      const i = a.shadowRoot.elementFromPoint(e, t);
      return a.isEqualNode(i) ? a : i.shadowRoot ? n(i) : i;
    }
    return a;
  }, "crawlShadows");
  return n(r) || r;
}, "deepElementFromPoint"), Vg, wi = { x: 0, y: 0 };
function Nd(e, t) {
  Vg = P2(e, t), dR(Vg);
}
o(Nd, "findAndDrawElement");
var O2 = /* @__PURE__ */ o((e, t) => {
  const { measureEnabled: r } = t.globals || {};
  return On(() => {
    if (typeof globalThis.document > "u")
      return;
    const n = /* @__PURE__ */ o((a) => {
      window.requestAnimationFrame(() => {
        a.stopPropagation(), wi.x = a.clientX, wi.y = a.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", n), () => {
      globalThis.document.removeEventListener("pointermove", n);
    };
  }, []), On(() => {
    const n = /* @__PURE__ */ o((i) => {
      window.requestAnimationFrame(() => {
        i.stopPropagation(), Nd(i.clientX, i.clientY);
      });
    }, "onPointerOver"), a = /* @__PURE__ */ o(() => {
      window.requestAnimationFrame(() => {
        GA();
      });
    }, "onResize");
    return t.viewMode === "story" && r && (globalThis.document.addEventListener("pointerover", n), zA(), globalThis.window.addEventListener("resize", a), Nd(wi.x, wi.y)), () => {
      globalThis.window.removeEventListener("resize", a), KA();
    };
  }, [r, t.viewMode]), e();
}, "withMeasure"), C2 = globalThis.FEATURES?.measure ? [O2] : [], A2 = {
  [HN]: !1
}, Jg = /* @__PURE__ */ o(() => ({
  decorators: C2,
  initialGlobals: A2
}), "default"), zg = /* @__PURE__ */ o((e) => {
  (Array.isArray(e) ? e : [e]).forEach(R2);
}, "clearStyles"), R2 = /* @__PURE__ */ o((e) => {
  const t = typeof e == "string" ? e : e.join(""), r = ee.document.getElementById(t);
  r && r.parentElement && r.parentElement.removeChild(r);
}, "clearStyle"), k2 = /* @__PURE__ */ o((e, t) => {
  const r = ee.document.getElementById(e);
  if (r)
    r.innerHTML !== t && (r.innerHTML = t);
  else {
    const n = ee.document.createElement("style");
    n.setAttribute("id", e), n.innerHTML = t, ee.document.head.appendChild(n);
  }
}, "addOutlineStyles");
function pR(e) {
  return ye`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
o(pR, "outlineCSS");
var I2 = /* @__PURE__ */ o((e, t) => {
  const r = t.globals || {}, n = [!0, "true"].includes(r[T_]), a = t.viewMode === "docs", i = TR(() => pR(a ? '[data-story-block="true"]' : ".sb-show-main"), [t]);
  return On(() => {
    const s = a ? `addon-outline-docs-${t.id}` : "addon-outline";
    return n ? k2(s, i) : zg(s), () => {
      zg(s);
    };
  }, [n, i, t]), e();
}, "withOutline"), j2 = globalThis.FEATURES?.outline ? [I2] : [], N2 = {
  [T_]: !1
}, Wg = /* @__PURE__ */ o(() => ({ decorators: j2, initialGlobals: N2 }), "default"), q2 = /* @__PURE__ */ o(({ parameters: e }) => {
  e?.test?.mockReset === !0 ? GT() : e?.test?.clearMocks === !0 ? WT() : e?.test?.restoreMocks !== !1 && KT();
}, "resetAllMocksLoader"), qd = /* @__PURE__ */ o((e, t = 0, r) => {
  if (t > 5 || e == null)
    return e;
  if (Zn(e))
    return r && e.mockName(r), e;
  if (typeof e == "function" && "isAction" in e && e.isAction && !("implicit" in e && e.implicit)) {
    const n = JT(e);
    return r && n.mockName(r), n;
  }
  if (Array.isArray(e)) {
    t++;
    for (let n = 0; n < e.length; n++)
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = qd(e[n], t));
    return e;
  }
  if (typeof e == "object" && e.constructor === Object) {
    t++;
    for (const [n, a] of Object.entries(e))
      Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = qd(a, t, n));
    return e;
  }
  return e;
}, "traverseArgs"), M2 = /* @__PURE__ */ o(({ initialArgs: e }) => {
  qd(e);
}, "nameSpiesAndWrapActionsInSpies"), Gg = !1, $2 = /* @__PURE__ */ o(async (e) => {
  globalThis.HTMLElement && e.canvasElement instanceof globalThis.HTMLElement && (e.canvas = YB(e.canvasElement));
  const t = globalThis.window?.navigator?.clipboard;
  if (t && (e.userEvent = Oo(
    { userEvent: XB.setup() },
    {
      intercept: !0,
      getKeys: /* @__PURE__ */ o((r) => Object.keys(r).filter((n) => n !== "eventWrapper"), "getKeys")
    }
  ).userEvent, Object.defineProperty(globalThis.window.navigator, "clipboard", {
    get: /* @__PURE__ */ o(() => t, "get"),
    configurable: !0
  }), !Gg)) {
    const r = HTMLElement.prototype.focus;
    let n = HTMLElement.prototype.focus;
    const a = /* @__PURE__ */ new Set();
    Object.defineProperties(HTMLElement.prototype, {
      focus: {
        configurable: !0,
        set: /* @__PURE__ */ o((i) => {
          n = i;
        }, "set"),
        get() {
          return a.has(this) ? r : (a.add(this), setTimeout(() => a.delete(this), 0), n);
        }
      }
    }), Gg = !0;
  }
}, "enhanceContext"), Kg = /* @__PURE__ */ o(() => ({
  loaders: [q2, M2, $2]
}), "default"), L2 = {
  [eq]: { value: void 0, isRotated: !1 }
}, Yg = /* @__PURE__ */ o(() => ({
  initialGlobals: L2
}), "default");
function nu() {
  return [
    // @ts-expect-error CJS fallback
    (Jg.default ?? Jg)(),
    // @ts-expect-error CJS fallback
    (Ng.default ?? Ng)(),
    // @ts-expect-error CJS fallback
    (Ug.default ?? Ug)(),
    // @ts-expect-error CJS fallback
    (Wg.default ?? Wg)(),
    // @ts-expect-error CJS fallback
    (Yg.default ?? Yg)(),
    // @ts-expect-error CJS fallback
    (Rg.default ?? Rg)(),
    // @ts-expect-error CJS fallback
    (qg.default ?? qg)(),
    // @ts-expect-error CJS fallback
    (Kg.default ?? Kg)()
  ];
}
o(nu, "getCoreAnnotations");
function D2(e) {
  let t;
  const r = {
    _tag: "Preview",
    input: e,
    get composed() {
      if (t)
        return t;
      const { addons: n, ...a } = e;
      return t = $a(
        Cn([...nu(), ...n ?? [], a])
      ), t;
    },
    meta(n) {
      return mR(n, this);
    }
  };
  return globalThis.globalProjectAnnotations = r.composed, r;
}
o(D2, "definePreview");
function F2(e) {
  return e;
}
o(F2, "definePreviewAddon");
function B2(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Preview";
}
o(B2, "isPreview");
function fR(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Meta";
}
o(fR, "isMeta");
function mR(e, t) {
  return {
    _tag: "Meta",
    input: e,
    preview: t,
    // @ts-expect-error hard
    story(r = {}) {
      return Vh(typeof r == "function" ? { render: r } : r, this);
    }
  };
}
o(mR, "defineMeta");
function ou(e) {
  return e != null && typeof e == "object" && "_tag" in e && e?._tag === "Story";
}
o(ou, "isStory");
function Vh(e, t) {
  let r;
  const n = /* @__PURE__ */ o(() => (r || (r = Qh(
    e,
    t.input,
    void 0,
    t.preview.composed
  )), r), "compose"), a = [];
  return {
    _tag: "Story",
    input: e,
    meta: t,
    // @ts-expect-error this is a private property used only once in renderers/react/src/preview
    __compose: n,
    __children: a,
    get composed() {
      const i = n(), { args: s, argTypes: l, parameters: c, id: u, tags: p, globals: f, storyName: m } = i;
      return { args: s, argTypes: l, parameters: c, id: u, tags: p, name: m, globals: f };
    },
    get play() {
      return e.play ?? t.input?.play ?? (async () => {
      });
    },
    async run(i) {
      await n().run(i);
    },
    test(i, s, l) {
      const c = typeof s != "function" ? s : {}, u = typeof s != "function" ? l : s, p = Ns(this.play) || Ns(u) ? async ({ context: m }) => {
        await this.play?.(m), await u(m);
      } : async (m) => {
        await this.play?.(m), await u(m);
      }, f = this.extend({
        ...c,
        name: i,
        tags: ["test-fn", "!autodocs", ...c.tags ?? []],
        play: p
      });
      return a.push(f), f;
    },
    extend(i) {
      return Vh(
        {
          ...this.input,
          ...i,
          args: { ...this.input.args || {}, ...i.args },
          argTypes: Wr(this.input.argTypes, i.argTypes),
          afterEach: [
            ..._e(this.input?.afterEach ?? []),
            ..._e(i.afterEach ?? [])
          ],
          beforeEach: [
            ..._e(this.input?.beforeEach ?? []),
            ..._e(i.beforeEach ?? [])
          ],
          decorators: [
            ..._e(this.input?.decorators ?? []),
            ..._e(i.decorators ?? [])
          ],
          globals: { ...this.input.globals, ...i.globals },
          loaders: [
            ..._e(this.input?.loaders ?? []),
            ..._e(i.loaders ?? [])
          ],
          parameters: Wr(this.input.parameters, i.parameters),
          tags: gR(...this.input.tags ?? [], ...i.tags ?? [])
        },
        this.meta
      );
    }
  };
}
o(Vh, "defineStory");
function hR(e) {
  return "__children" in e ? e.__children : [];
}
o(hR, "getStoryChildren");
var yR = /* @__PURE__ */ o((e) => e.toLowerCase().replace(/[ â€™â€“â€”â€•â€²Â¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, "-").replace(/-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), "sanitize"), Md = /* @__PURE__ */ o((e, t) => {
  const r = yR(e);
  if (r === "")
    throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
  return r;
}, "sanitizeSafe"), U2 = /* @__PURE__ */ o((e, t) => `${Md(e, "kind")}${t ? `--${Md(t, "name")}` : ""}`, "toId"), H2 = /* @__PURE__ */ o((e, t) => `${e}:${Md(t, "test")}`, "toTestId"), V2 = /* @__PURE__ */ o((e) => FA(e), "storyNameFromExport");
function $d(e, t) {
  return Array.isArray(t) ? t.includes(e) : e.match(t);
}
o($d, "matches");
function Rs(e, { includeStories: t, excludeStories: r }) {
  return (
    // https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs
    e !== "__esModule" && (!t || $d(e, t)) && (!r || !$d(e, r))
  );
}
o(Rs, "isExportStory");
var gR = /* @__PURE__ */ o((...e) => {
  const t = e.reduce((r, n) => (n.startsWith("!") ? r.delete(n.slice(1)) : r.add(n), r), /* @__PURE__ */ new Set());
  return Array.from(t);
}, "combineTags");
function bR() {
  const e = {
    setHandler: /* @__PURE__ */ o(() => {
    }, "setHandler"),
    send: /* @__PURE__ */ o(() => {
    }, "send")
  };
  return new __({ transport: e });
}
o(bR, "mockChannel");
var vR = class {
  constructor() {
    this.getChannel = /* @__PURE__ */ o(() => {
      if (!this.channel) {
        const e = bR();
        return this.setChannel(e), e;
      }
      return this.channel;
    }, "getChannel"), this.ready = /* @__PURE__ */ o(() => this.promise, "ready"), this.hasChannel = /* @__PURE__ */ o(() => !!this.channel, "hasChannel"), this.setChannel = /* @__PURE__ */ o((e) => {
      this.channel = e, this.resolve();
    }, "setChannel"), this.promise = new Promise((e) => {
      this.resolve = () => e(this.getChannel());
    });
  }
};
o(vR, "AddonStore");
var J2 = vR, Vu = "__STORYBOOK_ADDONS_PREVIEW";
function wR() {
  return ee[Vu] || (ee[Vu] = new J2()), ee[Vu];
}
o(wR, "getAddonsStore");
var zt = wR(), _R = class {
  constructor() {
    this.hookListsMap = void 0, this.mountedDecorators = void 0, this.prevMountedDecorators = void 0, this.currentHooks = void 0, this.nextHookIndex = void 0, this.currentPhase = void 0, this.currentEffects = void 0, this.prevEffects = void 0, this.currentDecoratorName = void 0, this.hasUpdates = void 0, this.currentContext = void 0, this.renderListener = /* @__PURE__ */ o((e) => {
      e === this.currentContext?.id && (this.triggerEffects(), this.currentContext = null, this.removeRenderListeners());
    }, "renderListener"), this.init();
  }
  init() {
    this.hookListsMap = /* @__PURE__ */ new WeakMap(), this.mountedDecorators = /* @__PURE__ */ new Set(), this.prevMountedDecorators = /* @__PURE__ */ new Set(), this.currentHooks = [], this.nextHookIndex = 0, this.currentPhase = "NONE", this.currentEffects = [], this.prevEffects = [], this.currentDecoratorName = null, this.hasUpdates = !1, this.currentContext = null;
  }
  clean() {
    this.prevEffects.forEach((e) => {
      e.destroy && e.destroy();
    }), this.init(), this.removeRenderListeners();
  }
  getNextHook() {
    const e = this.currentHooks[this.nextHookIndex];
    return this.nextHookIndex += 1, e;
  }
  triggerEffects() {
    this.prevEffects.forEach((e) => {
      !this.currentEffects.includes(e) && e.destroy && e.destroy();
    }), this.currentEffects.forEach((e) => {
      this.prevEffects.includes(e) || (e.destroy = e.create());
    }), this.prevEffects = this.currentEffects, this.currentEffects = [];
  }
  addRenderListeners() {
    this.removeRenderListeners(), zt.getChannel().on(Vi, this.renderListener);
  }
  removeRenderListeners() {
    zt.getChannel().removeListener(Vi, this.renderListener);
  }
};
o(_R, "HooksContext");
var ER = _R;
function Ld(e) {
  const t = /* @__PURE__ */ o((...r) => {
    const { hooks: n } = typeof r[0] == "function" ? r[1] : r[0], a = n.currentPhase, i = n.currentHooks, s = n.nextHookIndex, l = n.currentDecoratorName;
    n.currentDecoratorName = e.name, n.prevMountedDecorators.has(e) ? (n.currentPhase = "UPDATE", n.currentHooks = n.hookListsMap.get(e) || []) : (n.currentPhase = "MOUNT", n.currentHooks = [], n.hookListsMap.set(e, n.currentHooks), n.prevMountedDecorators.add(e)), n.nextHookIndex = 0;
    const c = ee.STORYBOOK_HOOKS_CONTEXT;
    ee.STORYBOOK_HOOKS_CONTEXT = n;
    const u = e(...r);
    if (ee.STORYBOOK_HOOKS_CONTEXT = c, n.currentPhase === "UPDATE" && n.getNextHook() != null)
      throw new Error(
        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      );
    return n.currentPhase = a, n.currentHooks = i, n.nextHookIndex = s, n.currentDecoratorName = l, u;
  }, "hookified");
  return t.originalFn = e, t;
}
o(Ld, "hookify");
var Ju = 0, z2 = 25, W2 = /* @__PURE__ */ o((e) => (t, r) => {
  const n = e(
    Ld(t),
    r.map((a) => Ld(a))
  );
  return (a) => {
    const { hooks: i } = a;
    i.prevMountedDecorators ??= /* @__PURE__ */ new Set(), i.mountedDecorators = /* @__PURE__ */ new Set([t, ...r]), i.currentContext = a, i.hasUpdates = !1;
    let s = n(a);
    for (Ju = 1; i.hasUpdates; )
      if (i.hasUpdates = !1, i.currentEffects = [], s = n(a), Ju += 1, Ju > z2)
        throw new Error(
          "Too many re-renders. Storybook limits the number of renders to prevent an infinite loop."
        );
    return i.addRenderListeners(), s;
  };
}, "applyHooks"), G2 = /* @__PURE__ */ o((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), "areDepsEqual"), Jh = /* @__PURE__ */ o(() => new Error("Storybook preview hooks can only be called inside decorators and story functions."), "invalidHooksError");
function zh() {
  return ee.STORYBOOK_HOOKS_CONTEXT || null;
}
o(zh, "getHooksContextOrNull");
function au() {
  const e = zh();
  if (e == null)
    throw Jh();
  return e;
}
o(au, "getHooksContextOrThrow");
function xR(e, t, r) {
  const n = au();
  if (n.currentPhase === "MOUNT") {
    r != null && !Array.isArray(r) && qe.warn(
      `${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`
    );
    const a = { name: e, deps: r };
    return n.currentHooks.push(a), t(a), a;
  }
  if (n.currentPhase === "UPDATE") {
    const a = n.getNextHook();
    if (a == null)
      throw new Error("Rendered more hooks than during the previous render.");
    return a.name !== e && qe.warn(
      `Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ""}. This will lead to bugs and errors if not fixed.`
    ), r != null && a.deps == null && qe.warn(
      `${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
    ), r != null && a.deps != null && r.length !== a.deps.length && qe.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${a.deps}
Incoming: ${r}`), (r == null || a.deps == null || !G2(r, a.deps)) && (t(a), a.deps = r), a;
  }
  throw Jh();
}
o(xR, "useHook");
function li(e, t, r) {
  const { memoizedState: n } = xR(
    e,
    (a) => {
      a.memoizedState = t();
    },
    r
  );
  return n;
}
o(li, "useMemoLike");
function TR(e, t) {
  return li("useMemo", e, t);
}
o(TR, "useMemo");
function Ma(e, t) {
  return li("useCallback", () => e, t);
}
o(Ma, "useCallback");
function Wh(e, t) {
  return li(e, () => ({ current: t }), []);
}
o(Wh, "useRefLike");
function K2(e) {
  return Wh("useRef", e);
}
o(K2, "useRef");
function SR() {
  const e = zh();
  if (e != null && e.currentPhase !== "NONE")
    e.hasUpdates = !0;
  else
    try {
      zt.getChannel().emit(Sp);
    } catch {
      qe.warn("State updates of Storybook preview hooks work only in browser");
    }
}
o(SR, "triggerUpdate");
function Gh(e, t) {
  const r = Wh(
    e,
    // @ts-expect-error S type should never be function, but there's no way to tell that to TypeScript
    typeof t == "function" ? t() : t
  ), n = /* @__PURE__ */ o((a) => {
    r.current = typeof a == "function" ? a(r.current) : a, SR();
  }, "setState");
  return [r.current, n];
}
o(Gh, "useStateLike");
function Y2(e) {
  return Gh("useState", e);
}
o(Y2, "useState");
function X2(e, t, r) {
  const n = r != null ? () => r(t) : t, [a, i] = Gh("useReducer", n);
  return [a, /* @__PURE__ */ o((s) => i((l) => e(l, s)), "dispatch")];
}
o(X2, "useReducer");
function On(e, t) {
  const r = au(), n = li("useEffect", () => ({ create: e }), t);
  r.currentEffects.includes(n) || r.currentEffects.push(n);
}
o(On, "useEffect");
function Q2(e, t = []) {
  const r = zt.getChannel();
  return On(() => (Object.entries(e).forEach(([n, a]) => r.on(n, a)), () => {
    Object.entries(e).forEach(
      ([n, a]) => r.removeListener(n, a)
    );
  }), [...Object.keys(e), ...t]), Ma(r.emit.bind(r), [r]);
}
o(Q2, "useChannel");
function iu() {
  const { currentContext: e } = au();
  if (e == null)
    throw Jh();
  return e;
}
o(iu, "useStoryContext");
function Z2(e, t) {
  const { parameters: r } = iu();
  if (e)
    return r[e] ?? t;
}
o(Z2, "useParameter");
function eU() {
  const e = zt.getChannel(), { id: t, args: r } = iu(), n = Ma(
    (i) => e.emit(Ap, { storyId: t, updatedArgs: i }),
    [e, t]
  ), a = Ma(
    (i) => e.emit(Pp, { storyId: t, argNames: i }),
    [e, t]
  );
  return [r, n, a];
}
o(eU, "useArgs");
function tU() {
  const e = zt.getChannel(), { globals: t } = iu(), r = Ma(
    (n) => e.emit(Cp, { globals: n }),
    [e]
  );
  return [t, r];
}
o(tU, "useGlobals");
var rU = /* @__PURE__ */ o(({
  name: e,
  parameterName: t,
  wrapper: r,
  skipIfNoParametersOrOptions: n = !1
}) => {
  const a = /* @__PURE__ */ o((i) => (s, l) => {
    const c = l.parameters && l.parameters[t];
    return c && c.disable || n && !i && !c ? s(l) : r(s, l, {
      options: i,
      parameters: c
    });
  }, "decorator");
  return (...i) => typeof i[0] == "function" ? a()(...i) : (...s) => {
    if (s.length > 1)
      return i.length > 1 ? a(i)(...s) : a(...i)(...s);
    throw new Error(
      `Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`
    );
  };
}, "makeDecorator"), zu = Ye(zv(), 1), ln = Symbol("incompatible"), Dd = /* @__PURE__ */ o((e, t) => {
  const r = t.type;
  if (e == null || !r || t.mapping)
    return e;
  switch (r.name) {
    case "string":
      return String(e);
    case "enum":
      return e;
    case "number":
      return Number(e);
    case "boolean":
      return String(e) === "true";
    case "array":
      return !r.value || !Array.isArray(e) ? ln : e.reduce((n, a, i) => {
        const s = Dd(a, { type: r.value });
        return s !== ln && (n[i] = s), n;
      }, new Array(e.length));
    case "object":
      return typeof e == "string" || typeof e == "number" ? e : !r.value || typeof e != "object" ? ln : Object.entries(e).reduce((n, [a, i]) => {
        const s = Dd(i, { type: r.value[a] });
        return s === ln ? n : Object.assign(n, { [a]: s });
      }, {});
    case "other": {
      const n = typeof e == "string" || typeof e == "number" || typeof e == "boolean";
      return r.value === "ReactNode" && n ? e : ln;
    }
    default:
      return ln;
  }
}, "map"), nU = /* @__PURE__ */ o((e, t) => Object.entries(e).reduce((r, [n, a]) => {
  if (!t[n])
    return r;
  const i = Dd(a, t[n]);
  return i === ln ? r : Object.assign(r, { [n]: i });
}, {}), "mapArgsToTypes"), Fd = /* @__PURE__ */ o((e, t) => Array.isArray(e) && Array.isArray(t) ? t.reduce(
  (r, n, a) => (r[a] = Fd(e[a], t[a]), r),
  [...e]
).filter((r) => r !== void 0) : !_t(e) || !_t(t) ? t : Object.keys({ ...e, ...t }).reduce((r, n) => {
  if (n in t) {
    const a = Fd(e[n], t[n]);
    a !== void 0 && (r[n] = a);
  } else
    r[n] = e[n];
  return r;
}, {}), "combineArgs"), oU = /* @__PURE__ */ o((e, t) => Object.entries(t).reduce((r, [n, { options: a }]) => {
  function i() {
    return n in e && (r[n] = e[n]), r;
  }
  if (o(i, "allowArg"), !a)
    return i();
  if (!Array.isArray(a))
    return Ue.error(ye`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `), i();
  if (a.some((f) => f && ["object", "function"].includes(typeof f)))
    return Ue.error(ye`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `), i();
  const s = Array.isArray(e[n]), l = s && e[n].findIndex((f) => !a.includes(f)), c = s && l === -1;
  if (e[n] === void 0 || a.includes(e[n]) || c)
    return i();
  const u = s ? `${n}[${l}]` : n, p = a.map((f) => typeof f == "string" ? `'${f}'` : String(f)).join(", ");
  return Ue.warn(`Received illegal value for '${u}'. Supported options: ${p}`), r;
}, {}), "validateOptions"), pa = Symbol("Deeply equal"), ks = /* @__PURE__ */ o((e, t) => {
  if (typeof e != typeof t)
    return t;
  if (Hv(e, t))
    return pa;
  if (Array.isArray(e) && Array.isArray(t)) {
    const r = t.reduce((n, a, i) => {
      const s = ks(e[i], a);
      return s !== pa && (n[i] = s), n;
    }, new Array(t.length));
    return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
  }
  return _t(e) && _t(t) ? Object.keys({ ...e, ...t }).reduce((r, n) => {
    const a = ks(e?.[n], t?.[n]);
    return a === pa ? r : Object.assign(r, { [n]: a });
  }, {}) : t;
}, "deepDiff"), PR = "UNTARGETED";
function OR({
  args: e,
  argTypes: t
}) {
  const r = {};
  return Object.entries(e).forEach(([n, a]) => {
    const { target: i = PR } = t[n] || {};
    r[i] = r[i] || {}, r[i][n] = a;
  }), r;
}
o(OR, "groupArgsByTarget");
function CR(e) {
  return Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e;
}
o(CR, "deleteUndefined");
var AR = class {
  constructor() {
    this.initialArgsByStoryId = {}, this.argsByStoryId = {};
  }
  get(e) {
    if (!(e in this.argsByStoryId))
      throw new Error(`No args known for ${e} -- has it been rendered yet?`);
    return this.argsByStoryId[e];
  }
  setInitial(e) {
    if (!this.initialArgsByStoryId[e.id])
      this.initialArgsByStoryId[e.id] = e.initialArgs, this.argsByStoryId[e.id] = e.initialArgs;
    else if (this.initialArgsByStoryId[e.id] !== e.initialArgs) {
      const t = ks(this.initialArgsByStoryId[e.id], this.argsByStoryId[e.id]);
      this.initialArgsByStoryId[e.id] = e.initialArgs, this.argsByStoryId[e.id] = e.initialArgs, t !== pa && this.updateFromDelta(e, t);
    }
  }
  updateFromDelta(e, t) {
    const r = oU(t, e.argTypes);
    this.argsByStoryId[e.id] = Fd(this.argsByStoryId[e.id], r);
  }
  updateFromPersisted(e, t) {
    const r = nU(t, e.argTypes);
    return this.updateFromDelta(e, r);
  }
  update(e, t) {
    if (!(e in this.argsByStoryId))
      throw new Error(`No args known for ${e} -- has it been rendered yet?`);
    this.argsByStoryId[e] = CR({
      ...this.argsByStoryId[e],
      ...t
    });
  }
};
o(AR, "ArgsStore");
var aU = AR, RR = /* @__PURE__ */ o((e = {}) => Object.entries(e).reduce((t, [r, { defaultValue: n }]) => (typeof n < "u" && (t[r] = n), t), {}), "getValuesFromArgTypes"), kR = class {
  constructor({
    globals: e = {},
    globalTypes: t = {}
  }) {
    this.set({ globals: e, globalTypes: t });
  }
  set({ globals: e = {}, globalTypes: t = {} }) {
    const r = this.initialGlobals && ks(this.initialGlobals, this.globals);
    this.allowedGlobalNames = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(t)]);
    const n = RR(t);
    this.initialGlobals = { ...n, ...e }, this.globals = this.initialGlobals, r && r !== pa && this.updateFromPersisted(r);
  }
  filterAllowedGlobals(e) {
    return Object.entries(e).reduce((t, [r, n]) => (this.allowedGlobalNames.has(r) ? t[r] = n : qe.warn(
      `Attempted to set a global (${r}) that is not defined in initial globals or globalTypes`
    ), t), {});
  }
  updateFromPersisted(e) {
    const t = this.filterAllowedGlobals(e);
    this.globals = { ...this.globals, ...t };
  }
  get() {
    return this.globals;
  }
  update(e) {
    this.globals = { ...this.globals, ...this.filterAllowedGlobals(e) };
    for (const t in e)
      e[t] === void 0 && (this.globals[t] = this.initialGlobals[t]);
  }
};
o(kR, "GlobalsStore");
var iU = kR, sU = Ye(zv(), 1), lU = (0, sU.default)(1)(
  (e) => Object.values(e).reduce(
    (t, r) => (t[r.importPath] = t[r.importPath] || r, t),
    {}
  )
), IR = class {
  constructor({ entries: e } = { v: 5, entries: {} }) {
    this.entries = e;
  }
  entryFromSpecifier(e) {
    const t = Object.values(this.entries);
    if (e === "*")
      return t[0];
    if (typeof e == "string")
      return this.entries[e] ? this.entries[e] : t.find((a) => a.id.startsWith(e));
    const { name: r, title: n } = e;
    return t.find((a) => a.name === r && a.title === n);
  }
  storyIdToEntry(e) {
    const t = this.entries[e];
    if (!t)
      throw new Jk({ storyId: e });
    return t;
  }
  importPathToEntry(e) {
    return lU(this.entries)[e];
  }
};
o(IR, "StoryIndexStore");
var uU = IR, cU = /* @__PURE__ */ o((e) => typeof e == "string" ? { name: e } : e, "normalizeType"), dU = /* @__PURE__ */ o((e) => typeof e == "string" ? { type: e } : e, "normalizeControl"), pU = /* @__PURE__ */ o((e, t) => {
  const { type: r, control: n, ...a } = e, i = {
    name: t,
    ...a
  };
  return r && (i.type = cU(r)), n ? i.control = dU(n) : n === !1 && (i.control = { disable: !0 }), i;
}, "normalizeInputType"), Is = /* @__PURE__ */ o((e) => oo(e, pU), "normalizeInputTypes"), _e = /* @__PURE__ */ o((e) => Array.isArray(e) ? e : e ? [e] : [], "normalizeArrays"), fU = ye`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function fa(e, t, r) {
  const n = t, a = typeof t == "function" ? t : null, { story: i } = n;
  i && (qe.debug("deprecated story", i), Zw(fU));
  const s = V2(e), l = typeof n != "function" && n.name || n.storyName || i?.name || s, c = [
    ..._e(n.decorators),
    ..._e(i?.decorators)
  ], u = { ...i?.parameters, ...n.parameters }, p = { ...i?.args, ...n.args }, f = { ...i?.argTypes, ...n.argTypes }, m = [..._e(n.loaders), ..._e(i?.loaders)], y = [
    ..._e(n.beforeEach),
    ..._e(i?.beforeEach)
  ], g = [
    ..._e(n.afterEach),
    ..._e(i?.afterEach)
  ], { render: v, play: _, tags: b = [], globals: E = {} } = n, C = u.__id || U2(r.id, s);
  return {
    moduleExport: t,
    id: C,
    name: l,
    tags: b,
    decorators: c,
    parameters: u,
    args: p,
    argTypes: Is(f),
    loaders: m,
    beforeEach: y,
    afterEach: g,
    globals: E,
    ...v && { render: v },
    ...a && { userStoryFn: a },
    ..._ && { play: _ }
  };
}
o(fa, "normalizeStory");
function js(e, t = e.title, r) {
  const { id: n, argTypes: a } = e;
  return {
    id: yR(n || t),
    ...e,
    title: t,
    ...a && { argTypes: Is(a) },
    parameters: {
      fileName: r,
      ...e.parameters
    }
  };
}
o(js, "normalizeComponentAnnotations");
var mU = /* @__PURE__ */ o((e) => {
  const { globals: t, globalTypes: r } = e;
  (t || r) && qe.error(
    "Global args/argTypes can only be set globally",
    JSON.stringify({
      globals: t,
      globalTypes: r
    })
  );
}, "checkGlobals"), hU = /* @__PURE__ */ o((e) => {
  const { options: t } = e;
  t?.storySort && qe.error("The storySort option parameter can only be set globally");
}, "checkStorySort"), _i = /* @__PURE__ */ o((e) => {
  e && (mU(e), hU(e));
}, "checkDisallowedParameters");
function jR(e, t, r) {
  const { default: n, __namedExportsOrder: a, ...i } = e, s = Object.values(i)[0];
  if (ou(s)) {
    const u = js(s.meta.input, r, t);
    _i(u.parameters);
    const p = { meta: u, stories: {}, moduleExports: e };
    return Object.keys(i).forEach((f) => {
      if (Rs(f, u)) {
        const m = i[f], y = fa(f, m.input, u);
        _i(y.parameters), p.stories[y.id] = y, hR(m).forEach((g) => {
          const v = g.input.name, _ = H2(y.id, v);
          g.input.parameters ??= {}, g.input.parameters.__id = _, p.stories[_] = fa(v, g.input, u);
        });
      }
    }), p.projectAnnotations = s.meta.preview.composed, p;
  }
  const l = js(
    n,
    r,
    t
  );
  _i(l.parameters);
  const c = { meta: l, stories: {}, moduleExports: e };
  return Object.keys(i).forEach((u) => {
    if (Rs(u, l)) {
      const p = fa(u, i[u], l);
      _i(p.parameters), c.stories[p.id] = p;
    }
  }), c;
}
o(jR, "processCSFFile");
function Ns(e) {
  return e != null && NR(e).includes("mount");
}
o(Ns, "mountDestructured");
function NR(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t)
    return [];
  const r = Bd(t[1]);
  if (!r.length)
    return [];
  const n = r[0];
  return n.startsWith("{") && n.endsWith("}") ? Bd(n.slice(1, -1).replace(/\s/g, "")).map((a) => a.replace(/:.*|=.*/g, "")) : [];
}
o(NR, "getUsedProps");
function Bd(e) {
  const t = [], r = [];
  let n = 0;
  for (let i = 0; i < e.length; i++)
    if (e[i] === "{" || e[i] === "[")
      r.push(e[i] === "{" ? "}" : "]");
    else if (e[i] === r[r.length - 1])
      r.pop();
    else if (!r.length && e[i] === ",") {
      const s = e.substring(n, i).trim();
      s && t.push(s), n = i + 1;
    }
  const a = e.substring(n).trim();
  return a && t.push(a), t;
}
o(Bd, "splitByComma");
function qR(e, t, r) {
  const n = r(e);
  return (a) => t(n, a);
}
o(qR, "decorateStory");
function MR({
  componentId: e,
  title: t,
  kind: r,
  id: n,
  name: a,
  story: i,
  parameters: s,
  initialArgs: l,
  argTypes: c,
  ...u
} = {}) {
  return u;
}
o(MR, "sanitizeStoryContextUpdate");
function $R(e, t) {
  const r = {}, n = /* @__PURE__ */ o((i) => (s) => {
    if (!r.value)
      throw new Error("Decorated function called without init");
    return r.value = {
      ...r.value,
      ...MR(s)
    }, i(r.value);
  }, "bindWithContext"), a = t.reduce(
    (i, s) => qR(i, s, n),
    e
  );
  return (i) => (r.value = i, a(i));
}
o($R, "defaultDecorateStory");
function Kh(e, t, r) {
  const { moduleExport: n, id: a, name: i } = e || {}, s = Yh(
    e,
    t,
    r
  ), l = /* @__PURE__ */ o(async (O) => {
    const S = {};
    for (const w of [
      _e(r.loaders),
      _e(t.loaders),
      _e(e.loaders)
    ]) {
      if (O.abortSignal.aborted)
        return S;
      const T = await Promise.all(w.map((M) => M(O)));
      Object.assign(S, ...T);
    }
    return S;
  }, "applyLoaders"), c = /* @__PURE__ */ o(async (O) => {
    const S = new Array();
    for (const w of [
      ..._e(r.beforeEach),
      ..._e(t.beforeEach),
      ..._e(e.beforeEach)
    ]) {
      if (O.abortSignal.aborted)
        return S;
      const T = await w(O);
      T && S.push(T);
    }
    return S;
  }, "applyBeforeEach"), u = /* @__PURE__ */ o(async (O) => {
    const S = [
      ..._e(r.afterEach),
      ..._e(t.afterEach),
      ..._e(e.afterEach)
    ].reverse();
    for (const w of S) {
      if (O.abortSignal.aborted)
        return;
      await w(O);
    }
  }, "applyAfterEach"), p = /* @__PURE__ */ o((O) => O.originalStoryFn(O.args, O), "undecoratedStoryFn"), { applyDecorators: f = $R, runStep: m } = r, y = [
    ..._e(e?.decorators),
    ..._e(t?.decorators),
    ..._e(r?.decorators)
  ], g = e?.userStoryFn || e?.render || t.render || r.render, v = W2(f)(p, y), _ = /* @__PURE__ */ o((O) => v(O), "unboundStoryFn"), b = e?.play ?? t?.play, E = Ns(b);
  if (!g && !E)
    throw new t1({ id: a });
  const C = /* @__PURE__ */ o((O) => async () => (await O.renderToCanvas(), O.canvas), "defaultMount"), k = e.mount ?? t.mount ?? r.mount ?? C, N = r.testingLibraryRender;
  return {
    storyGlobals: {},
    ...s,
    moduleExport: n,
    id: a,
    name: i,
    story: i,
    originalStoryFn: g,
    undecoratedStoryFn: p,
    unboundStoryFn: _,
    applyLoaders: l,
    applyBeforeEach: c,
    applyAfterEach: u,
    playFunction: b,
    runStep: m,
    mount: k,
    testingLibraryRender: N,
    renderToCanvas: r.renderToCanvas,
    usesMount: E
  };
}
o(Kh, "prepareStory");
function LR(e, t, r) {
  return {
    ...Yh(void 0, e, t),
    moduleExport: r
  };
}
o(LR, "prepareMeta");
function Yh(e, t, r) {
  const n = ["dev", "test"], a = ee.DOCS_OPTIONS?.autodocs === !0 ? ["autodocs"] : [], i = e?.tags?.includes("test-fn") ? ["!autodocs"] : [], s = gR(
    ...n,
    ...a,
    ...r.tags ?? [],
    ...t.tags ?? [],
    ...i,
    ...e?.tags ?? []
  ), l = Wr(
    r.parameters,
    t.parameters,
    e?.parameters
  ), { argTypesEnhancers: c = [], argsEnhancers: u = [] } = r, p = Wr(
    r.argTypes,
    t.argTypes,
    e?.argTypes
  );
  if (e) {
    const E = e?.userStoryFn || e?.render || t.render || r.render;
    l.__isArgsStory = E && E.length > 0;
  }
  const f = {
    ...r.args,
    ...t.args,
    ...e?.args
  }, m = {
    ...t.globals,
    ...e?.globals
  }, y = {
    componentId: t.id,
    title: t.title,
    kind: t.title,
    // Back compat
    id: e?.id || t.id,
    // if there's no story name, we create a fake one since enhancers expect a name
    name: e?.name || "__meta",
    story: e?.name || "__meta",
    // Back compat
    component: t.component,
    subcomponents: t.subcomponents,
    tags: s,
    parameters: l,
    initialArgs: f,
    argTypes: p,
    storyGlobals: m
  };
  y.argTypes = c.reduce(
    (E, C) => C({ ...y, argTypes: E }),
    y.argTypes
  );
  const g = { ...f };
  y.initialArgs = [...u].reduce(
    (E, C) => ({
      ...E,
      ...C({
        ...y,
        initialArgs: E
      })
    }),
    g
  );
  const { name: v, story: _, ...b } = y;
  return b;
}
o(Yh, "preparePartialAnnotations");
function Xh(e) {
  const { args: t } = e;
  let r = {
    ...e,
    allArgs: void 0,
    argsByTarget: void 0
  };
  if (ee.FEATURES?.argTypeTargetsV7) {
    const i = OR(e);
    r = {
      ...e,
      allArgs: e.args,
      argsByTarget: i,
      args: i[PR] || {}
    };
  }
  const n = Object.entries(r.args).reduce((i, [s, l]) => {
    if (!r.argTypes[s]?.mapping)
      return i[s] = l, i;
    const c = /* @__PURE__ */ o((u) => {
      const p = r.argTypes[s].mapping;
      return p && u in p ? p[u] : u;
    }, "mappingFn");
    return i[s] = Array.isArray(l) ? l.map(c) : c(l), i;
  }, {}), a = Object.entries(n).reduce((i, [s, l]) => {
    const c = r.argTypes[s] || {};
    return e2(c, n, r.globals) && (i[s] = l), i;
  }, {});
  return { ...r, unmappedArgs: t, args: a };
}
o(Xh, "prepareContext");
var Ud = /* @__PURE__ */ o((e, t, r) => {
  const n = typeof e;
  switch (n) {
    case "boolean":
    case "string":
    case "number":
    case "function":
    case "symbol":
      return { name: n };
  }
  return e ? r.has(e) ? (qe.warn(ye`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `), { name: "other", value: "cyclic object" }) : (r.add(e), Array.isArray(e) ? { name: "array", value: e.length > 0 ? Ud(e[0], t, new Set(r)) : { name: "other", value: "unknown" } } : { name: "object", value: oo(e, (a) => Ud(a, t, new Set(r))) }) : { name: "object", value: {} };
}, "inferType"), DR = /* @__PURE__ */ o((e) => {
  const { id: t, argTypes: r = {}, initialArgs: n = {} } = e, a = oo(n, (s, l) => ({
    name: l,
    type: Ud(s, `${t}.${l}`, /* @__PURE__ */ new Set())
  })), i = oo(r, (s, l) => ({
    name: l
  }));
  return Wr(a, i, r);
}, "inferArgTypes");
DR.secondPass = !0;
var Xg = /* @__PURE__ */ o((e, t) => Array.isArray(t) ? t.includes(e) : e.match(t), "matches"), yU = /* @__PURE__ */ o((e, t, r) => !t && !r ? e : e && Nb(e, (n, a) => {
  const i = n.name || a.toString();
  return !!(!t || Xg(i, t)) && (!r || !Xg(i, r));
}), "filterArgTypes"), gU = /* @__PURE__ */ o((e, t, r) => {
  const { type: n, options: a } = e;
  if (n) {
    if (r.color && r.color.test(t)) {
      const i = n.name;
      if (i === "string")
        return { control: { type: "color" } };
      i !== "enum" && qe.warn(
        `Addon controls: Control of type color only supports string, received "${i}" instead`
      );
    }
    if (r.date && r.date.test(t))
      return { control: { type: "date" } };
    switch (n.name) {
      case "array":
        return { control: { type: "object" } };
      case "boolean":
        return { control: { type: "boolean" } };
      case "string":
        return { control: { type: "text" } };
      case "number":
        return { control: { type: "number" } };
      case "enum": {
        const { value: i } = n;
        return { control: { type: i?.length <= 5 ? "radio" : "select" }, options: i };
      }
      case "function":
      case "symbol":
        return null;
      default:
        return { control: { type: a ? "select" : "object" } };
    }
  }
}, "inferControl"), FR = /* @__PURE__ */ o((e) => {
  const {
    argTypes: t,
    parameters: { __isArgsStory: r, controls: { include: n = null, exclude: a = null, matchers: i = {} } = {} }
  } = e;
  if (!r)
    return t;
  const s = yU(t, n, a), l = oo(s, (c, u) => c?.type && gU(c, u.toString(), i));
  return Wr(l, s);
}, "inferControls");
FR.secondPass = !0;
function $a({
  argTypes: e,
  globalTypes: t,
  argTypesEnhancers: r,
  decorators: n,
  loaders: a,
  beforeEach: i,
  afterEach: s,
  initialGlobals: l,
  ...c
}) {
  return {
    ...e && { argTypes: Is(e) },
    ...t && { globalTypes: Is(t) },
    decorators: _e(n),
    loaders: _e(a),
    beforeEach: _e(i),
    afterEach: _e(s),
    argTypesEnhancers: [
      ...r || [],
      DR,
      // There's an architectural decision to be made regarding embedded addons in core:
      //
      // Option 1: Keep embedded addons but ensure consistency by moving addon-specific code
      // (like inferControls) to live alongside the addon code itself. This maintains the
      // concept of core addons while improving code organization.
      //
      // Option 2: Fully integrate these addons into core, potentially moving UI components
      // into the manager and treating them as core features rather than addons. This is a
      // bigger architectural change requiring careful consideration.
      //
      // For now, we're keeping inferControls here as we need time to properly evaluate
      // these options and their implications. Some features (like Angular's cleanArgsDecorator)
      // currently rely on this behavior.
      //
      // TODO: Make an architectural decision on the handling of core addons
      FR
    ],
    initialGlobals: l,
    ...c
  };
}
o($a, "normalizeProjectAnnotations");
var bU = /* @__PURE__ */ o((e) => async () => {
  const t = [];
  for (const r of e) {
    const n = await r();
    n && t.unshift(n);
  }
  return async () => {
    for (const r of t)
      await r();
  };
}, "composeBeforeAllHooks");
function BR(e) {
  return async (t, r, n) => {
    await e.reduceRight(
      (a, i) => async () => i(t, a, n),
      async () => r(n)
    )();
  };
}
o(BR, "composeStepRunners");
function xo(e, t) {
  return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
o(xo, "getField");
function wr(e, t, r = {}) {
  return xo(e, t).reduce((n, a) => {
    const i = _e(a);
    return r.reverseFileOrder ? [...i, ...n] : [...n, ...i];
  }, []);
}
o(wr, "getArrayField");
function ta(e, t) {
  return Object.assign({}, ...xo(e, t));
}
o(ta, "getObjectField");
function Vn(e, t) {
  return xo(e, t).pop();
}
o(Vn, "getSingletonField");
function Cn(e) {
  const t = wr(e, "argTypesEnhancers"), r = xo(e, "runStep"), n = wr(e, "beforeAll");
  return {
    parameters: Wr(...xo(e, "parameters")),
    decorators: wr(e, "decorators", {
      reverseFileOrder: !(ee.FEATURES?.legacyDecoratorFileOrder ?? !1)
    }),
    args: ta(e, "args"),
    argsEnhancers: wr(e, "argsEnhancers"),
    argTypes: ta(e, "argTypes"),
    argTypesEnhancers: [
      ...t.filter((a) => !a.secondPass),
      ...t.filter((a) => a.secondPass)
    ],
    initialGlobals: ta(e, "initialGlobals"),
    globalTypes: ta(e, "globalTypes"),
    loaders: wr(e, "loaders"),
    beforeAll: bU(n),
    beforeEach: wr(e, "beforeEach"),
    afterEach: wr(e, "afterEach"),
    render: Vn(e, "render"),
    renderToCanvas: Vn(e, "renderToCanvas"),
    applyDecorators: Vn(e, "applyDecorators"),
    runStep: BR(r),
    tags: wr(e, "tags"),
    mount: Vn(e, "mount"),
    testingLibraryRender: Vn(e, "testingLibraryRender")
  };
}
o(Cn, "composeConfigs");
var UR = class {
  constructor() {
    this.reports = [];
  }
  async addReport(e) {
    this.reports.push(e);
  }
};
o(UR, "ReporterAPI");
var HR = UR;
function VR(e, t, r) {
  return ou(e) ? {
    story: e.input,
    meta: e.meta.input,
    preview: e.meta.preview.composed
  } : { story: e, meta: fR(t) ? t.input : t, preview: r };
}
o(VR, "getCsfFactoryAnnotations");
function vU(e) {
  globalThis.defaultProjectAnnotations = e;
}
o(vU, "setDefaultProjectAnnotations");
var wU = "ComposedStory", _U = "Unnamed Story";
function JR(e) {
  return e ? Cn([e]) : {};
}
o(JR, "extractAnnotation");
function EU(e) {
  const t = Array.isArray(e) ? e : [e];
  return globalThis.globalProjectAnnotations = Cn([
    ...nu(),
    globalThis.defaultProjectAnnotations ?? {},
    Cn(t.map(JR))
  ]), globalThis.globalProjectAnnotations ?? {};
}
o(EU, "setProjectAnnotations");
var Fr = [];
function Qh(e, t, r, n, a) {
  if (e === void 0)
    throw new Error("Expected a story but received undefined.");
  t.title = t.title ?? wU;
  const i = js(t), s = a || e.storyName || e.story?.name || e.name || _U, l = fa(
    s,
    e,
    i
  ), c = $a(
    Cn([
      n ?? globalThis.globalProjectAnnotations ?? {},
      r ?? {}
    ])
  ), u = Kh(
    l,
    i,
    c
  ), p = {
    ...RR(c.globalTypes),
    ...c.initialGlobals,
    ...u.storyGlobals
  }, f = new HR(), m = /* @__PURE__ */ o(() => {
    const b = Xh({
      hooks: new ER(),
      globals: p,
      args: { ...u.initialArgs },
      viewMode: "story",
      reporting: f,
      loaded: {},
      abortSignal: new AbortController().signal,
      step: /* @__PURE__ */ o((E, C) => u.runStep(E, C, b), "step"),
      canvasElement: null,
      canvas: {},
      userEvent: {},
      globalTypes: c.globalTypes,
      ...u,
      context: null,
      mount: null
    });
    return b.parameters.__isPortableStory = !0, b.context = b, u.renderToCanvas && (b.renderToCanvas = async () => {
      const E = await u.renderToCanvas?.(
        {
          componentId: u.componentId,
          title: u.title,
          id: u.id,
          name: u.name,
          tags: u.tags,
          showMain: /* @__PURE__ */ o(() => {
          }, "showMain"),
          showError: /* @__PURE__ */ o((C) => {
            throw new Error(`${C.title}
${C.description}`);
          }, "showError"),
          showException: /* @__PURE__ */ o((C) => {
            throw C;
          }, "showException"),
          forceRemount: !0,
          storyContext: b,
          storyFn: /* @__PURE__ */ o(() => u.unboundStoryFn(b), "storyFn"),
          unboundStoryFn: u.unboundStoryFn
        },
        b.canvasElement
      );
      E && Fr.push(E);
    }), b.mount = u.mount(b), b;
  }, "initializeContext");
  let y;
  const g = /* @__PURE__ */ o(async (b) => {
    const E = m();
    return E.canvasElement ??= globalThis?.document?.body, y && (E.loaded = y.loaded), Object.assign(E, b), u.playFunction(E);
  }, "play"), v = /* @__PURE__ */ o((b) => {
    const E = m();
    return Object.assign(E, b), zR(u, E);
  }, "run"), _ = u.playFunction ? g : void 0;
  return Object.assign(
    /* @__PURE__ */ o(function(b) {
      const E = m();
      return y && (E.loaded = y.loaded), E.args = {
        ...E.initialArgs,
        ...b
      }, u.unboundStoryFn(E);
    }, "storyFn"),
    {
      id: u.id,
      storyName: s,
      load: /* @__PURE__ */ o(async () => {
        for (const E of [...Fr].reverse())
          await E();
        Fr.length = 0;
        const b = m();
        b.loaded = await u.applyLoaders(b), Fr.push(...(await u.applyBeforeEach(b)).filter(Boolean)), y = b;
      }, "load"),
      globals: p,
      args: u.initialArgs,
      parameters: u.parameters,
      argTypes: u.argTypes,
      play: _,
      run: v,
      reporting: f,
      tags: u.tags
    }
  );
}
o(Qh, "composeStory");
var xU = /* @__PURE__ */ o((e, t, r, n) => Qh(e, t, r, {}, n), "defaultComposeStory");
function TU(e, t, r = xU) {
  const { default: n, __esModule: a, __namedExportsOrder: i, ...s } = e;
  let l = n;
  return Object.entries(s).reduce(
    (c, [u, p]) => {
      const { story: f, meta: m } = VR(p);
      return !l && m && (l = m), Rs(u, l) ? Object.assign(c, {
        [u]: r(f, l, t, u)
      }) : c;
    },
    {}
  );
}
o(TU, "composeStories");
function SU(e) {
  return e.extend({
    mount: /* @__PURE__ */ o(async ({ mount: t, page: r }, n) => {
      await n(async (a, ...i) => {
        if (!("__pw_type" in a) || "__pw_type" in a && a.__pw_type !== "jsx")
          throw new Error(ye`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
        const { props: s, ...l } = a;
        await r.evaluate(async (u) => {
          const p = await globalThis.__pwUnwrapObject?.(u);
          return ("__pw_type" in p ? p.type : p)?.load?.();
        }, l);
        const c = await t(a, ...i);
        return await r.evaluate(async (u) => {
          const p = await globalThis.__pwUnwrapObject?.(u), f = "__pw_type" in p ? p.type : p, m = document.querySelector("#root");
          return f?.play?.({ canvasElement: m });
        }, l), c;
      });
    }, "mount")
  });
}
o(SU, "createPlaywrightTest");
async function zR(e, t) {
  for (const i of [...Fr].reverse())
    await i();
  if (Fr.length = 0, !t.canvasElement) {
    const i = document.createElement("div");
    globalThis?.document?.body?.appendChild(i), t.canvasElement = i, Fr.push(() => {
      globalThis?.document?.body?.contains(i) && globalThis?.document?.body?.removeChild(i);
    });
  }
  if (t.loaded = await e.applyLoaders(t), t.abortSignal.aborted)
    return;
  Fr.push(...(await e.applyBeforeEach(t)).filter(Boolean));
  const r = e.playFunction, n = e.usesMount;
  if (n || await t.mount(), t.abortSignal.aborted)
    return;
  r && (n || (t.mount = async () => {
    throw new Xb({ playFunction: r.toString() });
  }), await r(t));
  let a;
  Kd() ? a = Yd() : await Xd(t.abortSignal), await e.applyAfterEach(t), await a?.();
}
o(zR, "runStory");
var Qg = 1e3, PU = 1e4, WR = class {
  constructor(e, t, r) {
    this.importFn = t, this.storyIndex = new uU(e), this.projectAnnotations = $a(
      Cn([...nu(), r])
    );
    const { initialGlobals: n, globalTypes: a } = this.projectAnnotations;
    this.args = new aU(), this.userGlobals = new iU({ globals: n, globalTypes: a }), this.hooks = {}, this.cleanupCallbacks = {}, this.processCSFFileWithCache = (0, zu.default)(Qg)(jR), this.prepareMetaWithCache = (0, zu.default)(Qg)(LR), this.prepareStoryWithCache = (0, zu.default)(PU)(Kh);
  }
  setProjectAnnotations(e) {
    this.projectAnnotations = $a(e);
    const { initialGlobals: t, globalTypes: r } = e;
    this.userGlobals.set({ globals: t, globalTypes: r });
  }
  // This means that one of the CSF files has changed.
  // If the `importFn` has changed, we will invalidate both caches.
  // If the `storyIndex` data has changed, we may or may not invalidate the caches, depending
  // on whether we've loaded the relevant files yet.
  async onStoriesChanged({
    importFn: e,
    storyIndex: t
  }) {
    e && (this.importFn = e), t && (this.storyIndex.entries = t.entries), this.cachedCSFFiles && await this.cacheAllCSFFiles();
  }
  // Get an entry from the index, waiting on initialization if necessary
  async storyIdToEntry(e) {
    return this.storyIndex.storyIdToEntry(e);
  }
  // To load a single CSF file to service a story we need to look up the importPath in the index
  async loadCSFFileByStoryId(e) {
    const { importPath: t, title: r } = this.storyIndex.storyIdToEntry(e), n = await this.importFn(t);
    return this.processCSFFileWithCache(n, t, r);
  }
  async loadAllCSFFiles() {
    const e = {};
    return Object.entries(this.storyIndex.entries).forEach(([t, { importPath: r }]) => {
      e[r] = t;
    }), (await Promise.all(
      Object.entries(e).map(async ([t, r]) => ({
        importPath: t,
        csfFile: await this.loadCSFFileByStoryId(r)
      }))
    )).reduce(
      (t, { importPath: r, csfFile: n }) => (t[r] = n, t),
      {}
    );
  }
  async cacheAllCSFFiles() {
    this.cachedCSFFiles = await this.loadAllCSFFiles();
  }
  preparedMetaFromCSFFile({ csfFile: e }) {
    const t = e.meta;
    return this.prepareMetaWithCache(
      t,
      this.projectAnnotations,
      e.moduleExports.default
    );
  }
  // Load the CSF file for a story and prepare the story from it and the project annotations.
  async loadStory({ storyId: e }) {
    const t = await this.loadCSFFileByStoryId(e);
    return this.storyFromCSFFile({ storyId: e, csfFile: t });
  }
  // This function is synchronous for convenience -- often times if you have a CSF file already
  // it is easier not to have to await `loadStory`.
  storyFromCSFFile({
    storyId: e,
    csfFile: t
  }) {
    const r = t.stories[e];
    if (!r)
      throw new Zk({ storyId: e });
    const n = t.meta, a = this.prepareStoryWithCache(
      r,
      n,
      t.projectAnnotations ?? this.projectAnnotations
    );
    return this.args.setInitial(a), this.hooks[a.id] = this.hooks[a.id] || new ER(), a;
  }
  // If we have a CSF file we can get all the stories from it synchronously
  componentStoriesFromCSFFile({
    csfFile: e
  }) {
    return Object.keys(this.storyIndex.entries).filter((t) => !!e.stories[t]).map((t) => this.storyFromCSFFile({ storyId: t, csfFile: e }));
  }
  async loadEntry(e) {
    const t = await this.storyIdToEntry(e), r = t.type === "docs" ? t.storiesImports : [], [n, ...a] = await Promise.all([
      this.importFn(t.importPath),
      ...r.map((i) => {
        const s = this.storyIndex.importPathToEntry(i);
        return this.loadCSFFileByStoryId(s.id);
      })
    ]);
    return { entryExports: n, csfFiles: a };
  }
  // A prepared story does not include args, globals or hooks. These are stored in the story store
  // and updated separately to the (immutable) story.
  getStoryContext(e, { forceInitialArgs: t = !1 } = {}) {
    const r = this.userGlobals.get(), { initialGlobals: n } = this.userGlobals, a = new HR();
    return Xh({
      ...e,
      args: t ? e.initialArgs : this.args.get(e.id),
      initialGlobals: n,
      globalTypes: this.projectAnnotations.globalTypes,
      userGlobals: r,
      reporting: a,
      globals: {
        ...r,
        ...e.storyGlobals
      },
      hooks: this.hooks[e.id]
    });
  }
  addCleanupCallbacks(e, ...t) {
    this.cleanupCallbacks[e.id] = (this.cleanupCallbacks[e.id] || []).concat(t);
  }
  async cleanupStory(e) {
    this.hooks[e.id].clean();
    const t = this.cleanupCallbacks[e.id];
    if (t)
      for (const r of [...t].reverse())
        await r();
    delete this.cleanupCallbacks[e.id];
  }
  extract(e = { includeDocsOnly: !1 }) {
    const { cachedCSFFiles: t } = this;
    if (console.log("extract: extracting stories", t), !t)
      throw new Wk();
    const r = Object.entries(this.storyIndex.entries).reduce(
      (n, [a, i]) => {
        if (i.type === "docs")
          return n;
        const s = t[i.importPath], l = this.storyFromCSFFile({ storyId: a, csfFile: s });
        return !e.includeDocsOnly && l.parameters.docsOnly || (n[a] = Object.entries(l).reduce(
          (c, [u, p]) => u === "story" && i.subtype === "test" ? { ...c, story: i.parentName } : u === "moduleExport" || typeof p == "function" ? c : Array.isArray(p) ? Object.assign(c, { [u]: p.slice().sort() }) : Object.assign(c, { [u]: p }),
          {
            args: l.initialArgs,
            globals: {
              ...this.userGlobals.initialGlobals,
              ...this.userGlobals.globals,
              ...l.storyGlobals
            },
            storyId: i.parent ? i.parent : a
          }
        )), n;
      },
      {}
    );
    return console.log("extract: stories", r), r;
  }
};
o(WR, "StoryStore");
var OU = WR;
function CU(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
o(CU, "slash");
function AU(e) {
  return e.flatMap((t) => t.split("/")).filter(Boolean).join("/");
}
o(AU, "pathJoin");
var su = new Error("prepareAborted"), { AbortController: Zg } = globalThis;
function Hd(e) {
  try {
    const { name: t = "Error", message: r = String(e), stack: n } = e;
    return { name: t, message: r, stack: n };
  } catch {
    return { name: "Error", message: String(e) };
  }
}
o(Hd, "serializeError");
var GR = class {
  constructor(e, t, r, n, a, i, s = { autoplay: !0, forceInitialArgs: !1 }, l) {
    this.channel = e, this.store = t, this.renderToScreen = r, this.callbacks = n, this.id = a, this.viewMode = i, this.renderOptions = s, this.type = "story", this.notYetRendered = !0, this.rerenderEnqueued = !1, this.disableKeyListeners = !1, this.teardownRender = /* @__PURE__ */ o(() => {
    }, "teardownRender"), this.torndown = !1, this.abortController = new Zg(), this.renderId = Date.now(), l && (this.story = l, this.phase = "preparing");
  }
  async runPhase(e, t, r) {
    this.phase = t, this.channel.emit(vn, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    }), r && (await r(), this.checkIfAborted(e));
  }
  checkIfAborted(e) {
    return e.aborted && !["finished", "aborted", "errored"].includes(this.phase) && (this.phase = "aborted", this.channel.emit(vn, {
      newPhase: this.phase,
      renderId: this.renderId,
      storyId: this.id
    })), e.aborted;
  }
  async prepare() {
    if (await this.runPhase(this.abortController.signal, "preparing", async () => {
      this.story = await this.store.loadStory({ storyId: this.id });
    }), this.abortController.signal.aborted)
      throw await this.store.cleanupStory(this.story), su;
  }
  // The two story "renders" are equal and have both loaded the same story
  isEqual(e) {
    return !!(this.id === e.id && this.story && this.story === e.story);
  }
  isPreparing() {
    return ["preparing"].includes(this.phase);
  }
  isPending() {
    return ["loading", "beforeEach", "rendering", "playing", "afterEach"].includes(
      this.phase
    );
  }
  async renderToElement(e) {
    return this.canvasElement = e, this.render({ initial: !0, forceRemount: !0 });
  }
  storyContext() {
    if (!this.story)
      throw new Error("Cannot call storyContext before preparing");
    const { forceInitialArgs: e } = this.renderOptions;
    return this.store.getStoryContext(this.story, { forceInitialArgs: e });
  }
  async render({
    initial: e = !1,
    forceRemount: t = !1
  } = {}) {
    const { canvasElement: r } = this;
    if (!this.story)
      throw new Error("cannot render when not prepared");
    const n = this.story;
    if (!r)
      throw new Error("cannot render when canvasElement is unset");
    const {
      id: a,
      componentId: i,
      title: s,
      name: l,
      tags: c,
      applyLoaders: u,
      applyBeforeEach: p,
      applyAfterEach: f,
      unboundStoryFn: m,
      playFunction: y,
      runStep: g
    } = n;
    t && !e && (this.cancelRender(), this.abortController = new Zg());
    const v = this.abortController.signal;
    let _ = !1;
    const b = n.usesMount;
    try {
      const E = {
        ...this.storyContext(),
        viewMode: this.viewMode,
        abortSignal: v,
        canvasElement: r,
        loaded: {},
        step: /* @__PURE__ */ o((D, J) => g(D, J, E), "step"),
        context: null,
        canvas: {},
        userEvent: {},
        renderToCanvas: /* @__PURE__ */ o(async () => {
          const D = await this.renderToScreen(C, r);
          this.teardownRender = D || (() => {
          }), _ = !0;
        }, "renderToCanvas"),
        // The story provides (set in a renderer) a mount function that is a higher order function
        // (context) => (...args) => Canvas
        //
        // Before assigning it to the context, we resolve the context dependency,
        // so that a user can just call it as await mount(...args) in their play function.
        mount: /* @__PURE__ */ o(async (...D) => {
          this.callbacks.showStoryDuringRender?.();
          let J = null;
          return await this.runPhase(v, "rendering", async () => {
            J = await n.mount(E)(...D);
          }), b && await this.runPhase(v, "playing"), J;
        }, "mount")
      };
      E.context = E;
      const C = {
        componentId: i,
        title: s,
        kind: s,
        id: a,
        name: l,
        story: l,
        tags: c,
        ...this.callbacks,
        showError: /* @__PURE__ */ o((D) => (this.phase = "errored", this.callbacks.showError(D)), "showError"),
        showException: /* @__PURE__ */ o((D) => (this.phase = "errored", this.callbacks.showException(D)), "showException"),
        forceRemount: t || this.notYetRendered,
        storyContext: E,
        storyFn: /* @__PURE__ */ o(() => m(E), "storyFn"),
        unboundStoryFn: m
      };
      if (await this.runPhase(v, "loading", async () => {
        E.loaded = await u(E);
      }), v.aborted)
        return;
      const k = await p(E);
      if (this.store.addCleanupCallbacks(n, ...k), this.checkIfAborted(v) || (!_ && !b && await E.mount(), this.notYetRendered = !1, v.aborted))
        return;
      const N = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0, O = /* @__PURE__ */ new Set(), S = /* @__PURE__ */ o((D) => {
        D.error && O.add(D.error);
      }, "onError"), w = /* @__PURE__ */ o((D) => {
        D.reason && O.add(D.reason);
      }, "onUnhandledRejection");
      if (this.renderOptions.autoplay && t && y && this.phase !== "errored") {
        window?.addEventListener?.("error", S), window?.addEventListener?.("unhandledrejection", w), this.disableKeyListeners = !0;
        try {
          if (b ? await y(E) : (E.mount = async () => {
            throw new Xb({ playFunction: y.toString() });
          }, await this.runPhase(v, "playing", async () => y(E))), !_)
            throw new r1();
          this.checkIfAborted(v), !N && O.size > 0 ? await this.runPhase(v, "errored") : await this.runPhase(v, "played");
        } catch (D) {
          if (this.callbacks.showStoryDuringRender?.(), await this.runPhase(v, "errored", async () => {
            this.channel.emit(n_, Hd(D));
          }), this.story.parameters.throwPlayFunctionExceptions !== !1)
            throw D;
          console.error(D);
        }
        if (!N && O.size > 0 && this.channel.emit(
          o_,
          Array.from(O).map(Hd)
        ), this.disableKeyListeners = !1, window?.removeEventListener?.("unhandledrejection", w), window?.removeEventListener?.("error", S), v.aborted)
          return;
      }
      await this.runPhase(v, "completing", async () => {
        Kd() ? this.store.addCleanupCallbacks(n, Yd()) : await Xd(v);
      }), await this.runPhase(v, "completed", async () => {
        this.channel.emit(Vi, a);
      }), this.phase !== "errored" && await this.runPhase(v, "afterEach", async () => {
        await f(E);
      });
      const T = !N && O.size > 0, M = E.reporting.reports.some(
        (D) => D.status === "failed"
      ), R = T || M;
      await this.runPhase(
        v,
        "finished",
        async () => this.channel.emit(oc, {
          storyId: a,
          status: R ? "error" : "success",
          reporters: E.reporting.reports
        })
      );
    } catch (E) {
      this.phase = "errored", this.callbacks.showException(E), await this.runPhase(
        v,
        "finished",
        async () => this.channel.emit(oc, {
          storyId: a,
          status: "error",
          reporters: []
        })
      );
    }
    this.rerenderEnqueued && (this.rerenderEnqueued = !1, this.render());
  }
  /**
   * Rerender the story. If the story is currently pending (loading/rendering), the rerender will be
   * enqueued, and will be executed after the current render is completed. Rerendering while playing
   * will not be enqueued, and will be executed immediately, to support rendering args changes while
   * playing.
   */
  async rerender() {
    if (this.isPending() && this.phase !== "playing")
      this.rerenderEnqueued = !0;
    else
      return this.render();
  }
  async remount() {
    return await this.teardown(), this.render({ forceRemount: !0 });
  }
  // If the story is torn down (either a new story is rendered or the docs page removes it)
  // we need to consider the fact that the initial render may not be finished
  // (possibly the loaders or the play function are still running). We use the controller
  // as a method to abort them, ASAP, but this is not foolproof as we cannot control what
  // happens inside the user's code.
  cancelRender() {
    this.abortController.abort();
  }
  cancelPlayFunction() {
    this.phase === "playing" && (this.abortController.abort(), this.runPhase(this.abortController.signal, "aborted"));
  }
  async teardown() {
    this.torndown = !0, this.cancelRender(), this.story && await this.store.cleanupStory(this.story);
    for (let e = 0; e < 3; e += 1) {
      if (!this.isPending()) {
        await this.teardownRender();
        return;
      }
      await new Promise((t) => setTimeout(t, 0));
    }
    window?.location?.reload?.(), await new Promise(() => {
    });
  }
};
o(GR, "StoryRender");
var Vd = GR, { fetch: RU } = ee, kU = "./index.json", KR = class {
  constructor(e, t, r = zt.getChannel(), n = !0) {
    this.importFn = e, this.getProjectAnnotations = t, this.channel = r, this.storyRenders = [], this.storeInitializationPromise = new Promise((a, i) => {
      this.resolveStoreInitializationPromise = a, this.rejectStoreInitializationPromise = i;
    }), n && this.initialize();
  }
  // Create a proxy object for `__STORYBOOK_STORY_STORE__` and `__STORYBOOK_PREVIEW__.storyStore`
  // That proxies through to the store once ready, and errors beforehand. This means we can set
  // `__STORYBOOK_STORY_STORE__ = __STORYBOOK_PREVIEW__.storyStore` without having to wait, and
  // similarly integrators can access the `storyStore` on the preview at any time, although
  // it is considered deprecated and we will no longer allow access in 9.0
  get storyStore() {
    return new Proxy(
      {},
      {
        get: /* @__PURE__ */ o((e, t) => {
          if (this.storyStoreValue)
            return Zw("Accessing the Story Store is deprecated and will be removed in 9.0"), this.storyStoreValue[t];
          throw new e1();
        }, "get")
      }
    );
  }
  // INITIALIZATION
  async initialize() {
    this.setupListeners();
    try {
      const e = await this.getProjectAnnotationsOrRenderError();
      await this.runBeforeAllHook(e), await this.initializeWithProjectAnnotations(e);
      const t = globalThis?.navigator?.userAgent;
      await this.channel.emit(i_, { userAgent: t });
    } catch (e) {
      this.rejectStoreInitializationPromise(e);
    }
  }
  ready() {
    return this.storeInitializationPromise;
  }
  setupListeners() {
    this.channel.on(p_, this.onStoryIndexChanged.bind(this)), this.channel.on(Cp, this.onUpdateGlobals.bind(this)), this.channel.on(Ap, this.onUpdateArgs.bind(this)), this.channel.on(v_, this.onRequestArgTypesInfo.bind(this)), this.channel.on(Pp, this.onResetArgs.bind(this)), this.channel.on(Sp, this.onForceReRender.bind(this)), this.channel.on(Hi, this.onForceRemount.bind(this)), this.channel.on(g_, this.onStoryHotUpdated.bind(this));
  }
  async getProjectAnnotationsOrRenderError() {
    try {
      const e = await this.getProjectAnnotations();
      if (this.renderToCanvas = e.renderToCanvas, !this.renderToCanvas)
        throw new Gk();
      return e;
    } catch (e) {
      throw this.renderPreviewEntryError("Error reading preview.js:", e), e;
    }
  }
  // If initialization gets as far as project annotations, this function runs.
  async initializeWithProjectAnnotations(e) {
    this.projectAnnotationsBeforeInitialization = e;
    try {
      const t = await this.getStoryIndexFromServer();
      return this.initializeWithStoryIndex(t);
    } catch (t) {
      throw this.renderPreviewEntryError("Error loading story index:", t), t;
    }
  }
  async runBeforeAllHook(e) {
    try {
      await this.beforeAllCleanup?.(), this.beforeAllCleanup = await e.beforeAll?.();
    } catch (t) {
      throw this.renderPreviewEntryError("Error in beforeAll hook:", t), t;
    }
  }
  async getStoryIndexFromServer() {
    const e = await RU(kU);
    if (e.status === 200)
      return e.json();
    throw new Kk({ text: await e.text() });
  }
  // If initialization gets as far as the story index, this function runs.
  initializeWithStoryIndex(e) {
    if (!this.projectAnnotationsBeforeInitialization)
      throw new Error("Cannot call initializeWithStoryIndex until project annotations resolve");
    this.storyStoreValue = new OU(
      e,
      this.importFn,
      this.projectAnnotationsBeforeInitialization
    ), delete this.projectAnnotationsBeforeInitialization, this.setInitialGlobals(), this.resolveStoreInitializationPromise();
  }
  async setInitialGlobals() {
    this.emitGlobals();
  }
  emitGlobals() {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "emitGlobals" });
    const e = {
      globals: this.storyStoreValue.userGlobals.get() || {},
      globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
    };
    this.channel.emit(l_, e);
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e
  }) {
    delete this.previewEntryError, this.getProjectAnnotations = e;
    const t = await this.getProjectAnnotationsOrRenderError();
    if (await this.runBeforeAllHook(t), !this.storyStoreValue) {
      await this.initializeWithProjectAnnotations(t);
      return;
    }
    this.storyStoreValue.setProjectAnnotations(t), this.emitGlobals();
  }
  async onStoryIndexChanged() {
    if (delete this.previewEntryError, !(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
      try {
        const e = await this.getStoryIndexFromServer();
        if (this.projectAnnotationsBeforeInitialization) {
          this.initializeWithStoryIndex(e);
          return;
        }
        await this.onStoriesChanged({ storyIndex: e });
      } catch (e) {
        throw this.renderPreviewEntryError("Error loading story index:", e), e;
      }
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e,
    storyIndex: t
  }) {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "onStoriesChanged" });
    await this.storyStoreValue.onStoriesChanged({ importFn: e, storyIndex: t });
  }
  async onUpdateGlobals({
    globals: e,
    currentStory: t
  }) {
    if (this.storyStoreValue || await this.storeInitializationPromise, !this.storyStoreValue)
      throw new kt({ methodName: "onUpdateGlobals" });
    if (this.storyStoreValue.userGlobals.update(e), t) {
      const { initialGlobals: r, storyGlobals: n, userGlobals: a, globals: i } = this.storyStoreValue.getStoryContext(t);
      this.channel.emit(ga, {
        initialGlobals: r,
        userGlobals: a,
        storyGlobals: n,
        globals: i
      });
    } else {
      const { initialGlobals: r, globals: n } = this.storyStoreValue.userGlobals;
      this.channel.emit(ga, {
        initialGlobals: r,
        userGlobals: n,
        storyGlobals: {},
        globals: n
      });
    }
    await Promise.all(this.storyRenders.map((r) => r.rerender()));
  }
  async onUpdateArgs({ storyId: e, updatedArgs: t }) {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "onUpdateArgs" });
    this.storyStoreValue.args.update(e, t), await Promise.all(
      this.storyRenders.filter((r) => r.id === e && !r.renderOptions.forceInitialArgs).map(
        (r) => (
          // We only run the play function, with in a force remount.
          // But when mount is destructured, the rendering happens inside of the play function.
          r.story && r.story.usesMount ? r.remount() : r.rerender()
        )
      )
    ), this.channel.emit(u_, {
      storyId: e,
      args: this.storyStoreValue.args.get(e)
    });
  }
  async onRequestArgTypesInfo({ id: e, payload: t }) {
    try {
      await this.storeInitializationPromise;
      const r = await this.storyStoreValue?.loadStory(t);
      this.channel.emit(ac, {
        id: e,
        success: !0,
        payload: { argTypes: r?.argTypes || {} },
        error: null
      });
    } catch (r) {
      this.channel.emit(ac, {
        id: e,
        success: !1,
        error: r?.message
      });
    }
  }
  async onResetArgs({ storyId: e, argNames: t }) {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "onResetArgs" });
    const r = this.storyRenders.find((a) => a.id === e)?.story || await this.storyStoreValue.loadStory({ storyId: e }), n = (t || [
      .../* @__PURE__ */ new Set([
        ...Object.keys(r.initialArgs),
        ...Object.keys(this.storyStoreValue.args.get(e))
      ])
    ]).reduce((a, i) => (a[i] = r.initialArgs[i], a), {});
    await this.onUpdateArgs({ storyId: e, updatedArgs: n });
  }
  // ForceReRender does not include a story id, so we simply must
  // re-render all stories in case they are relevant
  async onForceReRender() {
    await Promise.all(this.storyRenders.map((e) => e.rerender()));
  }
  async onForceRemount({ storyId: e }) {
    await Promise.all(this.storyRenders.filter((t) => t.id === e).map((t) => t.remount()));
  }
  async onStoryHotUpdated() {
    await Promise.all(this.storyRenders.map((e) => e.cancelPlayFunction()));
  }
  // Used by docs to render a story to a given element
  // Note this short-circuits the `prepare()` phase of the StoryRender,
  // main to be consistent with the previous behaviour. In the future,
  // we will change it to go ahead and load the story, which will end up being
  // "instant", although async.
  renderStoryToElement(e, t, r, n) {
    if (!this.renderToCanvas || !this.storyStoreValue)
      throw new kt({
        methodName: "renderStoryToElement"
      });
    const a = new Vd(
      this.channel,
      this.storyStoreValue,
      this.renderToCanvas,
      r,
      e.id,
      "docs",
      n,
      e
    );
    return a.renderToElement(t), this.storyRenders.push(a), async () => {
      await this.teardownRender(a);
    };
  }
  async teardownRender(e, { viewModeChanged: t } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== e), await e?.teardown?.({ viewModeChanged: t });
  }
  // API
  async loadStory({ storyId: e }) {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "loadStory" });
    return this.storyStoreValue.loadStory({ storyId: e });
  }
  getStoryContext(e, { forceInitialArgs: t = !1 } = {}) {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "getStoryContext" });
    return this.storyStoreValue.getStoryContext(e, { forceInitialArgs: t });
  }
  async extract(e) {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "extract" });
    if (this.previewEntryError)
      throw this.previewEntryError;
    return await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(e);
  }
  // UTILITIES
  renderPreviewEntryError(e, t) {
    this.previewEntryError = t, qe.error(e), qe.error(t), this.channel.emit(t_, t);
  }
};
o(KR, "Preview");
var IU = KR, YR = class {
  constructor(e, t, r, n) {
    this.channel = e, this.store = t, this.renderStoryToElement = r, this.storyIdByName = /* @__PURE__ */ o((a) => {
      const i = this.nameToStoryId.get(a);
      if (i)
        return i;
      throw new Error(`No story found with that name: ${a}`);
    }, "storyIdByName"), this.componentStories = /* @__PURE__ */ o(() => this.componentStoriesValue, "componentStories"), this.componentStoriesFromCSFFile = /* @__PURE__ */ o((a) => this.store.componentStoriesFromCSFFile({ csfFile: a }), "componentStoriesFromCSFFile"), this.storyById = /* @__PURE__ */ o((a) => {
      if (!a) {
        if (!this.primaryStory)
          throw new Error(
            "No primary story defined for docs entry. Did you forget to use `<Meta>`?"
          );
        return this.primaryStory;
      }
      const i = this.storyIdToCSFFile.get(a);
      if (!i)
        throw new Error(`Called \`storyById\` for story that was never loaded: ${a}`);
      return this.store.storyFromCSFFile({ storyId: a, csfFile: i });
    }, "storyById"), this.getStoryContext = /* @__PURE__ */ o((a) => ({
      ...this.store.getStoryContext(a),
      loaded: {},
      viewMode: "docs"
    }), "getStoryContext"), this.loadStory = /* @__PURE__ */ o((a) => this.store.loadStory({ storyId: a }), "loadStory"), this.componentStoriesValue = [], this.storyIdToCSFFile = /* @__PURE__ */ new Map(), this.exportToStory = /* @__PURE__ */ new Map(), this.exportsToCSFFile = /* @__PURE__ */ new Map(), this.nameToStoryId = /* @__PURE__ */ new Map(), this.attachedCSFFiles = /* @__PURE__ */ new Set(), n.forEach((a, i) => {
      this.referenceCSFFile(a);
    });
  }
  // This docs entry references this CSF file and can synchronously load the stories, as well
  // as reference them by module export. If the CSF is part of the "component" stories, they
  // can also be referenced by name and are in the componentStories list.
  referenceCSFFile(e) {
    this.exportsToCSFFile.set(e.moduleExports, e), this.exportsToCSFFile.set(e.moduleExports.default, e), this.store.componentStoriesFromCSFFile({ csfFile: e }).forEach((t) => {
      const r = e.stories[t.id];
      this.storyIdToCSFFile.set(r.id, e), this.exportToStory.set(r.moduleExport, t);
    });
  }
  attachCSFFile(e) {
    if (!this.exportsToCSFFile.has(e.moduleExports))
      throw new Error("Cannot attach a CSF file that has not been referenced");
    this.attachedCSFFiles.has(e) || (this.attachedCSFFiles.add(e), this.store.componentStoriesFromCSFFile({ csfFile: e }).forEach((t) => {
      this.nameToStoryId.set(t.name, t.id), this.componentStoriesValue.push(t), this.primaryStory || (this.primaryStory = t);
    }));
  }
  referenceMeta(e, t) {
    const r = this.resolveModuleExport(e);
    if (r.type !== "meta")
      throw new Error(
        "<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?"
      );
    t && this.attachCSFFile(r.csfFile);
  }
  get projectAnnotations() {
    const { projectAnnotations: e } = this.store;
    if (!e)
      throw new Error("Can't get projectAnnotations from DocsContext before they are initialized");
    return e;
  }
  resolveAttachedModuleExportType(e) {
    if (e === "story") {
      if (!this.primaryStory)
        throw new Error(
          "No primary story attached to this docs file, did you forget to use <Meta of={} />?"
        );
      return { type: "story", story: this.primaryStory };
    }
    if (this.attachedCSFFiles.size === 0)
      throw new Error(
        "No CSF file attached to this docs file, did you forget to use <Meta of={} />?"
      );
    const t = Array.from(this.attachedCSFFiles)[0];
    if (e === "meta")
      return { type: "meta", csfFile: t };
    const { component: r } = t.meta;
    if (!r)
      throw new Error(
        "Attached CSF file does not defined a component, did you forget to export one?"
      );
    return { type: "component", component: r };
  }
  resolveModuleExport(e) {
    const t = this.exportsToCSFFile.get(e);
    if (t)
      return { type: "meta", csfFile: t };
    const r = this.exportToStory.get(
      ou(e) ? e.input : e
    );
    return r ? { type: "story", story: r } : { type: "component", component: e };
  }
  resolveOf(e, t = []) {
    let r;
    if (["component", "meta", "story"].includes(e)) {
      const n = e;
      r = this.resolveAttachedModuleExportType(n);
    } else
      r = this.resolveModuleExport(e);
    if (t.length && !t.includes(r.type)) {
      const n = r.type === "component" ? "component or unknown" : r.type;
      throw new Error(ye`Invalid value passed to the 'of' prop. The value was resolved to a '${n}' type but the only types for this block are: ${t.join(
        ", "
      )}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
    }
    switch (r.type) {
      case "component":
        return {
          ...r,
          projectAnnotations: this.projectAnnotations
        };
      case "meta":
        return {
          ...r,
          preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: r.csfFile })
        };
      case "story":
      default:
        return r;
    }
  }
};
o(YR, "DocsContext");
var XR = YR, QR = class {
  constructor(e, t, r, n) {
    this.channel = e, this.store = t, this.entry = r, this.callbacks = n, this.type = "docs", this.subtype = "csf", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = r.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    const { entryExports: e, csfFiles: t = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw su;
    const { importPath: r, title: n } = this.entry, a = this.store.processCSFFileWithCache(
      e,
      r,
      n
    ), i = Object.keys(a.stories)[0];
    this.story = this.store.storyFromCSFFile({ storyId: i, csfFile: a }), this.csfFiles = [a, ...t], this.preparing = !1;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.story && this.story === e.story);
  }
  docsContext(e) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    const t = new XR(
      this.channel,
      this.store,
      e,
      this.csfFiles
    );
    return this.csfFiles.forEach((r) => t.attachCSFFile(r)), t;
  }
  async renderToElement(e, t) {
    if (!this.story || !this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    const r = this.docsContext(t), { docs: n } = this.story.parameters || {};
    if (!n)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    const a = await n.renderer(), { render: i } = a, s = /* @__PURE__ */ o(async () => {
      try {
        await i(r, n, e), this.channel.emit(Tp, this.id);
      } catch (l) {
        this.callbacks.showException(l);
      }
    }, "renderDocs");
    return this.rerender = async () => s(), this.teardownRender = async ({ viewModeChanged: l }) => {
      !l || !e || a.unmount(e);
    }, s();
  }
  async teardown({ viewModeChanged: e } = {}) {
    this.teardownRender?.({ viewModeChanged: e }), this.torndown = !0;
  }
};
o(QR, "CsfDocsRender");
var eb = QR, ZR = class {
  constructor(e, t, r, n) {
    this.channel = e, this.store = t, this.entry = r, this.callbacks = n, this.type = "docs", this.subtype = "mdx", this.torndown = !1, this.disableKeyListeners = !1, this.preparing = !1, this.id = r.id, this.renderId = Date.now();
  }
  isPreparing() {
    return this.preparing;
  }
  async prepare() {
    this.preparing = !0;
    const { entryExports: e, csfFiles: t = [] } = await this.store.loadEntry(this.id);
    if (this.torndown)
      throw su;
    this.csfFiles = t, this.exports = e, this.preparing = !1;
  }
  isEqual(e) {
    return !!(this.id === e.id && this.exports && this.exports === e.exports);
  }
  docsContext(e) {
    if (!this.csfFiles)
      throw new Error("Cannot render docs before preparing");
    return new XR(
      this.channel,
      this.store,
      e,
      this.csfFiles
    );
  }
  async renderToElement(e, t) {
    if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
      throw new Error("Cannot render docs before preparing");
    const r = this.docsContext(t), { docs: n } = this.store.projectAnnotations.parameters ?? {};
    if (!n)
      throw new Error(
        "Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed"
      );
    const a = { ...n, page: this.exports.default }, i = await n.renderer(), { render: s } = i, l = /* @__PURE__ */ o(async () => {
      try {
        await s(r, a, e), this.channel.emit(Tp, this.id);
      } catch (c) {
        this.callbacks.showException(c);
      }
    }, "renderDocs");
    return this.rerender = async () => l(), this.teardownRender = async ({ viewModeChanged: c } = {}) => {
      !c || !e || (i.unmount(e), this.torndown = !0);
    }, l();
  }
  async teardown({ viewModeChanged: e } = {}) {
    this.teardownRender?.({ viewModeChanged: e }), this.torndown = !0;
  }
};
o(ZR, "MdxDocsRender");
var tb = ZR, jU = globalThis;
function ek(e) {
  const t = e.composedPath && e.composedPath()[0] || e.target;
  return /input|textarea/i.test(t.tagName) || t.getAttribute("contenteditable") !== null;
}
o(ek, "focusInInput");
var tk = "attached-mdx", NU = "unattached-mdx";
function rk({ tags: e }) {
  return e?.includes(NU) || e?.includes(tk);
}
o(rk, "isMdxEntry");
function $i(e) {
  return e.type === "story";
}
o($i, "isStoryRender");
function nk(e) {
  return e.type === "docs";
}
o(nk, "isDocsRender");
function ok(e) {
  return nk(e) && e.subtype === "csf";
}
o(ok, "isCsfDocsRender");
var ak = class extends IU {
  constructor(e, t, r, n) {
    super(e, t, void 0, !1), this.importFn = e, this.getProjectAnnotations = t, this.selectionStore = r, this.view = n, this.initialize();
  }
  setupListeners() {
    super.setupListeners(), jU.onkeydown = this.onKeydown.bind(this), this.channel.on(Op, this.onSetCurrentStory.bind(this)), this.channel.on(b_, this.onUpdateQueryParams.bind(this)), this.channel.on(a_, this.onPreloadStories.bind(this));
  }
  async setInitialGlobals() {
    if (!this.storyStoreValue)
      throw new kt({ methodName: "setInitialGlobals" });
    const { globals: e } = this.selectionStore.selectionSpecifier || {};
    e && this.storyStoreValue.userGlobals.updateFromPersisted(e), this.emitGlobals();
  }
  // If initialization gets as far as the story index, this function runs.
  async initializeWithStoryIndex(e) {
    return await super.initializeWithStoryIndex(e), this.selectSpecifiedStory();
  }
  // Use the selection specifier to choose a story, then render it
  async selectSpecifiedStory() {
    if (!this.storyStoreValue)
      throw new kt({
        methodName: "selectSpecifiedStory"
      });
    if (this.selectionStore.selection) {
      await this.renderSelection();
      return;
    }
    if (!this.selectionStore.selectionSpecifier) {
      this.renderMissingStory();
      return;
    }
    const { storySpecifier: e, args: t } = this.selectionStore.selectionSpecifier, r = this.storyStoreValue.storyIndex.entryFromSpecifier(e);
    if (!r) {
      e === "*" ? this.renderStoryLoadingException(e, new Xk()) : this.renderStoryLoadingException(
        e,
        new Qk({ storySpecifier: e.toString() })
      );
      return;
    }
    const { id: n, type: a } = r;
    this.selectionStore.setSelection({ storyId: n, viewMode: a }), this.channel.emit(m_, this.selectionStore.selection), this.channel.emit(rc, this.selectionStore.selection), await this.renderSelection({ persistedArgs: t });
  }
  // EVENT HANDLERS
  // This happens when a config file gets reloaded
  async onGetProjectAnnotationsChanged({
    getProjectAnnotations: e
  }) {
    await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: e }), this.selectionStore.selection && this.renderSelection();
  }
  // This happens when a glob gets HMR-ed
  async onStoriesChanged({
    importFn: e,
    storyIndex: t
  }) {
    await super.onStoriesChanged({ importFn: e, storyIndex: t }), this.selectionStore.selection ? await this.renderSelection() : await this.selectSpecifiedStory();
  }
  onKeydown(e) {
    if (!this.storyRenders.find((t) => t.disableKeyListeners) && !ek(e)) {
      const { altKey: t, ctrlKey: r, metaKey: n, shiftKey: a, key: i, code: s, keyCode: l } = e;
      this.channel.emit(s_, {
        event: { altKey: t, ctrlKey: r, metaKey: n, shiftKey: a, key: i, code: s, keyCode: l }
      });
    }
  }
  async onSetCurrentStory(e) {
    this.selectionStore.setSelection({ viewMode: "story", ...e }), await this.storeInitializationPromise, this.channel.emit(rc, this.selectionStore.selection), this.renderSelection();
  }
  onUpdateQueryParams(e) {
    this.selectionStore.setQueryParams(e);
  }
  async onUpdateGlobals({ globals: e }) {
    const t = this.currentRender instanceof Vd && this.currentRender.story || void 0;
    super.onUpdateGlobals({ globals: e, currentStory: t }), (this.currentRender instanceof tb || this.currentRender instanceof eb) && await this.currentRender.rerender?.();
  }
  async onUpdateArgs({ storyId: e, updatedArgs: t }) {
    super.onUpdateArgs({ storyId: e, updatedArgs: t });
  }
  async onPreloadStories({ ids: e }) {
    await this.storeInitializationPromise, this.storyStoreValue && await Promise.allSettled(e.map((t) => this.storyStoreValue?.loadEntry(t)));
  }
  // RENDERING
  // We can either have:
  // - a story selected in "story" viewMode,
  //     in which case we render it to the root element, OR
  // - a story selected in "docs" viewMode,
  //     in which case we render the docsPage for that story
  async renderSelection({ persistedArgs: e } = {}) {
    const { renderToCanvas: t } = this;
    if (!this.storyStoreValue || !t)
      throw new kt({ methodName: "renderSelection" });
    const { selection: r } = this.selectionStore;
    if (!r)
      throw new Error("Cannot call renderSelection as no selection was made");
    const { storyId: n } = r;
    let a;
    try {
      a = await this.storyStoreValue.storyIdToEntry(n);
    } catch (f) {
      this.currentRender && await this.teardownRender(this.currentRender), this.renderStoryLoadingException(n, f);
      return;
    }
    const i = this.currentSelection?.storyId !== n, s = this.currentRender?.type !== a.type;
    a.type === "story" ? this.view.showPreparingStory({ immediate: s }) : this.view.showPreparingDocs({ immediate: s }), this.currentRender?.isPreparing() && await this.teardownRender(this.currentRender);
    let l;
    a.type === "story" ? l = new Vd(
      this.channel,
      this.storyStoreValue,
      t,
      this.mainStoryCallbacks(n),
      n,
      "story"
    ) : rk(a) ? l = new tb(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(n)
    ) : l = new eb(
      this.channel,
      this.storyStoreValue,
      a,
      this.mainStoryCallbacks(n)
    );
    const c = this.currentSelection;
    this.currentSelection = r;
    const u = this.currentRender;
    this.currentRender = l;
    try {
      await l.prepare();
    } catch (f) {
      u && await this.teardownRender(u), f !== su && this.renderStoryLoadingException(n, f);
      return;
    }
    const p = !i && u && !l.isEqual(u);
    if (e && $i(l) && (nr(!!l.story), this.storyStoreValue.args.updateFromPersisted(l.story, e)), u && !u.torndown && !i && !p && !s) {
      this.currentRender = u, this.channel.emit(y_, n), this.view.showMain();
      return;
    }
    if (u && await this.teardownRender(u, { viewModeChanged: s }), c && (i || s) && this.channel.emit(c_, n), $i(l)) {
      nr(!!l.story);
      const {
        parameters: f,
        initialArgs: m,
        argTypes: y,
        unmappedArgs: g,
        initialGlobals: v,
        userGlobals: _,
        storyGlobals: b,
        globals: E
      } = this.storyStoreValue.getStoryContext(l.story);
      this.channel.emit(f_, {
        id: n,
        parameters: f,
        initialArgs: m,
        argTypes: y,
        args: g
      }), this.channel.emit(ga, { userGlobals: _, storyGlobals: b, globals: E, initialGlobals: v });
    } else {
      let { parameters: f } = this.storyStoreValue.projectAnnotations;
      const { initialGlobals: m, globals: y } = this.storyStoreValue.userGlobals;
      if (this.channel.emit(ga, {
        globals: y,
        initialGlobals: m,
        storyGlobals: {},
        userGlobals: y
      }), ok(l) || l.entry.tags?.includes(tk)) {
        if (!l.csfFiles)
          throw new Yk({ storyId: n });
        ({ parameters: f } = this.storyStoreValue.preparedMetaFromCSFFile({
          csfFile: l.csfFiles[0]
        }));
      }
      this.channel.emit(r_, {
        id: n,
        parameters: f
      });
    }
    $i(l) ? (nr(!!l.story), this.storyRenders.push(l), this.currentRender.renderToElement(
      this.view.prepareForStory(l.story)
    )) : this.currentRender.renderToElement(
      this.view.prepareForDocs(),
      // This argument is used for docs, which is currently only compatible with HTMLElements
      this.renderStoryToElement.bind(this)
    );
  }
  async teardownRender(e, { viewModeChanged: t = !1 } = {}) {
    this.storyRenders = this.storyRenders.filter((r) => r !== e), await e?.teardown?.({ viewModeChanged: t });
  }
  // UTILITIES
  mainStoryCallbacks(e) {
    return {
      showStoryDuringRender: /* @__PURE__ */ o(() => this.view.showStoryDuringRender(), "showStoryDuringRender"),
      showMain: /* @__PURE__ */ o(() => this.view.showMain(), "showMain"),
      showError: /* @__PURE__ */ o((t) => this.renderError(e, t), "showError"),
      showException: /* @__PURE__ */ o((t) => this.renderException(e, t), "showException")
    };
  }
  renderPreviewEntryError(e, t) {
    super.renderPreviewEntryError(e, t), this.view.showErrorDisplay(t);
  }
  renderMissingStory() {
    this.view.showNoPreview(), this.channel.emit(nc);
  }
  renderStoryLoadingException(e, t) {
    qe.error(t), this.view.showErrorDisplay(t), this.channel.emit(nc, e);
  }
  // renderException is used if we fail to render the story and it is uncaught by the app layer
  renderException(e, t) {
    const { name: r = "Error", message: n = String(t), stack: a } = t, i = this.currentRender?.renderId;
    this.channel.emit(h_, { name: r, message: n, stack: a }), this.channel.emit(vn, { newPhase: "errored", renderId: i, storyId: e }), this.view.showErrorDisplay(t), qe.error(`Error rendering story '${e}':`), qe.error(t);
  }
  // renderError is used by the various app layers to inform the user they have done something
  // wrong -- for instance returned the wrong thing from a story
  renderError(e, { title: t, description: r }) {
    const n = this.currentRender?.renderId;
    this.channel.emit(d_, { title: t, description: r }), this.channel.emit(vn, { newPhase: "errored", renderId: n, storyId: e }), this.view.showErrorDisplay({ message: t, stack: r }), qe.error(`Error rendering story ${t}: ${r}`);
  }
};
o(ak, "PreviewWithSelection");
var qU = ak, Jd = Ye(ep(), 1), MU = Ye(ep(), 1), rb = /^[a-zA-Z0-9 _-]*$/, ik = /^-?[0-9]+(\.[0-9]+)?$/, $U = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i, sk = /^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i, zd = /* @__PURE__ */ o((e = "", t) => e === null || e === "" || !rb.test(e) ? !1 : t == null || t instanceof Date || typeof t == "number" || typeof t == "boolean" ? !0 : typeof t == "string" ? rb.test(t) || ik.test(t) || $U.test(t) || sk.test(t) : Array.isArray(t) ? t.every((r) => zd(e, r)) : _t(t) ? Object.entries(t).every(([r, n]) => zd(r, n)) : !1, "validateArgs"), LU = {
  delimiter: ";",
  // we're parsing a single query param
  nesting: !0,
  arrayRepeat: !0,
  arrayRepeatSyntax: "bracket",
  nestingSyntax: "js",
  // objects are encoded using dot notation
  valueDeserializer(e) {
    if (e.startsWith("!")) {
      if (e === "!undefined")
        return;
      if (e === "!null")
        return null;
      if (e === "!true")
        return !0;
      if (e === "!false")
        return !1;
      if (e.startsWith("!date(") && e.endsWith(")"))
        return new Date(e.replaceAll(" ", "+").slice(6, -1));
      if (e.startsWith("!hex(") && e.endsWith(")"))
        return `#${e.slice(5, -1)}`;
      const t = e.slice(1).match(sk);
      if (t)
        return e.startsWith("!rgba") || e.startsWith("!RGBA") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})` : e.startsWith("!hsla") || e.startsWith("!HSLA") ? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})` : e.startsWith("!rgb") || e.startsWith("!RGB") ? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})` : `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
    }
    return ik.test(e) ? Number(e) : e;
  }
}, nb = /* @__PURE__ */ o((e) => {
  const t = e.split(";").map((r) => r.replace("=", "~").replace(":", "="));
  return Object.entries((0, MU.parse)(t.join(";"), LU)).reduce((r, [n, a]) => zd(n, a) ? Object.assign(r, { [n]: a }) : (Ue.warn(ye`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `), r), {});
}, "parseArgsParam"), { history: lk, document: zr } = ee;
function uk(e) {
  const t = (e || "").match(/^\/story\/(.+)/);
  if (!t)
    throw new Error(`Invalid path '${e}',  must start with '/story/'`);
  return t[1];
}
o(uk, "pathToId");
var ck = /* @__PURE__ */ o(({
  selection: e,
  extraParams: t
}) => {
  const r = zr?.location.search.slice(1), { path: n, selectedKind: a, selectedStory: i, ...s } = (0, Jd.parse)(r);
  return `?${(0, Jd.stringify)({
    ...s,
    ...t,
    ...e && { id: e.storyId, viewMode: e.viewMode }
  })}`;
}, "getQueryString"), DU = /* @__PURE__ */ o((e) => {
  if (!e)
    return;
  const t = ck({ selection: e }), { hash: r = "" } = zr.location;
  zr.title = e.storyId, lk.replaceState({}, "", `${zr.location.pathname}${t}${r}`);
}, "setPath"), FU = /* @__PURE__ */ o((e) => e != null && typeof e == "object" && Array.isArray(e) === !1, "isObject"), ma = /* @__PURE__ */ o((e) => {
  if (e !== void 0) {
    if (typeof e == "string")
      return e;
    if (Array.isArray(e))
      return ma(e[0]);
    if (FU(e))
      return ma(
        Object.values(e).filter(Boolean)
      );
  }
}, "getFirstString"), BU = /* @__PURE__ */ o(() => {
  if (typeof zr < "u") {
    const e = zr.location.search.slice(1), t = (0, Jd.parse)(e), r = typeof t.args == "string" ? nb(t.args) : void 0, n = typeof t.globals == "string" ? nb(t.globals) : void 0;
    let a = ma(t.viewMode);
    (typeof a != "string" || !a.match(/docs|story/)) && (a = "story");
    const i = ma(t.path), s = i ? uk(i) : ma(t.id);
    if (s)
      return { storySpecifier: s, args: r, globals: n, viewMode: a };
  }
  return null;
}, "getSelectionSpecifierFromPath"), dk = class {
  constructor() {
    this.selectionSpecifier = BU();
  }
  setSelection(e) {
    this.selection = e, DU(this.selection);
  }
  setQueryParams(e) {
    const t = ck({ extraParams: e }), { hash: r = "" } = zr.location;
    lk.replaceState({}, "", `${zr.location.pathname}${t}${r}`);
  }
};
o(dk, "UrlStore");
var UU = dk, HU = Ye(F1(), 1), VU = Ye(ep(), 1), { document: ot } = ee, ob = 100, pk = /* @__PURE__ */ ((e) => (e.MAIN = "MAIN", e.NOPREVIEW = "NOPREVIEW", e.PREPARING_STORY = "PREPARING_STORY", e.PREPARING_DOCS = "PREPARING_DOCS", e.ERROR = "ERROR", e))(pk || {}), Wu = {
  PREPARING_STORY: "sb-show-preparing-story",
  PREPARING_DOCS: "sb-show-preparing-docs",
  MAIN: "sb-show-main",
  NOPREVIEW: "sb-show-nopreview",
  ERROR: "sb-show-errordisplay"
}, Gu = {
  centered: "sb-main-centered",
  fullscreen: "sb-main-fullscreen",
  padded: "sb-main-padded"
}, ab = new HU.default({
  escapeXML: !0
}), fk = class {
  constructor() {
    if (this.testing = !1, typeof ot < "u") {
      const { __SPECIAL_TEST_PARAMETER__: e } = (0, VU.parse)(ot.location.search.slice(1));
      switch (e) {
        case "preparing-story": {
          this.showPreparingStory(), this.testing = !0;
          break;
        }
        case "preparing-docs": {
          this.showPreparingDocs(), this.testing = !0;
          break;
        }
      }
    }
  }
  // Get ready to render a story, returning the element to render to
  prepareForStory(e) {
    return this.showStory(), this.applyLayout(e.parameters.layout), ot.documentElement.scrollTop = 0, ot.documentElement.scrollLeft = 0, this.storyRoot();
  }
  storyRoot() {
    return ot.getElementById("storybook-root");
  }
  prepareForDocs() {
    return this.showMain(), this.showDocs(), this.applyLayout("fullscreen"), ot.documentElement.scrollTop = 0, ot.documentElement.scrollLeft = 0, this.docsRoot();
  }
  docsRoot() {
    return ot.getElementById("storybook-docs");
  }
  applyLayout(e = "padded") {
    if (e === "none") {
      ot.body.classList.remove(this.currentLayoutClass), this.currentLayoutClass = null;
      return;
    }
    this.checkIfLayoutExists(e);
    const t = Gu[e];
    ot.body.classList.remove(this.currentLayoutClass), ot.body.classList.add(t), this.currentLayoutClass = t;
  }
  checkIfLayoutExists(e) {
    Gu[e] || qe.warn(
      ye`
          The desired layout: ${e} is not a valid option.
          The possible options are: ${Object.keys(Gu).join(", ")}, none.
        `
    );
  }
  showMode(e) {
    clearTimeout(this.preparingTimeout), Object.keys(pk).forEach((t) => {
      t === e ? ot.body.classList.add(Wu[t]) : ot.body.classList.remove(Wu[t]);
    });
  }
  showErrorDisplay({ message: e = "", stack: t = "" }) {
    let r = e, n = t;
    const a = e.split(`
`);
    a.length > 1 && ([r] = a, n = a.slice(1).join(`
`).replace(/^\n/, "")), ot.getElementById("error-message").innerHTML = ab.toHtml(r), ot.getElementById("error-stack").innerHTML = ab.toHtml(n), this.showMode(
      "ERROR"
      /* ERROR */
    );
  }
  showNoPreview() {
    this.testing || (this.showMode(
      "NOPREVIEW"
      /* NOPREVIEW */
    ), this.storyRoot()?.setAttribute("hidden", "true"), this.docsRoot()?.setAttribute("hidden", "true"));
  }
  showPreparingStory({ immediate: e = !1 } = {}) {
    clearTimeout(this.preparingTimeout), e ? this.showMode(
      "PREPARING_STORY"
      /* PREPARING_STORY */
    ) : this.preparingTimeout = setTimeout(
      () => this.showMode(
        "PREPARING_STORY"
        /* PREPARING_STORY */
      ),
      ob
    );
  }
  showPreparingDocs({ immediate: e = !1 } = {}) {
    clearTimeout(this.preparingTimeout), e ? this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ) : this.preparingTimeout = setTimeout(() => this.showMode(
      "PREPARING_DOCS"
      /* PREPARING_DOCS */
    ), ob);
  }
  showMain() {
    this.showMode(
      "MAIN"
      /* MAIN */
    );
  }
  showDocs() {
    this.storyRoot().setAttribute("hidden", "true"), this.docsRoot().removeAttribute("hidden");
  }
  showStory() {
    this.docsRoot().setAttribute("hidden", "true"), this.storyRoot().removeAttribute("hidden");
  }
  showStoryDuringRender() {
    ot.body.classList.add(Wu.MAIN);
  }
};
o(fk, "WebView");
var JU = fk, zU = class extends qU {
  constructor(e, t) {
    super(e, t, new UU(), new JU()), this.importFn = e, this.getProjectAnnotations = t, ee.__STORYBOOK_PREVIEW__ = this;
  }
};
o(zU, "PreviewWeb");
var { document: bn } = ee, WU = [
  "application/javascript",
  "application/ecmascript",
  "application/x-ecmascript",
  "application/x-javascript",
  "text/ecmascript",
  "text/javascript",
  "text/javascript1.0",
  "text/javascript1.1",
  "text/javascript1.2",
  "text/javascript1.3",
  "text/javascript1.4",
  "text/javascript1.5",
  "text/jscript",
  "text/livescript",
  "text/x-ecmascript",
  "text/x-javascript",
  // Support modern javascript
  "module"
], GU = "script", ib = "scripts-root";
function Wd() {
  const e = bn.createEvent("Event");
  e.initEvent("DOMContentLoaded", !0, !0), bn.dispatchEvent(e);
}
o(Wd, "simulateDOMContentLoaded");
function mk(e, t, r) {
  const n = bn.createElement("script");
  n.type = e.type === "module" ? "module" : "text/javascript", e.src ? (n.onload = t, n.onerror = t, n.src = e.src) : n.textContent = e.innerText, r ? r.appendChild(n) : bn.head.appendChild(n), e.parentNode.removeChild(e), e.src || t();
}
o(mk, "insertScript");
function Zh(e, t, r = 0) {
  e[r](() => {
    r++, r === e.length ? t() : Zh(e, t, r);
  });
}
o(Zh, "insertScriptsSequentially");
function KU(e) {
  let t = bn.getElementById(ib);
  t ? t.innerHTML = "" : (t = bn.createElement("div"), t.id = ib, bn.body.appendChild(t));
  const r = Array.from(e.querySelectorAll(GU));
  if (r.length) {
    const n = [];
    r.forEach((a) => {
      const i = a.getAttribute("type");
      (!i || WU.includes(i)) && n.push((s) => mk(a, s, t));
    }), n.length && Zh(n, Wd, void 0);
  } else
    Wd();
}
o(KU, "simulatePageLoad");
async function YU(e, t) {
  const r = t.parameters?.docs?.source?.transform, { id: n, unmappedArgs: a } = t, i = r && e ? r?.(e, t) : e, s = i ? await i : void 0;
  zt.getChannel().emit(N1, {
    id: n,
    source: s,
    args: a
  });
}
o(YU, "emitTransformCode");
const Ku = {
  xs: {
    name: "xs: 375px",
    styles: { width: "375px", height: "667px" }
  },
  mobile: {
    name: "mobile: 719px",
    styles: { width: "719px", height: "1024px" }
  },
  sm: {
    name: "sm: 720px",
    styles: { width: "720px", height: "1024px" }
  },
  md: {
    name: "md: 960px",
    styles: { width: "960px", height: "768px" }
  },
  lg: {
    name: "lg: 1280px",
    styles: { width: "1280px", height: "720px" }
  },
  xl: {
    name: "xl: 1440px",
    styles: { width: "1440px", height: "810px" }
  },
  xxl: {
    name: "xxl: 1920px",
    styles: { width: "1920px", height: "1080px" }
  }
};
Object.keys(Ku).reduce(
  (e, t) => ({
    ...e,
    [t]: `${parseInt(Ku[t].styles.width, 10)}x${parseInt(Ku[t].styles.height, 10)}`
  }),
  {}
);
rU({
  name: "withScreenshot",
  parameterName: "screenshot",
  skipIfNoParametersOrOptions: !1,
  wrapper: (e, t, { parameters: r, options: n }) => {
    if (typeof process < "u" && (process == null ? void 0 : Fi.JEST_WORKER_ID) !== void 0)
      return e(t);
    const a = r || n;
    return Ak.triggerScreenshot(a, t), e(t);
  }
});
var Li = /* @__PURE__ */ ((e) => (e.PROPERTY_LOGO_CLICK = "epic-wf-prop-logo-on-click", e.FOOTER_LINK_CLICK = "epic-wf-footer-link-on-click", e.FOOTER_BUTTON_CLICK = "epic-wf-footer-button-on-click", e.IS_READY = "epic-wf-footer-is-ready", e))(Li || {});
const XU = ":host{box-sizing:border-box;color:var(--color-text-secondary, rgba(255, 255, 255, .65));max-width:52.5rem;font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.75rem;letter-spacing:.02em}@media (max-width: 719.9px){:host{text-align:center}}";
var QU = Object.defineProperty, ZU = Object.getOwnPropertyDescriptor, hk = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? ZU(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && QU(t, r, a), a;
};
let qs = class extends Pt {
  constructor() {
    super(...arguments), this.text = "";
  }
  render() {
    if (!this.text)
      return console.debug("footer-copyright text is missing!"), ae``;
    const e = `${(/* @__PURE__ */ new Date()).getFullYear()}`, t = this.text.replace(/\{year\}/g, e).replace(/\{YEAR\}/g, e).replace(/&copy;/g, "Â©");
    return ae` <span class="copyright">${t}</span> `;
  }
};
qs.styles = St`
		${Tt(XU)}
	`;
hk([
  ne()
], qs.prototype, "text", 2);
qs = hk([
  Lt("epic-wf-footer-copyright")
], qs);
const sb = (e, t) => {
  customElements.get(e) || customElements.define(e, t);
}, e5 = (e) => (t, r) => {
  r !== void 0 ? r.addInitializer(() => {
    sb(e, t);
  }) : sb(e, t);
}, t5 = ":host{fill:var(--color-icon-primary, #ffffff);display:flex;box-sizing:border-box}:host svg{height:100%;width:100%}:host([textcolor=primary]){fill:var(--color-svg-primary, #ffffff)}:host([textcolor=secondary]){fill:var(--color-svg-secondary, rgba(255, 255, 255, .65))}:host([textcolor=disabled]){fill:var(--color-svg-disabled, rgba(255, 255, 255, .65))}:host([textcolor=link]){fill:var(--color-svg-link, #26bbff)}:host([textcolor=select]){fill:var(--color-svg-select, #26bbff)}:host([textcolor=success]){fill:var(--color-svg-success, #45c761)}:host([textcolor=warning]){fill:var(--color-svg-warning, #ffc229)}:host([textcolor=critical]){fill:var(--color-svg-critical, #ff6173)}:host([textcolor=onAccent]){fill:var(--color-svg-onAccent, #000000)}:host([textcolor=contrast]){fill:var(--color-svg-contrast, #ffffff)}:host([accentcolor=blue]){fill:var(--color-svg-blue, #26bbff)}:host([accentcolor=lime]){fill:var(--color-svg-lime, #a9d34f)}:host([accentcolor=yellow]){fill:var(--color-svg-yellow, #ffc229)}:host([accentcolor=red]){fill:var(--color-svg-red, #ff3f56)}:host([accentcolor=pink]){fill:var(--color-svg-pink, #fe54ba)}:host([accentcolor=purple]){fill:var(--color-svg-purple, #be3dff)}:host([accentcolor=indigo]){fill:var(--color-svg-indigo, #7371ff)}:host([accentcolor=cyan]){fill:var(--color-svg-cyan, #43dac2)}:host([accentcolor=green]){fill:var(--color-svg-green, #45c761)}:host([accentcolor=amber]){fill:var(--color-svg-amber, #ff8e1f)}:host([accentcolor=orange]){fill:var(--color-svg-orange, #fd6535)}:host([accentcolor=brown]){fill:var(--color-svg-brown, #b2715d)}:host([accentcolor=epicgames]){fill:var(--color-svg-epicgames, #26bbff)}:host([accentcolor=fallguys]){fill:var(--color-svg-fallguys, #60e9ff)}:host([accentcolor=fortnite]){fill:var(--color-svg-fortnite, #f7ff1a)}:host([accentcolor=rocketleague]){fill:var(--color-svg-rocketleague, #faa41a)}:host([accentcolor=twinmotion]){fill:var(--color-svg-twinmotion, #f43c9c)}", r5 = async (e) => {
  if (!e)
    return null;
  let t;
  switch (e) {
    case "a_slash_b":
      return t = await import("./a-slash-b.W_Cnlyu--W_Cnlyu-.mjs"), d(t.default);
    case "accessibility_filled":
      return t = await import("./accessibility-filled.BpUfcCi1-CmHLb0e0.mjs"), d(t.default);
    case "accessibility":
      return t = await import("./accessibility.CiYAgPVJ-CiYAgPVJ.mjs"), d(t.default);
    case "adobe_illustrator":
      return t = await import("./adobe-illustrator.IidBePh6-IidBePh6.mjs"), d(t.default);
    case "adobe_photoshop":
      return t = await import("./adobe-photoshop.2iG9QE1z-2iG9QE1z.mjs"), d(t.default);
    case "adobe_substance_3d_modeler":
      return t = await import("./adobe-substance-3d-modeler.VcrLkuc0-VcrLkuc0.mjs"), d(t.default);
    case "adobe_substance_3d_painter":
      return t = await import("./adobe-substance-3d-painter.BZzn4qo6-BZzn4qo6.mjs"), d(t.default);
    case "ai_filled":
      return t = await import("./ai-filled.BErCIJiF-BErCIJiF.mjs"), d(t.default);
    case "ai":
      return t = await import("./ai.Bgv4etct-Bgv4etct.mjs"), d(t.default);
    case "alarm_clock_filled":
      return t = await import("./alarm-clock-filled.DR1Kg3eo-DR1Kg3eo.mjs"), d(t.default);
    case "alarm_clock":
      return t = await import("./alarm-clock.C8lJX-dg-C8lJX-dg.mjs"), d(t.default);
    case "alternating_diagonal_lines_square_filled":
      return t = await import("./alternating-diagonal-lines-square-filled.Cg-V8g2l-Cg-V8g2l.mjs"), d(t.default);
    case "alternating_diagonal_lines_square":
      return t = await import("./alternating-diagonal-lines-square.N0bjlMyx-N0bjlMyx.mjs"), d(t.default);
    case "anchor":
      return t = await import("./anchor.CQwbs9ND-CQwbs9ND.mjs"), d(t.default);
    case "android":
      return t = await import("./android.BF0zUxsY-BF0zUxsY.mjs"), d(t.default);
    case "ao":
      return t = await import("./ao.DcOfCo0b-DcOfCo0b.mjs"), d(t.default);
    case "apple":
      return t = await import("./apple.JcvTJZ_p-JcvTJZ_p.mjs"), d(t.default);
    case "archive_filled":
      return t = await import("./archive-filled.Dmouv6ix-Dmouv6ix.mjs"), d(t.default);
    case "archive":
      return t = await import("./archive.CsTr22ap-CsTr22ap.mjs"), d(t.default);
    case "arrow_down_circle_filled":
      return t = await import("./arrow-down-circle-filled.iBUoeEcn-iBUoeEcn.mjs"), d(t.default);
    case "arrow_down_circle":
      return t = await import("./arrow-down-circle.D55Wd9fb-D55Wd9fb.mjs"), d(t.default);
    case "arrow_down_list_wide_to_narrow":
      return t = await import("./arrow-down-list-wide-to-narrow.BByDbFwp-BByDbFwp.mjs"), d(t.default);
    case "arrow_down_right_arrow_up_left":
      return t = await import("./arrow-down-right-arrow-up-left.k3VYiLki-k3VYiLki.mjs"), d(t.default);
    case "arrow_down_right_to_square":
      return t = await import("./arrow-down-right-to-square.DdVyLgE4-DdVyLgE4.mjs"), d(t.default);
    case "arrow_down_semi_dashed_circle":
      return t = await import("./arrow-down-semi-dashed-circle.BCcx44bL-BCcx44bL.mjs"), d(t.default);
    case "arrow_down_to_bracket":
      return t = await import("./arrow-down-to-bracket.B5mg--Yb-B5mg--Yb.mjs"), d(t.default);
    case "arrow_down_turn_left":
      return t = await import("./arrow-down-turn-left.Ddk87uoM-Ddk87uoM.mjs"), d(t.default);
    case "arrow_down":
      return t = await import("./arrow-down.KA1xwH1X-KA1xwH1X.mjs"), d(t.default);
    case "arrow_left_circle_filled":
      return t = await import("./arrow-left-circle-filled.PBQQSG3Q-PBQQSG3Q.mjs"), d(t.default);
    case "arrow_left_circle":
      return t = await import("./arrow-left-circle.D9bO9iXO-D9bO9iXO.mjs"), d(t.default);
    case "arrow_left_to_line":
      return t = await import("./arrow-left-to-line.N4itJJSd-N4itJJSd.mjs"), d(t.default);
    case "arrow_left":
      return t = await import("./arrow-left.D2hFgUwm-D2hFgUwm.mjs"), d(t.default);
    case "arrow_right_arrow_left_horizontal":
      return t = await import("./arrow-right-arrow-left-horizontal.CiXaBSfc-CiXaBSfc.mjs"), d(t.default);
    case "arrow_right_circle_filled":
      return t = await import("./arrow-right-circle-filled.DeLhrQhH-DeLhrQhH.mjs"), d(t.default);
    case "arrow_right_circle":
      return t = await import("./arrow-right-circle.xLPiXX6q-xLPiXX6q.mjs"), d(t.default);
    case "arrow_right_from_bracket":
      return t = await import("./arrow-right-from-bracket.89Xns2lq-89Xns2lq.mjs"), d(t.default);
    case "arrow_right_to_bracket":
      return t = await import("./arrow-right-to-bracket.BrcL_Uz1-BrcL_Uz1.mjs"), d(t.default);
    case "arrow_right_to_line":
      return t = await import("./arrow-right-to-line.CrAxAyeL-CrAxAyeL.mjs"), d(t.default);
    case "arrow_right":
      return t = await import("./arrow-right.CwdQF_U9-CwdQF_U9.mjs"), d(t.default);
    case "arrow_rotate_left":
      return t = await import("./arrow-rotate-left.DBs5FzM5-Cqov6seQ.mjs"), d(t.default);
    case "arrow_rotate_right":
      return t = await import("./arrow-rotate-right.DRrVEOfC-DRrVEOfC.mjs"), d(t.default);
    case "arrow_rotate_x":
      return t = await import("./arrow-rotate-x.ShPpqgyR-ShPpqgyR.mjs"), d(t.default);
    case "arrow_rotate_y":
      return t = await import("./arrow-rotate-y.DfHDjFAr-DfHDjFAr.mjs"), d(t.default);
    case "arrow_turn_left_down":
      return t = await import("./arrow-turn-left-down.0sj1hMG9-0sj1hMG9.mjs"), d(t.default);
    case "arrow_turn_up_left":
      return t = await import("./arrow-turn-up-left.0VecCQWV-0VecCQWV.mjs"), d(t.default);
    case "arrow_turn_up_right":
      return t = await import("./arrow-turn-up-right.yQllv3Lc-yQllv3Lc.mjs"), d(t.default);
    case "arrow_up_arrow_down_vertical":
      return t = await import("./arrow-up-arrow-down-vertical.CXSYPXjI-CXSYPXjI.mjs"), d(t.default);
    case "arrow_up_circle_filled":
      return t = await import("./arrow-up-circle-filled.Ay28qzNC-Ay28qzNC.mjs"), d(t.default);
    case "arrow_up_circle":
      return t = await import("./arrow-up-circle.BRIQvQUg-BRIQvQUg.mjs"), d(t.default);
    case "arrow_up_from_bracket":
      return t = await import("./arrow-up-from-bracket.C1pqCqJm-C1pqCqJm.mjs"), d(t.default);
    case "arrow_up_left_arrow_down_right_collide":
      return t = await import("./arrow-up-left-arrow-down-right-collide.Cg4CTWiI-Cg4CTWiI.mjs"), d(t.default);
    case "arrow_up_left_arrow_down_right":
      return t = await import("./arrow-up-left-arrow-down-right.x27TVYEH-x27TVYEH.mjs"), d(t.default);
    case "arrow_up_list_narrow_to_wide":
      return t = await import("./arrow-up-list-narrow-to-wide.pnfViF-s-pnfViF-s.mjs"), d(t.default);
    case "arrow_up_right_from_square":
      return t = await import("./arrow-up-right-from-square.lZ8eLwV3-lZ8eLwV3.mjs"), d(t.default);
    case "arrow_up":
      return t = await import("./arrow-up.DS7I-4EO-DS7I-4EO.mjs"), d(t.default);
    case "arrows_crossed":
      return t = await import("./arrows-crossed.CH83KMsj-CH83KMsj.mjs"), d(t.default);
    case "arrows_horizontal_from_center":
      return t = await import("./arrows-horizontal-from-center.D9FJCM0E-D9FJCM0E.mjs"), d(t.default);
    case "arrows_horizontal_to_lines":
      return t = await import("./arrows-horizontal-to-lines.DORZKFMr-DORZKFMr.mjs"), d(t.default);
    case "arrows_rotate_right":
      return t = await import("./arrows-rotate-right.B0kETBm5-B0kETBm5.mjs"), d(t.default);
    case "arrows_vertical_from_center":
      return t = await import("./arrows-vertical-from-center.BijwcrYb-BijwcrYb.mjs"), d(t.default);
    case "arrows_vertical_to_lines":
      return t = await import("./arrows-vertical-to-lines.BM5rdeNm-BM5rdeNm.mjs"), d(t.default);
    case "artstation":
      return t = await import("./artstation.BtRre1Zb-BtRre1Zb.mjs"), d(t.default);
    case "at":
      return t = await import("./at.C9iJiGd1-C9iJiGd1.mjs"), d(t.default);
    case "autodesk":
      return t = await import("./autodesk.JmWHMU8X-JmWHMU8X.mjs"), d(t.default);
    case "axe_filled":
      return t = await import("./axe-filled.DekOl2ED-DekOl2ED.mjs"), d(t.default);
    case "axe":
      return t = await import("./axe.Edu3KlXT-Edu3KlXT.mjs"), d(t.default);
    case "backpack_filled":
      return t = await import("./backpack-filled.m23D-0_Z-m23D-0_Z.mjs"), d(t.default);
    case "backpack":
      return t = await import("./backpack.co3WQu8I-co3WQu8I.mjs"), d(t.default);
    case "backward_end_filled":
      return t = await import("./backward-end-filled.CIyQTgj9-CIyQTgj9.mjs"), d(t.default);
    case "backward_end":
      return t = await import("./backward-end.D-C5lXMK-D-C5lXMK.mjs"), d(t.default);
    case "backward_filled":
      return t = await import("./backward-filled.CvJF7-aK-CvJF7-aK.mjs"), d(t.default);
    case "backward":
      return t = await import("./backward.D2uKJWHk-D2uKJWHk.mjs"), d(t.default);
    case "badge_filled":
      return t = await import("./badge-filled.DFgw1TFk-DFgw1TFk.mjs"), d(t.default);
    case "badge":
      return t = await import("./badge.D8LRp-wh-D8LRp-wh.mjs"), d(t.default);
    case "ball_filled":
      return t = await import("./ball-filled.C0Z6BKxH-C0Z6BKxH.mjs"), d(t.default);
    case "ball":
      return t = await import("./ball.CTR-PEGf-CTR-PEGf.mjs"), d(t.default);
    case "bass_filled":
      return t = await import("./bass-filled.DCCYduRd-DCCYduRd.mjs"), d(t.default);
    case "bass":
      return t = await import("./bass.BoCSoE0i-BoCSoE0i.mjs"), d(t.default);
    case "behance":
      return t = await import("./behance.D5qdWydP-D5qdWydP.mjs"), d(t.default);
    case "bell_badge_filled":
      return t = await import("./bell-badge-filled.8YwwWwQa-8YwwWwQa.mjs"), d(t.default);
    case "bell_badge":
      return t = await import("./bell-badge.CsVtz85v-CsVtz85v.mjs"), d(t.default);
    case "bell_filled":
      return t = await import("./bell-filled.r05thf5_-3PMA2Pwc.mjs"), d(t.default);
    case "bell_slash_filled":
      return t = await import("./bell-slash-filled.CtpOeLSq-CJhWVfhH.mjs"), d(t.default);
    case "bell_slash":
      return t = await import("./bell-slash.BsLVwhcH-BsLVwhcH.mjs"), d(t.default);
    case "bell":
      return t = await import("./bell.CT0CAQ9W-CT0CAQ9W.mjs"), d(t.default);
    case "blender":
      return t = await import("./blender.U70Zq8aK-U70Zq8aK.mjs"), d(t.default);
    case "block_quote":
      return t = await import("./block-quote.XB0ZXL37-XB0ZXL37.mjs"), d(t.default);
    case "bluetooth":
      return t = await import("./bluetooth.CDYF9WFP-CDYF9WFP.mjs"), d(t.default);
    case "bold":
      return t = await import("./bold.DOBDO4jx-DOBDO4jx.mjs"), d(t.default);
    case "bolt_filled":
      return t = await import("./bolt-filled.Dn4V2WkP-Dn4V2WkP.mjs"), d(t.default);
    case "bolt_slash_filled":
      return t = await import("./bolt-slash-filled.CEc_ulWI-CEc_ulWI.mjs"), d(t.default);
    case "bolt_slash":
      return t = await import("./bolt-slash.BpGNj9Mx-BpGNj9Mx.mjs"), d(t.default);
    case "bolt":
      return t = await import("./bolt.BqeoqpLv-BqeoqpLv.mjs"), d(t.default);
    case "bookmark_filled":
      return t = await import("./bookmark-filled.BdzY-4zN-BdzY-4zN.mjs"), d(t.default);
    case "bookmark":
      return t = await import("./bookmark.CVHnBKhi-CVHnBKhi.mjs"), d(t.default);
    case "bowl_filled":
      return t = await import("./bowl-filled.CUDld_BC-CUDld_BC.mjs"), d(t.default);
    case "bowl":
      return t = await import("./bowl.LDxRGKrH-LDxRGKrH.mjs"), d(t.default);
    case "box_check_filled":
      return t = await import("./box-check-filled.BojtgDkF-BojtgDkF.mjs"), d(t.default);
    case "box_check":
      return t = await import("./box-check.Dfj0zgpR-Dfj0zgpR.mjs"), d(t.default);
    case "box_cogwheel_filled":
      return t = await import("./box-cogwheel-filled.Bt0YEYeW-Bt0YEYeW.mjs"), d(t.default);
    case "box_cogwheel":
      return t = await import("./box-cogwheel.BqJBqlcE-BqJBqlcE.mjs"), d(t.default);
    case "box_filled":
      return t = await import("./box-filled.Dki0YotG-Dki0YotG.mjs"), d(t.default);
    case "box_minus_filled":
      return t = await import("./box-minus-filled.D9l5P-rE-CMK-SkHh.mjs"), d(t.default);
    case "box_minus":
      return t = await import("./box-minus.DhjB_RRC-DhjB_RRC.mjs"), d(t.default);
    case "box_pen_filled":
      return t = await import("./box-pen-filled.Z1MCHLDv-Z1MCHLDv.mjs"), d(t.default);
    case "box_pen":
      return t = await import("./box-pen.DmCxIpDK-DmCxIpDK.mjs"), d(t.default);
    case "box_plus_filled":
      return t = await import("./box-plus-filled.BqWANJa_-BqWANJa_.mjs"), d(t.default);
    case "box_plus":
      return t = await import("./box-plus.BdkYbVPi-BdkYbVPi.mjs"), d(t.default);
    case "box_x_mark_filled":
      return t = await import("./box-x-mark-filled.jarkrTaB-jarkrTaB.mjs"), d(t.default);
    case "box_x_mark":
      return t = await import("./box-x-mark.DhU8I_aQ-DhU8I_aQ.mjs"), d(t.default);
    case "box":
      return t = await import("./box.DpEioDDc-DpEioDDc.mjs"), d(t.default);
    case "branch":
      return t = await import("./branch.B8ZP-Bvj-B8ZP-Bvj.mjs"), d(t.default);
    case "brick_wall_filled":
      return t = await import("./brick-wall-filled.DJIDRMK3-DJIDRMK3.mjs"), d(t.default);
    case "brick_wall":
      return t = await import("./brick-wall.B6vftHRv-B6vftHRv.mjs"), d(t.default);
    case "briefcase_filled":
      return t = await import("./briefcase-filled.DA4vuL2z-DA4vuL2z.mjs"), d(t.default);
    case "briefcase":
      return t = await import("./briefcase.Dufew702-Dufew702.mjs"), d(t.default);
    case "browser_window_cogwheel_filled":
      return t = await import("./browser-window-cogwheel-filled.y8yZ136s-y8yZ136s.mjs"), d(t.default);
    case "browser_window_cogwheel":
      return t = await import("./browser-window-cogwheel.Dp2_pkRY-Dp2_pkRY.mjs"), d(t.default);
    case "browser_window_filled":
      return t = await import("./browser-window-filled.BqwXDhqv-BqwXDhqv.mjs"), d(t.default);
    case "browser_window":
      return t = await import("./browser-window.COGBPZ-A-COGBPZ-A.mjs"), d(t.default);
    case "brush_filled":
      return t = await import("./brush-filled.xwe1olmf-xwe1olmf.mjs"), d(t.default);
    case "brush":
      return t = await import("./brush.Dsim9FJv-Dsim9FJv.mjs"), d(t.default);
    case "bug_filled":
      return t = await import("./bug-filled.CG_do4WH-CG_do4WH.mjs"), d(t.default);
    case "bug":
      return t = await import("./bug.RZClSblS-RZClSblS.mjs"), d(t.default);
    case "building_filled":
      return t = await import("./building-filled.CbqVhG6w-CbqVhG6w.mjs"), d(t.default);
    case "building":
      return t = await import("./building.DW5L1m41-DW5L1m41.mjs"), d(t.default);
    case "bullet_list":
      return t = await import("./bullet-list.Bb5kp_Pk-Bb5kp_Pk.mjs"), d(t.default);
    case "bullhorn_filled":
      return t = await import("./bullhorn-filled.DcidvXHF-CORBZNq7.mjs"), d(t.default);
    case "bullhorn":
      return t = await import("./bullhorn.DTZgVcSB-DTZgVcSB.mjs"), d(t.default);
    case "bump_arrow_up":
      return t = await import("./bump-arrow-up.CyAqOjOO-CyAqOjOO.mjs"), d(t.default);
    case "burger_filled":
      return t = await import("./burger-filled.CAQIvwqf-CAQIvwqf.mjs"), d(t.default);
    case "burger":
      return t = await import("./burger.CO3RtZ1C-CO3RtZ1C.mjs"), d(t.default);
    case "calendar_arrows_filled":
      return t = await import("./calendar-arrows-filled.BxEPeJn2-BxEPeJn2.mjs"), d(t.default);
    case "calendar_arrows":
      return t = await import("./calendar-arrows.BJVDM7wp-BJVDM7wp.mjs"), d(t.default);
    case "calendar_check_filled":
      return t = await import("./calendar-check-filled.sgHwtXrS-sgHwtXrS.mjs"), d(t.default);
    case "calendar_check":
      return t = await import("./calendar-check.D0UloNi--D0UloNi-.mjs"), d(t.default);
    case "calendar_cogwheel_filled":
      return t = await import("./calendar-cogwheel-filled.BkQPrnsc-BkQPrnsc.mjs"), d(t.default);
    case "calendar_cogwheel":
      return t = await import("./calendar-cogwheel.OXeMavU9-OXeMavU9.mjs"), d(t.default);
    case "calendar_filled":
      return t = await import("./calendar-filled.B7A81Ge1-B7A81Ge1.mjs"), d(t.default);
    case "calendar_minus_filled":
      return t = await import("./calendar-minus-filled.BfhqXZbO-BfhqXZbO.mjs"), d(t.default);
    case "calendar_minus":
      return t = await import("./calendar-minus.BT-xCvyA-BT-xCvyA.mjs"), d(t.default);
    case "calendar_pen_filled":
      return t = await import("./calendar-pen-filled.COEeW2Tp-COEeW2Tp.mjs"), d(t.default);
    case "calendar_pen":
      return t = await import("./calendar-pen.D3xb2nbB-D3xb2nbB.mjs"), d(t.default);
    case "calendar_plus_filled":
      return t = await import("./calendar-plus-filled.D59QsHIe-D59QsHIe.mjs"), d(t.default);
    case "calendar_plus":
      return t = await import("./calendar-plus.DNsyw26P-DNsyw26P.mjs"), d(t.default);
    case "calendar_x_mark_filled":
      return t = await import("./calendar-x-mark-filled.CqEzVUw8-CqEzVUw8.mjs"), d(t.default);
    case "calendar_x_mark":
      return t = await import("./calendar-x-mark.BnUH3XiR-BnUH3XiR.mjs"), d(t.default);
    case "calendar":
      return t = await import("./calendar.B2eVGUCn-B2eVGUCn.mjs"), d(t.default);
    case "camera_filled":
      return t = await import("./camera-filled.Dgnbk97Z-Dgnbk97Z.mjs"), d(t.default);
    case "camera_slash_filled":
      return t = await import("./camera-slash-filled.BKIR2jeV-BKIR2jeV.mjs"), d(t.default);
    case "camera_slash":
      return t = await import("./camera-slash.BXmxw2k1-BXmxw2k1.mjs"), d(t.default);
    case "camera":
      return t = await import("./camera.D08G_CbW-D08G_CbW.mjs"), d(t.default);
    case "car_filled":
      return t = await import("./car-filled.CRR-VAWI-CRR-VAWI.mjs"), d(t.default);
    case "car":
      return t = await import("./car.Dlcl-NqY-Dlcl-NqY.mjs"), d(t.default);
    case "card_holder_filled":
      return t = await import("./card-holder-filled.CvMRbILX-CvMRbILX.mjs"), d(t.default);
    case "card_holder":
      return t = await import("./card-holder.Il6N-0X0-Il6N-0X0.mjs"), d(t.default);
    case "chart_bar_x_axis_filled":
      return t = await import("./chart-bar-x-axis-filled.CDUS65L5-CDUS65L5.mjs"), d(t.default);
    case "chart_bar_x_axis":
      return t = await import("./chart-bar-x-axis.DseHFaRf-DseHFaRf.mjs"), d(t.default);
    case "chart_line_down_trend_xy_axis":
      return t = await import("./chart-line-down-trend-xy-axis.BrbrQ8rF-BrbrQ8rF.mjs"), d(t.default);
    case "chart_line_up_trend_xy_axis":
      return t = await import("./chart-line-up-trend-xy-axis.z8Dx_F6Y-z8Dx_F6Y.mjs"), d(t.default);
    case "chart_pie_filled":
      return t = await import("./chart-pie-filled.D6fnVo5U-D6fnVo5U.mjs"), d(t.default);
    case "chart_pie":
      return t = await import("./chart-pie.CQyQVGk_-CQyQVGk_.mjs"), d(t.default);
    case "check_circle_filled":
      return t = await import("./check-circle-filled.DZvJw0pj-CpuWKgNW.mjs"), d(t.default);
    case "check_circle":
      return t = await import("./check-circle.DDzL8GQS-DDzL8GQS.mjs"), d(t.default);
    case "check_double":
      return t = await import("./check-double.EZepoGaw-EZepoGaw.mjs"), d(t.default);
    case "check_square_filled":
      return t = await import("./check-square-filled.2P1SyjPY-2P1SyjPY.mjs"), d(t.default);
    case "check_square":
      return t = await import("./check-square.CDrSwmSy-CDrSwmSy.mjs"), d(t.default);
    case "check":
      return t = await import("./check.B535HyRi-B535HyRi.mjs"), d(t.default);
    case "checkerboard_2x2":
      return t = await import("./checkerboard-2x2.xFi0_dAA-xFi0_dAA.mjs"), d(t.default);
    case "checkerboard_4x4":
      return t = await import("./checkerboard-4x4.DIGgwdKy-DIGgwdKy.mjs"), d(t.default);
    case "checklist":
      return t = await import("./checklist.DqepExmU-DqepExmU.mjs"), d(t.default);
    case "checkmark_seal_filled":
      return t = await import("./checkmark-seal-filled.qvMWvtq9-qvMWvtq9.mjs"), d(t.default);
    case "checkmark_seal":
      return t = await import("./checkmark-seal.Bllg2v52-Bllg2v52.mjs"), d(t.default);
    case "chefs_hat_filled":
      return t = await import("./chefs-hat-filled.BBzAz9e4-BBzAz9e4.mjs"), d(t.default);
    case "chefs_hat":
      return t = await import("./chefs-hat.Bpy-xcqK-Bpy-xcqK.mjs"), d(t.default);
    case "chevron_down_double":
      return t = await import("./chevron-down-double.B4ifpdGf-B4ifpdGf.mjs"), d(t.default);
    case "chevron_down":
      return t = await import("./chevron-down.ByqXecK1-Bm922ghA.mjs"), d(t.default);
    case "chevron_left_double":
      return t = await import("./chevron-left-double.B0A2LdPb-B0A2LdPb.mjs"), d(t.default);
    case "chevron_left_to_line":
      return t = await import("./chevron-left-to-line.DpDJwwJL-DpDJwwJL.mjs"), d(t.default);
    case "chevron_left_to_vertical_line_filled":
      return t = await import("./chevron-left-to-vertical-line-filled.D69xH4lB-D69xH4lB.mjs"), d(t.default);
    case "chevron_left_to_vertical_line":
      return t = await import("./chevron-left-to-vertical-line.pAmiDFuo-pAmiDFuo.mjs"), d(t.default);
    case "chevron_left":
      return t = await import("./chevron-left.5NxKEhgw-5NxKEhgw.mjs"), d(t.default);
    case "chevron_right_double":
      return t = await import("./chevron-right-double.pfo6aV7Q-pfo6aV7Q.mjs"), d(t.default);
    case "chevron_right_from_vertical_line_filled":
      return t = await import("./chevron-right-from-vertical-line-filled.CSa_9MPA-CSa_9MPA.mjs"), d(t.default);
    case "chevron_right_from_vertical_line":
      return t = await import("./chevron-right-from-vertical-line.G3DByH8q-G3DByH8q.mjs"), d(t.default);
    case "chevron_right_to_line":
      return t = await import("./chevron-right-to-line.CGtkNvqp-CGtkNvqp.mjs"), d(t.default);
    case "chevron_right":
      return t = await import("./chevron-right.CVg59ZJK-CVg59ZJK.mjs"), d(t.default);
    case "chevron_up_double":
      return t = await import("./chevron-up-double.JIT8RUaP-JIT8RUaP.mjs"), d(t.default);
    case "chevron_up":
      return t = await import("./chevron-up.Cl4ZaywG-DV2Izvms.mjs"), d(t.default);
    case "cinema_4d":
      return t = await import("./cinema-4d.C_WNLgor-C_WNLgor.mjs"), d(t.default);
    case "circle_filled":
      return t = await import("./circle-filled.D2_-GSFv-D2_-GSFv.mjs"), d(t.default);
    case "circle_invert":
      return t = await import("./circle-invert.AwTLGW_T-AwTLGW_T.mjs"), d(t.default);
    case "circle_line_right_down_circle_line_to_left_up_filled":
      return t = await import("./circle-line-right-down-circle-line-to-left-up-filled.CAaz2Yrq-CAaz2Yrq.mjs"), d(t.default);
    case "circle_line_right_down_circle_line_to_left_up":
      return t = await import("./circle-line-right-down-circle-line-to-left-up.Dte0TmIq-Dte0TmIq.mjs"), d(t.default);
    case "circle_radial_streaks":
      return t = await import("./circle-radial-streaks.BVSYPWci-BVSYPWci.mjs"), d(t.default);
    case "circle":
      return t = await import("./circle.BpV3efRT-BpV3efRT.mjs"), d(t.default);
    case "circles_bottom_left_top_right_filled":
      return t = await import("./circles-bottom-left-top-right-filled.CcjbQp0Z-CcjbQp0Z.mjs"), d(t.default);
    case "circles_bottom_left_top_right":
      return t = await import("./circles-bottom-left-top-right.wdw7LFeg-wdw7LFeg.mjs"), d(t.default);
    case "circles_filled":
      return t = await import("./circles-filled.D2fOOZwj-D2fOOZwj.mjs"), d(t.default);
    case "circles":
      return t = await import("./circles.Cxpxk4N6-Cxpxk4N6.mjs"), d(t.default);
    case "clapper_filled":
      return t = await import("./clapper-filled.C7sbs3B6-C7sbs3B6.mjs"), d(t.default);
    case "clapper":
      return t = await import("./clapper.CIgnVioi-CIgnVioi.mjs"), d(t.default);
    case "clipboard_filled":
      return t = await import("./clipboard-filled.CrSa3wPS-CrSa3wPS.mjs"), d(t.default);
    case "clipboard_lines_filled":
      return t = await import("./clipboard-lines-filled.BwS7Q4nB-BwS7Q4nB.mjs"), d(t.default);
    case "clipboard_lines":
      return t = await import("./clipboard-lines.k281yqMx-k281yqMx.mjs"), d(t.default);
    case "clipboard":
      return t = await import("./clipboard.Bql4JnEl-Bql4JnEl.mjs"), d(t.default);
    case "clock_arrow_rotate_left":
      return t = await import("./clock-arrow-rotate-left.CLY2C7vu-CLY2C7vu.mjs"), d(t.default);
    case "clock_arrow_rotate_right":
      return t = await import("./clock-arrow-rotate-right.CXZdnnVA-CXZdnnVA.mjs"), d(t.default);
    case "clock_filled":
      return t = await import("./clock-filled.CQiPTkpu-BXIw60fr.mjs"), d(t.default);
    case "clock":
      return t = await import("./clock.aUn0W--U-aUn0W--U.mjs"), d(t.default);
    case "cloud_arrow_down_filled":
      return t = await import("./cloud-arrow-down-filled.CIDFDksO-CIDFDksO.mjs"), d(t.default);
    case "cloud_arrow_down":
      return t = await import("./cloud-arrow-down.BWQaI74F-BWQaI74F.mjs"), d(t.default);
    case "cloud_arrow_up_filled":
      return t = await import("./cloud-arrow-up-filled.D0b6eTPt-D0b6eTPt.mjs"), d(t.default);
    case "cloud_arrow_up":
      return t = await import("./cloud-arrow-up.Ck2wfJME-Ck2wfJME.mjs"), d(t.default);
    case "cloud_filled":
      return t = await import("./cloud-filled.CQ0akqYU-CQ0akqYU.mjs"), d(t.default);
    case "cloud":
      return t = await import("./cloud.Be15t1fl-Be15t1fl.mjs"), d(t.default);
    case "code_block":
      return t = await import("./code-block.C9Lggf4d-C9Lggf4d.mjs"), d(t.default);
    case "code":
      return t = await import("./code.4BzMZ2cJ-4BzMZ2cJ.mjs"), d(t.default);
    case "cog_filled":
      return t = await import("./cog-filled.BoG3AouY-BoG3AouY.mjs"), d(t.default);
    case "cog":
      return t = await import("./cog.C8DrtQXy-C8DrtQXy.mjs"), d(t.default);
    case "combined_geometric_shapes":
      return t = await import("./combined-geometric-shapes.B1g9WH95-B1g9WH95.mjs"), d(t.default);
    case "comet_filled":
      return t = await import("./comet-filled.QRhoadYQ-QRhoadYQ.mjs"), d(t.default);
    case "comet":
      return t = await import("./comet.KwIEkDt1-KwIEkDt1.mjs"), d(t.default);
    case "commit":
      return t = await import("./commit.CMfHib7M-CMfHib7M.mjs"), d(t.default);
    case "compass_filled":
      return t = await import("./compass-filled.BgBtjF3b-BgBtjF3b.mjs"), d(t.default);
    case "compass":
      return t = await import("./compass.B6vM2WGS-B6vM2WGS.mjs"), d(t.default);
    case "compile_filled":
      return t = await import("./compile-filled.C7ffh5BS-C7ffh5BS.mjs"), d(t.default);
    case "compile":
      return t = await import("./compile.B66HSS8e-B66HSS8e.mjs"), d(t.default);
    case "compress":
      return t = await import("./compress.q2KOPw4K-q2KOPw4K.mjs"), d(t.default);
    case "computer_chip_filled":
      return t = await import("./computer-chip-filled.VmGsfSMk-VmGsfSMk.mjs"), d(t.default);
    case "computer_chip":
      return t = await import("./computer-chip.D5ejky9t-D5ejky9t.mjs"), d(t.default);
    case "computer_mouse_filled":
      return t = await import("./computer-mouse-filled.Bsgmbtqo-Bsgmbtqo.mjs"), d(t.default);
    case "computer_mouse_left_click_filled":
      return t = await import("./computer-mouse-left-click-filled.CtIqJq_s-CtIqJq_s.mjs"), d(t.default);
    case "computer_mouse_left_click":
      return t = await import("./computer-mouse-left-click.DDPZAX0w-DDPZAX0w.mjs"), d(t.default);
    case "computer_mouse_right_click_filled":
      return t = await import("./computer-mouse-right-click-filled.BvQoEp9J-BvQoEp9J.mjs"), d(t.default);
    case "computer_mouse_right_click":
      return t = await import("./computer-mouse-right-click.CO4oDUrP-CO4oDUrP.mjs"), d(t.default);
    case "computer_mouse":
      return t = await import("./computer-mouse.B0A4Kz2y-B0A4Kz2y.mjs"), d(t.default);
    case "computer_network_filled":
      return t = await import("./computer-network-filled.Bsv7sJja-Bsv7sJja.mjs"), d(t.default);
    case "computer_network":
      return t = await import("./computer-network.DugYvjV6-DugYvjV6.mjs"), d(t.default);
    case "cookie_filled":
      return t = await import("./cookie-filled.BzakUHPM-BzakUHPM.mjs"), d(t.default);
    case "cookie_slash_filled":
      return t = await import("./cookie-slash-filled.DVGHQd6--DVGHQd6-.mjs"), d(t.default);
    case "cookie_slash":
      return t = await import("./cookie-slash.WL3_iZvi-WL3_iZvi.mjs"), d(t.default);
    case "cookie":
      return t = await import("./cookie.Cdk37uIL-Cdk37uIL.mjs"), d(t.default);
    case "coupon_filled":
      return t = await import("./coupon-filled.DFg8rJq3-DFg8rJq3.mjs"), d(t.default);
    case "coupon":
      return t = await import("./coupon.CMltiw3F-CMltiw3F.mjs"), d(t.default);
    case "credit_card_check_filled":
      return t = await import("./credit-card-check-filled.B9-9PsBh-B9-9PsBh.mjs"), d(t.default);
    case "credit_card_check":
      return t = await import("./credit-card-check.C03edTie-C03edTie.mjs"), d(t.default);
    case "credit_card_cogwheel_filled":
      return t = await import("./credit-card-cogwheel-filled.CILJcKLl-CILJcKLl.mjs"), d(t.default);
    case "credit_card_cogwheel":
      return t = await import("./credit-card-cogwheel.BINg_vxQ-BINg_vxQ.mjs"), d(t.default);
    case "credit_card_filled":
      return t = await import("./credit-card-filled.CgJefeFr-CgJefeFr.mjs"), d(t.default);
    case "credit_card_minus_filled":
      return t = await import("./credit-card-minus-filled.C2HwQb7g-C2HwQb7g.mjs"), d(t.default);
    case "credit_card_minus":
      return t = await import("./credit-card-minus.DkDbVLyR-DkDbVLyR.mjs"), d(t.default);
    case "credit_card_pen_filled":
      return t = await import("./credit-card-pen-filled.DRZ2gaHS-DRZ2gaHS.mjs"), d(t.default);
    case "credit_card_pen":
      return t = await import("./credit-card-pen.CuXTrVw--CuXTrVw-.mjs"), d(t.default);
    case "credit_card_plus_filled":
      return t = await import("./credit-card-plus-filled.DryUDOQO-DryUDOQO.mjs"), d(t.default);
    case "credit_card_plus":
      return t = await import("./credit-card-plus.K8P5C_Cu-K8P5C_Cu.mjs"), d(t.default);
    case "credit_card_x_mark_filled":
      return t = await import("./credit-card-x-mark-filled.Bxbw0zjT-Bxbw0zjT.mjs"), d(t.default);
    case "credit_card_x_mark":
      return t = await import("./credit-card-x-mark.BADR-Ufj-BADR-Ufj.mjs"), d(t.default);
    case "credit_card":
      return t = await import("./credit-card.DS9-hH3Y-DS9-hH3Y.mjs"), d(t.default);
    case "crop":
      return t = await import("./crop.D9tbBow2-D9tbBow2.mjs"), d(t.default);
    case "crosshair":
      return t = await import("./crosshair.Bxdu5NBb-Bxdu5NBb.mjs"), d(t.default);
    case "crown_filled":
      return t = await import("./crown-filled.DavTc61R-DavTc61R.mjs"), d(t.default);
    case "crown":
      return t = await import("./crown.NozS8Xsh-NozS8Xsh.mjs"), d(t.default);
    case "cube_filled":
      return t = await import("./cube-filled.B2ENbPNx-B2ENbPNx.mjs"), d(t.default);
    case "cube_magnifier_filled":
      return t = await import("./cube-magnifier-filled.Cp7oaxiB-Cp7oaxiB.mjs"), d(t.default);
    case "cube_magnifier":
      return t = await import("./cube-magnifier.DDenHdQF-DDenHdQF.mjs"), d(t.default);
    case "cube_sparkle_filled":
      return t = await import("./cube-sparkle-filled.DfFyleeO-DfFyleeO.mjs"), d(t.default);
    case "cube_sparkle":
      return t = await import("./cube-sparkle.B60V4lvq-B60V4lvq.mjs"), d(t.default);
    case "cube":
      return t = await import("./cube.Brz9km6M-Brz9km6M.mjs"), d(t.default);
    case "curly_braces":
      return t = await import("./curly-braces.CnV-XSal-CnV-XSal.mjs"), d(t.default);
    case "database_filled":
      return t = await import("./database-filled.CcqLWnN0-rqIAvwnk.mjs"), d(t.default);
    case "database":
      return t = await import("./database.l4EyPH0O-l4EyPH0O.mjs"), d(t.default);
    case "deviantart":
      return t = await import("./deviantart.C2cCZP-8-C2cCZP-8.mjs"), d(t.default);
    case "diagonal_lines_square_filled":
      return t = await import("./diagonal-lines-square-filled.CV201hUK-CV201hUK.mjs"), d(t.default);
    case "diagonal_lines_square":
      return t = await import("./diagonal-lines-square.DZDTBQzO-DZDTBQzO.mjs"), d(t.default);
    case "dictionary_filled":
      return t = await import("./dictionary-filled.D1APxzmO-D1APxzmO.mjs"), d(t.default);
    case "dictionary":
      return t = await import("./dictionary.BmpZugvr-BmpZugvr.mjs"), d(t.default);
    case "directional_pad_filled":
      return t = await import("./directional-pad-filled.CuSvQr---CuSvQr--.mjs"), d(t.default);
    case "directional_pad":
      return t = await import("./directional-pad.D-6g9Dzy-D-6g9Dzy.mjs"), d(t.default);
    case "discord":
      return t = await import("./discord.B2WdWsf0-B2WdWsf0.mjs"), d(t.default);
    case "display_filled":
      return t = await import("./display-filled.BcV79d06-BcV79d06.mjs"), d(t.default);
    case "display_x_mark_filled":
      return t = await import("./display-x-mark-filled.Cx4VG6J--Cx4VG6J-.mjs"), d(t.default);
    case "display_x_mark":
      return t = await import("./display-x-mark.CFsdkgfU-CFsdkgfU.mjs"), d(t.default);
    case "display":
      return t = await import("./display.C-8ye7uF-C-8ye7uF.mjs"), d(t.default);
    case "dollar_sign_circle_filled":
      return t = await import("./dollar-sign-circle-filled.BRy5LSgC-BRy5LSgC.mjs"), d(t.default);
    case "dollar_sign_circle":
      return t = await import("./dollar-sign-circle.TbibnKkz-TbibnKkz.mjs"), d(t.default);
    case "dot_square_filled":
      return t = await import("./dot-square-filled.Ds26I_g2-Ds26I_g2.mjs"), d(t.default);
    case "dot_square":
      return t = await import("./dot-square.A5NIskX--A5NIskX-.mjs"), d(t.default);
    case "drag_handle_horizontal":
      return t = await import("./drag-handle-horizontal.CkdadBXU-CkdadBXU.mjs"), d(t.default);
    case "drag_handle_vertical":
      return t = await import("./drag-handle-vertical.BvzXTSgY-BvzXTSgY.mjs"), d(t.default);
    case "drop_cap":
      return t = await import("./drop-cap.C9zxjf-U-C9zxjf-U.mjs"), d(t.default);
    case "drop_dashed_circle":
      return t = await import("./drop-dashed-circle.DefCwMVo-DefCwMVo.mjs"), d(t.default);
    case "drop_filled":
      return t = await import("./drop-filled.CEUTVvVA-CEUTVvVA.mjs"), d(t.default);
    case "drop":
      return t = await import("./drop.D-3GMUVI-D-3GMUVI.mjs"), d(t.default);
    case "dropbox":
      return t = await import("./dropbox.WBW2mzd7-WBW2mzd7.mjs"), d(t.default);
    case "drum_filled":
      return t = await import("./drum-filled.BlGiKHDO-BlGiKHDO.mjs"), d(t.default);
    case "drum":
      return t = await import("./drum.BZXfitMD-BZXfitMD.mjs"), d(t.default);
    case "dual_display_filled":
      return t = await import("./dual-display-filled.soY-SY7x-soY-SY7x.mjs"), d(t.default);
    case "dual_display":
      return t = await import("./dual-display.CBW5EAw_-CBW5EAw_.mjs"), d(t.default);
    case "earth_filled":
      return t = await import("./earth-filled.DfOovZJa-DfOovZJa.mjs"), d(t.default);
    case "earth_location_filled":
      return t = await import("./earth-location-filled.Z_ukiaHu-Z_ukiaHu.mjs"), d(t.default);
    case "earth_location":
      return t = await import("./earth-location.BSnuHx8n-BSnuHx8n.mjs"), d(t.default);
    case "earth":
      return t = await import("./earth.BRLLXJJZ-BRLLXJJZ.mjs"), d(t.default);
    case "ellipsis_horizontal_circle_filled":
      return t = await import("./ellipsis-horizontal-circle-filled.CRCSrley-CRCSrley.mjs"), d(t.default);
    case "ellipsis_horizontal_circle":
      return t = await import("./ellipsis-horizontal-circle.DZ6DZuzn-DZ6DZuzn.mjs"), d(t.default);
    case "ellipsis_horizontal":
      return t = await import("./ellipsis-horizontal.DOEH26Ht-DOEH26Ht.mjs"), d(t.default);
    case "ellipsis_vertical_circle_filled":
      return t = await import("./ellipsis-vertical-circle-filled.B_R8UVOs-B_R8UVOs.mjs"), d(t.default);
    case "ellipsis_vertical_circle":
      return t = await import("./ellipsis-vertical-circle.DZTcjqtW-DZTcjqtW.mjs"), d(t.default);
    case "ellipsis_vertical":
      return t = await import("./ellipsis-vertical.DHNn5ooc-DHNn5ooc.mjs"), d(t.default);
    case "emoji_child_filled":
      return t = await import("./emoji-child-filled.CqVXu7dF-CqVXu7dF.mjs"), d(t.default);
    case "emoji_child":
      return t = await import("./emoji-child.4PLkOhGU-4PLkOhGU.mjs"), d(t.default);
    case "emoji_happy_filled":
      return t = await import("./emoji-happy-filled.CNe1cHC9-CNe1cHC9.mjs"), d(t.default);
    case "emoji_happy":
      return t = await import("./emoji-happy.B0V2KPJK-B0V2KPJK.mjs"), d(t.default);
    case "emoji_neutral_filled":
      return t = await import("./emoji-neutral-filled.BIszb6vh-BIszb6vh.mjs"), d(t.default);
    case "emoji_neutral":
      return t = await import("./emoji-neutral.B0ETdtSC-B0ETdtSC.mjs"), d(t.default);
    case "emoji_plus_filled":
      return t = await import("./emoji-plus-filled.CKwIBnik-CKwIBnik.mjs"), d(t.default);
    case "emoji_plus":
      return t = await import("./emoji-plus.a_HGZiN--a_HGZiN-.mjs"), d(t.default);
    case "emoji_sad_filled":
      return t = await import("./emoji-sad-filled.BMn8QgXy-BMn8QgXy.mjs"), d(t.default);
    case "emoji_sad":
      return t = await import("./emoji-sad.BVseo9WM-BVseo9WM.mjs"), d(t.default);
    case "emoji_smile_filled":
      return t = await import("./emoji-smile-filled.CWARXIby-CWARXIby.mjs"), d(t.default);
    case "emoji_smile":
      return t = await import("./emoji-smile.qIei2cvx-qIei2cvx.mjs"), d(t.default);
    case "envelope_arrows_filled":
      return t = await import("./envelope-arrows-filled.CeU5eHtI-CeU5eHtI.mjs"), d(t.default);
    case "envelope_arrows":
      return t = await import("./envelope-arrows.Cr8noEA0-Cr8noEA0.mjs"), d(t.default);
    case "envelope_cogwheel_filled":
      return t = await import("./envelope-cogwheel-filled.DJQ5uMRw-DJQ5uMRw.mjs"), d(t.default);
    case "envelope_cogwheel":
      return t = await import("./envelope-cogwheel.FIIGFLrV-FIIGFLrV.mjs"), d(t.default);
    case "envelope_filled":
      return t = await import("./envelope-filled.ChTf0boF-ChTf0boF.mjs"), d(t.default);
    case "envelope_open_filled":
      return t = await import("./envelope-open-filled.DID_Dgz2-B7Ctm1t3.mjs"), d(t.default);
    case "envelope_open":
      return t = await import("./envelope-open.CBl47bSD-CBl47bSD.mjs"), d(t.default);
    case "envelope_pen_filled":
      return t = await import("./envelope-pen-filled.De5VlQay-smGwtfoF.mjs"), d(t.default);
    case "envelope_pen":
      return t = await import("./envelope-pen.CR73weLy-CR73weLy.mjs"), d(t.default);
    case "envelope_question_filled":
      return t = await import("./envelope-question-filled.CQd_x1kU-CQd_x1kU.mjs"), d(t.default);
    case "envelope_question":
      return t = await import("./envelope-question.C7HhYbrO-C7HhYbrO.mjs"), d(t.default);
    case "envelope_x_mark_filled":
      return t = await import("./envelope-x-mark-filled.By-Pg6ZU-By-Pg6ZU.mjs"), d(t.default);
    case "envelope_x_mark":
      return t = await import("./envelope-x-mark.CJ6LFw-2-CJ6LFw-2.mjs"), d(t.default);
    case "envelope":
      return t = await import("./envelope.DlV9aFhN-DlV9aFhN.mjs"), d(t.default);
    case "epic_games":
      return t = await import("./epic-games.CmGk1B-o-CmGk1B-o.mjs"), d(t.default);
    case "epic_rewards_filled":
      return t = await import("./epic-rewards-filled.B-GPKbMr-B-GPKbMr.mjs"), d(t.default);
    case "epic_rewards":
      return t = await import("./epic-rewards.CwnhiUZT-CwnhiUZT.mjs"), d(t.default);
    case "epic":
      return t = await import("./epic.1KTH7Myg-1KTH7Myg.mjs"), d(t.default);
    case "eraser_filled":
      return t = await import("./eraser-filled.Bp_rvpb3-Bp_rvpb3.mjs"), d(t.default);
    case "eraser":
      return t = await import("./eraser.CwS6rV9c-CwS6rV9c.mjs"), d(t.default);
    case "euro_sign_circle_filled":
      return t = await import("./euro-sign-circle-filled.LOAEoz7k-LOAEoz7k.mjs"), d(t.default);
    case "euro_sign_circle":
      return t = await import("./euro-sign-circle.8f4aJvVu-8f4aJvVu.mjs"), d(t.default);
    case "exclamation_circle_filled":
      return t = await import("./exclamation-circle-filled.BaM-ex0w-KColAWuM.mjs"), d(t.default);
    case "exclamation_circle":
      return t = await import("./exclamation-circle.DpBL6A1g-DpBL6A1g.mjs"), d(t.default);
    case "exclamation_triangle_filled":
      return t = await import("./exclamation-triangle-filled.MohopSTx-MohopSTx.mjs"), d(t.default);
    case "exclamation_triangle":
      return t = await import("./exclamation-triangle.DPbnpARE-DPbnpARE.mjs"), d(t.default);
    case "expand":
      return t = await import("./expand.CM1yEZX4-CM1yEZX4.mjs"), d(t.default);
    case "external_drive_filled":
      return t = await import("./external-drive-filled.DVIWi29Q-DVIWi29Q.mjs"), d(t.default);
    case "external_drive":
      return t = await import("./external-drive.jKRDTOMZ-jKRDTOMZ.mjs"), d(t.default);
    case "eye_dropper_filled":
      return t = await import("./eye-dropper-filled.CplU4fFP-CDFEkRCR.mjs"), d(t.default);
    case "eye_dropper":
      return t = await import("./eye-dropper.s3fBiUq1-s3fBiUq1.mjs"), d(t.default);
    case "eye_filled":
      return t = await import("./eye-filled.BzHX-xGD-BzHX-xGD.mjs"), d(t.default);
    case "eye_slash_filled":
      return t = await import("./eye-slash-filled.DGYuXb8T-DGYuXb8T.mjs"), d(t.default);
    case "eye_slash":
      return t = await import("./eye-slash.BTmqWULm-BTmqWULm.mjs"), d(t.default);
    case "eye":
      return t = await import("./eye.Ca8hiHtY-Ca8hiHtY.mjs"), d(t.default);
    case "fab":
      return t = await import("./fab.Bz3ii5GN-Bz3ii5GN.mjs"), d(t.default);
    case "facebook":
      return t = await import("./facebook.CWLejaHJ-CWLejaHJ.mjs"), d(t.default);
    case "fall_guys":
      return t = await import("./fall-guys.DtJN9g2N-DtJN9g2N.mjs"), d(t.default);
    case "figma":
      return t = await import("./figma.CNJs0QxO-CNJs0QxO.mjs"), d(t.default);
    case "figure_rigged":
      return t = await import("./figure-rigged.DZ6FuJOB-DZ6FuJOB.mjs"), d(t.default);
    case "file_check_filled":
      return t = await import("./file-check-filled._XbeSzlI-_XbeSzlI.mjs"), d(t.default);
    case "file_check":
      return t = await import("./file-check.P1ft5sZ7-P1ft5sZ7.mjs"), d(t.default);
    case "file_code_filled":
      return t = await import("./file-code-filled.DmVggtrI-DmVggtrI.mjs"), d(t.default);
    case "file_code":
      return t = await import("./file-code.mxAEZh5u-mxAEZh5u.mjs"), d(t.default);
    case "file_cogwheel_filled":
      return t = await import("./file-cogwheel-filled.dOmSaaQm-dOmSaaQm.mjs"), d(t.default);
    case "file_cogwheel":
      return t = await import("./file-cogwheel.BmMdd5_J-BmMdd5_J.mjs"), d(t.default);
    case "file_filled":
      return t = await import("./file-filled.tILKDx7o-tILKDx7o.mjs"), d(t.default);
    case "file_lines_filled":
      return t = await import("./file-lines-filled.BXRaTIw7-BXRaTIw7.mjs"), d(t.default);
    case "file_lines":
      return t = await import("./file-lines.CV0rqSHA-CV0rqSHA.mjs"), d(t.default);
    case "file_magnifier_filled":
      return t = await import("./file-magnifier-filled.d_QzWEUX-d_QzWEUX.mjs"), d(t.default);
    case "file_magnifier":
      return t = await import("./file-magnifier.th7Q8is1-th7Q8is1.mjs"), d(t.default);
    case "file_minus_filled":
      return t = await import("./file-minus-filled.BiqRIxcj-BiqRIxcj.mjs"), d(t.default);
    case "file_minus":
      return t = await import("./file-minus.CQSI9Bze-CQSI9Bze.mjs"), d(t.default);
    case "file_pen_filled":
      return t = await import("./file-pen-filled.CISTbAbi-CISTbAbi.mjs"), d(t.default);
    case "file_pen":
      return t = await import("./file-pen.BVzFHbiU-BVzFHbiU.mjs"), d(t.default);
    case "file_plus_filled":
      return t = await import("./file-plus-filled.CUl1EFKT-CUl1EFKT.mjs"), d(t.default);
    case "file_plus":
      return t = await import("./file-plus.BvQCWK9w-BvQCWK9w.mjs"), d(t.default);
    case "file_x_mark_filled":
      return t = await import("./file-x-mark-filled.D4bYOPP3-D4bYOPP3.mjs"), d(t.default);
    case "file_x_mark":
      return t = await import("./file-x-mark.CpX6v-FN-CpX6v-FN.mjs"), d(t.default);
    case "file_zipper_filled":
      return t = await import("./file-zipper-filled.DLZvuPZJ-DLZvuPZJ.mjs"), d(t.default);
    case "file_zipper":
      return t = await import("./file-zipper.UBof_-iU-UBof_-iU.mjs"), d(t.default);
    case "file":
      return t = await import("./file.epELrrqh-epELrrqh.mjs"), d(t.default);
    case "film":
      return t = await import("./film.C8XW5zTN-C8XW5zTN.mjs"), d(t.default);
    case "fingerprint":
      return t = await import("./fingerprint.BvewPip5-BvewPip5.mjs"), d(t.default);
    case "flag_filled":
      return t = await import("./flag-filled.D5oF75gl-D5oF75gl.mjs"), d(t.default);
    case "flag_slash_filled":
      return t = await import("./flag-slash-filled.DUKd0ERb-DUKd0ERb.mjs"), d(t.default);
    case "flag_slash":
      return t = await import("./flag-slash.BnQT-iF3-BnQT-iF3.mjs"), d(t.default);
    case "flag":
      return t = await import("./flag.BMydsXYT-BMydsXYT.mjs"), d(t.default);
    case "flame_filled":
      return t = await import("./flame-filled.BcAhpYDe-BcAhpYDe.mjs"), d(t.default);
    case "flame":
      return t = await import("./flame.pgQFTXm5-pgQFTXm5.mjs"), d(t.default);
    case "floppy_disk_filled":
      return t = await import("./floppy-disk-filled.PgenmmWf-PgenmmWf.mjs"), d(t.default);
    case "floppy_disk":
      return t = await import("./floppy-disk.BHaKUDjl-BHaKUDjl.mjs"), d(t.default);
    case "flower_filled":
      return t = await import("./flower-filled.DJyXkykh-DJyXkykh.mjs"), d(t.default);
    case "flower":
      return t = await import("./flower.D2abzcXl-D2abzcXl.mjs"), d(t.default);
    case "folder_check_filled":
      return t = await import("./folder-check-filled.DnJwC_Ht-DnJwC_Ht.mjs"), d(t.default);
    case "folder_check":
      return t = await import("./folder-check.BUIIm4XN-BUIIm4XN.mjs"), d(t.default);
    case "folder_closed_filled":
      return t = await import("./folder-closed-filled.X9ETt8gc-X9ETt8gc.mjs"), d(t.default);
    case "folder_closed":
      return t = await import("./folder-closed.BxX2zATN-BxX2zATN.mjs"), d(t.default);
    case "folder_code_filled":
      return t = await import("./folder-code-filled.D1hA9u2p-D1hA9u2p.mjs"), d(t.default);
    case "folder_code":
      return t = await import("./folder-code.VLoy4zI8-VLoy4zI8.mjs"), d(t.default);
    case "folder_cogwheel_filled":
      return t = await import("./folder-cogwheel-filled.C3ASa2cm-C3ASa2cm.mjs"), d(t.default);
    case "folder_cogwheel":
      return t = await import("./folder-cogwheel.COApbwwd-COApbwwd.mjs"), d(t.default);
    case "folder_filled":
      return t = await import("./folder-filled.Cn9n_jlY-Cn9n_jlY.mjs"), d(t.default);
    case "folder_magnifier_filled":
      return t = await import("./folder-magnifier-filled.DyTVpPHb-DyTVpPHb.mjs"), d(t.default);
    case "folder_magnifier":
      return t = await import("./folder-magnifier.CQYB75xo-CQYB75xo.mjs"), d(t.default);
    case "folder_minus_filled":
      return t = await import("./folder-minus-filled.CkLqNWqF-CkLqNWqF.mjs"), d(t.default);
    case "folder_minus":
      return t = await import("./folder-minus.Ckg6YjAg-Ckg6YjAg.mjs"), d(t.default);
    case "folder_open_filled":
      return t = await import("./folder-open-filled.3_YNJaqs-3_YNJaqs.mjs"), d(t.default);
    case "folder_open":
      return t = await import("./folder-open.BpfswKWN-BpfswKWN.mjs"), d(t.default);
    case "folder_pen_filled":
      return t = await import("./folder-pen-filled.UbpsUQ6p-UbpsUQ6p.mjs"), d(t.default);
    case "folder_pen":
      return t = await import("./folder-pen.Dww-a5g--Dww-a5g-.mjs"), d(t.default);
    case "folder_plus_filled":
      return t = await import("./folder-plus-filled.BS6r7mYK-BS6r7mYK.mjs"), d(t.default);
    case "folder_plus":
      return t = await import("./folder-plus.COxH_6MF-COxH_6MF.mjs"), d(t.default);
    case "folder_user_filled":
      return t = await import("./folder-user-filled.CkiOLqaW-CkiOLqaW.mjs"), d(t.default);
    case "folder_user":
      return t = await import("./folder-user.DkOW-U6z-DkOW-U6z.mjs"), d(t.default);
    case "folder_x_mark_filled":
      return t = await import("./folder-x-mark-filled.v3lEviAe-v3lEviAe.mjs"), d(t.default);
    case "folder_x_mark":
      return t = await import("./folder-x-mark.DGXMrVAo-DGXMrVAo.mjs"), d(t.default);
    case "folder":
      return t = await import("./folder.DZ-mrfbu-DZ-mrfbu.mjs"), d(t.default);
    case "fork":
      return t = await import("./fork.lKZJthgq-lKZJthgq.mjs"), d(t.default);
    case "formatting_slash":
      return t = await import("./formatting-slash.8GeaWUmP-8GeaWUmP.mjs"), d(t.default);
    case "fortnite_creative":
      return t = await import("./fortnite-creative.BbwWZyZy-BbwWZyZy.mjs"), d(t.default);
    case "fortnite":
      return t = await import("./fortnite.CtY6BOT6-CtY6BOT6.mjs"), d(t.default);
    case "forward_end_filled":
      return t = await import("./forward-end-filled.iKY72de2-iKY72de2.mjs"), d(t.default);
    case "forward_end":
      return t = await import("./forward-end.BCZ2G9BT-BCZ2G9BT.mjs"), d(t.default);
    case "forward_filled":
      return t = await import("./forward-filled.CtDyHXCr-CtDyHXCr.mjs"), d(t.default);
    case "forward":
      return t = await import("./forward.CwSk1HSX-CwSk1HSX.mjs"), d(t.default);
    case "four_lines_horizontal_align_center":
      return t = await import("./four-lines-horizontal-align-center.DSQ7-vdv-DSQ7-vdv.mjs"), d(t.default);
    case "four_lines_horizontal_align_left":
      return t = await import("./four-lines-horizontal-align-left.DO6LgGtf-DO6LgGtf.mjs"), d(t.default);
    case "four_lines_horizontal_align_right":
      return t = await import("./four-lines-horizontal-align-right.DL9OVcqi-DL9OVcqi.mjs"), d(t.default);
    case "four_lines_horizontal":
      return t = await import("./four-lines-horizontal.CqFKbFAs-CqFKbFAs.mjs"), d(t.default);
    case "funnel_filled":
      return t = await import("./funnel-filled.CLu168-c-DXpLDZCf.mjs"), d(t.default);
    case "funnel":
      return t = await import("./funnel.COD--Kka-COD--Kka.mjs"), d(t.default);
    case "gamepad_check_filled":
      return t = await import("./gamepad-check-filled.Bn6nNuuM-Bn6nNuuM.mjs"), d(t.default);
    case "gamepad_check":
      return t = await import("./gamepad-check.Dmybu2_8-Dmybu2_8.mjs"), d(t.default);
    case "gamepad_cogwheel_filled":
      return t = await import("./gamepad-cogwheel-filled.xOH2Yalp-xOH2Yalp.mjs"), d(t.default);
    case "gamepad_cogwheel":
      return t = await import("./gamepad-cogwheel.CdPHS5Ei-CdPHS5Ei.mjs"), d(t.default);
    case "gamepad_filled":
      return t = await import("./gamepad-filled.BBPDs0Ml-BBPDs0Ml.mjs"), d(t.default);
    case "gamepad_minus_filled":
      return t = await import("./gamepad-minus-filled.CaXnGp6--CaXnGp6-.mjs"), d(t.default);
    case "gamepad_minus":
      return t = await import("./gamepad-minus.srY4A1JP-srY4A1JP.mjs"), d(t.default);
    case "gamepad_plus_filled":
      return t = await import("./gamepad-plus-filled.B4ldW8nY-B4ldW8nY.mjs"), d(t.default);
    case "gamepad_plus":
      return t = await import("./gamepad-plus.BBLqxFaU-BBLqxFaU.mjs"), d(t.default);
    case "gamepad_trend_up_filled":
      return t = await import("./gamepad-trend-up-filled.DvhMbxJx-DvhMbxJx.mjs"), d(t.default);
    case "gamepad_trend_up":
      return t = await import("./gamepad-trend-up.D9nm0PkX-D9nm0PkX.mjs"), d(t.default);
    case "gamepad_x_mark_filled":
      return t = await import("./gamepad-x-mark-filled.ClcdE2RM-ClcdE2RM.mjs"), d(t.default);
    case "gamepad_x_mark":
      return t = await import("./gamepad-x-mark.BedMQhAS-BedMQhAS.mjs"), d(t.default);
    case "gamepad":
      return t = await import("./gamepad.C_jEoUgx-C_jEoUgx.mjs"), d(t.default);
    case "ghost_filled":
      return t = await import("./ghost-filled.BFjPtU_D-BFjPtU_D.mjs"), d(t.default);
    case "ghost":
      return t = await import("./ghost.HjUr36uP-HjUr36uP.mjs"), d(t.default);
    case "gif":
      return t = await import("./gif.DY-QRYTe-DY-QRYTe.mjs"), d(t.default);
    case "gift_arrow_left_filled":
      return t = await import("./gift-arrow-left-filled.CocjqU1q-CocjqU1q.mjs"), d(t.default);
    case "gift_arrow_left":
      return t = await import("./gift-arrow-left.Ck2H92Wq-Ck2H92Wq.mjs"), d(t.default);
    case "gift_arrow_right_filled":
      return t = await import("./gift-arrow-right-filled.Dk7jIziR-Dk7jIziR.mjs"), d(t.default);
    case "gift_arrow_right":
      return t = await import("./gift-arrow-right.B5qwg396-B5qwg396.mjs"), d(t.default);
    case "gift_card_filled":
      return t = await import("./gift-card-filled.2nBiRD2x-2nBiRD2x.mjs"), d(t.default);
    case "gift_card":
      return t = await import("./gift-card.Du29hKuU-Du29hKuU.mjs"), d(t.default);
    case "gift_filled":
      return t = await import("./gift-filled.CYBN45OC-CYBN45OC.mjs"), d(t.default);
    case "gift":
      return t = await import("./gift.flgden0a-flgden0a.mjs"), d(t.default);
    case "github":
      return t = await import("./github.bQxfAREC-bQxfAREC.mjs"), d(t.default);
    case "gizmo":
      return t = await import("./gizmo.DJIBJdIH-DJIBJdIH.mjs"), d(t.default);
    case "glasses_filled":
      return t = await import("./glasses-filled.6VHSi7gU-CRz1oEem.mjs"), d(t.default);
    case "glasses":
      return t = await import("./glasses.BDPcWI0I-BDPcWI0I.mjs"), d(t.default);
    case "globe_location":
      return t = await import("./globe-location.DsXwPNWa-DsXwPNWa.mjs"), d(t.default);
    case "globe":
      return t = await import("./globe.D8CEr5Rm-D8CEr5Rm.mjs"), d(t.default);
    case "google":
      return t = await import("./google.Duxu2Rwu-Duxu2Rwu.mjs"), d(t.default);
    case "graduation_cap_filled":
      return t = await import("./graduation-cap-filled.94x6YcsH-94x6YcsH.mjs"), d(t.default);
    case "graduation_cap":
      return t = await import("./graduation-cap.BiTGthmj-BiTGthmj.mjs"), d(t.default);
    case "guitar_filled":
      return t = await import("./guitar-filled.BY0abHt8-BY0abHt8.mjs"), d(t.default);
    case "guitar":
      return t = await import("./guitar.DnDSaGQa-DnDSaGQa.mjs"), d(t.default);
    case "hand_heart_filled":
      return t = await import("./hand-heart-filled.pKqMlm7K-pKqMlm7K.mjs"), d(t.default);
    case "hand_heart":
      return t = await import("./hand-heart.DDv_G76q-DDv_G76q.mjs"), d(t.default);
    case "hashtag":
      return t = await import("./hashtag.BXELwIsz-BXELwIsz.mjs"), d(t.default);
    case "heading":
      return t = await import("./heading.DQofBerc-DQofBerc.mjs"), d(t.default);
    case "headphones_filled":
      return t = await import("./headphones-filled.CCJCeDIq-CCJCeDIq.mjs"), d(t.default);
    case "headphones_mic_filled":
      return t = await import("./headphones-mic-filled.D8-9Jr3Q-D8-9Jr3Q.mjs"), d(t.default);
    case "headphones_mic":
      return t = await import("./headphones-mic.BRMC_Bas-BRMC_Bas.mjs"), d(t.default);
    case "headphones_slash_filled":
      return t = await import("./headphones-slash-filled.BGU7aofb-BGU7aofb.mjs"), d(t.default);
    case "headphones_slash":
      return t = await import("./headphones-slash.du49R52f-du49R52f.mjs"), d(t.default);
    case "headphones":
      return t = await import("./headphones.Dxp07Onb-Dxp07Onb.mjs"), d(t.default);
    case "heart_filled":
      return t = await import("./heart-filled.Bmdl619Q-Bmdl619Q.mjs"), d(t.default);
    case "heart":
      return t = await import("./heart.DXqt3Wa9-DXqt3Wa9.mjs"), d(t.default);
    case "highlight_shadow_circle_filled":
      return t = await import("./highlight-shadow-circle-filled.SxUK3rsw-SxUK3rsw.mjs"), d(t.default);
    case "highlight_shadow_circle":
      return t = await import("./highlight-shadow-circle.DejKxlZt-DejKxlZt.mjs"), d(t.default);
    case "hook":
      return t = await import("./hook.DRjdkMzz-DRjdkMzz.mjs"), d(t.default);
    case "houdini":
      return t = await import("./houdini.BL4oFaIb-D8GZXYzX.mjs"), d(t.default);
    case "hourglass_filled":
      return t = await import("./hourglass-filled.C8k7GEt3-C8k7GEt3.mjs"), d(t.default);
    case "hourglass":
      return t = await import("./hourglass.Cs8u55dh-Cs8u55dh.mjs"), d(t.default);
    case "house_filled":
      return t = await import("./house-filled.Dtjsp_eL-Dtjsp_eL.mjs"), d(t.default);
    case "house":
      return t = await import("./house.2c061fn2-2c061fn2.mjs"), d(t.default);
    case "id_card_filled":
      return t = await import("./id-card-filled.BIoxbhU3-BIoxbhU3.mjs"), d(t.default);
    case "id_card_pen_filled":
      return t = await import("./id-card-pen-filled.1Ge_Ah8F-1Ge_Ah8F.mjs"), d(t.default);
    case "id_card_pen":
      return t = await import("./id-card-pen.CrUWxAEC-CrUWxAEC.mjs"), d(t.default);
    case "id_card":
      return t = await import("./id-card.D5Jted5A-D5Jted5A.mjs"), d(t.default);
    case "image_carousel_filled":
      return t = await import("./image-carousel-filled.BVmDtRVp-BVmDtRVp.mjs"), d(t.default);
    case "image_carousel":
      return t = await import("./image-carousel.9qL2PlXz-9qL2PlXz.mjs"), d(t.default);
    case "image_filled":
      return t = await import("./image-filled.Bdi2T4HW-Bdi2T4HW.mjs"), d(t.default);
    case "image_landscape_filled":
      return t = await import("./image-landscape-filled.DVHNtGuv-DVHNtGuv.mjs"), d(t.default);
    case "image_landscape_magnifier_filled":
      return t = await import("./image-landscape-magnifier-filled.B4p6_s0o-B4p6_s0o.mjs"), d(t.default);
    case "image_landscape_magnifier":
      return t = await import("./image-landscape-magnifier.Czr9GdNG-Czr9GdNG.mjs"), d(t.default);
    case "image_landscape":
      return t = await import("./image-landscape.BbyQ0eZ4-BbyQ0eZ4.mjs"), d(t.default);
    case "image_panorama_filled":
      return t = await import("./image-panorama-filled.C9hDm5JE-C9hDm5JE.mjs"), d(t.default);
    case "image_panorama":
      return t = await import("./image-panorama.DciNIkt0-DciNIkt0.mjs"), d(t.default);
    case "image_polaroid_filled":
      return t = await import("./image-polaroid-filled.Dfkp7NVB-Dfkp7NVB.mjs"), d(t.default);
    case "image_polaroid":
      return t = await import("./image-polaroid.CLit_8Hq-CLit_8Hq.mjs"), d(t.default);
    case "image_slash_filled":
      return t = await import("./image-slash-filled.yZgj-Anr-yZgj-Anr.mjs"), d(t.default);
    case "image_slash":
      return t = await import("./image-slash.DiyCEgQ0-DiyCEgQ0.mjs"), d(t.default);
    case "image":
      return t = await import("./image.Co6iiQhC-Co6iiQhC.mjs"), d(t.default);
    case "images_stacked_filled":
      return t = await import("./images-stacked-filled.BN0-s5XU-BN0-s5XU.mjs"), d(t.default);
    case "images_stacked":
      return t = await import("./images-stacked.BGX-zsHe-BGX-zsHe.mjs"), d(t.default);
    case "imdb":
      return t = await import("./imdb.C0QnF8Fm-C0QnF8Fm.mjs"), d(t.default);
    case "infinity":
      return t = await import("./infinity.sBOBEAps-IPnkUukV.mjs"), d(t.default);
    case "info_circle_filled":
      return t = await import("./info-circle-filled.C2DVOR-A-C2DVOR-A.mjs"), d(t.default);
    case "info_circle":
      return t = await import("./info-circle.CdVaFPWm-CdVaFPWm.mjs"), d(t.default);
    case "instagram":
      return t = await import("./instagram.BeFLUKil-BeFLUKil.mjs"), d(t.default);
    case "italic":
      return t = await import("./italic.z5bk6dDf-z5bk6dDf.mjs"), d(t.default);
    case "jpg":
      return t = await import("./jpg.Cl5FUfgB-Cl5FUfgB.mjs"), d(t.default);
    case "key_filled":
      return t = await import("./key-filled.B9QZheQU-B9QZheQU.mjs"), d(t.default);
    case "key":
      return t = await import("./key.CRz1S3t9-CRz1S3t9.mjs"), d(t.default);
    case "keyboard_filled":
      return t = await import("./keyboard-filled.DF4S-FU6-DF4S-FU6.mjs"), d(t.default);
    case "keyboard":
      return t = await import("./keyboard.DFV_zk2v-DFV_zk2v.mjs"), d(t.default);
    case "keytar_filled":
      return t = await import("./keytar-filled.fpzRbz1Z-fpzRbz1Z.mjs"), d(t.default);
    case "keytar":
      return t = await import("./keytar.B-wxuQUg-B-wxuQUg.mjs"), d(t.default);
    case "kids_web_services":
      return t = await import("./kids-web-services.FNW89m6u-FNW89m6u.mjs"), d(t.default);
    case "lab_beaker_filled":
      return t = await import("./lab-beaker-filled.DKsRKnEG-DKsRKnEG.mjs"), d(t.default);
    case "lab_beaker":
      return t = await import("./lab-beaker.DTZBvCxp-DTZBvCxp.mjs"), d(t.default);
    case "lamp_filled":
      return t = await import("./lamp-filled.v3WZ6sP2-v3WZ6sP2.mjs"), d(t.default);
    case "lamp":
      return t = await import("./lamp.tqui30AC-tqui30AC.mjs"), d(t.default);
    case "language":
      return t = await import("./language.CBcOq1T6-CBcOq1T6.mjs"), d(t.default);
    case "laptop_filled":
      return t = await import("./laptop-filled.DM9bSaUu-DM9bSaUu.mjs"), d(t.default);
    case "laptop":
      return t = await import("./laptop._Gs8m8bS-_Gs8m8bS.mjs"), d(t.default);
    case "layout_1_filled":
      return t = await import("./layout-1-filled.BOgrL00I-BOgrL00I.mjs"), d(t.default);
    case "layout_1":
      return t = await import("./layout-1._XHZ-sT_-_XHZ-sT_.mjs"), d(t.default);
    case "layout_2_filled":
      return t = await import("./layout-2-filled.Buzme8yX-Buzme8yX.mjs"), d(t.default);
    case "layout_2":
      return t = await import("./layout-2.C2YLR-Rn-C2YLR-Rn.mjs"), d(t.default);
    case "layout_3_filled":
      return t = await import("./layout-3-filled.CWkiBupM-CWkiBupM.mjs"), d(t.default);
    case "layout_3":
      return t = await import("./layout-3.CkIMv5hx-CkIMv5hx.mjs"), d(t.default);
    case "layout_4_filled":
      return t = await import("./layout-4-filled.ylGgpC_u-ylGgpC_u.mjs"), d(t.default);
    case "layout_4":
      return t = await import("./layout-4.BctsRe-P-BctsRe-P.mjs"), d(t.default);
    case "layout_5_filled":
      return t = await import("./layout-5-filled.Bq4mdM9m-Bq4mdM9m.mjs"), d(t.default);
    case "layout_5":
      return t = await import("./layout-5.7UcEtZZf-7UcEtZZf.mjs"), d(t.default);
    case "layout_6_filled":
      return t = await import("./layout-6-filled.CiO9J99y-CiO9J99y.mjs"), d(t.default);
    case "layout_6":
      return t = await import("./layout-6.D4TwwXKd-D4TwwXKd.mjs"), d(t.default);
    case "leaf_filled":
      return t = await import("./leaf-filled.ioGqJOl9-ioGqJOl9.mjs"), d(t.default);
    case "leaf":
      return t = await import("./leaf.BaB0ucN9-BaB0ucN9.mjs"), d(t.default);
    case "legal_hammer_filled":
      return t = await import("./legal-hammer-filled.nI5rcC_5-nI5rcC_5.mjs"), d(t.default);
    case "legal_hammer_slash_filled":
      return t = await import("./legal-hammer-slash-filled.Biv_OQ_B-DNPy0KcQ.mjs"), d(t.default);
    case "legal_hammer_slash":
      return t = await import("./legal-hammer-slash.BlR7pNpU-BlR7pNpU.mjs"), d(t.default);
    case "legal_hammer":
      return t = await import("./legal-hammer.BqFkVtsC-BqFkVtsC.mjs"), d(t.default);
    case "lego_brick_filled":
      return t = await import("./lego-brick-filled.COqhg9W5-COqhg9W5.mjs"), d(t.default);
    case "lego_brick":
      return t = await import("./lego-brick.BPSMUHEX-BPSMUHEX.mjs"), d(t.default);
    case "lego_head_filled":
      return t = await import("./lego-head-filled.CrVh3nHM-CrVh3nHM.mjs"), d(t.default);
    case "lego_head":
      return t = await import("./lego-head.CEKZXem7-CEKZXem7.mjs"), d(t.default);
    case "lego":
      return t = await import("./lego.CVTTcAPJ-CVTTcAPJ.mjs"), d(t.default);
    case "letter_m_arrow_down_rectangle_filled":
      return t = await import("./letter-m-arrow-down-rectangle-filled.BiCYaz15-BiCYaz15.mjs"), d(t.default);
    case "letter_m_arrow_down_rectangle":
      return t = await import("./letter-m-arrow-down-rectangle.BZT2bvPT-BZT2bvPT.mjs"), d(t.default);
    case "life_preserver":
      return t = await import("./life-preserver.5NbwI7Kj-5NbwI7Kj.mjs"), d(t.default);
    case "lightbulb_filled":
      return t = await import("./lightbulb-filled.23JglFsC-23JglFsC.mjs"), d(t.default);
    case "lightbulb":
      return t = await import("./lightbulb.CSGDi2fR-CSGDi2fR.mjs"), d(t.default);
    case "line_bars_vertical":
      return t = await import("./line-bars-vertical.Cp3CmZqz-Cp3CmZqz.mjs"), d(t.default);
    case "lines_horizontal":
      return t = await import("./lines-horizontal.BZFgMcme-BZFgMcme.mjs"), d(t.default);
    case "lines_square_stack_filled":
      return t = await import("./lines-square-stack-filled.CTF_du-2-CTF_du-2.mjs"), d(t.default);
    case "lines_square_stack":
      return t = await import("./lines-square-stack.BIAKPiUh-BIAKPiUh.mjs"), d(t.default);
    case "link_broken":
      return t = await import("./link-broken.DfhEuCgh-DfhEuCgh.mjs"), d(t.default);
    case "link":
      return t = await import("./link.CbZU4-EY-CbZU4-EY.mjs"), d(t.default);
    case "linkedin":
      return t = await import("./linkedin.DBhVuQHi-Dnsq4Dgk.mjs"), d(t.default);
    case "linux":
      return t = await import("./linux.CqKPV5FZ-CqKPV5FZ.mjs"), d(t.default);
    case "list_check":
      return t = await import("./list-check.Bi7yIGUM-Bi7yIGUM.mjs"), d(t.default);
    case "list_cogwheel":
      return t = await import("./list-cogwheel.7VO1mMoi-7VO1mMoi.mjs"), d(t.default);
    case "list_magnifier":
      return t = await import("./list-magnifier.BWguAe9--BWguAe9-.mjs"), d(t.default);
    case "list_minus":
      return t = await import("./list-minus.B8X_vhag-B8X_vhag.mjs"), d(t.default);
    case "list_plus":
      return t = await import("./list-plus.Cu9ZV38E-Cu9ZV38E.mjs"), d(t.default);
    case "list_timer":
      return t = await import("./list-timer.CC2qf9M8-CC2qf9M8.mjs"), d(t.default);
    case "list_x_mark":
      return t = await import("./list-x-mark.BGvxz--A-BGvxz--A.mjs"), d(t.default);
    case "loading":
      return t = await import("./loading.Dn901fkd-Dn901fkd.mjs"), d(t.default);
    case "location_drop_filled":
      return t = await import("./location-drop-filled.B2uEC8a8-B2uEC8a8.mjs"), d(t.default);
    case "location_drop":
      return t = await import("./location-drop.r42cdG18-r42cdG18.mjs"), d(t.default);
    case "lock_arrows_filled":
      return t = await import("./lock-arrows-filled.DOr3rM9t-DOr3rM9t.mjs"), d(t.default);
    case "lock_arrows":
      return t = await import("./lock-arrows.C3zXx0xU-C3zXx0xU.mjs"), d(t.default);
    case "lock_filled":
      return t = await import("./lock-filled.Dd4S6QDi-Dd4S6QDi.mjs"), d(t.default);
    case "lock_open_filled":
      return t = await import("./lock-open-filled.D81jfKfK-D81jfKfK.mjs"), d(t.default);
    case "lock_open":
      return t = await import("./lock-open.Cu1y2ll2-Cu1y2ll2.mjs"), d(t.default);
    case "lock_pen_filled":
      return t = await import("./lock-pen-filled.q2L0vR4--q2L0vR4-.mjs"), d(t.default);
    case "lock_pen":
      return t = await import("./lock-pen.Co8fptW2-Co8fptW2.mjs"), d(t.default);
    case "lock_question_filled":
      return t = await import("./lock-question-filled.BZAVIx8D-BZAVIx8D.mjs"), d(t.default);
    case "lock_question":
      return t = await import("./lock-question.DReMmFo2-DReMmFo2.mjs"), d(t.default);
    case "lock":
      return t = await import("./lock.UBt_9FfT-UBt_9FfT.mjs"), d(t.default);
    case "macos":
      return t = await import("./macos.D_OMlJe8-D_OMlJe8.mjs"), d(t.default);
    case "macro_filled":
      return t = await import("./macro-filled.dJ5wvc5F-dJ5wvc5F.mjs"), d(t.default);
    case "macro":
      return t = await import("./macro.CkbolJ0f-CkbolJ0f.mjs"), d(t.default);
    case "magazine_check_filled":
      return t = await import("./magazine-check-filled.BIX8jiuB-BIX8jiuB.mjs"), d(t.default);
    case "magazine_check":
      return t = await import("./magazine-check.is0qda6M-is0qda6M.mjs"), d(t.default);
    case "magazine_filled":
      return t = await import("./magazine-filled.CIKQlSHc-CIKQlSHc.mjs"), d(t.default);
    case "magazine_link_filled":
      return t = await import("./magazine-link-filled.ByAAiA0E-ByAAiA0E.mjs"), d(t.default);
    case "magazine_link":
      return t = await import("./magazine-link.DIlo_RDH-DIlo_RDH.mjs"), d(t.default);
    case "magazine":
      return t = await import("./magazine.FhJXREIE-FhJXREIE.mjs"), d(t.default);
    case "magnet_filled":
      return t = await import("./magnet-filled.CNEm_Bmt-CNEm_Bmt.mjs"), d(t.default);
    case "magnet":
      return t = await import("./magnet.CU43wpBp-CU43wpBp.mjs"), d(t.default);
    case "magnifier_filled":
      return t = await import("./magnifier-filled.CUSfrKp5-CUSfrKp5.mjs"), d(t.default);
    case "magnifier_minus_filled":
      return t = await import("./magnifier-minus-filled.CwNbv5Kj-CwNbv5Kj.mjs"), d(t.default);
    case "magnifier_minus":
      return t = await import("./magnifier-minus.bFPGgQiL-bFPGgQiL.mjs"), d(t.default);
    case "magnifier_plus_filled":
      return t = await import("./magnifier-plus-filled.DT6UMGeX-DT6UMGeX.mjs"), d(t.default);
    case "magnifier_plus":
      return t = await import("./magnifier-plus.CeDHRBn6-CeDHRBn6.mjs"), d(t.default);
    case "magnifier":
      return t = await import("./magnifier.D87sMV3t-D87sMV3t.mjs"), d(t.default);
    case "materialx":
      return t = await import("./materialx.CHkK8_oQ-CHkK8_oQ.mjs"), d(t.default);
    case "medal_1_filled":
      return t = await import("./medal-1-filled.DpPZu4S0-DpPZu4S0.mjs"), d(t.default);
    case "medal_1":
      return t = await import("./medal-1.uJXloO1u-uJXloO1u.mjs"), d(t.default);
    case "medal_2_filled":
      return t = await import("./medal-2-filled.Dlz2ajjf-Dlz2ajjf.mjs"), d(t.default);
    case "medal_2":
      return t = await import("./medal-2.b7xm_LgF-b7xm_LgF.mjs"), d(t.default);
    case "medal_3_filled":
      return t = await import("./medal-3-filled.BHfi7LfC-BHfi7LfC.mjs"), d(t.default);
    case "medal_3":
      return t = await import("./medal-3.BdBMenuA-BdBMenuA.mjs"), d(t.default);
    case "medal_star_filled":
      return t = await import("./medal-star-filled.CnN0S5yQ-CnN0S5yQ.mjs"), d(t.default);
    case "medal_star":
      return t = await import("./medal-star.BUIePWt--BUIePWt-.mjs"), d(t.default);
    case "merge_x_mark":
      return t = await import("./merge-x-mark.DZnJTrol-DZnJTrol.mjs"), d(t.default);
    case "merge":
      return t = await import("./merge.CevWru8q-CevWru8q.mjs"), d(t.default);
    case "metahuman":
      return t = await import("./metahuman.BujZafR1-BujZafR1.mjs"), d(t.default);
    case "meteor_filled":
      return t = await import("./meteor-filled.BPU6o4Oc-BPU6o4Oc.mjs"), d(t.default);
    case "meteor":
      return t = await import("./meteor.C9JUv0jh-C9JUv0jh.mjs"), d(t.default);
    case "mic_blocked_filled":
      return t = await import("./mic-blocked-filled.BSVm2LA--BSVm2LA-.mjs"), d(t.default);
    case "mic_blocked":
      return t = await import("./mic-blocked.BSbyztRB-BSbyztRB.mjs"), d(t.default);
    case "mic_filled":
      return t = await import("./mic-filled.DWZU62vm-DWZU62vm.mjs"), d(t.default);
    case "mic_slash_filled":
      return t = await import("./mic-slash-filled.DRrJ9gFh-DRrJ9gFh.mjs"), d(t.default);
    case "mic_slash":
      return t = await import("./mic-slash.CGiViv0r-CGiViv0r.mjs"), d(t.default);
    case "mic":
      return t = await import("./mic.BQAaVDtq-BQAaVDtq.mjs"), d(t.default);
    case "military_badge_filled":
      return t = await import("./military-badge-filled.B67AhEDA-B67AhEDA.mjs"), d(t.default);
    case "military_badge":
      return t = await import("./military-badge.CngJq3n6-CngJq3n6.mjs"), d(t.default);
    case "minecraft":
      return t = await import("./minecraft.D9ms79AV-D9ms79AV.mjs"), d(t.default);
    case "minus_circle_filled":
      return t = await import("./minus-circle-filled.Cj2dED0M-Cj2dED0M.mjs"), d(t.default);
    case "minus_circle":
      return t = await import("./minus-circle.DfQmr3l8-DfQmr3l8.mjs"), d(t.default);
    case "minus_square_filled":
      return t = await import("./minus-square-filled.ma5Na3jc-ma5Na3jc.mjs"), d(t.default);
    case "minus_square":
      return t = await import("./minus-square.viz5WVVp-viz5WVVp.mjs"), d(t.default);
    case "minus":
      return t = await import("./minus.Bui2gha4-Bui2gha4.mjs"), d(t.default);
    case "mixer":
      return t = await import("./mixer.De1FHk0G-De1FHk0G.mjs"), d(t.default);
    case "moon_filled":
      return t = await import("./moon-filled.hLHnUZoe-lxvGwvnz.mjs"), d(t.default);
    case "moon":
      return t = await import("./moon.Byhl64dh-Byhl64dh.mjs"), d(t.default);
    case "mouse_filled":
      return t = await import("./mouse-filled.DBA1u5xK-DBA1u5xK.mjs"), d(t.default);
    case "mouse":
      return t = await import("./mouse.Z0cyw7G5-Z0cyw7G5.mjs"), d(t.default);
    case "multiple_shapes_filled":
      return t = await import("./multiple-shapes-filled.dXBWj9Or-dXBWj9Or.mjs"), d(t.default);
    case "multiple_shapes":
      return t = await import("./multiple-shapes.BcRV4FQw-BcRV4FQw.mjs"), d(t.default);
    case "music_note_filled":
      return t = await import("./music-note-filled.CL02y0-u-CEzc7LKu.mjs"), d(t.default);
    case "music_note":
      return t = await import("./music-note.DIY4r5tX-DIY4r5tX.mjs"), d(t.default);
    case "mydisney":
      return t = await import("./mydisney.B_2Cva2J-B_2Cva2J.mjs"), d(t.default);
    case "naver":
      return t = await import("./naver.CIT9oz2t-CIT9oz2t.mjs"), d(t.default);
    case "network":
      return t = await import("./network.Bj2Bszmc-Bj2Bszmc.mjs"), d(t.default);
    case "newspaper_filled":
      return t = await import("./newspaper-filled.yaLWVZ2--yaLWVZ2-.mjs"), d(t.default);
    case "newspaper":
      return t = await import("./newspaper.NfZQeAgV-NfZQeAgV.mjs"), d(t.default);
    case "nintendo_switch":
      return t = await import("./nintendo-switch.BHyhFinS-BHyhFinS.mjs"), d(t.default);
    case "nintendo":
      return t = await import("./nintendo.C3WjDDnV-C3WjDDnV.mjs"), d(t.default);
    case "node_filled":
      return t = await import("./node-filled.DDdwSwFY-DDdwSwFY.mjs"), d(t.default);
    case "node":
      return t = await import("./node.EFVaviVy-EFVaviVy.mjs"), d(t.default);
    case "note_filled":
      return t = await import("./note-filled.DhaQBE9k-DhaQBE9k.mjs"), d(t.default);
    case "note_pen_filled":
      return t = await import("./note-pen-filled.CSBLMsff-CSBLMsff.mjs"), d(t.default);
    case "note_pen":
      return t = await import("./note-pen.DJgfh2Vr-DJgfh2Vr.mjs"), d(t.default);
    case "note":
      return t = await import("./note.Cr885C-_-Cr885C-_.mjs"), d(t.default);
    case "notebook_filled":
      return t = await import("./notebook-filled.DP4hleCj-DP4hleCj.mjs"), d(t.default);
    case "notebook_pen_filled":
      return t = await import("./notebook-pen-filled.38gwoUCz-38gwoUCz.mjs"), d(t.default);
    case "notebook_pen":
      return t = await import("./notebook-pen.DUDF4Jso-DUDF4Jso.mjs"), d(t.default);
    case "notebook":
      return t = await import("./notebook.BKkkyAQA-BKkkyAQA.mjs"), d(t.default);
    case "numbered_list":
      return t = await import("./numbered-list.CzkhazmK-CzkhazmK.mjs"), d(t.default);
    case "off":
      return t = await import("./off.DzRFGo5V-DzRFGo5V.mjs"), d(t.default);
    case "paint_brush_filled":
      return t = await import("./paint-brush-filled.DxbrCw4A-DxbrCw4A.mjs"), d(t.default);
    case "paint_brush":
      return t = await import("./paint-brush.DhTsDoWo-DhTsDoWo.mjs"), d(t.default);
    case "palette_filled":
      return t = await import("./palette-filled.DlFD2f93-DlFD2f93.mjs"), d(t.default);
    case "palette":
      return t = await import("./palette.Da4Py9kX-Da4Py9kX.mjs"), d(t.default);
    case "paper_clip":
      return t = await import("./paper-clip.B_MErVWG-B_MErVWG.mjs"), d(t.default);
    case "paper_plane_filled":
      return t = await import("./paper-plane-filled.D4ahysCa-D4ahysCa.mjs"), d(t.default);
    case "paper_plane":
      return t = await import("./paper-plane.BS21xUvi-BS21xUvi.mjs"), d(t.default);
    case "paragraph":
      return t = await import("./paragraph.DJLc-Cv7-DJLc-Cv7.mjs"), d(t.default);
    case "parent_child_check_filled":
      return t = await import("./parent-child-check-filled.CfV_nf3V-CfV_nf3V.mjs"), d(t.default);
    case "parent_child_check":
      return t = await import("./parent-child-check.BAo5YJiu-BAo5YJiu.mjs"), d(t.default);
    case "parent_child_cogwheel_filled":
      return t = await import("./parent-child-cogwheel-filled.DgNQcmAm-DgNQcmAm.mjs"), d(t.default);
    case "parent_child_cogwheel":
      return t = await import("./parent-child-cogwheel.D7Gf_BIp-D7Gf_BIp.mjs"), d(t.default);
    case "parent_child_filled":
      return t = await import("./parent-child-filled.36bw7wFI-36bw7wFI.mjs"), d(t.default);
    case "parent_child":
      return t = await import("./parent-child.BwNM-Emr-BwNM-Emr.mjs"), d(t.default);
    case "passport_filled":
      return t = await import("./passport-filled.BSiiIdvL-BSiiIdvL.mjs"), d(t.default);
    case "passport":
      return t = await import("./passport.RCXXoNYV-RCXXoNYV.mjs"), d(t.default);
    case "password_field_filled":
      return t = await import("./password-field-filled.CICZJUIQ-CICZJUIQ.mjs"), d(t.default);
    case "password_field":
      return t = await import("./password-field.lXLkin-K-lXLkin-K.mjs"), d(t.default);
    case "pause_circle_filled":
      return t = await import("./pause-circle-filled.CIXgkInu-CIXgkInu.mjs"), d(t.default);
    case "pause_circle":
      return t = await import("./pause-circle.DIkQ_U8g-DIkQ_U8g.mjs"), d(t.default);
    case "pause_filled":
      return t = await import("./pause-filled.Do8EaMJB-Do8EaMJB.mjs"), d(t.default);
    case "pause":
      return t = await import("./pause.DUdBRvdT-DUdBRvdT.mjs"), d(t.default);
    case "paw_filled":
      return t = await import("./paw-filled.CowIxYpC-CowIxYpC.mjs"), d(t.default);
    case "paw":
      return t = await import("./paw.Cy2zhT2G-Cy2zhT2G.mjs"), d(t.default);
    case "pen_ruler_filled":
      return t = await import("./pen-ruler-filled.CHJMZ7XM-CHJMZ7XM.mjs"), d(t.default);
    case "pen_ruler":
      return t = await import("./pen-ruler.5o8F1GJB-5o8F1GJB.mjs"), d(t.default);
    case "pencil_filled":
      return t = await import("./pencil-filled.DFlFRgbg-DFlFRgbg.mjs"), d(t.default);
    case "pencil_scribble_filled":
      return t = await import("./pencil-scribble-filled.qK0lAao3-Df4wkl28.mjs"), d(t.default);
    case "pencil_scribble":
      return t = await import("./pencil-scribble.zemdDKcL-zemdDKcL.mjs"), d(t.default);
    case "pencil_slash_filled":
      return t = await import("./pencil-slash-filled.Bpo0sSbk-B6djEDkx.mjs"), d(t.default);
    case "pencil_slash":
      return t = await import("./pencil-slash.xcyM8K7W-xcyM8K7W.mjs"), d(t.default);
    case "pencil_square":
      return t = await import("./pencil-square.UzNmtfBO-UzNmtfBO.mjs"), d(t.default);
    case "pencil":
      return t = await import("./pencil.BkkESZIo-BkkESZIo.mjs"), d(t.default);
    case "percent_seal_filled":
      return t = await import("./percent-seal-filled.CHJK-rJ--CHJK-rJ-.mjs"), d(t.default);
    case "percent_seal":
      return t = await import("./percent-seal.dN4eNvpm-dN4eNvpm.mjs"), d(t.default);
    case "percent":
      return t = await import("./percent.n2nms-5I-n2nms-5I.mjs"), d(t.default);
    case "person_dancing_filled":
      return t = await import("./person-dancing-filled.BHI9H2Fi-BHI9H2Fi.mjs"), d(t.default);
    case "person_dancing":
      return t = await import("./person-dancing._dbDUk-e-_dbDUk-e.mjs"), d(t.default);
    case "phone_filled":
      return t = await import("./phone-filled.BsDnynMF-BsDnynMF.mjs"), d(t.default);
    case "phone":
      return t = await import("./phone.CQx1djkU-CQx1djkU.mjs"), d(t.default);
    case "photo_frame":
      return t = await import("./photo-frame.DrFzOYJl-DrFzOYJl.mjs"), d(t.default);
    case "pin_filled":
      return t = await import("./pin-filled.B5XCbkNK-B5XCbkNK.mjs"), d(t.default);
    case "pin":
      return t = await import("./pin.DWyjWPR_-DWyjWPR_.mjs"), d(t.default);
    case "pinterest":
      return t = await import("./pinterest.D7nUwTsa-D7nUwTsa.mjs"), d(t.default);
    case "plane_filled":
      return t = await import("./plane-filled.BB8dVF32-BB8dVF32.mjs"), d(t.default);
    case "plane":
      return t = await import("./plane.ClaqYrRl-ClaqYrRl.mjs"), d(t.default);
    case "play_circle_filled":
      return t = await import("./play-circle-filled.e8s1CsZH-e8s1CsZH.mjs"), d(t.default);
    case "play_circle":
      return t = await import("./play-circle.BNajA6lO-BNajA6lO.mjs"), d(t.default);
    case "play_filled":
      return t = await import("./play-filled.Dvukt4h3-Dvukt4h3.mjs"), d(t.default);
    case "play":
      return t = await import("./play.CzVQLLzE-CzVQLLzE.mjs"), d(t.default);
    case "playstation":
      return t = await import("./playstation.CGAgFuWl-CGAgFuWl.mjs"), d(t.default);
    case "plus_circle_filled":
      return t = await import("./plus-circle-filled.QbtWDUiC-QbtWDUiC.mjs"), d(t.default);
    case "plus_circle":
      return t = await import("./plus-circle.BBRjW2kf-BBRjW2kf.mjs"), d(t.default);
    case "plus_square_filled":
      return t = await import("./plus-square-filled.jQL3TVj5-jQL3TVj5.mjs"), d(t.default);
    case "plus_square":
      return t = await import("./plus-square.BvIZ2PhL-BvIZ2PhL.mjs"), d(t.default);
    case "plus":
      return t = await import("./plus.DvOd4JfE-DvOd4JfE.mjs"), d(t.default);
    case "png":
      return t = await import("./png.vnYh5ksp-vnYh5ksp.mjs"), d(t.default);
    case "poster_filled":
      return t = await import("./poster-filled.UiQMnj6H-UiQMnj6H.mjs"), d(t.default);
    case "poster":
      return t = await import("./poster.CRsqNi-i-CRsqNi-i.mjs"), d(t.default);
    case "postparty":
      return t = await import("./postparty.Cm4kaRVx-Cm4kaRVx.mjs"), d(t.default);
    case "power_cord_filled":
      return t = await import("./power-cord-filled.6gVzL3t_-BvPsqY2q.mjs"), d(t.default);
    case "power_cord":
      return t = await import("./power-cord.DcHNEkWk-DcHNEkWk.mjs"), d(t.default);
    case "pro":
      return t = await import("./pro.C-BhFvhy-C-BhFvhy.mjs"), d(t.default);
    case "prompt_check_filled":
      return t = await import("./prompt-check-filled.DSnrepBm-DSnrepBm.mjs"), d(t.default);
    case "prompt_check":
      return t = await import("./prompt-check.mO5krZST-mO5krZST.mjs"), d(t.default);
    case "prompt_exclamation_filled":
      return t = await import("./prompt-exclamation-filled.CQrqtWv3-CQrqtWv3.mjs"), d(t.default);
    case "prompt_exclamation":
      return t = await import("./prompt-exclamation.DxdvwZEI-DxdvwZEI.mjs"), d(t.default);
    case "prompt_info_filled":
      return t = await import("./prompt-info-filled.DK9JJ76q-DK9JJ76q.mjs"), d(t.default);
    case "prompt_info":
      return t = await import("./prompt-info.D6OnlQ27-D6OnlQ27.mjs"), d(t.default);
    case "prompt_x_mark_filled":
      return t = await import("./prompt-x-mark-filled.Ciw7XFeY-Ciw7XFeY.mjs"), d(t.default);
    case "prompt_x_mark":
      return t = await import("./prompt-x-mark.DUIdAIGY-DUIdAIGY.mjs"), d(t.default);
    case "pull_request":
      return t = await import("./pull-request.DlOJgJdQ-DlOJgJdQ.mjs"), d(t.default);
    case "puzzle_filled":
      return t = await import("./puzzle-filled.m6telrFD-m6telrFD.mjs"), d(t.default);
    case "puzzle":
      return t = await import("./puzzle.DihgS3WU-DihgS3WU.mjs"), d(t.default);
    case "qr_code":
      return t = await import("./qr-code.CRdzEF7k-CRdzEF7k.mjs"), d(t.default);
    case "question_circle_filled":
      return t = await import("./question-circle-filled.ieQOaRrC-ieQOaRrC.mjs"), d(t.default);
    case "question_circle":
      return t = await import("./question-circle.DZrwNAeP-DZrwNAeP.mjs"), d(t.default);
    case "quixel":
      return t = await import("./quixel.CAShk2Bu-CAShk2Bu.mjs"), d(t.default);
    case "realitycapture":
      return t = await import("./realitycapture.DDFXiwte-DDFXiwte.mjs"), d(t.default);
    case "realityscan":
      return t = await import("./realityscan.Dd1HWjfA-Dd1HWjfA.mjs"), d(t.default);
    case "receipt_arrow_turn_up_left_filled":
      return t = await import("./receipt-arrow-turn-up-left-filled.lNdCIjaN-lNdCIjaN.mjs"), d(t.default);
    case "receipt_arrow_turn_up_left":
      return t = await import("./receipt-arrow-turn-up-left.DZc8zB05-DZc8zB05.mjs"), d(t.default);
    case "receipt_dollar_sign_filled":
      return t = await import("./receipt-dollar-sign-filled.D_oidV_n-D_oidV_n.mjs"), d(t.default);
    case "receipt_dollar_sign":
      return t = await import("./receipt-dollar-sign.BxxtF9cF-BxxtF9cF.mjs"), d(t.default);
    case "receipt_filled":
      return t = await import("./receipt-filled.BHtVSFaj-BHtVSFaj.mjs"), d(t.default);
    case "receipt_percentage_filled":
      return t = await import("./receipt-percentage-filled.BR_5uR56-BR_5uR56.mjs"), d(t.default);
    case "receipt_percentage":
      return t = await import("./receipt-percentage.DJKLrYuO-DJKLrYuO.mjs"), d(t.default);
    case "receipt":
      return t = await import("./receipt.DFiXJaqP-DFiXJaqP.mjs"), d(t.default);
    case "rectangle_stacked_filled":
      return t = await import("./rectangle-stacked-filled.KLZO87NG-KLZO87NG.mjs"), d(t.default);
    case "rectangle_stacked":
      return t = await import("./rectangle-stacked.C-xumzMh-C-xumzMh.mjs"), d(t.default);
    case "reddit":
      return t = await import("./reddit.DspRDTU0-DspRDTU0.mjs"), d(t.default);
    case "resolution_16k":
      return t = await import("./resolution-16k.BdndTB-F-BdndTB-F.mjs"), d(t.default);
    case "resolution_4k":
      return t = await import("./resolution-4k.DQlU0D2W-DQlU0D2W.mjs"), d(t.default);
    case "resolution_8k":
      return t = await import("./resolution-8k.Ba7zrL9L-Ba7zrL9L.mjs"), d(t.default);
    case "roblox":
      return t = await import("./roblox.BSwVd7vq-D2U9k1My.mjs"), d(t.default);
    case "robot_filled":
      return t = await import("./robot-filled.BDSIOOT5-BDSIOOT5.mjs"), d(t.default);
    case "robot_surprised_filled":
      return t = await import("./robot-surprised-filled.Dd-c4Nx7-Dd-c4Nx7.mjs"), d(t.default);
    case "robot_surprised":
      return t = await import("./robot-surprised.BoQO1Nwq-BoQO1Nwq.mjs"), d(t.default);
    case "robot_x_marks_filled":
      return t = await import("./robot-x-marks-filled.D9CaP8oG-D9CaP8oG.mjs"), d(t.default);
    case "robot_x_marks":
      return t = await import("./robot-x-marks.zuzfy-Iu-zuzfy-Iu.mjs"), d(t.default);
    case "robot":
      return t = await import("./robot.Bx2gQavN-Bx2gQavN.mjs"), d(t.default);
    case "rocket_filled":
      return t = await import("./rocket-filled.Do2L0hC_-Do2L0hC_.mjs"), d(t.default);
    case "rocket_league_sideswipe":
      return t = await import("./rocket-league-sideswipe.CiwqUq37-CiwqUq37.mjs"), d(t.default);
    case "rocket_league":
      return t = await import("./rocket-league.LvRYj9Ix-LvRYj9Ix.mjs"), d(t.default);
    case "rocket":
      return t = await import("./rocket.kPLRuTjh-kPLRuTjh.mjs"), d(t.default);
    case "route_end":
      return t = await import("./route-end.DwjcHRgA-DwjcHRgA.mjs"), d(t.default);
    case "route_start":
      return t = await import("./route-start.B5Cj4PYQ-B5Cj4PYQ.mjs"), d(t.default);
    case "rss":
      return t = await import("./rss.CmM8PjQs-CmM8PjQs.mjs"), d(t.default);
    case "ruble_sign_circle_filled":
      return t = await import("./ruble-sign-circle-filled.Cl7mBraw-Cl7mBraw.mjs"), d(t.default);
    case "ruble_sign_circle":
      return t = await import("./ruble-sign-circle.DEHry4IP-DEHry4IP.mjs"), d(t.default);
    case "ruler_filled":
      return t = await import("./ruler-filled.BcLbUOsC-BcLbUOsC.mjs"), d(t.default);
    case "ruler":
      return t = await import("./ruler.DbN1mSJd-DbN1mSJd.mjs"), d(t.default);
    case "rupee_sign_circle_filled":
      return t = await import("./rupee-sign-circle-filled.SCgQpCk_-SCgQpCk_.mjs"), d(t.default);
    case "rupee_sign_circle":
      return t = await import("./rupee-sign-circle.B7mmuEPJ-B7mmuEPJ.mjs"), d(t.default);
    case "salesforce":
      return t = await import("./salesforce.zEH_afkM-zEH_afkM.mjs"), d(t.default);
    case "samsung":
      return t = await import("./samsung.BUrWctQa-BUrWctQa.mjs"), d(t.default);
    case "scales_filled":
      return t = await import("./scales-filled.DOtVSlh5-DOtVSlh5.mjs"), d(t.default);
    case "scales":
      return t = await import("./scales.CX8o4oRv-CX8o4oRv.mjs"), d(t.default);
    case "scan_cube":
      return t = await import("./scan-cube.CT5jEFOj-CT5jEFOj.mjs"), d(t.default);
    case "scan_qr_code":
      return t = await import("./scan-qr-code.CdYk5pXi-CdYk5pXi.mjs"), d(t.default);
    case "scan":
      return t = await import("./scan.B3TUUitp-B3TUUitp.mjs"), d(t.default);
    case "screen_dashboard_filled":
      return t = await import("./screen-dashboard-filled.BKxAz7Ee-BKxAz7Ee.mjs"), d(t.default);
    case "screen_dashboard":
      return t = await import("./screen-dashboard.DHlukGxO-DHlukGxO.mjs"), d(t.default);
    case "screen_presentation_filled":
      return t = await import("./screen-presentation-filled.CqaejnCA-CqaejnCA.mjs"), d(t.default);
    case "screen_presentation":
      return t = await import("./screen-presentation.CCeQz7i7-CCeQz7i7.mjs"), d(t.default);
    case "screen_slideshow_filled":
      return t = await import("./screen-slideshow-filled.CGdU3a2o-CGdU3a2o.mjs"), d(t.default);
    case "screen_slideshow":
      return t = await import("./screen-slideshow.BgMdTotJ-BgMdTotJ.mjs"), d(t.default);
    case "scroll_filled":
      return t = await import("./scroll-filled.BLk4A1nK-BLk4A1nK.mjs"), d(t.default);
    case "scroll":
      return t = await import("./scroll.Dd18uea--Dd18uea-.mjs"), d(t.default);
    case "server_filled":
      return t = await import("./server-filled.C2Mqwo75-C2Mqwo75.mjs"), d(t.default);
    case "server":
      return t = await import("./server.cnfpq_uR-cnfpq_uR.mjs"), d(t.default);
    case "shield_check_filled":
      return t = await import("./shield-check-filled.XR2DV85g-XR2DV85g.mjs"), d(t.default);
    case "shield_check_pen_filled":
      return t = await import("./shield-check-pen-filled.BSL6rpl9-BSL6rpl9.mjs"), d(t.default);
    case "shield_check_pen":
      return t = await import("./shield-check-pen.DpXNx7QK-DpXNx7QK.mjs"), d(t.default);
    case "shield_check":
      return t = await import("./shield-check.DAGQstxc-DAGQstxc.mjs"), d(t.default);
    case "shield_filled":
      return t = await import("./shield-filled.Djbq6i_O-Djbq6i_O.mjs"), d(t.default);
    case "shield_lock_filled":
      return t = await import("./shield-lock-filled.D05lzv4F-D05lzv4F.mjs"), d(t.default);
    case "shield_lock":
      return t = await import("./shield-lock.BuTH5HN_-BuTH5HN_.mjs"), d(t.default);
    case "shield_plus_filled":
      return t = await import("./shield-plus-filled.C3HsoEzT-C3HsoEzT.mjs"), d(t.default);
    case "shield_plus":
      return t = await import("./shield-plus.Bz_U0dA9-Bz_U0dA9.mjs"), d(t.default);
    case "shield_slash_filled":
      return t = await import("./shield-slash-filled.D9f2c9es-Bgasm3F-.mjs"), d(t.default);
    case "shield_slash":
      return t = await import("./shield-slash.BZ-q2pPM-BZ-q2pPM.mjs"), d(t.default);
    case "shield_x_mark_filled":
      return t = await import("./shield-x-mark-filled.oxFO0aGv-oxFO0aGv.mjs"), d(t.default);
    case "shield_x_mark":
      return t = await import("./shield-x-mark.Dc97U6mA-Dc97U6mA.mjs"), d(t.default);
    case "shield":
      return t = await import("./shield.5tP4Vr1--5tP4Vr1-.mjs"), d(t.default);
    case "shoes_filled":
      return t = await import("./shoes-filled.gJC4NO0--gJC4NO0-.mjs"), d(t.default);
    case "shoes":
      return t = await import("./shoes.DCz3lEV5-DCz3lEV5.mjs"), d(t.default);
    case "shooting_star":
      return t = await import("./shooting-star.aPjZuhsv-aPjZuhsv.mjs"), d(t.default);
    case "shopping_bag_clock_filled":
      return t = await import("./shopping-bag-clock-filled.Cx7BrCsA-Cx7BrCsA.mjs"), d(t.default);
    case "shopping_bag_clock":
      return t = await import("./shopping-bag-clock.BCGboG9W-BCGboG9W.mjs"), d(t.default);
    case "shopping_bag_filled":
      return t = await import("./shopping-bag-filled.DBl_8NqD-DBl_8NqD.mjs"), d(t.default);
    case "shopping_bag":
      return t = await import("./shopping-bag.uPA4XX41-uPA4XX41.mjs"), d(t.default);
    case "shopping_cart_check_filled":
      return t = await import("./shopping-cart-check-filled.PwdcagT9-PwdcagT9.mjs"), d(t.default);
    case "shopping_cart_check":
      return t = await import("./shopping-cart-check.FQvFUhOt-FQvFUhOt.mjs"), d(t.default);
    case "shopping_cart_filled":
      return t = await import("./shopping-cart-filled.iZepmIRh-iZepmIRh.mjs"), d(t.default);
    case "shopping_cart_minus_filled":
      return t = await import("./shopping-cart-minus-filled.BW2qhDFe-BW2qhDFe.mjs"), d(t.default);
    case "shopping_cart_minus":
      return t = await import("./shopping-cart-minus.BuQg7TOu-BuQg7TOu.mjs"), d(t.default);
    case "shopping_cart_plus_filled":
      return t = await import("./shopping-cart-plus-filled.BhVyTYPL-BhVyTYPL.mjs"), d(t.default);
    case "shopping_cart_plus":
      return t = await import("./shopping-cart-plus.CDU1CohN-CDU1CohN.mjs"), d(t.default);
    case "shopping_cart_trend_up_filled":
      return t = await import("./shopping-cart-trend-up-filled.DgAmkCJt-DgAmkCJt.mjs"), d(t.default);
    case "shopping_cart_trend_up":
      return t = await import("./shopping-cart-trend-up.C4LpVuwh-C4LpVuwh.mjs"), d(t.default);
    case "shopping_cart":
      return t = await import("./shopping-cart.NTTDz4mY-NTTDz4mY.mjs"), d(t.default);
    case "signal":
      return t = await import("./signal.CLzY05jQ-CLzY05jQ.mjs"), d(t.default);
    case "sketchfab":
      return t = await import("./sketchfab.C6rmM0_6-C6rmM0_6.mjs"), d(t.default);
    case "skyscraper_filled":
      return t = await import("./skyscraper-filled.BwVDjIML-BwVDjIML.mjs"), d(t.default);
    case "skyscraper":
      return t = await import("./skyscraper.D7ctIvxQ-D7ctIvxQ.mjs"), d(t.default);
    case "slack":
      return t = await import("./slack.BrOzQlph-BrOzQlph.mjs"), d(t.default);
    case "slash_circle":
      return t = await import("./slash-circle.XPSiGZKY-XPSiGZKY.mjs"), d(t.default);
    case "slider_compare_filled":
      return t = await import("./slider-compare-filled.DW-cfTeD-DW-cfTeD.mjs"), d(t.default);
    case "slider_compare":
      return t = await import("./slider-compare.D4dOO8FQ-D4dOO8FQ.mjs"), d(t.default);
    case "slider_sequence_filled":
      return t = await import("./slider-sequence-filled.C7mDovQx-C7mDovQx.mjs"), d(t.default);
    case "slider_sequence":
      return t = await import("./slider-sequence.BqK8GL80-BqK8GL80.mjs"), d(t.default);
    case "sliders_horizontal_filled":
      return t = await import("./sliders-horizontal-filled.CBdSWDey-CBdSWDey.mjs"), d(t.default);
    case "sliders_horizontal":
      return t = await import("./sliders-horizontal.ySgmIkO0-ySgmIkO0.mjs"), d(t.default);
    case "snapchat":
      return t = await import("./snapchat.BPsn1NX6-BPsn1NX6.mjs"), d(t.default);
    case "snowflake":
      return t = await import("./snowflake.uZMAiAh5-uZMAiAh5.mjs"), d(t.default);
    case "sparkle_filled":
      return t = await import("./sparkle-filled.ZSeAc83a-QOP4GJby.mjs"), d(t.default);
    case "sparkle":
      return t = await import("./sparkle.BHqjtkTs-BHqjtkTs.mjs"), d(t.default);
    case "speaker_high_filled":
      return t = await import("./speaker-high-filled.DA8aLi-q-DA8aLi-q.mjs"), d(t.default);
    case "speaker_high":
      return t = await import("./speaker-high.22ZRNg-P-22ZRNg-P.mjs"), d(t.default);
    case "speaker_locked_filled":
      return t = await import("./speaker-locked-filled.BeCwD747-BeCwD747.mjs"), d(t.default);
    case "speaker_locked":
      return t = await import("./speaker-locked.BxAw6rFX-BxAw6rFX.mjs"), d(t.default);
    case "speaker_low_filled":
      return t = await import("./speaker-low-filled.pAMyYWVN-pAMyYWVN.mjs"), d(t.default);
    case "speaker_low":
      return t = await import("./speaker-low.Dtqcm0RW-Dtqcm0RW.mjs"), d(t.default);
    case "speaker_medium_filled":
      return t = await import("./speaker-medium-filled.6pCLbpBn-6pCLbpBn.mjs"), d(t.default);
    case "speaker_medium":
      return t = await import("./speaker-medium.nR95FU8t-nR95FU8t.mjs"), d(t.default);
    case "speaker_minus_filled":
      return t = await import("./speaker-minus-filled.0VuY9bEn-0VuY9bEn.mjs"), d(t.default);
    case "speaker_minus":
      return t = await import("./speaker-minus.C5mVwFkz-C5mVwFkz.mjs"), d(t.default);
    case "speaker_plus_filled":
      return t = await import("./speaker-plus-filled.oLNnL60i-oLNnL60i.mjs"), d(t.default);
    case "speaker_plus":
      return t = await import("./speaker-plus.DNnNXRDd-DNnNXRDd.mjs"), d(t.default);
    case "speaker_slash_filled":
      return t = await import("./speaker-slash-filled.Cc-5HOVp-Cc-5HOVp.mjs"), d(t.default);
    case "speaker_slash":
      return t = await import("./speaker-slash.1a1yfxcY-1a1yfxcY.mjs"), d(t.default);
    case "speaker_x_mark_filled":
      return t = await import("./speaker-x-mark-filled.DlDzUf2f-DlDzUf2f.mjs"), d(t.default);
    case "speaker_x_mark":
      return t = await import("./speaker-x-mark.DYZFfVty-DYZFfVty.mjs"), d(t.default);
    case "speedometer_filled":
      return t = await import("./speedometer-filled.DyFE5mfX-DyFE5mfX.mjs"), d(t.default);
    case "speedometer":
      return t = await import("./speedometer.I9wCdTnM-I9wCdTnM.mjs"), d(t.default);
    case "spotlight_filled":
      return t = await import("./spotlight-filled.C8ISmNt6-C8ISmNt6.mjs"), d(t.default);
    case "spotlight":
      return t = await import("./spotlight.CKtb15hD-CKtb15hD.mjs"), d(t.default);
    case "spraycan_filled":
      return t = await import("./spraycan-filled.D4ezDskT-D4ezDskT.mjs"), d(t.default);
    case "spraycan":
      return t = await import("./spraycan.DZ-RGXFH-DZ-RGXFH.mjs"), d(t.default);
    case "square_badge_filled":
      return t = await import("./square-badge-filled.XvlQe2ur-XvlQe2ur.mjs"), d(t.default);
    case "square_badge":
      return t = await import("./square-badge.CMBbk20D-CMBbk20D.mjs"), d(t.default);
    case "square_filled":
      return t = await import("./square-filled.CgMOTUyV-CgMOTUyV.mjs"), d(t.default);
    case "square_four_dots_diagonal_line":
      return t = await import("./square-four-dots-diagonal-line.gTKwgot_-gTKwgot_.mjs"), d(t.default);
    case "square_four_wavy_lines_filled":
      return t = await import("./square-four-wavy-lines-filled.BOT0gvNt-BOT0gvNt.mjs"), d(t.default);
    case "square_four_wavy_lines":
      return t = await import("./square-four-wavy-lines.DK4xWr8P-DK4xWr8P.mjs"), d(t.default);
    case "square_grid_2x2_filled":
      return t = await import("./square-grid-2x2-filled.Cwe6HTe6-Cwe6HTe6.mjs"), d(t.default);
    case "square_grid_2x2":
      return t = await import("./square-grid-2x2.Cx5Zeeyb-Cx5Zeeyb.mjs"), d(t.default);
    case "square_grid_plus_filled":
      return t = await import("./square-grid-plus-filled.DsW11c3B-DsW11c3B.mjs"), d(t.default);
    case "square_grid_plus":
      return t = await import("./square-grid-plus.Bpv5sNuM-Bpv5sNuM.mjs"), d(t.default);
    case "square_line_bottom_filled":
      return t = await import("./square-line-bottom-filled.tE9nQrgK-tE9nQrgK.mjs"), d(t.default);
    case "square_line_bottom":
      return t = await import("./square-line-bottom.d66FWhv4-d66FWhv4.mjs"), d(t.default);
    case "square_line_left_filled":
      return t = await import("./square-line-left-filled.5sg42gVY-5sg42gVY.mjs"), d(t.default);
    case "square_line_left":
      return t = await import("./square-line-left.DTc8FdJa-DTc8FdJa.mjs"), d(t.default);
    case "square_line_right_filled":
      return t = await import("./square-line-right-filled.DJwggRZ7-DJwggRZ7.mjs"), d(t.default);
    case "square_line_right":
      return t = await import("./square-line-right.DXbnHUc4-DXbnHUc4.mjs"), d(t.default);
    case "square_line_top_filled":
      return t = await import("./square-line-top-filled.DzITcHD--DzITcHD-.mjs"), d(t.default);
    case "square_line_top":
      return t = await import("./square-line-top.DN0vwdAy-DN0vwdAy.mjs"), d(t.default);
    case "square_on_tilted_square_filled":
      return t = await import("./square-on-tilted-square-filled.ZtMsoSuW-ZtMsoSuW.mjs"), d(t.default);
    case "square_on_tilted_square":
      return t = await import("./square-on-tilted-square.DFNu_Akq-DFNu_Akq.mjs"), d(t.default);
    case "square_split_horizontally_filled":
      return t = await import("./square-split-horizontally-filled.wl0GApnc-wl0GApnc.mjs"), d(t.default);
    case "square_split_horizontally":
      return t = await import("./square-split-horizontally.9E66MZQk-9E66MZQk.mjs"), d(t.default);
    case "square_split_vertically_filled":
      return t = await import("./square-split-vertically-filled.7-XvDEcN-7-XvDEcN.mjs"), d(t.default);
    case "square_split_vertically":
      return t = await import("./square-split-vertically.DUuwYSj9-DUuwYSj9.mjs"), d(t.default);
    case "square":
      return t = await import("./square.BdfqpSw5-BdfqpSw5.mjs"), d(t.default);
    case "stack_1_filled":
      return t = await import("./stack-1-filled.DV9d806G-DV9d806G.mjs"), d(t.default);
    case "stack_1":
      return t = await import("./stack-1.CdOuAhg1-CdOuAhg1.mjs"), d(t.default);
    case "stack_2_filled":
      return t = await import("./stack-2-filled.BSImVHOu-BSImVHOu.mjs"), d(t.default);
    case "stack_2":
      return t = await import("./stack-2.DpbK633H-DpbK633H.mjs"), d(t.default);
    case "stack_3_filled":
      return t = await import("./stack-3-filled.DhN-SP6r-DhN-SP6r.mjs"), d(t.default);
    case "stack_3":
      return t = await import("./stack-3.CLLckMTW-CLLckMTW.mjs"), d(t.default);
    case "stacked_squares_diagonal_cutouts":
      return t = await import("./stacked-squares-diagonal-cutouts.BTdCeMUr-BTdCeMUr.mjs"), d(t.default);
    case "stacked_squares_filled":
      return t = await import("./stacked-squares-filled.CnPBG6dV-CnPBG6dV.mjs"), d(t.default);
    case "stacked_squares":
      return t = await import("./stacked-squares.RD7L5oJQ-RD7L5oJQ.mjs"), d(t.default);
    case "stamp_filled":
      return t = await import("./stamp-filled.CNifRT9F-CNifRT9F.mjs"), d(t.default);
    case "stamp":
      return t = await import("./stamp.Nq3pSais-Nq3pSais.mjs"), d(t.default);
    case "star_circle_filled":
      return t = await import("./star-circle-filled.Ben37kN9-Ben37kN9.mjs"), d(t.default);
    case "star_circle":
      return t = await import("./star-circle.DaTW_gG8-DaTW_gG8.mjs"), d(t.default);
    case "star_filled":
      return t = await import("./star-filled.CgtGhNW--CgtGhNW-.mjs"), d(t.default);
    case "star_trail_filled":
      return t = await import("./star-trail-filled.ClumlMWd-ClumlMWd.mjs"), d(t.default);
    case "star_trail":
      return t = await import("./star-trail.BfZpy_ND-BfZpy_ND.mjs"), d(t.default);
    case "star":
      return t = await import("./star.BfP2riWv-BfP2riWv.mjs"), d(t.default);
    case "steam":
      return t = await import("./steam.1PWBjZF2-1PWBjZF2.mjs"), d(t.default);
    case "sterling_sign_circle_filled":
      return t = await import("./sterling-sign-circle-filled.B_8_rgyx-C5JAOr6H.mjs"), d(t.default);
    case "sterling_sign_circle":
      return t = await import("./sterling-sign-circle.C7EcIqG8-C7EcIqG8.mjs"), d(t.default);
    case "sticker_filled":
      return t = await import("./sticker-filled.JkK-FBal-JkK-FBal.mjs"), d(t.default);
    case "sticker":
      return t = await import("./sticker.D7-Jxu_1-D7-Jxu_1.mjs"), d(t.default);
    case "stop_circle_filled":
      return t = await import("./stop-circle-filled.D0abYUhE-D0abYUhE.mjs"), d(t.default);
    case "stop_circle":
      return t = await import("./stop-circle.BdPczmMm-BdPczmMm.mjs"), d(t.default);
    case "stop_filled":
      return t = await import("./stop-filled.SQKhvr4x-SQKhvr4x.mjs"), d(t.default);
    case "stop":
      return t = await import("./stop.BdfqpSw5-BdfqpSw5.mjs"), d(t.default);
    case "store_filled":
      return t = await import("./store-filled.BNW23a4k-BNW23a4k.mjs"), d(t.default);
    case "store":
      return t = await import("./store.DMtZtae--DMtZtae-.mjs"), d(t.default);
    case "strike_through":
      return t = await import("./strike-through.CyJxn76V-CyJxn76V.mjs"), d(t.default);
    case "student_filled":
      return t = await import("./student-filled.2lCWaZwc-2lCWaZwc.mjs"), d(t.default);
    case "student":
      return t = await import("./student.w8Ifrt7t-w8Ifrt7t.mjs"), d(t.default);
    case "sun_filled":
      return t = await import("./sun-filled.DLq2_seP-DLq2_seP.mjs"), d(t.default);
    case "sun":
      return t = await import("./sun.CXJe2K5G-CXJe2K5G.mjs"), d(t.default);
    case "sunbed_umbrella_filled":
      return t = await import("./sunbed-umbrella-filled.Dobf9XZm-Dobf9XZm.mjs"), d(t.default);
    case "sunbed_umbrella":
      return t = await import("./sunbed-umbrella.DmDK-fYZ-DmDK-fYZ.mjs"), d(t.default);
    case "svg":
      return t = await import("./svg.OTY0rL-Y-OTY0rL-Y.mjs"), d(t.default);
    case "t_shirt_filled":
      return t = await import("./t-shirt-filled.Ci7zhWY6-Ci7zhWY6.mjs"), d(t.default);
    case "t_shirt":
      return t = await import("./t-shirt.R6p-i3n1-R6p-i3n1.mjs"), d(t.default);
    case "tablet_filled":
      return t = await import("./tablet-filled.DlqdZPJk-DlqdZPJk.mjs"), d(t.default);
    case "tablet":
      return t = await import("./tablet.BSnOKdoE-BSnOKdoE.mjs"), d(t.default);
    case "tag_filled":
      return t = await import("./tag-filled.D8fxCC1s-D8fxCC1s.mjs"), d(t.default);
    case "tag":
      return t = await import("./tag.BAXkKokd-BAXkKokd.mjs"), d(t.default);
    case "talk_bubble_badge_filled":
      return t = await import("./talk-bubble-badge-filled.DreAgXtq-DreAgXtq.mjs"), d(t.default);
    case "talk_bubble_badge":
      return t = await import("./talk-bubble-badge.BWnsVDZO-BWnsVDZO.mjs"), d(t.default);
    case "talk_bubble_dots_filled":
      return t = await import("./talk-bubble-dots-filled.DdC26MON-DdC26MON.mjs"), d(t.default);
    case "talk_bubble_dots":
      return t = await import("./talk-bubble-dots.D2_xDIb4-D2_xDIb4.mjs"), d(t.default);
    case "talk_bubble_exclamation_filled":
      return t = await import("./talk-bubble-exclamation-filled.Cjv5EUrm-Cjv5EUrm.mjs"), d(t.default);
    case "talk_bubble_exclamation":
      return t = await import("./talk-bubble-exclamation.oEsSH6N2-oEsSH6N2.mjs"), d(t.default);
    case "talk_bubble_filled":
      return t = await import("./talk-bubble-filled.C9_o-caU-Cmn38SBb.mjs"), d(t.default);
    case "talk_bubble_slash_filled":
      return t = await import("./talk-bubble-slash-filled.BmpvDL-D-lBMa9xOh.mjs"), d(t.default);
    case "talk_bubble_slash":
      return t = await import("./talk-bubble-slash.Cq_vr2rI-Cq_vr2rI.mjs"), d(t.default);
    case "talk_bubble":
      return t = await import("./talk-bubble.CtnYYxK9-CtnYYxK9.mjs"), d(t.default);
    case "talk_bubbles_filled":
      return t = await import("./talk-bubbles-filled.CpR6_dgP-CpR6_dgP.mjs"), d(t.default);
    case "talk_bubbles":
      return t = await import("./talk-bubbles.N8sKhcJW-N8sKhcJW.mjs"), d(t.default);
    case "target_arrow":
      return t = await import("./target-arrow.BG9KSLPI-BG9KSLPI.mjs"), d(t.default);
    case "target_cursor":
      return t = await import("./target-cursor.CGdZSsHq-CGdZSsHq.mjs"), d(t.default);
    case "template_filled":
      return t = await import("./template-filled.CYCiTNAE-CYCiTNAE.mjs"), d(t.default);
    case "template":
      return t = await import("./template.DNXQy1RI-DNXQy1RI.mjs"), d(t.default);
    case "terminal_filled":
      return t = await import("./terminal-filled.IzdCjIEY-IzdCjIEY.mjs"), d(t.default);
    case "terminal":
      return t = await import("./terminal.C5_M-vxP-C5_M-vxP.mjs"), d(t.default);
    case "terrain_upward_lines_filled":
      return t = await import("./terrain-upward-lines-filled.CEhjtc7g-CEhjtc7g.mjs"), d(t.default);
    case "terrain_upward_lines":
      return t = await import("./terrain-upward-lines.k-QiMROs-k-QiMROs.mjs"), d(t.default);
    case "text_field_filled":
      return t = await import("./text-field-filled.BZIoQd_2-BZIoQd_2.mjs"), d(t.default);
    case "text_field":
      return t = await import("./text-field.CS_c3cDK-CS_c3cDK.mjs"), d(t.default);
    case "text":
      return t = await import("./text.uBTsO1wV-uBTsO1wV.mjs"), d(t.default);
    case "three_lines_horizontal_decrease":
      return t = await import("./three-lines-horizontal-decrease.OO_wINNZ-OO_wINNZ.mjs"), d(t.default);
    case "threelateral":
      return t = await import("./threelateral.B1XVNwzn-B1XVNwzn.mjs"), d(t.default);
    case "thumb_down_filled":
      return t = await import("./thumb-down-filled.0NQVYDrz-0NQVYDrz.mjs"), d(t.default);
    case "thumb_down":
      return t = await import("./thumb-down.DZboWZBS-DZboWZBS.mjs"), d(t.default);
    case "thumb_up_filled":
      return t = await import("./thumb-up-filled.CZ9rPfNU-CZ9rPfNU.mjs"), d(t.default);
    case "thumb_up":
      return t = await import("./thumb-up.Cb-427Fq-Cb-427Fq.mjs"), d(t.default);
    case "tiktok":
      return t = await import("./tiktok.CKuYEC6K-C5RmSnib.mjs"), d(t.default);
    case "timer":
      return t = await import("./timer.BckEdUzQ-BckEdUzQ.mjs"), d(t.default);
    case "trash_filled":
      return t = await import("./trash-filled.EehdtB05-EehdtB05.mjs"), d(t.default);
    case "trash":
      return t = await import("./trash.CPQzOQQD-CPQzOQQD.mjs"), d(t.default);
    case "tray_filled":
      return t = await import("./tray-filled.CQVP_rlX-CQVP_rlX.mjs"), d(t.default);
    case "tray":
      return t = await import("./tray.Bc5Tg-kY-Bc5Tg-kY.mjs"), d(t.default);
    case "tree_filled":
      return t = await import("./tree-filled.D39M2ZAd-D39M2ZAd.mjs"), d(t.default);
    case "tree":
      return t = await import("./tree.Da8leLhf-Da8leLhf.mjs"), d(t.default);
    case "trello":
      return t = await import("./trello.DK7n4_ut-DK7n4_ut.mjs"), d(t.default);
    case "triangle_filled":
      return t = await import("./triangle-filled.CuumNs6t-CuumNs6t.mjs"), d(t.default);
    case "triangle":
      return t = await import("./triangle.DwJ38yZi-DwJ38yZi.mjs"), d(t.default);
    case "trophy_filled":
      return t = await import("./trophy-filled.DUKIi94Y-DUKIi94Y.mjs"), d(t.default);
    case "trophy":
      return t = await import("./trophy.Bpn8tORJ-Bpn8tORJ.mjs"), d(t.default);
    case "tumblr":
      return t = await import("./tumblr.Bf-yRQOk-Bf-yRQOk.mjs"), d(t.default);
    case "twinmotion":
      return t = await import("./twinmotion.DzVhb570-DzVhb570.mjs"), d(t.default);
    case "twitch":
      return t = await import("./twitch.C228Em66-C228Em66.mjs"), d(t.default);
    case "twitter_x":
      return t = await import("./twitter-x.BsaC8aT_-BsaC8aT_.mjs"), d(t.default);
    case "umbrella_filled":
      return t = await import("./umbrella-filled.Gm1okay4-Gm1okay4.mjs"), d(t.default);
    case "umbrella":
      return t = await import("./umbrella.CxOddSOj-CxOddSOj.mjs"), d(t.default);
    case "underline":
      return t = await import("./underline.CeahOtig-CeahOtig.mjs"), d(t.default);
    case "unity":
      return t = await import("./unity.BjAlPTY3-BjAlPTY3.mjs"), d(t.default);
    case "unreal_engine":
      return t = await import("./unreal-engine.CwUu8k_L-CwUu8k_L.mjs"), d(t.default);
    case "uplay":
      return t = await import("./uplay.MPrx3jwF-MPrx3jwF.mjs"), d(t.default);
    case "user_arrows_filled":
      return t = await import("./user-arrows-filled.DQ1IfJjK-DQ1IfJjK.mjs"), d(t.default);
    case "user_arrows":
      return t = await import("./user-arrows.DugKWnZm-DugKWnZm.mjs"), d(t.default);
    case "user_check_filled":
      return t = await import("./user-check-filled.DL9dQ3ol-DL9dQ3ol.mjs"), d(t.default);
    case "user_check":
      return t = await import("./user-check.DNHJzTyY-DNHJzTyY.mjs"), d(t.default);
    case "user_cogwheel_filled":
      return t = await import("./user-cogwheel-filled.C9HCZakA-C9HCZakA.mjs"), d(t.default);
    case "user_cogwheel":
      return t = await import("./user-cogwheel.Bo5WdO7E-Bo5WdO7E.mjs"), d(t.default);
    case "user_filled":
      return t = await import("./user-filled.D-ir8K6E-D-ir8K6E.mjs"), d(t.default);
    case "user_glow_filled":
      return t = await import("./user-glow-filled.DHossbSM-DHossbSM.mjs"), d(t.default);
    case "user_glow":
      return t = await import("./user-glow.DqyG3xaa-DqyG3xaa.mjs"), d(t.default);
    case "user_group_filled":
      return t = await import("./user-group-filled.6pD5lnZO-6pD5lnZO.mjs"), d(t.default);
    case "user_group":
      return t = await import("./user-group.AocJrQhU-AocJrQhU.mjs"), d(t.default);
    case "user_link_filled":
      return t = await import("./user-link-filled.ENI87MhK-ENI87MhK.mjs"), d(t.default);
    case "user_link":
      return t = await import("./user-link.CXTavcZx-CXTavcZx.mjs"), d(t.default);
    case "user_list_filled":
      return t = await import("./user-list-filled.D0Sg7OPz-D0Sg7OPz.mjs"), d(t.default);
    case "user_list":
      return t = await import("./user-list.CB4TOyeW-CB4TOyeW.mjs"), d(t.default);
    case "user_magnifier_filled":
      return t = await import("./user-magnifier-filled.DCHSahA8-DCHSahA8.mjs"), d(t.default);
    case "user_magnifier":
      return t = await import("./user-magnifier.Dq1noWxk-Dq1noWxk.mjs"), d(t.default);
    case "user_minus_filled":
      return t = await import("./user-minus-filled.DN1gWZLP-DN1gWZLP.mjs"), d(t.default);
    case "user_minus":
      return t = await import("./user-minus.Hgsr8y0Y-Hgsr8y0Y.mjs"), d(t.default);
    case "user_plus_filled":
      return t = await import("./user-plus-filled.C9xsGRqf-C9xsGRqf.mjs"), d(t.default);
    case "user_plus":
      return t = await import("./user-plus.LqWxXXab-LqWxXXab.mjs"), d(t.default);
    case "user_target_filled":
      return t = await import("./user-target-filled.ChMh9tTl-ChMh9tTl.mjs"), d(t.default);
    case "user_target":
      return t = await import("./user-target.hzOPfCs1-hzOPfCs1.mjs"), d(t.default);
    case "user_x_mark_filled":
      return t = await import("./user-x-mark-filled.COlMbiBL-COlMbiBL.mjs"), d(t.default);
    case "user_x_mark":
      return t = await import("./user-x-mark.a2_pneRQ-a2_pneRQ.mjs"), d(t.default);
    case "user":
      return t = await import("./user.Ca1Dqpjj-Ca1Dqpjj.mjs"), d(t.default);
    case "users_filled":
      return t = await import("./users-filled.BCnU1_Dw-BCnU1_Dw.mjs"), d(t.default);
    case "users":
      return t = await import("./users.mKdCTOcN-mKdCTOcN.mjs"), d(t.default);
    case "v_bucks_filled":
      return t = await import("./v-bucks-filled.BjkPxpY5-BjkPxpY5.mjs"), d(t.default);
    case "v_bucks":
      return t = await import("./v-bucks._VvyWQ5O-_VvyWQ5O.mjs"), d(t.default);
    case "v_ray":
      return t = await import("./v-ray.BqD1r57Y-BqD1r57Y.mjs"), d(t.default);
    case "verse":
      return t = await import("./verse.Cy1PfXqh-Cy1PfXqh.mjs"), d(t.default);
    case "video_filled":
      return t = await import("./video-filled.CtXUtXZG-CtXUtXZG.mjs"), d(t.default);
    case "video_slash_filled":
      return t = await import("./video-slash-filled.D0njLwPD-D0njLwPD.mjs"), d(t.default);
    case "video_slash":
      return t = await import("./video-slash.BCKh4tas-BCKh4tas.mjs"), d(t.default);
    case "video":
      return t = await import("./video.iSbwUitI-iSbwUitI.mjs"), d(t.default);
    case "view_360_degree":
      return t = await import("./view-360-degree.B_Js9T8p-B_Js9T8p.mjs"), d(t.default);
    case "vimeo":
      return t = await import("./vimeo.9tSTovtX-9tSTovtX.mjs"), d(t.default);
    case "vk":
      return t = await import("./vk.CmIB7kdh-CmIB7kdh.mjs"), d(t.default);
    case "wallet_filled":
      return t = await import("./wallet-filled.C5RaMtem-C5RaMtem.mjs"), d(t.default);
    case "wallet":
      return t = await import("./wallet.BUuWKqyf-BUuWKqyf.mjs"), d(t.default);
    case "waveform":
      return t = await import("./waveform.Dd7iAECq-Dd7iAECq.mjs"), d(t.default);
    case "wavy_lines_horizontal":
      return t = await import("./wavy-lines-horizontal.MOOc55rb-MOOc55rb.mjs"), d(t.default);
    case "webhooks":
      return t = await import("./webhooks.CmatbdD2-CmatbdD2.mjs"), d(t.default);
    case "wegame":
      return t = await import("./wegame.DeffJ30i-DeffJ30i.mjs"), d(t.default);
    case "weibo":
      return t = await import("./weibo.DyUXLdqk-DyUXLdqk.mjs"), d(t.default);
    case "wheel":
      return t = await import("./wheel.Bg4FPQhe-Bg4FPQhe.mjs"), d(t.default);
    case "wifi_exclamation":
      return t = await import("./wifi-exclamation.rZW2cJm8-rZW2cJm8.mjs"), d(t.default);
    case "wifi_slash":
      return t = await import("./wifi-slash.Cdj8tmFt-Cdj8tmFt.mjs"), d(t.default);
    case "wifi":
      return t = await import("./wifi.MwC9R83i-MwC9R83i.mjs"), d(t.default);
    case "windows":
      return t = await import("./windows.CL6oj3iF-CL6oj3iF.mjs"), d(t.default);
    case "wireframe_circle":
      return t = await import("./wireframe-circle.d8gdXCKb-d8gdXCKb.mjs"), d(t.default);
    case "wrapper_filled":
      return t = await import("./wrapper-filled.Bzi_mjG6-Bzi_mjG6.mjs"), d(t.default);
    case "wrapper":
      return t = await import("./wrapper.CaHubA3V-CaHubA3V.mjs"), d(t.default);
    case "wrench_filled":
      return t = await import("./wrench-filled.Dl3oMj9F-Dl3oMj9F.mjs"), d(t.default);
    case "wrench":
      return t = await import("./wrench.CWf8lfR5-CWf8lfR5.mjs"), d(t.default);
    case "x_mark_circle_filled":
      return t = await import("./x-mark-circle-filled.CsiDWnEK-CsiDWnEK.mjs"), d(t.default);
    case "x_mark_circle":
      return t = await import("./x-mark-circle.D6_s9Xhx-D6_s9Xhx.mjs"), d(t.default);
    case "x_mark_square_filled":
      return t = await import("./x-mark-square-filled.BRQImxA4-BRQImxA4.mjs"), d(t.default);
    case "x_mark_square":
      return t = await import("./x-mark-square.D1aRweZV-D1aRweZV.mjs"), d(t.default);
    case "x_mark":
      return t = await import("./x-mark.CMjRQoJG-CMjRQoJG.mjs"), d(t.default);
    case "xbox":
      return t = await import("./xbox.BVjP_uT0-BVjP_uT0.mjs"), d(t.default);
    case "yen_sign_circle_filled":
      return t = await import("./yen-sign-circle-filled.D7JUkV39-D7JUkV39.mjs"), d(t.default);
    case "yen_sign_circle":
      return t = await import("./yen-sign-circle.oTGQNGZA-oTGQNGZA.mjs"), d(t.default);
    case "yk":
      return t = await import("./yk.CgVEpyWM-CgVEpyWM.mjs"), d(t.default);
    case "youtube":
      return t = await import("./youtube.C2ZKmD_u-C2ZKmD_u.mjs"), d(t.default);
    case "zbrush":
      return t = await import("./zbrush.BiIrJ-ki-BiIrJ-ki.mjs"), d(t.default);
    default:
      return null;
  }
};
var n5 = Object.defineProperty, o5 = Object.getOwnPropertyDescriptor, lu = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? o5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && n5(t, r, a), a;
};
let To = class extends Pt {
  constructor() {
    super(...arguments), this.icon = "", this.accentColor = "", this.textColor = "";
  }
  render() {
    const e = this.icon;
    return e ? ae`${Ek(
      r5(e).then((t) => t || (console.warn("epic-wf-eds-icon invalid icon passed, make sure to pass snake_case"), "")),
      ae``
    )}` : ae``;
  }
};
To.styles = St`
		${Tt(t5)}
	`;
lu([
  ne()
], To.prototype, "icon", 2);
lu([
  ne()
], To.prototype, "accentColor", 2);
lu([
  ne()
], To.prototype, "textColor", 2);
To = lu([
  e5("epic-wf-eds-icon")
], To);
const a5 = ":host{display:contents}.footer-button{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none;font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;justify-content:center;align-items:center;gap:var(--dimension-8, 8px);flex-shrink:0;border-radius:.5rem;background:var(--color-fill-secondary-default, rgba(255, 255, 255, .15));height:2.5rem;padding:.5rem 1rem}.footer-button>*{pointer-events:none}.footer-button:not([disabled]){cursor:pointer}.footer-button:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}.footer-button:hover,.footer-button:active:focus-visible{background:var(--color-fill-secondary-hover, rgba(255, 255, 255, .35))}.footer-button-variant-outline{border:.0625rem solid var(--color-border-default, rgba(255, 255, 255, .35));background:var(--color-fill-tertiary-default, rgba(0, 0, 0, 0))}.footer-button-variant-outline:hover,.footer-button-variant-outline:active:focus-visible{border-color:var(--color-border-hover, rgba(255, 255, 255, .65));background:var(--color-fill-tertiary-hover, rgba(255, 255, 255, .15))}.footer-button-padding-large{height:3rem;padding:.75rem 1.25rem}.footer-button epic-wf-eds-icon{max-width:1.25rem;max-height:1.25rem}.footer-button:focus-visible{border-radius:.5rem}";
var i5 = Object.defineProperty, s5 = Object.getOwnPropertyDescriptor, $o = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? s5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && i5(t, r, a), a;
};
let Qr = class extends Pt {
  constructor() {
    super(...arguments), this.variant = "secondary", this.padding = "normal", this.key = "";
  }
  _click(e) {
    this.onClick && this.onClick(e);
  }
  _keyDown(e) {
    var t;
    ["Space", "Enter", "NumpadEnter"].includes(e.code) && (["Enter", "NumpadEnter"].includes(e.code) && ((t = this.link) != null && t.href) || this._click(e));
  }
  render() {
    var e;
    if (!this.link) return ae``;
    const t = `footer-button footer-button-variant-${this.variant} footer-button-padding-${this.padding}`;
    return (e = this.link) != null && e.href ? ae`
			<a @click=${this._click} @keypress=${this._keyDown} class=${t} href=${this.link.href}>
				<span class="label">${this.link.label}</span>
				<epic-wf-eds-icon icon=${ha(this.link.endIcon)} textColor="primary"></epic-wf-eds-icon>
			</a>
			<slot></slot>
		` : ae`
				<button type="button" @click=${this._click} @keydown=${this._keyDown} class=${t}>
					<span class="label">${this.link.label}</span>
					<epic-wf-eds-icon icon=${ha(this.link.endIcon)} textColor="primary"></epic-wf-eds-icon>
				</button>
				<slot></slot>
			`;
  }
};
Qr.styles = St`
		${Tt(a5)}
	`;
$o([
  ne()
], Qr.prototype, "onClick", 2);
$o([
  ne({ type: Object })
], Qr.prototype, "link", 2);
$o([
  ne()
], Qr.prototype, "variant", 2);
$o([
  ne()
], Qr.prototype, "padding", 2);
$o([
  ne()
], Qr.prototype, "key", 2);
Qr = $o([
  Lt("epic-wf-footer-button")
], Qr);
const ey = (e, t, r, n) => !(!Di(r, n) || !l5(e, t)), l5 = (e, t) => {
  var r;
  if (!t?.length || typeof e != "string" || !e?.length) return !0;
  const n = t.length > 2 ? t.replace(/[a-z]/gi, "").slice(0, 2) : t;
  return (r = e?.toLowerCase()) == null ? void 0 : r.includes(n.toLowerCase());
}, Di = (e, t) => {
  var r;
  if (!t?.length || typeof e != "string" || !e?.length) return !0;
  const n = t.length > 2 ? t.replace(/[a-z]/gi, "").slice(-2) : t;
  return (r = e?.toLowerCase()) == null ? void 0 : r.includes(n.toLowerCase());
}, u5 = ".visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}:host{box-sizing:border-box;display:block;position:relative;width:100%}.footer-link{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;--link-block-padding-fallback: .625rem;--link-inline-padding-fallback: 1rem;align-items:center;border-radius:.5rem;box-sizing:border-box;color:var(--color-text-primary, #ffffff);display:flex;column-gap:.25rem;justify-content:space-between;margin-block:0;margin-inline:0;line-height:1.25rem;min-height:1.25rem;padding-block:var(--link-block-padding, var(--link-block-padding-fallback));padding-inline:var(--link-inline-padding, var(--link-inline-padding-fallback));position:relative;text-decoration:none;-webkit-user-select:none;user-select:none;z-index:3;outline-offset:var(--link-outline-offset, -.5rem);transition:color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));color:var(--color-text-secondary, rgba(255, 255, 255, .65));font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.75rem;letter-spacing:.02em;padding-block:0rem;padding-inline:0rem;text-align:start;width:min-content;max-width:100%}.footer-link>*{pointer-events:none}.footer-link:not([disabled]){cursor:pointer}.footer-link:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){.footer-link{--link-block-padding-fallback: .75rem}}@media (max-width: 1279.9px){.footer-link{--link-inline-padding-fallback: .75rem}}.footer-link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em;flex-grow:1}@media (max-width: 719.9px){.footer-link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:1rem}}.footer-link:hover,.footer-link.active{background-color:var(--color-background-transparent-elevated-high-hover, rgba(255, 255, 255, .15));color:var(--color-text-primary, #ffffff)}.footer-link:focus-visible{border-radius:.875rem}@media (min-width: 720px){.footer-link.parent:hover,.footer-link.parent.active{color:var(--color-text-secondary, rgba(255, 255, 255, .65))}}.footer-link.md{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em}.footer-link.md .label{line-height:140%}.footer-link.xs .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.75rem;letter-spacing:.02em}.footer-link:hover{background-color:transparent}.footer-link:focus-visible{outline-offset:.125rem;outline-width:.0625rem;border-radius:0}.footer-link .label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:130%}@media (max-width: 719.9px){.footer-link .label{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.875rem;letter-spacing:.02em}}.footer-link .icon-wrapper{display:flex}.footer-link svg{transition:transform var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1)),color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1));fill:var(--color-text-primary, #ffffff);flex-shrink:0;height:.75rem;width:.75rem}@media (max-width: 719.9px){.footer-link svg{fill:var(--color-text-secondary, rgba(255, 255, 255, .65))}}";
var c5 = Object.defineProperty, d5 = Object.getOwnPropertyDescriptor, Kt = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? d5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && c5(t, r, a), a;
};
let xt = class extends Pt {
  constructor() {
    super(...arguments), this.hrefTemplate = "", this.locale = "", this.domain = "", this.label = "", this.href = "", this.size = "sm";
  }
  render() {
    if (!ey(
      this.localesWhitelist,
      this.locale,
      this.countryCodesWhitelist,
      this.countryCode
    ))
      return ae``;
    let t;
    if (this.hrefTemplate && (t = Gd({ domain: this.domain, hrefTemplate: this.hrefTemplate, locale: this.locale }), this.href = t), !t)
      return ae``;
    if (!this.label)
      return console.debug("footer-link label attribute is missing!"), ae``;
    const r = `footer-link ${this.size || ""}`;
    return ae`
			<a class="${r}" href=${t} target=${ha(this.target)} title=${this.label}>
				<span class="label">${this.label}</span>
			</a>
			<slot></slot>
		`;
  }
};
xt.styles = St`
		${Tt(u5)}
	`;
Kt([
  ne()
], xt.prototype, "hrefTemplate", 2);
Kt([
  ne()
], xt.prototype, "locale", 2);
Kt([
  ne()
], xt.prototype, "domain", 2);
Kt([
  ne()
], xt.prototype, "label", 2);
Kt([
  ne()
], xt.prototype, "localesWhitelist", 2);
Kt([
  ne()
], xt.prototype, "target", 2);
Kt([
  ne()
], xt.prototype, "href", 2);
Kt([
  ne()
], xt.prototype, "size", 2);
Kt([
  ne()
], xt.prototype, "countryCodesWhitelist", 2);
Kt([
  ne()
], xt.prototype, "countryCode", 2);
xt = Kt([
  Lt("epic-wf-footer-link")
], xt);
const p5 = ":host{flex:calc(16.6667% - 2rem);min-width:0}@media (max-width: 1439.9px){:host{flex:calc(33.3333% - 2rem)}}@media (max-width: 719.9px){:host{flex:100%}}.footer-link-column{display:flex;flex-direction:column;gap:1rem}.footer-link-column .column-heading-desktop{display:flex}.footer-link-column .column-heading-mobile{display:none}@media (max-width: 719.9px){.footer-link-column{gap:0}.footer-link-column .column-heading-desktop{display:none}.footer-link-column .column-heading-mobile{display:flex}}hr{height:.0625rem;margin:0;padding:0;background:var(--color-border-subtle, rgba(255, 255, 255, .15));border:0}button.column-heading-mobile{appearance:none;background-color:transparent;border:0;color:inherit;font-family:inherit;font-size:inherit;padding:0;text-decoration:none;-webkit-user-select:none;user-select:none;justify-content:space-between;pointer-events:none}button.column-heading-mobile>*{pointer-events:none}button.column-heading-mobile:not([disabled]){cursor:pointer}button.column-heading-mobile:focus-visible{outline-style:solid;outline-color:#fff;outline-width:.125rem;border-radius:.125rem}@media (max-width: 719.9px){button.column-heading-mobile{pointer-events:auto;cursor:pointer;padding-block-start:1.25rem;padding-block-end:1.25rem;border-top:1px solid var(--color-border-subtle, rgba(255, 255, 255, .15))}button.column-heading-mobile:focus-visible{outline:1px solid var(--color-text-primary, #ffffff);outline-offset:.125rem}button.column-heading-mobile[aria-expanded=true] span.icon{transform:rotate(180deg);transition:transform .2s var(--easing, cubic-bezier(.45, 0, .55, 1))}button.column-heading-mobile[aria-expanded=true]~ul{visibility:visible;max-height:100vh;padding-block-end:1.25rem;transition:all .2s var(--easing, cubic-bezier(.45, 0, .55, 1))}}h3{font-family:Inter,sans-serif;font-style:normal;font-weight:700;line-height:120%;letter-spacing:-.005rem;font-size:1.25rem;letter-spacing:-.01875rem;line-height:100%;margin:0;padding:0;color:var(--color-text-primary, #ffffff)}.icon{height:1.25rem;width:1.25rem;fill:var(--color-icon-primary, #ffffff);transition:transform .2s var(--easing, cubic-bezier(.45, 0, .55, 1))}@media (min-width: 720px){.icon{display:none}}ul{list-style:none;margin:0;padding:0;display:flex;flex-direction:column}ul li{padding-block:.375rem}ul li a{width:min-content}@media (max-width: 719.9px){ul{overflow:hidden;visibility:hidden;max-height:0;transition:all .2s var(--easing, cubic-bezier(.45, 0, .55, 1));padding-inline-start:.25rem;transform:translate(-.25rem)}}";
var f5 = Object.defineProperty, m5 = Object.getOwnPropertyDescriptor, on = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? m5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && f5(t, r, a), a;
};
let ir = class extends Pt {
  constructor() {
    super(...arguments), this.heading = "", this.items = new Array(), this.locale = "", this.domain = "", this.isExpanded = !1, this.handleClick = (e) => {
      e.preventDefault(), this.isExpanded = !this.isExpanded;
    }, this.handleKeyDown = (e) => {
      ["Space", "Enter", "NumpadEnter"].includes(e.code) && (e.preventDefault(), this.isExpanded = !this.isExpanded);
    };
  }
  render() {
    var e;
    return (e = this.items) != null && e.length ? ae`
			<div class="footer-link-column">
				<h3 class="column-heading-desktop">${this.heading}</h3>
				<button
					class="column-heading-mobile"
					id="${this.heading}-button"
					aria-controls="${this.heading}-content"
					aria-expanded="${this.isExpanded}"
					@click=${this.handleClick}
					@keydown=${this.handleKeyDown}
				>
					<h3>${this.heading}</h3>
					<span aria-hidden="true" class="icon">${d(Tk)}</span>
				</button>
				<ul id="${this.heading}-content" class="${this.isExpanded ? "expanded" : "collapsed"}">
					${this.items.map((t) => ey(
      t.localesWhitelist,
      this.locale,
      t.countryCodesWhitelist,
      this.countryCode
    ) ? ae`<li>
							<epic-wf-footer-link
								label=${t.label || ""}
								size="md"
								hrefTemplate=${t.hrefTemplate || ""}
								domain=${this.domain || ""}
								locale=${this.locale || ""}
								@click=${(n) => {
      typeof this.onClick == "function" && this.onClick(n, t);
    }}
							>
							</epic-wf-footer-link>
						</li>` : null)}
				</ul>
			</div>
		` : ae``;
  }
};
ir.styles = St`
		${Tt(p5)}
	`;
on([
  ne()
], ir.prototype, "heading", 2);
on([
  ne({ type: Array, converter: st })
], ir.prototype, "items", 2);
on([
  ne()
], ir.prototype, "locale", 2);
on([
  ne()
], ir.prototype, "domain", 2);
on([
  ne()
], ir.prototype, "countryCode", 2);
on([
  xk()
], ir.prototype, "isExpanded", 2);
on([
  ne()
], ir.prototype, "onClick", 2);
ir = on([
  Lt("epic-wf-footer-link-column")
], ir);
const h5 = "ul{list-style:none;margin:0;padding:0;display:flex;gap:1rem}epic-wf-eds-icon{height:1.75rem;width:1.75rem;transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}a:hover epic-wf-eds-icon{fill:var(--color-text-primary, #ffffff)}";
var y5 = Object.defineProperty, g5 = Object.getOwnPropertyDescriptor, yk = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? g5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && y5(t, r, a), a;
};
let Ms = class extends Pt {
  constructor() {
    super(...arguments), this.socialIcons = new Array();
  }
  render() {
    var e;
    return (e = this.socialIcons) != null && e.length ? ae`
			<ul class="footer-social-icons">
				${this.socialIcons.map((t) => t?.icon ? ae`
						<li>
							<a href=${t.href || ""} aria-label=${t.logoAlt || ""} target="_blank">
								<epic-wf-eds-icon icon=${ha(t.icon)} textColor="secondary"></epic-wf-eds-icon>
							</a>
						</li>
					` : ae``)}
			</ul>
		` : ae``;
  }
};
Ms.styles = St`
		${Tt(h5)}
	`;
yk([
  ne({ type: Array, converter: st })
], Ms.prototype, "socialIcons", 2);
Ms = yk([
  Lt("epic-wf-footer-social-icons")
], Ms);
const b5 = ":host{box-sizing:border-box;display:flex;align-items:center}:host .logo{display:block;display:flex;align-items:center}:host .logo__img{display:block;width:auto}:host .logo__img--icon{display:none}@media (min-width: 720px) and (max-width: 959.9px){:host .logo--has-icon .logo__img{display:none}:host .logo--has-icon .logo__img--icon{display:block}}";
var v5 = Object.defineProperty, w5 = Object.getOwnPropertyDescriptor, ui = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? w5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && v5(t, r, a), a;
};
let An = class extends Pt {
  constructor() {
    super(...arguments), this.logo = {}, this.iconOnlyLogo = {}, this.logoAlt = "", this.width = 32;
  }
  render() {
    var e, t;
    const r = !!(this.logo && ((e = this.logo) != null && e.url)), n = !!(this.iconOnlyLogo && ((t = this.iconOnlyLogo) != null && t.url)), a = r ? ae`
					<img
						alt=${this.logoAlt}
						class="logo__img"
						fetchpriority="high"
						height="32"
						src=${this.logo.url}
						width=${this.width || "auto"}
					/>
				` : null, i = n ? ae`
					<img
						alt=${this.logoAlt}
						class="logo__img logo__img--icon"
						height="32"
						src=${this.iconOnlyLogo.url}
						width="32"
					/>
				` : null;
    return ae`<span class=${`logo ${n ? "logo--has-icon" : ""}`}>${a}${i}</span>`;
  }
};
An.styles = St`
		${Tt(b5)}
	`;
ui([
  ne({ type: Object })
], An.prototype, "logo", 2);
ui([
  ne({ type: Object })
], An.prototype, "iconOnlyLogo", 2);
ui([
  ne()
], An.prototype, "logoAlt", 2);
ui([
  ne({ type: Number })
], An.prototype, "width", 2);
An = ui([
  Lt("epic-wf-footer-property-logo")
], An);
const _5 = ":host{display:contents}.footer-tags-legal-card{display:flex;width:22.5rem;flex-shrink:0;max-width:100%;padding:1rem;align-items:center;gap:1rem;border-radius:.5rem;border:1px solid var(--color-palette-transparent-light-005, rgba(255, 255, 255, .05));background:var(--color-palette-transparent-light-005, rgba(255, 255, 255, .05));box-sizing:border-box}.footer-tags-legal-card-image{height:4.5rem;width:auto}.footer-tags-legal-card-details{gap:.5rem;display:flex;flex-direction:column;flex-grow:1}.footer-tags-legal-card-details span{font-family:Inter,sans-serif;font-style:normal;font-weight:400;line-height:150%;font-size:.75rem;letter-spacing:.02em;color:var(--color-text-secondary, rgba(255, 255, 255, .65))}.footer-tags-legal-card-details hr{height:.0625rem;margin:0;padding:0;background:var(--color-border-subtle, rgba(255, 255, 255, .15));border:0}";
var E5 = Object.defineProperty, x5 = Object.getOwnPropertyDescriptor, ty = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? x5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && E5(t, r, a), a;
};
let La = class extends Pt {
  constructor() {
    super(...arguments), this.height = 72;
  }
  render() {
    var e, t, r, n, a, i;
    if (!((t = (e = this.legalCard) == null ? void 0 : e.asset) != null && t.url)) return ae``;
    const s = this.legalCard.detailsBottom ? ae`<hr />
					<span>${this.legalCard.detailsBottom}</span>` : "";
    return ae`
			<div class="footer-tags-legal-card">
				<img
					class="footer-tags-legal-card-image"
					alt=${this.legalCard.detailsTop || ""}
					height=${this.height}
					loading="lazy"
					src=${((n = (r = this.legalCard) == null ? void 0 : r.asset) == null ? void 0 : n.optUrl) || ((i = (a = this.legalCard) == null ? void 0 : a.asset) == null ? void 0 : i.url)}
					width="auto"
				/>
				<div class="footer-tags-legal-card-details"><span>${this.legalCard.detailsTop}</span> ${s}</div>
			</div>
		`;
  }
};
La.styles = St`
		${Tt(_5)}
	`;
ty([
  ne({ type: Object, converter: st })
], La.prototype, "legalCard", 2);
ty([
  ne({ type: Number })
], La.prototype, "height", 2);
La = ty([
  Lt("epic-wf-footer-tags-legal-card")
], La);
const T5 = ":host{display:contents}ul{list-style:none;margin:0;padding:0;display:flex;gap:1rem;flex-wrap:wrap}@media (max-width: 719.9px){ul{align-items:center;justify-content:center}}.epic-wf-footer-tags-brand-icon epic-wf-eds-icon{height:1.5rem;width:1.5rem;transition:fill var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}.epic-wf-footer-tags-brand-icon .epic-wf-custom-icon{display:block;background-color:var(--color-text-secondary, rgba(255, 255, 255, .65));height:1.5rem;aspect-ratio:var(--footer-tags-icon-ratio, 1);-webkit-mask-image:var(--footer-tags-icon-mask);mask-image:var(--footer-tags-icon-mask);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:contain;mask-size:contain;-webkit-mask-position:center;mask-position:center;transition:background-color var(--easing-duration, .12s) var(--easing, cubic-bezier(.65, 0, .35, 1))}a:hover epic-wf-eds-icon{fill:var(--color-text-primary, #ffffff)}a:hover .epic-wf-custom-icon{background-color:var(--color-text-primary, #ffffff)}";
var S5 = Object.defineProperty, P5 = Object.getOwnPropertyDescriptor, ry = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? P5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && S5(t, r, a), a;
};
let Da = class extends Pt {
  constructor() {
    super(...arguments), this.locale = "", this.tagsBrandIcons = [];
  }
  render() {
    var e;
    return (e = this.tagsBrandIcons) != null && e.length ? ae`
			<ul class="footer-tags-brand-icons">
				${this.tagsBrandIcons.map((t) => {
      var r, n, a, i, s, l, c;
      if (!t?.icon && !((r = t?.asset) != null && r.url)) return ae``;
      let u;
      if ((a = (n = t?.asset) == null ? void 0 : n.url) != null && a.length) {
        const m = (i = t?.asset) == null ? void 0 : i.url, y = t?.aspectRatio || !!((s = t?.asset) != null && s.height) && `${(l = t?.asset) == null ? void 0 : l.width} / ${(c = t?.asset) == null ? void 0 : c.height}` || "1";
        u = ae`<i
							style="--footer-tags-icon-mask: url(${m}); --footer-tags-icon-ratio: ${y};"
							class="epic-wf-custom-icon"
						></i>`;
      } else t?.icon && (u = ae`<epic-wf-eds-icon icon=${ha(t.icon)} textColor="secondary"></epic-wf-eds-icon>`);
      const p = t.logoAlt || "", f = Gd({ hrefTemplate: t.href, locale: this.locale });
      return f ? ae`
							<li>
								<a
									class="epic-wf-footer-tags-brand-icon"
									href=${f}
									aria-label=${p}
									title=${p}
									target="_blank"
								>
									${u}
								</a>
							</li>
						` : ae`
						<li>
							<span class="epic-wf-footer-tags-brand-icon"> ${u} </span>
						</li>
					`;
    })}
			</ul>
		` : ae``;
  }
};
Da.styles = St`
		${Tt(T5)}
	`;
ry([
  ne()
], Da.prototype, "locale", 2);
ry([
  ne({ type: Array, converter: st })
], Da.prototype, "tagsBrandIcons", 2);
Da = ry([
  Lt("epic-wf-footer-tags-brand-icons")
], Da);
const O5 = "ul.footer-tags-legal-icons{list-style:none;margin:0;padding:0;display:flex;gap:1rem;flex-wrap:wrap;flex-direction:row;justify-content:end}@media (max-width: 719.9px){ul.footer-tags-legal-icons{justify-content:center}}";
var C5 = Object.defineProperty, A5 = Object.getOwnPropertyDescriptor, ny = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? A5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && C5(t, r, a), a;
};
let Fa = class extends Pt {
  constructor() {
    super(...arguments), this.legalIcons = [], this.height = 64;
  }
  render() {
    var e;
    return (e = this.legalIcons) != null && e.length ? ae`
			<ul class="footer-tags-legal-icons">
				${this.legalIcons.map((t) => {
      var r, n, a;
      if (!((r = t?.asset) != null && r.url)) return ae``;
      const i = ae`<img
						alt=${t.logoAlt || ""}
						height=${this.height}
						src=${((n = t?.asset) == null ? void 0 : n.optUrl) || ((a = t?.asset) == null ? void 0 : a.url)}
						width="auto"
					/>`;
      return t.href ? ae`
							<li>
								<a
									href=${t.href || ""}
									aria-label=${t.logoAlt || ""}
									title=${t.logoAlt || ""}
									target="_blank"
								>
									${i}
								</a>
							</li>
						` : ae`<li>${i}</li>`;
    })}
			</ul>
		` : ae``;
  }
};
Fa.styles = St`
		${Tt(O5)}
	`;
ny([
  ne({ type: Array, converter: st })
], Fa.prototype, "legalIcons", 2);
ny([
  ne({ type: Number })
], Fa.prototype, "height", 2);
Fa = ny([
  Lt("epic-wf-footer-tags-legal-icons")
], Fa);
const R5 = ":host{display:contents}.footer-tags-legal-item{display:flex;flex-direction:column;align-items:end}@media (max-width: 719.9px){.footer-tags-legal-item{align-items:center}}";
var k5 = Object.defineProperty, I5 = Object.getOwnPropertyDescriptor, oy = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? I5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && k5(t, r, a), a;
};
let Ba = class extends Pt {
  constructor() {
    super(...arguments), this.tagsLegalItems = [], this.countryCode = "US";
  }
  render() {
    var e, t, r, n;
    if (!((e = this.tagsLegalItems) != null && e.length)) return ae``;
    let a = [];
    if ((t = this.tagsLegalItems) != null && t.some((l) => Di(l.countryCodes, this.countryCode)) ? a = (r = this.tagsLegalItems) == null ? void 0 : r.filter(
      (l) => Di(l.countryCodes, this.countryCode)
    ) : this.countryCode !== "US" && (a = (n = this.tagsLegalItems) == null ? void 0 : n.filter(
      (l) => Di(l.countryCodes, "US")
    )), !a?.length) return ae``;
    const i = a?.find(
      (l) => l.__typename === "FooterTagsLegalCard"
    );
    if (i)
      return ae`<epic-wf-footer-tags-legal-card .legalCard=${i}></epic-wf-footer-tags-legal-card>`;
    const s = a?.filter(
      (l) => l.__typename === "FooterTagsLegalItem"
    );
    return s?.length ? ae`
			<div class="footer-tags-legal-items">
				${s.map(
      (l) => ae`
						<div class="footer-tags-legal-item">
							<epic-wf-footer-tags-legal-icons .legalIcons=${l.legalIcons}></epic-wf-footer-tags-legal-icons>
							<epic-wf-footer-link label=${l.title || ""} size="sm" hrefTemplate=${l.titleHref || ""}>
							</epic-wf-footer-link>
						</div>
					`
    )}
			</div>
		` : ae``;
  }
};
Ba.styles = St`
		${Tt(R5)}
	`;
oy([
  ne({ type: Array, converter: st })
], Ba.prototype, "tagsLegalItems", 2);
oy([
  ne({ type: String })
], Ba.prototype, "countryCode", 2);
Ba = oy([
  Lt("epic-wf-footer-tags-legal-items")
], Ba);
const j5 = ":host{display:contents}.footer-tags-legal-wrapper{display:flex;flex-direction:column;gap:2.5rem;flex-grow:1;max-width:100%;box-sizing:border-box}.footer-tags-legal-wrapper .footer-tags-legal{gap:2.5rem;display:flex;flex-direction:row;justify-content:space-between;align-items:center}@media (max-width: 719.9px){.footer-tags-legal-wrapper .footer-tags-legal{flex-direction:column;justify-content:center}}.footer-tags-legal-wrapper>hr{height:.0625rem;margin:0;padding:0;background:var(--color-border-subtle, rgba(255, 255, 255, .15));border:0}@media (max-width: 719.9px){.footer-tags-legal-wrapper>hr{display:none}}";
var N5 = Object.defineProperty, q5 = Object.getOwnPropertyDescriptor, uu = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? q5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && N5(t, r, a), a;
};
let So = class extends Pt {
  constructor() {
    super(...arguments), this.locale = "", this.footerTagsLegal = {};
  }
  render() {
    var e, t, r, n, a, i;
    if (!((t = (e = this.footerTagsLegal) == null ? void 0 : e.tagsBrandIcons) != null && t.length) && !((n = (r = this.footerTagsLegal) == null ? void 0 : r.tagsLegalItems) != null && n.length)) return ae``;
    const s = ((i = (a = this.countryCode) == null ? void 0 : a.toUpperCase()) == null ? void 0 : i.trim()) || "US";
    return ae`
			<section class="footer-tags-legal-wrapper">
				<div class="footer-tags-legal">
					<epic-wf-footer-tags-brand-icons
						locale=${this.locale}
						.tagsBrandIcons=${this.footerTagsLegal.tagsBrandIcons}
					></epic-wf-footer-tags-brand-icons>
					<epic-wf-footer-tags-legal-items
						.tagsLegalItems=${this.footerTagsLegal.tagsLegalItems}
						countryCode=${s}
					></epic-wf-footer-tags-legal-items>
				</div>
				<hr />
			</section>
		`;
  }
};
So.styles = St`
		${Tt(j5)}
	`;
uu([
  ne()
], So.prototype, "locale", 2);
uu([
  ne({ type: Object, converter: st })
], So.prototype, "footerTagsLegal", 2);
uu([
  ne({ type: String })
], So.prototype, "countryCode", 2);
So = uu([
  Lt("epic-wf-footer-tags-legal")
], So);
const M5 = 'svg{fill:currentColor}svg[viewBox="0 0 24 24"]{inline-size:1.5rem;block-size:1.5rem}svg[viewBox="0 0 20 20"]{inline-size:1.25rem;block-size:1.25rem}svg{color:var(--color-icon-primary, #ffffff)}.visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin-block:-1px;margin-inline:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.footer-link-columns-wrapper{display:flex;flex-direction:column;gap:2.5rem}@media (max-width: 719.9px){hr{display:none}}.footer-link-columns{display:flex;column-gap:2rem;row-gap:3rem}@media (max-width: 719.9px){.footer-link-columns{row-gap:0;border-bottom:1px solid var(--color-border-subtle, rgba(255, 255, 255, .15))}}@media (max-width: 1439.9px){.footer-link-columns{flex-wrap:wrap}}@media (prefers-reduced-motion: reduce){*,:before,:after{animation-delay:-1ms!important;animation-duration:0s!important;transition-delay:1ms!important;transition-duration:0s!important}}ul{list-style:none;margin:0;padding:0}footer{width:100%;display:flex;flex-direction:column;gap:2.5rem;font-family:Inter,sans-serif;padding:5rem;padding-inline:7.5rem;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background:var(--color-background-elevated-low-default, #18181c);color:var(--color-text-secondary, rgba(255, 255, 255, .65))}@media (max-width: 1919.9px){footer{padding-inline:4rem}}@media (max-width: 719.9px){footer{padding-inline:1rem}}@media (max-width: 719.9px){footer[data-property-logo-icon-valid=false] section.top{flex-direction:column}}hr{height:.0625rem;margin:0;padding:0;background:var(--color-border-subtle, rgba(255, 255, 255, .15));border:0}.flex{display:flex}.flex.column{flex-direction:column}.flex.space-evenly{justify-content:space-evenly}.flex.space-between{justify-content:space-between}.flex.align-center{align-items:center}.flex.gap24{gap:1.5rem}.flex.gap40{gap:2.5rem}.bottom-links{display:flex;flex-wrap:wrap;column-gap:1.5rem;row-gap:.5rem}@media (max-width: 719.9px){.bottom-links{justify-content:center}}@media (max-width: 719.9px){section.top{flex-direction:column;gap:2.5rem}section.top .flex{flex-direction:column;gap:2.5rem}}@media (max-width: 719.9px){section.bottom{flex-direction:column;gap:2.5rem;align-items:center}section.bottom .flex{align-items:center}}', gk = () => window?.__epic_games_footer_geoip_country_code || "US", $5 = (e) => e || gk(), L5 = (e, t) => !e.footerColumns || !e.footerColumns.length ? ae`` : ae`
		<section class="footer-link-columns-wrapper">
			<hr />
			<div class="footer-link-columns">
				${e.footerColumns.map(
  (r) => ae`
						<epic-wf-footer-link-column
							heading=${r.heading || ""}
							.items=${r.items || []}
							domain=${e.domain || ""}
							locale=${t || ""}
							countryCode=${e.countryCode || ""}
							.onClick=${e._linkClick.bind(e)}
						></epic-wf-footer-link-column>
					`
)}
			</div>
			<hr />
		</section>
	`;
var D5 = Object.defineProperty, F5 = Object.getOwnPropertyDescriptor, ft = (e, t, r, n) => {
  for (var a = n > 1 ? void 0 : n ? F5(t, r) : t, i = e.length - 1, s; i >= 0; i--)
    (s = e[i]) && (a = (n ? s(t, r, a) : s(a)) || a);
  return n && a && D5(t, r, a), a;
};
const B5 = {
  "zh-hans": "zh-CN",
  "zh-hant": "zh-TW"
};
let it = class extends Pt {
  constructor() {
    super(...arguments), this.allPageData = {}, this._locale = "", this._propertyValuesInit = "", this.isReady = !1, this.hygraphLocaleMapping = {}, this.domain = "", this.propertyLogo = {}, this.socialIcons = new Array(), this.newsletterButton = {}, this.footerColumns = new Array(), this.footerCopyright = {}, this.backToTopButton = {}, this.footerBottomLinks = {}, this.countryCode = gk(), this.disableNewsletter = !1;
  }
  connectedCallback() {
    super.connectedCallback(), this._propertyValuesInit || this.updatePropertyValues("en"), setTimeout(() => {
      this.isReady = !0, this.dispatchEvent(
        new CustomEvent(Li.IS_READY, {
          bubbles: !0,
          composed: !0
        })
      );
    }, 350);
  }
  getReverseLocale(e) {
    if (!e) return;
    const r = Object.fromEntries(
      Object.entries(this.hygraphLocaleMapping || {}).map((n) => {
        const a = n[1] || "";
        return [a?.toLowerCase() || a, n[0]];
      })
    )[e.toLowerCase()];
    return r || B5[e.toLowerCase()];
  }
  set locale(e) {
    if (!e || this.locale === e) return;
    const r = this.getReverseLocale(e) || e, n = this._locale;
    this._locale = r, n !== r && this._propertyValuesInit !== r && this.updatePropertyValues(r);
  }
  get locale() {
    return this._locale || "en-US";
  }
  getMappedHygraphLocale(e) {
    return this.hygraphLocaleMapping && typeof this.hygraphLocaleMapping[e] < "u" ? this.hygraphLocaleMapping[e] : e;
  }
  async updatePropertyValues(e) {
    var t, r, n;
    if (!e) return;
    const a = e.replace(/-/g, "_"), i = ((t = this.allPageData) == null ? void 0 : t[a]) || {}, { id: s, ...l } = i;
    if (l && Object.keys(l).length)
      Object.assign(this, l), this._propertyValuesInit = e;
    else if ((r = this.allPageData) != null && r.en) {
      const c = (n = this.allPageData) == null ? void 0 : n.en, { id: u, ...p } = c;
      Object.assign(this, p), this._propertyValuesInit = "en";
    }
  }
  _linkClick(e, t) {
    t && (t.hrefTemplate && (t.hrefTemplate = Gd({
      domain: this.domain,
      locale: this.getMappedHygraphLocale(this.locale),
      hrefTemplate: t.hrefTemplate
    })), this.dispatchEvent(
      new CustomEvent(Li.FOOTER_LINK_CLICK, {
        detail: { originalEvent: e, link: t },
        bubbles: !0,
        composed: !0
      })
    ));
  }
  _buttonClick(e, t, r) {
    this.dispatchEvent(
      new CustomEvent(Li.FOOTER_BUTTON_CLICK, {
        detail: {
          originalEvent: e,
          link: {
            href: t?.href,
            label: t?.label,
            endIcon: t?.endIcon
          },
          key: r
        },
        bubbles: !0,
        composed: !0
      })
    );
  }
  handleScrollToTop(e) {
    window.scrollTo && (e.preventDefault(), window.scrollTo({
      top: 0,
      behavior: "smooth"
    }));
  }
  render() {
    var e, t, r, n, a, i, s, l, c, u, p;
    const f = !!((e = this.propertyLogo) != null && e.logo && ((r = (t = this.propertyLogo) == null ? void 0 : t.logo) != null && r.url)), m = !!((n = this.propertyLogo) != null && n.iconOnlyLogo && ((i = (a = this.propertyLogo) == null ? void 0 : a.iconOnlyLogo) != null && i.url)), y = f || m;
    return (this.dir === "" || this.dir === yr.LTR) && fy(this.locale) ? (this.dir = yr.RTL, this.setAttribute("dir", yr.RTL)) : this.dir === yr.RTL && !fy(this.locale) && (this.dir = yr.LTR, this.setAttribute("dir", yr.LTR)), ae`
			<footer
				class="global-footer ${this.dir === yr.RTL ? yr.RTL : ""}"
				data-property-logo-valid=${y}
				data-property-logo-icon-valid=${m}
				id="global-footer"
			>
				<section class="top flex space-between align-center gap40">
					<epic-wf-footer-property-logo
						.logo=${((s = this.propertyLogo) == null ? void 0 : s.logo) || {}}
						.iconOnlyLogo=${((l = this.propertyLogo) == null ? void 0 : l.iconOnlyLogo) || {}}
						logoAlt=${((c = this.propertyLogo) == null ? void 0 : c.logoAlt) || ""}
					></epic-wf-footer-property-logo>
					<div class="flex gap40 align-center">
						<epic-wf-footer-social-icons .socialIcons=${this.socialIcons || []}></epic-wf-footer-social-icons>
						${this.newsletterButton && !this.disableNewsletter ? ae`<epic-wf-footer-button
									.link=${this.newsletterButton}
									.onClick=${(g) => {
      this._buttonClick(g, this.newsletterButton, "newsletterButton");
    }}
									key="newsletterButton"
									variant="outline"
								></epic-wf-footer-button>` : ae``}
					</div>
				</section>

				${L5(this, this.getMappedHygraphLocale(this.locale || ""))}

				<epic-wf-footer-tags-legal
					locale=${this.locale}
					.footerTagsLegal=${this.footerTagsLegal}
					.countryCode=${this.countryCode}
				></epic-wf-footer-tags-legal>

				<section class="bottom flex space-between">
					<div class="flex column gap40">
						<epic-wf-footer-copyright text=${((u = this.footerCopyright) == null ? void 0 : u.text) || ""}></epic-wf-footer-copyright>
						<ul class="bottom-links">
							${(((p = this.footerBottomLinks) == null ? void 0 : p.items) || []).map((g) => {
      const v = this.getMappedHygraphLocale(this.locale || "");
      return ey(g.localesWhitelist, v, g.countryCodesWhitelist, this.countryCode) ? ae` <li>
									<epic-wf-footer-link
										size="xs"
										label=${g.label || ""}
										hrefTemplate=${g.hrefTemplate || ""}
										domain=${this.domain || ""}
										locale=${v}
										countryCode=${this.countryCode}
										countryCodesWhitelist=${g.countryCodesWhitelist || ""}
										@click=${(_) => {
        this._linkClick(_, g);
      }}
									>
									</epic-wf-footer-link>
								</li>` : null;
    })}
						</ul>
					</div>

					<epic-wf-footer-button
						.link=${this.backToTopButton}
						.onClick=${(g) => {
      this._buttonClick(g, this.backToTopButton, "backToTopButton"), this.handleScrollToTop(g);
    }}
						key="backToTopButton"
						padding="large"
					></epic-wf-footer-button>
				</section>
			</footer>
		`;
  }
};
it.styles = St`
		${Tt(M5)}
	`;
ft([
  ne()
], it.prototype, "locale", 1);
ft([
  ne({ type: Object, converter: st })
], it.prototype, "hygraphLocaleMapping", 2);
ft([
  ne()
], it.prototype, "domain", 2);
ft([
  ne({ type: Object, converter: st })
], it.prototype, "propertyLogo", 2);
ft([
  ne({ type: Array, converter: st })
], it.prototype, "socialIcons", 2);
ft([
  ne({ type: Object, converter: st })
], it.prototype, "newsletterButton", 2);
ft([
  ne({ type: Array, converter: st })
], it.prototype, "footerColumns", 2);
ft([
  ne({ type: Object, converter: st })
], it.prototype, "footerCopyright", 2);
ft([
  ne({ type: Object, converter: st })
], it.prototype, "backToTopButton", 2);
ft([
  ne({ type: Array, converter: st })
], it.prototype, "footerBottomLinks", 2);
ft([
  ne({ type: Object, converter: st })
], it.prototype, "footerTagsLegal", 2);
ft([
  ne({ type: String, converter: $5 })
], it.prototype, "countryCode", 2);
ft([
  ne({ type: Boolean, converter: Sk })
], it.prototype, "disableNewsletter", 2);
it = ft([
  Lt("epic-wf-footer")
], it);
export {
  it as F,
  M5 as s
};
